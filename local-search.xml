<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring Security里Session的探讨与延伸</title>
    <link href="/2021/08/10/Spring%20Security%E9%87%8CSession%E7%9A%84%E6%8E%A2%E8%AE%A8%E4%B8%8E%E5%BB%B6%E4%BC%B8/"/>
    <url>/2021/08/10/Spring%20Security%E9%87%8CSession%E7%9A%84%E6%8E%A2%E8%AE%A8%E4%B8%8E%E5%BB%B6%E4%BC%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Security里Session的探讨与延伸"><a href="#Spring-Security里Session的探讨与延伸" class="headerlink" title="Spring Security里Session的探讨与延伸"></a>Spring Security里Session的探讨与延伸</h1><h2 id="✍️问题的引入"><a href="#✍️问题的引入" class="headerlink" title="✍️问题的引入"></a>✍️问题的引入</h2><p>在上文中，我们简单分析了一个基于RBAC模型的Spring Security的设计思路，通过配置，我们的确登陆成功了，但是有没有想过一个问题，你在服务端的安全管理使用了 Spring Security，用户登录成功之后，<strong>Spring Security 帮你把用户信息保存在 Session 里，但是具体保存在哪里</strong>，要是不深究你可能就不知道， 这带来了一个问题，<strong>如果用户在前端操作修改了当前用户信息，在不重新登录的情况下，如何获取到最新的用户信息？</strong></p><p>这也是一直困扰我的问题，我是通过阅读源码发现了关键的一步，并利用这个Key去实现了额外的功能，这个我们到时候再分析。</p><h2 id="🔫又是Authentication"><a href="#🔫又是Authentication" class="headerlink" title="🔫又是Authentication"></a>🔫又是Authentication</h2><p>在 Spring Security 中有一个非常重要的对象叫做 <code>Authentication</code>，我们可以在任何地方注入 <code>Authentication</code> 进而获取到当前登录用户信息，<code>Authentication</code> 本身是一个接口，它有很多实现类：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809222725161.png" alt="image-20210809222725161"></p><p>在这众多的实现类中，我们最常用的就是<code>UsernamePasswordAuthenticationToken</code>了，但是当我们打开这个类的源码后，却发现这个类平平无奇，他只有两个属性、两个构造方法以及若干个 get/set 方法；当然，他还有更多属性在它的父类上。</p><p>但是从它仅有的这两个属性中，我们也能大致看出，这个类就保存了我们登录用户的基本信息。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809222813938.png" alt="image-20210809222813938"></p><p>那么我们的登录信息是如何存到这两个对象中的？这就要来梳理一下登录流程了。</p><h2 id="⏳登录流程"><a href="#⏳登录流程" class="headerlink" title="⏳登录流程"></a>⏳登录流程</h2><p>在 Spring Security 中，认证与授权的相关校验都是在一系列的过滤器链中完成的，在这一系列的过滤器链中，和认证相关的过滤器就是 <code>UsernamePasswordAuthenticationFilter</code>，篇幅问题，我这里列出来该类中几个重要方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> <span class="hljs-keyword">extends</span></span><span class="hljs-class"><span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;String username = obtainUsername(request);String password = obtainPassword(request);UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password);setDetails(request, authRequest);<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainPassword</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">return</span> request.getParameter(passwordParameter);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainUsername</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">return</span> request.getParameter(usernameParameter);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authRequest)</span> </span>&#123;authRequest.setDetails(authenticationDetailsSource.buildDetails(request));&#125;&#125;</code></pre></div><p>根据这段源码我们可以看出：</p><ol><li>首先通过 <code>obtainUsername</code> 和 <code>obtainPassword</code> 方法提取出请求里边的用户名/密码出来，提取方式就是<code> request.getParameter</code> ，这也是为什么 Spring Security 中默认的表单登录要通过 key/value 的形式传递参数，而不能传递 JSON 参数，如果像传递 JSON 参数，修改这里的逻辑即可（参考RBAC的实现）。</li><li>获取到请求里传递来的用户名/密码之后，接下来就构造一个 <code>UsernamePasswordAuthenticationToken</code> 对象，传入 username 和 password，username 对应了 <code>UsernamePasswordAuthenticationToken</code> 中的 <code>principal</code> 属性，而 password 则对应了它的 <code>credentials</code> 属性。</li><li>接下来 setDetails 方法给 details 属性赋值，<code>UsernamePasswordAuthenticationToken</code> 本身是没有 details 属性的，这个属性在它的父类 <code>AbstractAuthenticationToken</code> 中。details 是一个对象，这个对象里边放的是 <code>WebAuthenticationDetails</code> 实例，该实例主要描述了两个信息，请求的 <code>remoteAddress</code> 以及请求的 <code>sessionId</code>。</li><li>最后一步，就是调用 <code>authenticate</code> 方法去做校验了。</li></ol><p><strong>从这段源码中，大家可以看出来请求的各种信息基本上都找到了自己的位置，找到了位置，这就方便我们未来去获取了。</strong></p><p>接下来我们再来看请求的具体校验操作。</p><p>在前面的<code>attemptAuthentication</code>方法中，该方法的最后一步开始做校验，校验操作首先要获取到一个<code> AuthenticationManager</code>，这里拿到的是 <code>ProviderManager</code> ，所以接下来我们就进入到<code>ProviderManager</code>的<code>authenticate</code>方法中，当然这个方法也比较长，我这里仅仅摘列出来几个重要的地方：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;Class&lt;? extends Authentication&gt; toTest = authentication.getClass();<span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;<span class="hljs-keyword">if</span> (!provider.supports(toTest)) &#123;<span class="hljs-keyword">continue</span>;&#125;result = provider.authenticate(authentication);<span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;copyDetails(authentication, result);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> &amp;&amp; parent != <span class="hljs-keyword">null</span>) &#123;result = parentResult = parent.authenticate(authentication);&#125;<span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (eraseCredentialsAfterAuthentication&amp;&amp; (result <span class="hljs-keyword">instanceof</span> CredentialsContainer)) &#123;((CredentialsContainer) result).eraseCredentials();&#125;<span class="hljs-keyword">if</span> (parentResult == <span class="hljs-keyword">null</span>) &#123;eventPublisher.publishAuthenticationSuccess(result);&#125;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">throw</span> lastException;&#125;</code></pre></div><p><strong>这个方法就比较魔幻了，因为几乎关于认证的重要逻辑都将在这里完成：</strong></p><ol><li>首先获取 <code>authentication </code>的 Class，判断当前 <code>provider</code> 是否支持该 <code>authentication</code></li><li>如果支持，则调用 <code>provider</code> 的 <code>authenticate</code> 方法开始做校验，校验完成后，会返回一个新的 <code>Authentication</code>。一会来和大家捋这个方法的具体逻辑。</li><li>这里的 <code>provider</code> 可能有多个，如果 <code>provider </code>的 <code>authenticate</code> 方法没能正常返回一个 <code>Authentication</code>，则调用 <code>provider</code> 的 <code>parent</code> 的 <code>authenticate </code>方法继续校验。</li><li><code>copyDetails</code> 方法则用来把旧的 Token 的 details 属性拷贝到新的 Token 中来。</li><li>接下来会调用 <code>eraseCredentials</code> 方法擦除凭证信息，也就是你的密码，这个擦除方法比较简单，就是将 Token 中的 <code>credentials</code> 属性置空。</li><li>最后通过 <code>publishAuthenticationSuccess</code> 方法将登录成功的事件广播出去。</li></ol><p>大致的流程，就是上面这样，在 for 循环中，第一次拿到的 provider 是一个 <code>AnonymousAuthenticationProvider</code>，这个 provider 压根就不支持 <code>UsernamePasswordAuthenticationToken</code>，也就是会直接在 <code>provider.supports</code> 方法中返回 false，结束 for 循环，然后会进入到下一个 if 中，直接调用 parent 的 authenticate 方法进行校验。</p><p>而 parent 就是 <code>ProviderManager</code>，所以会再次回到这个 <code>authenticate</code> 方法中。再次回到 <code>authenticate</code> 方法中，provider 也变成了 <code>DaoAuthenticationProvider</code>，这个 provider 是支持 <code>UsernamePasswordAuthenticationToken</code> 的，所以会顺利进入到该类的 <code>authenticate</code> 方法去执行，而 <code>DaoAuthenticationProvider</code> 继承自 <code>AbstractUserDetailsAuthenticationProvider</code> 并且没有重写 <code>authenticate</code> 方法，所以 我们最终来到 <code>AbstractUserDetailsAuthenticationProvider#authenticate </code>方法中：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;String username = (authentication.getPrincipal() == <span class="hljs-keyword">null</span>) ? <span class="hljs-string">&quot;NONE_PROVIDED&quot;</span>: authentication.getName();user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);preAuthenticationChecks.check(user);additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication);postAuthenticationChecks.check(user);Object principalToReturn = user;<span class="hljs-keyword">if</span> (forcePrincipalAsString) &#123;principalToReturn = user.getUsername();&#125;<span class="hljs-keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);&#125;</code></pre></div><p>这里的逻辑就比较简单了：</p><ol><li>首先从 <code>Authentication</code> 提取出登录用户名。</li><li>然后通过拿着 username 去调用 <code>retrieveUser </code>方法去获取当前用户对象，这一步会调用我们自己在登录时候的写的<code>loadUserByUsername</code>方法，所以这里返回的 user 其实就是你的登录对象，可以参考<a href="https://github.com/Lucifer2u/xm-luciferpro/blob/master/luciferpro-server/luciferpro-service/src/main/java/org/lucifer/vbluciferpro/service/HrService.java">我github中</a>的29行</li><li>接下来调用 <code>preAuthenticationChecks.check</code> 方法去检验 user 中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等。</li><li><code>additionalAuthenticationChecks</code> 方法则是做密码比对的，好多人好奇 Spring Security 的密码加密之后，是如何进行比较的，看这里就懂了，因为比较的逻辑很简单，我这里就不贴代码出来了。</li><li>最后在 <code>postAuthenticationChecks.check</code> 方法中检查密码是否过期。</li><li>接下来有一个 <code>forcePrincipalAsString </code>属性，这个是是否强制将<code> Authentication</code> 中的 principal 属性设置为字符串，这个属性我们一开始在<code>UsernamePasswordAuthenticationFilter</code>类中其实就是设置为字符串的（即 username），但是默认情况下，当用户登录成功之后， 这个属性的值就变成当前用户这个对象了。之所以会这样，就是因为 forcePrincipalAsString 默认为 false，不过这块其实不用改，就用 false，这样在后期获取当前用户信息的时候反而方便很多。</li><li>最后，通过<code> createSuccessAuthentication</code> 方法构建一个新的 <code>UsernamePasswordAuthenticationToken</code></li></ol><p>好了，那么登录的校验流程现在就基本和大家捋了一遍了。那么接下来还有一个问题，登录的用户信息我们去哪里查找？</p><h2 id="⚙️用户信息保存"><a href="#⚙️用户信息保存" class="headerlink" title="⚙️用户信息保存"></a>⚙️用户信息保存</h2><p>要去找登录的用户信息，我们得先来解决一个问题，就是上面我们说了这么多，这一切是从哪里开始被触发的？</p><p>我们来到 <code>UsernamePasswordAuthenticationFilter</code> 的父类 <code>AbstractAuthenticationProcessingFilter</code> 中，这个类我们经常会见到，因为很多时候当我们想要在 Spring Security <a href="https://lucifer2u.github.io/2021/08/09/%E6%B5%85%E8%B0%88Spring%20Security%E5%AE%9E%E7%8E%B0RBAC%E6%A8%A1%E5%9E%8B/#%E5%AE%9E%E7%8E%B0JSON%E6%A0%BC%E5%BC%8F%E7%99%BB%E9%99%86">自定义一个登录验证码或者将登录参数改为 JSON</a> 的时候，我们都需自定义过滤器继承自 <code>AbstractAuthenticationProcessingFilter</code> ，毫无疑问，<code>UsernamePasswordAuthenticationFilter#attemptAuthentication</code> 方法就是在 <code>AbstractAuthenticationProcessingFilter</code> 类的 doFilter 方法中被触发的：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;HttpServletRequest request = (HttpServletRequest) req;HttpServletResponse response = (HttpServletResponse) res;Authentication authResult;<span class="hljs-keyword">try</span> &#123;authResult = attemptAuthentication(request, response);<span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;sessionStrategy.onAuthentication(authResult, request, response);&#125;<span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;chain.doFilter(request, response);&#125;successfulAuthentication(request, response, chain, authResult);&#125;</code></pre></div><p>从上面的代码中，我们可以看到，当 <code>attemptAuthentication</code> 方法被调用时，实际上就是触发了 <code>UsernamePasswordAuthenticationFilter#attemptAuthentication</code> 方法，当登录抛出异常的时候，<code>unsuccessfulAuthentication</code> 方法会被调用，而当登录成功的时候，<code>successfulAuthentication</code> 方法则会被调用，那我们就来看一看 <code>successfulAuthentication</code> 方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;  <span class="hljs-comment">//本文问题的key</span>SecurityContextHolder.getContext().setAuthentication(authResult);rememberMeServices.loginSuccess(request, response, authResult);<span class="hljs-comment">// Fire event</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;eventPublisher.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(authResult, <span class="hljs-keyword">this</span>.getClass()));&#125;successHandler.onAuthenticationSuccess(request, response, authResult);&#125;</code></pre></div><p>在这里有一段很重要的代码，就是 <code>SecurityContextHolder.getContext().setAuthentication(authResult);</code> ，登录成功的用户信息被保存在这里，也就是说，在任何地方，如果我们想获取用户登录信息，都可以从 <code>SecurityContextHolder.getContext()</code> 中获取到，想修改，也可以在这里修改。</p><blockquote><p><strong>注意，这里的authResult存的是一个ThreadLocal的变量</strong></p><p>最后大家还看到有一个 <code>successHandler.onAuthenticationSuccess</code>，这就是我们在 SecurityConfig 中配置登录成功回调方法，就是在这里被触发的，这块大家也可以参考<a href="https://github.com/Lucifer2u/xm-luciferpro/blob/master/luciferpro-server/luciferpro-web/src/main/java/org/lucifer/vbluciferpro/config/SecurityConfig.java">我github里边的配置</a>。 </p></blockquote><p><strong>到此为止，我们Session的信息也能确认也保存到这里了，拿到这个信息，我们就可以按着这里思路去我<a href="https://github.com/Lucifer2u/xm-luciferpro">github上的后端管理项目</a>中设计新的内容，比如我在个人中心中，想要在不重新登录的情况下，获取到最新的用户信息，下面我将针对个人中心的设计思路进行阐述</strong></p><h2 id="💣如果登陆失败呢？"><a href="#💣如果登陆失败呢？" class="headerlink" title="💣如果登陆失败呢？"></a>💣如果登陆失败呢？</h2><h3 id="🔑引入"><a href="#🔑引入" class="headerlink" title="🔑引入"></a>🔑引入</h3><p>正确情况下，当我们登录成功后，可以通过如下方式获取到当前登录用户信息：</p><ol><li><code>SecurityContextHolder.getContext().getAuthentication()</code></li><li>在 Controller 的方法中，加入 <code>Authentication </code>参数</li></ol><p>正常情况下，我们通过如上两种方式的任意一种就可以获取到已经登录的用户信息。</p><p><strong>但是我们需要思考，异常情况，就是这两种方式中的任意一种，都返回 null。</strong></p><p>都返回 null，意味着系统收到当前请求时并不知道你已经登录了（因为你没有在系统中留下任何有效信息），这会带来两个问题：</p><ol><li>无法获取到当前登录用户信息。</li><li>当你发送任何请求，系统都会给你返回 401。</li></ol><h3 id="🔒开始剖析"><a href="#🔒开始剖析" class="headerlink" title="🔒开始剖析"></a>🔒开始剖析</h3><p>要弄明白这个问题，我们就得明白 Spring Security 中的用户信息到底是在哪里存的？</p><p>前面说了两种数据获取方式，但是这两种数据获取方式，获取到的数据又是从哪里来的？</p><p><strong><code>SecurityContextHolder</code> 中的数据，本质上是保存在 <code>ThreadLocal</code> 中，<code>ThreadLocal</code> 的特点是存在它里边的数据，哪个线程存的，哪个线程才能访问到。</strong></p><p>这样就带来一个问题，当不同的请求进入到服务端之后，由不同的 thread 去处理，按理说后面的请求就可能无法获取到登录请求的线程存入的数据，例如登录请求在线程 A 中将登录用户信息存入 <code>ThreadLocal</code>，后面的请求来了，在线程 B 中处理，那此时就无法获取到用户的登录信息。</p><p><strong>但实际上，正常情况下，我们每次都能够获取到登录用户信息，这又是怎么回事呢？</strong></p><p>这我们就要引入 Spring Security 中的 <code>SecurityContextPersistenceFilter</code>了。</p><p>小伙伴们都知道，无论是 Spring Security 还是 Shiro，它的一系列功能其实都是由过滤器来完成的，在 Spring Security 中，我们熟悉的是<code>UsernamePasswordAuthenticationFilter</code> 过滤器，在这个过滤器之前，还有一个过滤器就是 <code>SecurityContextPersistenceFilter</code>，请求在到达 <code>UsernamePasswordAuthenticationFilter</code> 之前都会先经过 <code>SecurityContextPersistenceFilter</code>。</p><p>我们来看下它的源码(部分)：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityContextPersistenceFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;HttpServletRequest request = (HttpServletRequest) req;HttpServletResponse response = (HttpServletResponse) res;HttpRequestResponseHolder holder = <span class="hljs-keyword">new</span> HttpRequestResponseHolder(request,response);SecurityContext contextBeforeChainExecution = repo.loadContext(holder);<span class="hljs-keyword">try</span> &#123;SecurityContextHolder.setContext(contextBeforeChainExecution);chain.doFilter(holder.getRequest(), holder.getResponse());&#125;<span class="hljs-keyword">finally</span> &#123;SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();SecurityContextHolder.clearContext();repo.saveContext(contextAfterChainExecution, holder.getRequest(),holder.getResponse());&#125;&#125;&#125;</code></pre></div><p>原本的方法很长，我这里列出来了比较关键的几个部分：</p><ol><li><code>SecurityContextPersistenceFilter</code> 继承自 <code>GenericFilterBean</code>，而<code> GenericFilterBean</code> 则是 Filter 的实现，所以 <code>SecurityContextPersistenceFilter</code> 作为一个过滤器，它里边最重要的方法就是 doFilter 了。</li><li>在 doFilter 方法中，它首先会从 repo 中读取一个 <code>SecurityContext</code> 出来，这里的 repo 实际上就是 <code>HttpSessionSecurityContextRepository</code>，读取 <code>SecurityContext</code> 的操作会进入到 <code>readSecurityContextFromSession</code> 方法中，在这里我们看到了读取的核心方法 <code>Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);</code>，这里的 <code>springSecurityContextKey</code> 对象的值就是 <code>SPRING_SECURITY_CONTEXT</code>，读取出来的对象最终会被转为一个 <code>SecurityContext</code> 对象。</li><li><code>SecurityContext</code> 是一个接口，它有一个唯一的实现类 <code>SecurityContextImpl</code>，这个实现类其实就是用户信息在 session 中保存的 value。</li><li>在拿到 <code>SecurityContext </code>之后，通过 <code>SecurityContextHolder.setContext</code> 方法将这个 SecurityContext 设置到 <code>ThreadLocal </code>中去，这样，在当前请求中，<code>Spring Security</code> 的后续操作，我们都可以直接从<code>SecurityContextHolder</code>中获取到用户信息了。</li><li>接下来，通过<code> chain.doFilter</code> 让请求继续向下走（这个时候就会进入到 <code>UsernamePasswordAuthenticationFilter</code> 过滤器中了）。</li><li>在过滤器链走完之后，数据响应给前端之后，finally 中还有一步收尾操作，这一步很关键。这里从 <code>SecurityContextHolder</code> 中获取到 <code>SecurityContext</code>，获取到之后，会把 <code>SecurityContextHolder</code> 清空，然后调用 <code>repo.saveContext</code> 方法将获取到的<code>SecurityContext</code>存入 session 中。</li></ol><p>至此，整个流程就很明了了。</p><p><strong>每一个请求到达服务端的时候，首先从 session 中找出来 <code>SecurityContext</code> ，然后设置到 <code>SecurityContextHolder </code>中去，方便后续使用，当这个请求离开的时候，<code>SecurityContextHolder</code> 会被清空，<code>SecurityContext</code> 会被放回 session 中，方便下一个请求来的时候获取。</strong></p><p>搞明白这一点之后，再去解决 Spring Security 登录后无法获取到当前登录用户这个问题，就非常 easy 了。</p><h3 id="😄问题解决"><a href="#😄问题解决" class="headerlink" title="😄问题解决"></a>😄问题解决</h3><p>经过上面的分析之后，我们再来回顾一下为什么会发生登录之后无法获取到当前用户信息这样的事情？</p><p>最简单情况的就是你在一个新的线程中去执行 <code>SecurityContextHolder.getContext().getAuthentication()</code>，这肯定获取不到用户信息，无需多说。例如下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/menu&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getMenusByHrId</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();            System.out.println(authentication);        &#125;    &#125;).start();    <span class="hljs-keyword">return</span> menuService.getMenusByHrId();&#125;</code></pre></div><p>这种简单的问题相信大家都能够很容易排查到。</p><p><strong>还有一种隐藏比较深的就是在 <code>SecurityContextPersistenceFilter </code>的 doFilter 方法中没能从 session 中加载到用户信息，进而导致 <code>SecurityContextHolder </code>里边空空如也。</strong></p><p>在 <code>SecurityContextPersistenceFilter </code>中没能加载到用户信息，原因可能就比较多了，例如：</p><ul><li><strong>「上一个请求临走的时候，没有将数据存储到 session 中去。」</strong></li><li><strong>「当前请求自己没走过滤器链。」</strong></li></ul><p>什么时候会发生这个问题呢？有的小伙伴可能在配置 <code>SecurityConfig#configure(WebSecurity)</code> 方法时，会忽略掉一个重要的点。</p><p>当我们想让 Spring Security 中的资源可以匿名访问时，我们有两种办法：</p><ol><li>不走 Spring Security 过滤器链。</li><li>继续走 Spring Security 过滤器链，但是可以匿名访问。</li></ol><p>这两种办法对应了两种不同的配置方式。其中第一种配置可能会影响到我们获取登录用户信息，第二种则不影响，所以这里我们来重点看看第一种。</p><p>不想走 Spring Security 过滤器链，我们一般可以通过如下方式配置：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>,<span class="hljs-string">&quot;/js/**&quot;</span>,<span class="hljs-string">&quot;/index.html&quot;</span>,<span class="hljs-string">&quot;/img/**&quot;</span>,<span class="hljs-string">&quot;/fonts/**&quot;</span>,<span class="hljs-string">&quot;/favicon.ico&quot;</span>,<span class="hljs-string">&quot;/verifyCode&quot;</span>);&#125;</code></pre></div><p>正常这样配置是没有问题的。</p><p>如果你很不巧，把登录请求地址放进来了，那就 gg 了。虽然登录请求可以被所有人访问，但是不能放在这里（而应该通过允许匿名访问的方式来给请求放行）。<strong>「如果放在这里，登录请求将不走 <code>SecurityContextPersistenceFilter</code> 过滤器，也就意味着不会将登录用户信息存入 session，进而导致后续请求无法获取到登录用户信息。」</strong></p><h2 id="👤沿着路：个人中心的设计"><a href="#👤沿着路：个人中心的设计" class="headerlink" title="👤沿着路：个人中心的设计"></a>👤沿着路：个人中心的设计</h2><h3 id="🔑如何获取用户信息"><a href="#🔑如何获取用户信息" class="headerlink" title="🔑如何获取用户信息"></a>🔑如何获取用户信息</h3><p>在Spring Security中提供了<code>Authentication</code>，可以直接在Controller中直接注入就可以使用</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/hr/info&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Hr <span class="hljs-title">getCurrentHr</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;    <span class="hljs-keyword">return</span> ((Hr) authentication.getPrincipal());&#125;</code></pre></div><h3 id="🔑如何修改用户信息"><a href="#🔑如何修改用户信息" class="headerlink" title="🔑如何修改用户信息"></a>🔑如何修改用户信息</h3><p>因为Spring Security帮你把Session保存好了，自己没处理，所以只能通过上诉分析的结果来更改，接下来定义接口：</p><p>相当于重新构建一个<code>Authentication</code> 实例放到Context中去，又分为：</p><ul><li><strong>修改用户的基础信息，不需要重新登录</strong></li><li><strong>修改密码后需要重新登录（在前端处理此逻辑）</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping(&quot;/hr/info&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateHr</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Hr hr, Authentication authentication)</span> </span>&#123;    <span class="hljs-keyword">if</span> (hrService.updateHr(hr) == <span class="hljs-number">1</span>) &#123;      <span class="hljs-comment">//利用上面的思路，直接修改</span>        SecurityContextHolder.getContext().setAuthentication(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(hr, authentication.getCredentials(), authentication.getAuthorities()));        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);&#125;<span class="hljs-meta">@PutMapping(&quot;/hr/pass&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateHrPasswd</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Map&lt;String, Object&gt; info)</span> </span>&#123;    String oldpass = (String) info.get(<span class="hljs-string">&quot;oldpass&quot;</span>);    String pass = (String) info.get(<span class="hljs-string">&quot;pass&quot;</span>);    Integer hrid = (Integer) info.get(<span class="hljs-string">&quot;hrid&quot;</span>);    <span class="hljs-keyword">if</span> (hrService.updateHrPasswd(oldpass, pass, hrid)) &#123;        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);&#125;</code></pre></div><p>因为修改密码需要设计到数据库的操作，然后设计Service层</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updateHrPasswd</span><span class="hljs-params">(String oldpass, String pass, Integer hrid)</span> </span>&#123;    Hr hr = hrMapper.selectByPrimaryKey(hrid);    BCryptPasswordEncoder encoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    <span class="hljs-keyword">if</span> (encoder.matches(oldpass, hr.getPassword())) &#123;        String encodePass = encoder.encode(pass);        Integer result = hrMapper.updatePasswd(hrid, encodePass);        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p>然后定义Mapper</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updatePasswd&quot;</span>&gt;</span>  update hr set password = #&#123;encodePass&#125; where id=#&#123;hrid&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></div><p>这样就完成了个人中心的基础配置，修改头像可以存在云端或者自己本地的服务器上，看自己如何选择，我是用FaseDFS完成了存储的问题，以后有机会另外写一篇文章讨论</p><p><strong>这样关于Session的问题，我们还能继续探讨，在现实中我们会有这样的请求，已经登陆了的用户，再另一端登陆的时候，需要把之前登陆的信息抹除并踢掉，防止多端登陆，造成不必要的麻烦</strong></p><h2 id="🦶继续走：踢掉已登录用户"><a href="#🦶继续走：踢掉已登录用户" class="headerlink" title="🦶继续走：踢掉已登录用户"></a>🦶继续走：踢掉已登录用户</h2><h3 id="🤔分析需求"><a href="#🤔分析需求" class="headerlink" title="🤔分析需求"></a>🤔分析需求</h3><p>在同一个系统中，我们可能只允许一个用户在一个终端上登录，一般来说这可能是出于安全方面的考虑，但是也有一些情况是出于业务上的考虑</p><p>要实现一个用户不可以同时在两台设备上登录，我们有两种思路：</p><ul><li>后来的登录自动踢掉前面的登录，就像大家在QQ中看到的效果。</li><li>如果用户已经登录，则不允许后来者登录。</li></ul><p>这种思路都能实现这个功能，具体使用哪一个，还要看我们具体的需求。</p><h3 id="🔧基础配置"><a href="#🔧基础配置" class="headerlink" title="🔧基础配置"></a>🔧基础配置</h3><p><strong>想要踢掉已登录的用户配置</strong>起来比较简单，我们只需要将最大会话数设置为 1 即可，配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            .anyRequest().authenticated()            .sessionManagement()            .maximumSessions(<span class="hljs-number">1</span>);&#125;</code></pre></div><p><code>setMaximumSessions</code> 表示配置最大会话数为 1，这样后面的登录就会自动踢掉前面的登录。</p><p>如果相同的用户已经登录了，你不想踢掉他，而是想禁止新的登录操作，那也好办，配置方式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            .anyRequest().authenticated()            .sessionManagement()            .maximumSessions(<span class="hljs-number">1</span>)            .maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>);&#125;</code></pre></div><p>添加 <code>maxSessionsPreventsLogin</code> 配置即可。此时一个浏览器登录成功后，另外一个浏览器就登录不了了。</p><blockquote><p>maxSessionsPreventsLogin提供两种session保护策略：</p><ul><li>true表示已经登录就不予许再次登录，</li><li>false表示允许再次登录但是之前的登录账户会被踢下线</li></ul></blockquote><p>不过还没完，我们还需要再提供一个 Bean：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function">HttpSessionEventPublisher <span class="hljs-title">httpSessionEventPublisher</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpSessionEventPublisher();&#125;</code></pre></div><p><strong>为什么要加这个 Bean 呢？因为在 Spring Security 中，它是通过监听 session 的销毁事件，来及时的清理 session 的记录</strong>。用户从不同的浏览器登录后，都会有对应的 session，当用户注销登录之后，session 就会失效，但是默认的失效是通过调用 <code>StandardSession#invalidate</code> 方法来实现的，这一个失效事件无法被 Spring 容器感知到，进而导致当用户注销登录之后，Spring Security 没有及时清理会话信息表，以为用户还在线，进而导致用户无法重新登录进来（大家可以不添加上面的 Bean，然后让用户注销登录之后再重新登录）。</p><p>为了解决这一问题，我们提供一个 <code>HttpSessionEventPublisher</code> ，这个类实现了 <code>HttpSessionListener</code> 接口，在该 Bean 中，可以将 session 创建以及销毁的事件及时感知到，并且调用 Spring 中的事件机制将相关的创建和销毁事件发布出去，进而被 Spring Security 感知到，该类部分源码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent event)</span> </span>&#123;HttpSessionCreatedEvent e = <span class="hljs-keyword">new</span> HttpSessionCreatedEvent(event.getSession());getContext(event.getSession().getServletContext()).publishEvent(e);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent event)</span> </span>&#123;HttpSessionDestroyedEvent e = <span class="hljs-keyword">new</span> HttpSessionDestroyedEvent(event.getSession());getContext(event.getSession().getServletContext()).publishEvent(e);&#125;</code></pre></div><p>OK，虽然多了一个配置，但是依然很简单！</p><h3 id="📖实现原理"><a href="#📖实现原理" class="headerlink" title="📖实现原理"></a>📖实现原理</h3><p>上面这个功能，在 Spring Security 中是怎么实现的呢？我们来稍微分析一下源码。</p><p>首先我们知道，在用户登录的过程中，会经过 <code>UsernamePasswordAuthenticationFilter</code>，而 <code>UsernamePasswordAuthenticationFilter</code> 中过滤方法的调用是在 <code>AbstractAuthenticationProcessingFilter</code> 中触发的，我们来看下 <code>AbstractAuthenticationProcessingFilter#doFilter </code>方法的调用：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;HttpServletRequest request = (HttpServletRequest) req;HttpServletResponse response = (HttpServletResponse) res;<span class="hljs-keyword">if</span> (!requiresAuthentication(request, response)) &#123;chain.doFilter(request, response);<span class="hljs-keyword">return</span>;&#125;Authentication authResult;<span class="hljs-keyword">try</span> &#123;authResult = attemptAuthentication(request, response);<span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;sessionStrategy.onAuthentication(authResult, request, response);&#125;<span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// Authentication success</span><span class="hljs-keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;chain.doFilter(request, response);&#125;successfulAuthentication(request, response, chain, authResult);</code></pre></div><p>在这段代码中，我们可以看到，调用 <code>attemptAuthentication</code> 方法走完认证流程之后，回来之后，<strong>接下来就是调用 <code>sessionStrategy.onAuthentication</code> 方法，这个方法就是用来处理 session 的并发问题的。</strong>具体在：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentSessionControlAuthenticationStrategy</span> <span class="hljs-keyword">implements</span></span><span class="hljs-class"><span class="hljs-title">MessageSourceAware</span>, <span class="hljs-title">SessionAuthenticationStrategy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthentication</span><span class="hljs-params">(Authentication authentication,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<span class="hljs-keyword">final</span> List&lt;SessionInformation&gt; sessions = sessionRegistry.getAllSessions(authentication.getPrincipal(), <span class="hljs-keyword">false</span>);<span class="hljs-keyword">int</span> sessionCount = sessions.size();<span class="hljs-keyword">int</span> allowedSessions = getMaximumSessionsForThisUser(authentication);<span class="hljs-keyword">if</span> (sessionCount &lt; allowedSessions) &#123;<span class="hljs-comment">// They haven&#x27;t got too many login sessions running at present</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (allowedSessions == -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// We permit unlimited logins</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (sessionCount == allowedSessions) &#123;HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// Only permit it though if this request is associated with one of the</span><span class="hljs-comment">// already registered sessions</span><span class="hljs-keyword">for</span> (SessionInformation si : sessions) &#123;<span class="hljs-keyword">if</span> (si.getSessionId().equals(session.getId())) &#123;<span class="hljs-keyword">return</span>;&#125;&#125;&#125;<span class="hljs-comment">// If the session is null, a new one will be created by the parent class,</span><span class="hljs-comment">// exceeding the allowed number</span>&#125;allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allowableSessionsExceeded</span><span class="hljs-params">(List&lt;SessionInformation&gt; sessions,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> allowableSessions, SessionRegistry registry)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> SessionAuthenticationException </span>&#123;<span class="hljs-keyword">if</span> (exceptionIfMaximumExceeded || (sessions == <span class="hljs-keyword">null</span>)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SessionAuthenticationException(messages.getMessage(<span class="hljs-string">&quot;ConcurrentSessionControlAuthenticationStrategy.exceededAllowed&quot;</span>,<span class="hljs-keyword">new</span> Object[] &#123;allowableSessions&#125;,<span class="hljs-string">&quot;Maximum sessions of &#123;0&#125; for this principal exceeded&quot;</span>));&#125;<span class="hljs-comment">// Determine least recently used sessions, and mark them for invalidation</span>sessions.sort(Comparator.comparing(SessionInformation::getLastRequest));<span class="hljs-keyword">int</span> maximumSessionsExceededBy = sessions.size() - allowableSessions + <span class="hljs-number">1</span>;List&lt;SessionInformation&gt; sessionsToBeExpired = sessions.subList(<span class="hljs-number">0</span>, maximumSessionsExceededBy);<span class="hljs-keyword">for</span> (SessionInformation session: sessionsToBeExpired) &#123;session.expireNow();&#125;&#125;&#125;</code></pre></div><p>这段核心代码我来给大家稍微解释下：</p><ol><li>首先调用 <code>sessionRegistry.getAllSessions</code> 方法获取当前用户的所有 session，该方法在调用时，传递两个参数，一个是当前用户的 <code>authentication</code>，另一个参数 false 表示不包含已经过期的 session（在用户登录成功后，会将用户的 sessionid 存起来，其中 key 是用户的主体（principal），value 则是该主题对应的 sessionid 组成的一个集合）。</li><li>接下来计算出当前用户已经有几个有效 session 了，同时获取允许的 session 并发数。</li><li>如果当前 session 数（sessionCount）小于 session 并发数（allowedSessions），则不做任何处理；如果 allowedSessions 的值为 -1，表示对 session 数量不做任何限制。</li><li>如果当前 session 数（sessionCount）等于 session 并发数（allowedSessions），那就先看看当前 session 是否不为 null，并且已经存在于 sessions 中了，如果已经存在了，那都是自家人，不做任何处理；如果当前 session 为 null，那么意味着将有一个新的 session 被创建出来，届时当前 session 数（sessionCount）就会超过 session 并发数（allowedSessions）。</li><li>如果前面的代码中都没能 return 掉，那么将进入策略判断方法 <code>allowableSessionsExceeded</code> 中。</li><li><code>allowableSessionsExceeded</code> 方法中，首先会有 <code>exceptionIfMaximumExceeded </code>属性，这就是我们在 SecurityConfig 中配置的 <code>maxSessionsPreventsLogin</code> 的值，默认为 false，如果为 true，就直接抛出异常，那么这次登录就失败了（禁止新的登录），如果为 false，则对 sessions 按照请求时间进行排序，然后再使多余的 session 过期即可（踢掉已经登录用户）。</li></ol><h3 id="🪣用户配置放入库"><a href="#🪣用户配置放入库" class="headerlink" title="🪣用户配置放入库"></a>🪣用户配置放入库</h3><p><strong>但是，就是我们的用户是配置在内存中的用户，我们没有将用户放到数据库中去。在做 Spring Security 的 session 并发处理时，直接将内存中的用户切换为数据库中的用户会有问题</strong></p><p>我们就要先搞明白 Spring Security 是怎么保存用户对象和 session 的。</p><p>Spring Security 中通过 SessionRegistryImpl 类来实现对会话信息的统一管理，我们来看下这个类的源码（部分）：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionRegistryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SessionRegistry</span>,</span><span class="hljs-class"><span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">SessionDestroyedEvent</span>&gt; </span>&#123;<span class="hljs-comment">/** &lt;principal:Object,SessionIdSet&gt; */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Object, Set&lt;String&gt;&gt; principals;<span class="hljs-comment">/** &lt;sessionId:Object,SessionInformation&gt; */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, SessionInformation&gt; sessionIds;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerNewSession</span><span class="hljs-params">(String sessionId, Object principal)</span> </span>&#123;<span class="hljs-keyword">if</span> (getSessionInformation(sessionId) != <span class="hljs-keyword">null</span>) &#123;removeSessionInformation(sessionId);&#125;sessionIds.put(sessionId,<span class="hljs-keyword">new</span> SessionInformation(principal, sessionId, <span class="hljs-keyword">new</span> Date()));principals.compute(principal, (key, sessionsUsedByPrincipal) -&gt; &#123;<span class="hljs-keyword">if</span> (sessionsUsedByPrincipal == <span class="hljs-keyword">null</span>) &#123;sessionsUsedByPrincipal = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;&gt;();&#125;sessionsUsedByPrincipal.add(sessionId);<span class="hljs-keyword">return</span> sessionsUsedByPrincipal;&#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeSessionInformation</span><span class="hljs-params">(String sessionId)</span> </span>&#123;SessionInformation info = getSessionInformation(sessionId);<span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;sessionIds.remove(sessionId);principals.computeIfPresent(info.getPrincipal(), (key, sessionsUsedByPrincipal) -&gt; &#123;sessionsUsedByPrincipal.remove(sessionId);<span class="hljs-keyword">if</span> (sessionsUsedByPrincipal.isEmpty()) &#123;sessionsUsedByPrincipal = <span class="hljs-keyword">null</span>;&#125;<span class="hljs-keyword">return</span> sessionsUsedByPrincipal;&#125;);&#125;&#125;</code></pre></div><p>这个类的源码还是比较长，我这里提取出来一些比较关键的部分：</p><ol><li>首先大家看到，一上来声明了一个<code>principals</code>对象，这是一个支持并发访问的 map 集合，集合的 key 就是用户的主体（<code>principal</code>），正常来说，用户的 <code>principal</code> 其实就是用户对象，在之前的文章中也和大家讲过 <code>principal</code> 是怎么样存入到<code> Authentication</code> 中的，而集合的 value 则是一个 set 集合，这个 set 集合中保存了这个用户对应的<code> sessionid</code></li><li>如有新的 session 需要添加，就在 <code>registerNewSession</code> 方法中进行添加，具体是调用 <code>principals.compute</code> 方法进行添加，key 就是 <code>principal</code></li><li>如果用户注销登录，<code>sessionid</code> 需要移除，相关操作在 <code>removeSessionInformation </code>方法中完成，具体也是调用 <code>principals.computeIfPresent </code>方法，这些关于集合的基本操作我就不再赘述了。</li></ol><p>看到这里，大家发现一个问题，<code>ConcurrentMap</code> 集合的 key 是 <code>principal </code>对象，<strong>用对象做 key，一定要重写 equals 方法和 hashCode 方法，</strong>否则第一次存完数据，下次就找不到了，这是 JavaSE 方面的知识，我就不用多说了。</p><p>首先第一步，我们重写实体类的 equals 和 hashCode 方法，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;    ...    ...    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        Hr hr = (Hr) o;        <span class="hljs-keyword">return</span> Objects.equals(username, hr.username);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Objects.hash(username);    &#125;    ...    ...&#125;</code></pre></div><h3 id="💻结合项目"><a href="#💻结合项目" class="headerlink" title="💻结合项目"></a>💻结合项目</h3><p><strong>由于目前是采用了 JSON 格式登录，所以如果项目控制 session 并发数，就会有一些额外的问题要处理。</strong></p><p><strong>最大的问题在于我们用自定义的过滤器代替了 <code>UsernamePasswordAuthenticationFilter</code>，进而导致前面所讲的关于 session 的配置，统统失效。</strong>所有相关的配置我们都要在新的过滤器 <code>LoginFilter</code> 中进行配置 ，包括 <code>SessionAuthenticationStrategy</code> 也需要我们自己手动配置了。</p><p><strong>接下来在 <code>SecurityConfig </code>中进行配置。</strong></p><p>这里我们要自己提供 <code>SessionAuthenticationStrategy</code>，而前面处理 session 并发的是<code> ConcurrentSessionControlAuthenticationStrategy</code>，也就是说，我们需要自己提供一个 <code>ConcurrentSessionControlAuthenticationStrategy</code> 的实例，然后配置给 <code>LoginFilter</code>，但是在创建 <code>ConcurrentSessionControlAuthenticationStrategy</code> 实例的过程中，还需要有一个 <code>SessionRegistryImpl</code> 对象。</p><p>前面我们说过，<code>SessionRegistryImpl</code> 对象是用来维护会话信息的，现在这个东西也要我们自己来提供，<code>SessionRegistryImpl </code>实例很好创建，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function">SessionRegistryImpl <span class="hljs-title">sessionRegistry</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SessionRegistryImpl();&#125;</code></pre></div><p>然后在 <code>SecurityConfig</code> 中的 <code>LoginFilter</code> 中配置 <code>SessionAuthenticationStrategy</code>，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    LoginFilter loginFilter = <span class="hljs-keyword">new</span> LoginFilter();<span class="hljs-comment">//自己提供   </span>    ConcurrentSessionControlAuthenticationStrategy sessionStrategy = <span class="hljs-keyword">new</span> ConcurrentSessionControlAuthenticationStrategy(sessionRegistry());    sessionStrategy.setMaximumSessions(<span class="hljs-number">1</span>);    loginFilter.setSessionAuthenticationStrategy(sessionStrategy);    <span class="hljs-keyword">return</span> loginFilter;&#125;</code></pre></div><p>我们在这里自己手动构建 <code>ConcurrentSessionControlAuthenticationStrategy</code> 实例，构建时传递 <code>SessionRegistryImpl </code>参数，然后设置 session 的并发数为 1，最后再将 <code>sessionStrategy</code> 配置给 <code>LoginFilter</code></p><p>这就配置完了吗？没有！session 处理还有一个关键的过滤器叫做 <code>ConcurrentSessionFilter</code>，本来这个过滤器是不需要我们管的，但是这个过滤器中也用到了 <code>SessionRegistryImpl</code>，而 <code>SessionRegistryImpl</code> 现在是由我们自己来定义的，所以，该过滤器我们也要重新配置一下，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            ...    http.addFilterAt(<span class="hljs-keyword">new</span> ConcurrentSessionFilter(sessionRegistry(), event -&gt; &#123;        HttpServletResponse resp = event.getResponse();        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);        resp.setStatus(<span class="hljs-number">401</span>);        PrintWriter out = resp.getWriter();        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.error(<span class="hljs-string">&quot;您已在另一台设备登录，本次登录已下线!&quot;</span>)));        out.flush();        out.close();    &#125;), ConcurrentSessionFilter.class);&#125;</code></pre></div><p>在这里，我们重新创建一个 <code>ConcurrentSessionFilter</code> 的实例，代替系统默认的即可。在创建新的 <code>ConcurrentSessionFilter</code> 实例时，需要两个参数：</p><ol><li><code>sessionRegistry</code> 就是我们前面提供的 <code>SessionRegistryImpl </code>实例。</li><li>第二个参数，是一个处理 session 过期后的回调函数，也就是说，当用户被另外一个登录踢下线之后，你要给什么样的下线提示，就在这里来完成。</li></ol><p>最后，我们还需要在处理完登录数据之后，手动向 <code>SessionRegistryImpl</code> 中添加一条记录：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SessionRegistry sessionRegistry;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-comment">//省略</span>            Hr principal = <span class="hljs-keyword">new</span> Hr();            principal.setUsername(username);            sessionRegistry.registerNewSession(request.getSession(<span class="hljs-keyword">true</span>).getId(), principal);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);        &#125;         ...        ...    &#125;&#125;</code></pre></div><p>在这里，我们手动调用 <code>sessionRegistry.registerNewSession</code> 方法，向 <code>SessionRegistryImpl</code> 中添加一条 session 记录。</p><p>此刻，我们在基于上篇文章“浅谈Spring Security实现RBAC模型”中的配置类又变得有所丰富起来，这里附上过滤器和配置类的全部代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SessionRegistry sessionRegistry;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-keyword">if</span> (!request.getMethod().equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(                    <span class="hljs-string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());        &#125;        String verify_code = (String) request.getSession().getAttribute(<span class="hljs-string">&quot;verify_code&quot;</span>);        <span class="hljs-keyword">if</span> (request.getContentType().contains(MediaType.APPLICATION_JSON_VALUE) || request.getContentType().contains(MediaType.APPLICATION_JSON_UTF8_VALUE)) &#123;            Map&lt;String, String&gt; loginData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            <span class="hljs-keyword">try</span> &#123;                loginData = <span class="hljs-keyword">new</span> ObjectMapper().readValue(request.getInputStream(), Map.class);            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            &#125;<span class="hljs-keyword">finally</span> &#123;                String code = loginData.get(<span class="hljs-string">&quot;code&quot;</span>);                checkCode(response, code, verify_code);            &#125;            String username = loginData.get(getUsernameParameter());            String password = loginData.get(getPasswordParameter());            <span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;                username = <span class="hljs-string">&quot;&quot;</span>;            &#125;            <span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;                password = <span class="hljs-string">&quot;&quot;</span>;            &#125;            username = username.trim();            UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(                    username, password);            setDetails(request, authRequest);            Hr principal = <span class="hljs-keyword">new</span> Hr();            principal.setUsername(username);            sessionRegistry.registerNewSession(request.getSession(<span class="hljs-keyword">true</span>).getId(), principal);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);        &#125; <span class="hljs-keyword">else</span> &#123;            checkCode(response, request.getParameter(<span class="hljs-string">&quot;code&quot;</span>), verify_code);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.attemptAuthentication(request, response);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkCode</span><span class="hljs-params">(HttpServletResponse resp, String code, String verify_code)</span> </span>&#123;        <span class="hljs-keyword">if</span> (code == <span class="hljs-keyword">null</span> || verify_code == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(code) || !verify_code.toLowerCase().equals(code.toLowerCase())) &#123;            <span class="hljs-comment">//验证码不正确</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">&quot;验证码不正确&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p><strong>配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HrService hrService;    <span class="hljs-meta">@Autowired</span>    CustomFilterInvocationSecurityMetadataSource customFilterInvocationSecurityMetadataSource;    <span class="hljs-meta">@Autowired</span>    CustomUrlDecisionManager customUrlDecisionManager;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(hrService);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//防止访问登录页面死循环，不用进入Security拦截</span>        web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/img/**&quot;</span>, <span class="hljs-string">&quot;/fonts/**&quot;</span>, <span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;/verifyCode&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        LoginFilter loginFilter = <span class="hljs-keyword">new</span> LoginFilter();        loginFilter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;                    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                    PrintWriter out = response.getWriter();                    Hr hr = (Hr) authentication.getPrincipal();                    hr.setPassword(<span class="hljs-keyword">null</span>);                    RespBean ok = RespBean.ok(<span class="hljs-string">&quot;登录成功!&quot;</span>, hr);                    String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok);                    out.write(s);                    out.flush();                    out.close();                &#125;        );        loginFilter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;                    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                    PrintWriter out = response.getWriter();                    RespBean respBean = RespBean.error(exception.getMessage());                    <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> LockedException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;账户被锁定，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;密码过期，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;账户过期，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> DisabledException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;账户被禁用，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;用户名或者密码输入错误，请重新输入!&quot;</span>);                    &#125;                    out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));                    out.flush();                    out.close();                &#125;        );        loginFilter.setAuthenticationManager(authenticationManagerBean());        loginFilter.setFilterProcessesUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>);        <span class="hljs-comment">//手动构建</span>        ConcurrentSessionControlAuthenticationStrategy sessionStrategy = <span class="hljs-keyword">new</span> ConcurrentSessionControlAuthenticationStrategy(sessionRegistry());        <span class="hljs-comment">//最多一个用户登录</span>        sessionStrategy.setMaximumSessions(<span class="hljs-number">1</span>);        loginFilter.setSessionAuthenticationStrategy(sessionStrategy);        <span class="hljs-keyword">return</span> loginFilter;    &#125;    <span class="hljs-comment">//用来维护会话信息的</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">SessionRegistryImpl <span class="hljs-title">sessionRegistry</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SessionRegistryImpl();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;                        object.setAccessDecisionManager(customUrlDecisionManager);                        object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);                        <span class="hljs-keyword">return</span> object;                    &#125;                &#125;)                .and()                .logout()                .logoutSuccessHandler((req, resp, authentication) -&gt; &#123;                            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                            PrintWriter out = resp.getWriter();                            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.ok(<span class="hljs-string">&quot;注销成功!&quot;</span>)));                            out.flush();                            out.close();                        &#125;                )                .permitAll()                .and()                .csrf().disable().exceptionHandling()                <span class="hljs-comment">//没有认证时，在这里处理结果，不要重定向</span>                .authenticationEntryPoint((req, resp, authException) -&gt; &#123;                            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                            resp.setStatus(<span class="hljs-number">401</span>);                            PrintWriter out = resp.getWriter();                            RespBean respBean = RespBean.error(<span class="hljs-string">&quot;访问失败!&quot;</span>);                            <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;                                respBean.setMsg(<span class="hljs-string">&quot;请求失败，请联系管理员!&quot;</span>);                            &#125;                            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));                            out.flush();                            out.close();                        &#125;                );        http.addFilterAt(<span class="hljs-keyword">new</span> ConcurrentSessionFilter(sessionRegistry(), event -&gt; &#123;            HttpServletResponse resp = event.getResponse();            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);            resp.setStatus(<span class="hljs-number">401</span>);            PrintWriter out = resp.getWriter();            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.error(<span class="hljs-string">&quot;您已在另一台设备登录，本次登录已下线!&quot;</span>)));            out.flush();            out.close();        &#125;), ConcurrentSessionFilter.class);        http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Spring Security实现RBAC模型</title>
    <link href="/2021/08/09/%E6%B5%85%E8%B0%88Spring%20Security%E5%AE%9E%E7%8E%B0RBAC%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/08/09/%E6%B5%85%E8%B0%88Spring%20Security%E5%AE%9E%E7%8E%B0RBAC%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="浅谈Spring-Security实现RBAC模型"><a href="#浅谈Spring-Security实现RBAC模型" class="headerlink" title="浅谈Spring Security实现RBAC模型"></a>浅谈Spring Security实现RBAC模型</h1><blockquote><p>本文将结合我所做的项目来探讨一下利用Spring Security实现RBAC模型的简要步骤以及利用Spring Security做项目时候发现与改进</p></blockquote><h2 id="🤔️什么是RBAC"><a href="#🤔️什么是RBAC" class="headerlink" title="🤔️什么是RBAC"></a>🤔️什么是RBAC</h2><p><strong>RBAC权限模型（Role-Based Access Control）</strong>即：基于角色的权限控制。模型中有几个关键的术语：</p><ul><li>用户：系统接口及功能访问的操作者</li><li>权限：能够访问某接口或者做某操作的授权资格</li><li>角色：具有一类相同操作权限的用户的总称</li></ul><p><strong>RBAC权限模型核心授权逻辑如下：</strong></p><ul><li>某用户是什么角色？</li><li>某角色具有什么权限？</li><li>通过角色的权限推导用户的权限</li></ul><p>对于一个用户来说，如果直接将用户与权限关联，会有以下问题：</p><ul><li>现在用户是Lucifer、Melrose，以后随着人员增加，每一个用户都需要重新授权</li><li>或者Lucifer、Melrose离职，需要针对每一个用户进行多种权限的回收</li></ul><p><strong>如果给每个用户分配一个角色呢？</strong></p><ul><li>一个用户有一个角色</li><li>一个角色有多个操作（菜单）权限</li><li>一个操作权限可以赋予多个角色</li></ul><p>但是在实际的应用系统中，<strong>一个用户一个角色远远满足不了需求</strong>。如果我们希望一个用户既担任销售角色、又暂时担任副总角色。该怎么做呢？为了增加系统设计的适用性，我们通常设计：</p><ul><li>一个用户有一个或多个角色</li><li>一个角色包含多个用户</li><li>一个角色有多种权限</li><li>一个权限可以赋予多个角色</li></ul><p>所以，每个角色的权限可以对应为访问某个URL的权利，即所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面访问权限。</p><h2 id="✏️权限表的设计"><a href="#✏️权限表的设计" class="headerlink" title="✏️权限表的设计"></a>✏️权限表的设计</h2><p>在设计表的时候，可以引入RBAC模型的思想</p><blockquote><p>下面是我做的一个项目中所设计的表，项目链接：<a href="https://github.com/Lucifer2u/xm-luciferpro">https://github.com/Lucifer2u/xm-luciferpro</a></p></blockquote><p><strong>权限数据库</strong>主要包含了五张表，分别是<strong>资源表、角色表、用户表、资源角色表、用户角色表</strong>，数据库关系模型如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/p274.png" alt="p274"></p><ul><li>hr表是<strong>用户表</strong>，存放了用户的基本信息</li><li>role是<strong>角色表</strong>，name字段表示角色的英文名称，按照SpringSecurity的规范，将以<code>ROLE_</code>开始，nameZh字段表示角色的中文名称</li><li>menu表是一个资源表，该表涉及到的字段有点多，由于我的前端采用了Vue来做，因此当用户登录成功之后，系统将根据用户的角色动态加载需要的模块，所有模块的信息将保存在menu表中，menu表中的<strong>path、component、iconCls、keepAlive、requireAuth等字段都是Vue-Router中需要的字段</strong>，也就是说<strong>menu中的数据到时候会以json的形式返回给前端，再由vue动态更新router，menu中还有一个字段url，表示一个url pattern，即路径匹配规则</strong>，假设有一个路径匹配规则为<code>/admin/**</code>,那么当用户在客户端发起一个<code>/admin/user</code>的请求，将被<code>/admin/**</code>拦截到，系统再去查看这个规则对应的角色是哪些，然后再去查看该用户是否具备相应的角色，进而判断该请求是否合法</li></ul><p><strong>这样每个人都有相应的角色，然后都需要根据实际的角色权限去访问不同的菜单</strong></p><h2 id="🔒动态处理角色和资源的关系"><a href="#🔒动态处理角色和资源的关系" class="headerlink" title="🔒动态处理角色和资源的关系"></a>🔒动态处理角色和资源的关系</h2><p>要分析以上问题，我们需要回顾Spring Security的登录流程对整体流程进行了解才能更好的把握此节的内容</p><h3 id="Spring-Security的登录流程"><a href="#Spring-Security的登录流程" class="headerlink" title="Spring Security的登录流程"></a>Spring Security的登录流程</h3><p>Spring Security的登录验证流程核心就是过滤器链。</p><p><img src="https://img.kancloud.cn/73/50/73506bb0f3f3834c410ba17353a8168e_1409x389.png" alt="img"></p><ul><li>贯穿于整个过滤器链始终有一个上下文对象<code>SecurityContext</code>和一个<code>Authentication</code>对象（登录认证的主体）</li><li>一旦某一个该主体通过其中某一个过滤器的认证，<code>Authentication</code>对象信息被填充，比如：<code>isAuthenticated=true</code>表示该主体通过验证。</li><li>如果该主体通过了所有的过滤器，仍然没有被认证，在整个过滤器链的最后方有一个<code>FilterSecurityInterceptor</code>过滤器（虽然叫Interceptor，但它是名副其实的过滤器，不是拦截器）。判断<code>Authentication</code>对象的认证状态，如果没有通过认证则抛出异常，通过认证则访问后端API。</li><li>之后进入响应阶段，<code>FilterSecurityInterceptor</code>抛出的异常被<code>ExceptionTranslationFilter</code>对异常进行相应的处理。比如：用户名密码登录异常，会被引导到登录页重新登陆。</li><li>如果是登陆成功且没有任何异常，在请求响应中最后一个过滤器<code>SecurityContextPersistenceFilter</code>中将<code>SecurityContext</code>放入session。下次再进行请求的时候，直接从<code>SecurityContextPersistenceFilter</code>的session中取出认证信息。从而避免多次重复认证。（如果想修改用户信息，可以从这里拿）</li></ul><p>SpringSecurity提供了多种登录认证的方式，由多种Filter过滤器来实现，比如：</p><ul><li><code>BasicAuthenticationFilter</code>实现的是HttpBasic模式的登录认证</li><li><code>UsernamePasswordAuthenticationFilter</code>实现用户名密码的登录认证</li><li><code>RememberMeAuthenticationFilter</code>实现登录认证的“记住我”的功能</li><li><code>SocialAuthenticationFilter</code>实现社交媒体方式登录认证的处理，如：QQ、微信</li><li><code>Oauth2AuthenticationProcessingFilter</code>和<code>Oauth2ClientAuthenticationProcessingFilter</code>实现Oauth2的鉴权方式</li></ul><p>根据我们不同的需求实现及配置，不同的Filter会被加载到应用中。</p><h3 id="过滤器登录验证细节"><a href="#过滤器登录验证细节" class="headerlink" title="过滤器登录验证细节"></a>过滤器登录验证细节</h3><p><img src="https://img.kancloud.cn/ce/5e/ce5e1f7877e0155577d5511b95ea2100_660x441.png" alt="img"></p><h4 id="构建登录认证主体"><a href="#构建登录认证主体" class="headerlink" title="构建登录认证主体"></a><strong>构建登录认证主体</strong></h4><p>如图所示，当用户登陆的时候首先被某一种认证方式的过滤器拦截（以用户名密码登录为例）。如：<code>UsernamePasswordAuthenticationFilter</code>会使用用户名和密码创建一个登录认证凭证：<code>UsernamePasswordAuthenticationToken</code>，进而获取一个<code>Authentication</code>对象，该对象代表身份验证的主体，贯穿于用户认证流程始终。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808215018034.png" alt="image-20210808215018034"></p><h4 id="多种认证方式的管理-ProviderManager"><a href="#多种认证方式的管理-ProviderManager" class="headerlink" title="多种认证方式的管理 ProviderManager"></a><strong>多种认证方式的管理 ProviderManager</strong></h4><p>随后使用<code>AuthenticationManager</code> 接口对登录认证主体进行authenticate认证。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthenticationManager</span> </span>&#123;    <span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;&#125;</code></pre></div><p><code>ProviderManager</code>继承于<code>AuthenticationManager</code>是登录验证的核心类。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationManager</span>, <span class="hljs-title">MessageSourceAware</span>, <span class="hljs-title">InitializingBean</span> </span>&#123;    ……    <span class="hljs-keyword">private</span> List&lt;AuthenticationProvider&gt; providers;    ……</code></pre></div><p><code>ProviderManager</code>保管了多个<code>AuthenticationProvider</code>，每一种登录认证方式都可以尝试对登录认证主体进行认证。只要有一种方式被认证成功，<code>Authentication</code>对象就成为被认可的主体。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;    <span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication var1)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; var1)</span></span>;&#125;</code></pre></div><blockquote><p><code>RememberMeAuthenticationProvider</code>定义了“记住我”功能的登录验证逻辑</p><p><code>DaoAuthenticationProvider</code>加载数据库用户信息，进行用户密码的登录验证</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808220226118.png" alt="image-20210808220226118"></p></blockquote><p>而<code>DaoAuthenticationProvider</code>就是我们实现登录的关键，下面详细分析</p><h4 id="数据库加载用户信息-DaoAuthenticationProvider"><a href="#数据库加载用户信息-DaoAuthenticationProvider" class="headerlink" title="数据库加载用户信息 DaoAuthenticationProvider"></a><strong>数据库加载用户信息 DaoAuthenticationProvider</strong></h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoAuthenticationProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractUserDetailsAuthenticationProvider</span> </span></code></pre></div><p>从源码中发现，需要从数据库获取用户信息的时候，即我们需要加载用户信息进行登录验证的时候，我们需要实现<code>UserDetailsService</code>接口，重写<code>loadUserByUsername</code>方法，参数是用户输入的用户名。返回值是<code>UserDetails</code></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808220514527.png" alt="image-20210808220514527"></p><h4 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a><strong>SecurityContext</strong></h4><p>完成登录认证之后，将认证完成的<code>Authentication</code>对象(authenticate: true, 有授权列表authority list, 和username信息)放入<code>SecurityContext</code>上下文里面。后续的请求就直接从<code>SecurityContextFilter</code>中获得认证主体，从而访问资源。</p><h3 id="结合源码讲解登录验证流程"><a href="#结合源码讲解登录验证流程" class="headerlink" title="结合源码讲解登录验证流程"></a>结合源码讲解登录验证流程</h3><p>我们就以用户名、密码登录方式为例讲解一下Spring Security的登录认证流程。</p><p><img src="https://img.kancloud.cn/96/5b/965b390cafd239b8f33c44496a99dd64_978x674.png" alt="img"></p><h4 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a><strong>UsernamePasswordAuthenticationFilter</strong></h4><p>该过滤器封装用户基本信息（用户名、密码），定义登录表单数据接收相关的信息。如：</p><ul><li>默认的表单用户名密码input框name是username、password</li><li>默认的处理登录请求路径是/login、使用POST方法</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808222037202.png" alt="image-20210808222037202"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808222219124.png" alt="image-20210808222219124"></p><h4 id="AbstractAuthenticationProcessingFilter的doFilter方法的验证过程"><a href="#AbstractAuthenticationProcessingFilter的doFilter方法的验证过程" class="headerlink" title="AbstractAuthenticationProcessingFilter的doFilter方法的验证过程"></a><strong>AbstractAuthenticationProcessingFilter的doFilter方法的验证过程</strong></h4><p><code>UsernamePasswordAuthenticationFilter</code>继承自抽象类<code>AbstractAuthenticationProcessingFilter</code>，该抽象类定义了验证成功与验证失败的处理方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span></span><span class="hljs-class">      <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationEventPublisherAware</span>, <span class="hljs-title">MessageSourceAware</span> </span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808222657609.png" alt="image-20210808222657609"></p><h4 id="验证成功之后的Handler和验证失败之后的handler"><a href="#验证成功之后的Handler和验证失败之后的handler" class="headerlink" title="验证成功之后的Handler和验证失败之后的handler"></a><strong>验证成功之后的Handler和验证失败之后的handler</strong></h4><p><code>AbstractAuthenticationProcessingFilter</code>中定义了验证成功与验证失败的处理Handler。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AuthenticationSuccessHandler successHandler = <span class="hljs-keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();<span class="hljs-keyword">private</span> AuthenticationFailureHandler failureHandler = <span class="hljs-keyword">new</span> SimpleUrlAuthenticationFailureHandler();</code></pre></div><p>也就是说当我们需要自定义验证成功或失败的处理方法时，要去实现<code>AuthenticationSuccessHandler</code>或<code>AuthenticationfailureHandler</code>接口</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808222936948.png" alt="image-20210808222936948"></p><h3 id="👏回到正题"><a href="#👏回到正题" class="headerlink" title="👏回到正题"></a>👏回到正题</h3><p>我们知道如果我们不希望用户、角色、权限信息写死在配置里面。我们应该实现<code>UserDetails</code>与<code>UserDetailsService</code>接口，从而从数据库或者其他的存储上动态的加载这些信息。</p><h4 id="UserDetails与UserDetailsService是什么呢？"><a href="#UserDetails与UserDetailsService是什么呢？" class="headerlink" title="UserDetails与UserDetailsService是什么呢？"></a><strong>UserDetails与UserDetailsService是什么呢？</strong></h4><p><code>UserDetailsService</code>接口表达的是如何动态加载<code>UserDetails</code>数据。</p><ul><li><code>UserDetailsService</code>接口有一个方法叫做<code>loadUserByUsername</code>，我们实现动态加载用户、角色、权限信息就是通过实现该方法。函数见名知义：通过用户名加载用户。该方法的返回值就是<code>UserDetails</code></li><li><code>UserDetails</code>就是用户信息，即：用户名、密码、该用户所具有的权限。</li></ul><p>下面我们来看一下<code>UserDetails</code>接口都有哪些方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">//获取用户的权限集合</span>    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();    <span class="hljs-comment">//获取密码</span>    <span class="hljs-function">String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//获取用户名</span>    <span class="hljs-function">String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//账号是否没过期</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//账号是否没被锁定</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//密码是否没过期</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//账户是否可用</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>现在我们明白了，只要我们把这些信息提供给Spring Security，Spring Security就知道怎么做登录验证了，根本不需要我们自己写Controller实现登录验证逻辑。那我们怎么把这些信息提供给Spring Security，用的就是下面的接口方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;   <span class="hljs-function">UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException</span>;&#125;</code></pre></div><p>现在我们明白了，只要我们把这些信息提供给Spring Security，Spring Security就知道怎么做登录验证了，根本不需要我们自己写Controller实现登录验证逻辑。那我们怎么把这些信息提供给Spring Security，用的就是下面的接口方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;   <span class="hljs-function">UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException</span>;&#125;</code></pre></div><h4 id="实现UserDetails-接口"><a href="#实现UserDetails-接口" class="headerlink" title="实现UserDetails 接口"></a>实现UserDetails 接口</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;  String password;  <span class="hljs-comment">//密码</span>  String username;  <span class="hljs-comment">//用户名</span>  <span class="hljs-keyword">boolean</span> accountNonExpired;   <span class="hljs-comment">//是否没过期</span>  <span class="hljs-keyword">boolean</span> accountNonLocked;   <span class="hljs-comment">//是否没被锁定</span>  <span class="hljs-keyword">boolean</span> credentialsNonExpired;  <span class="hljs-comment">//密码是否没过期</span>  <span class="hljs-keyword">boolean</span> enabled;  <span class="hljs-comment">//账号是否可用</span>  Collection&lt;? extends GrantedAuthority&gt; authorities;  <span class="hljs-comment">//用户的权限集合</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;    <span class="hljs-keyword">this</span>.password = password;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;    <span class="hljs-keyword">this</span>.username = username;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAccountNonExpired</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> accountNonExpired)</span> </span>&#123;    <span class="hljs-keyword">this</span>.accountNonExpired = accountNonExpired;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAccountNonLocked</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> accountNonLocked)</span> </span>&#123;    <span class="hljs-keyword">this</span>.accountNonLocked = accountNonLocked;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCredentialsNonExpired</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> credentialsNonExpired)</span> </span>&#123;    <span class="hljs-keyword">this</span>.credentialsNonExpired = credentialsNonExpired;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnabled</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> enabled)</span> </span>&#123;    <span class="hljs-keyword">this</span>.enabled = enabled;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthorities</span><span class="hljs-params">(Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;    <span class="hljs-keyword">this</span>.authorities = authorities;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;    <span class="hljs-keyword">return</span> authorities;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> password;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> username;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//暂时未用到，直接返回true，表示账户未过期</span>  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//暂时未用到，直接返回true，表示账户未被锁定</span>  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//暂时未用到，直接返回true，表示账户密码未过期</span>  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> enabled;  &#125;&#125;</code></pre></div><p>我们就是写了一个适应于<code>UserDetails</code>的Bean类，所谓的 <code>UserDetails</code>接口实现就是一些get方法。</p><ul><li>get方法由Spring Security调用，获取认证及鉴权的数据</li><li>我们通过set方法或构造函数为 Spring Security 提供<code>UserDetails</code>数据（从数据库查询）。</li><li><strong>当enabled的值为false的时候，Spring Security 会自动的禁用该用户，禁止该用户进行系统登录。</strong></li><li>通常数据库表sys_user字段要和Hr 属性一一对应，比如username、password、enabled。</li></ul><blockquote><p>目前数据库表里面没有定义accountNonExpired、accountNonLocked、credentialsNonExpired这三个字段，我一般不喜欢搞这么多字段控制用户的登录认证行为，笔者觉得简单点好，一个enabled字段就够了。所以这三个成员变量对应的get方法，直接返回true即可。</p></blockquote><p>另外，<strong>UserDetails中还有一个方法叫做getAuthorities，该方法用来获取当前用户所具有的角色</strong>，我的角色中有一个roles属性（即role表）用来描述当前用户的角色，因此我的getAuthorities方法的实现如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;    List&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (Role role : roles) &#123;        authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));    &#125;    <span class="hljs-keyword">return</span> authorities;&#125;</code></pre></div><p>即直接从<code>roles</code>中获取当前用户所具有的角色，构造<code>SimpleGrantedAuthority</code>然后返回即可</p><p><code>SimpleGrantedAuthority</code>简单来说就是存储授予<code>Authentication</code>对象的权限的字符串表示形式。</p><h4 id="SimpleGrantedAuthority"><a href="#SimpleGrantedAuthority" class="headerlink" title="SimpleGrantedAuthority"></a><strong>SimpleGrantedAuthority</strong></h4><p>在Security中，角色和权限共用<code>GrantedAuthority</code>接口，唯一的不同角色就是多了个前缀”ROLE_”，而且它没有Shiro的那种从属关系，即一个角色包含哪些权限等等。在Security看来角色和权限时一样的，它认证的时候，把所有权限（角色、权限）都取出来，而不是分开验证。</p><p>所以，在Security提供的<code>UserDetailsService</code>默认实现<code>JdbcDaoImpl</code>中，角色和权限都存储在auhtorities表中。而不是像Shiro那样，角色有个roles表，权限有个permissions表。以及相关的管理表等等。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleGrantedAuthority</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GrantedAuthority</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String role;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleGrantedAuthority</span><span class="hljs-params">(String role)</span> </span>&#123;      Assert.hasText(role, <span class="hljs-string">&quot;A granted authority textual representation is required&quot;</span>);      <span class="hljs-keyword">this</span>.role = role;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthority</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.role;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == obj) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125;      <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> SimpleGrantedAuthority) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.role.equals(((SimpleGrantedAuthority) obj).role);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.role.hashCode();   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.role;   &#125;&#125;</code></pre></div><p>注意，在构建<code>SimpleGrantedAuthority</code>对象的时候，它没有添加任何前缀。所以表示”角色”的权限，在数据库中就带有”ROLE_”前缀了。所以<code>authorities</code>表中的视图可能是这样的。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220537827.png" alt="image-20210809220537827"></p><p><strong>角色和权限能否分开存储？角色能不能不带”ROLE_”前缀</strong></p><p>当然可以分开存储，你可以定义两张表，一张存角色，一张存权限。但是你自定义<code>UserDetailsService</code>的时候，需要保证把这两张表的数据都取出来，放到<code>UserDails</code>的权限集合中。当然你数据库中存储的角色也可以不带”ROLE_”前缀，就像这样。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220551920.png" alt="image-20210809220551920"></p><p>但是前面说到了，Security才不管你是角色，还是权限。它只比对字符串。</p><p>比如它有个表达式hasRole(“ADMIN”)。那它实际上查询的是用户权限集合中是否存在字符串”ROLE_ADMIN”。如果你从角色表中取出用户所拥有的角色时不加上”ROLE_”前缀，那验证的时候就匹配不上了。</p><p>所以角色信息存储的时候可以没有”ROLE_”前缀，但是包装成<code>GrantedAuthority</code>对象的时候必须要有。</p><h4 id="自定义Service"><a href="#自定义Service" class="headerlink" title="自定义Service"></a>自定义Service</h4><p>创建好<code>Hr</code>之后，接下来我们需要创建<code>HrService</code>，用来执行登录等操作，**<code>HrService</code>需要实现<code>UserDetailsService</code>接口，如下：**</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HrService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HrMapper hrMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        Hr hr = hrMapper.loadUserByUsername(username);        <span class="hljs-keyword">if</span> (hr == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;用户名不存在！&quot;</span>);        &#125;        hr.setRoles(hrMapper.getHrRolesById(hr.getId()));        <span class="hljs-keyword">return</span> hr;    &#125;</code></pre></div><p>这里最主要是实现了**<code>UserDetailsService</code>接口中的<code>loadUserByUsername</code>方法**，在执行登录的过程中，这个方法将根据用户名去查找用户，如果用户不存在，则抛出<code>UsernameNotFoundException</code>异常，否则直接将查到的<code>Hr</code>返回。<code>HrMapper</code>用来执行数据库的查询操作。</p><h2 id="🔑根据请求地址获取角色"><a href="#🔑根据请求地址获取角色" class="headerlink" title="🔑根据请求地址获取角色"></a>🔑根据请求地址获取角色</h2><p>先引入一下<code>SecurityMetadataSource</code>的概念：</p><h3 id="SecurityMetadataSource"><a href="#SecurityMetadataSource" class="headerlink" title="SecurityMetadataSource"></a>SecurityMetadataSource</h3><p><code>SecurityMetadataSource</code>是<code>Spring Security</code>的一个概念模型接口。用于表示对受权限保护的”安全对象”的权限设置信息。一个该类对象可以被理解成一个映射表，映射表中的每一项包含如下信息 :</p><ul><li>安全对象</li><li>安全对象所需权限信息</li></ul><p>围绕该映射表，<code>SecurityMetadataSource</code> 定义了如下方法 :</p><ul><li><code>Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException;</code></li></ul><blockquote><p>获取某个受保护的安全对象<code>object</code>的所需要的权限信息,是一组<code>ConfigAttribute</code>对象的集合，如果该安全对象<code>object</code>不被当前<code>SecurityMetadataSource</code>对象支持,则抛出异常<code>IllegalArgumentException</code>。<br>该方法通常配合<code>boolean supports(Class&lt;?&gt; clazz)</code>一起使用，先使用<code>boolean supports(Class&lt;?&gt; clazz)</code>确保安全对象能被当前<code>SecurityMetadataSource</code>支持，然后再调用该方法。</p></blockquote><ul><li><code>Collection&lt;ConfigAttribute&gt; getAllConfigAttributes()</code></li></ul><blockquote><p>获取该<code>SecurityMetadataSource</code>对象中保存的针对所有安全对象的权限信息的集合。该方法的主要目的是被<code>AbstractSecurityInterceptor</code>用于启动时校验每个<code>ConfigAttribute</code>对象。</p></blockquote><ul><li><code>boolean supports(Class&lt;?&gt; clazz)</code></li></ul><blockquote><p>这里<code>clazz</code>表示安全对象的类型，该方法用于告知调用者当前<code>SecurityMetadataSource</code>是否支持此类安全对象，只有支持的时候，才能对这类安全对象调用<code>getAttributes</code>方法。</p></blockquote><p><strong>继承关系</strong></p><p><img src="https://img-blog.csdnimg.cn/20190623090023883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZHlfemhhbmcyMDA3,size_16,color_FFFFFF,t_70" alt="SecurityMetadataSource"><br><code>Spring Security</code>对<code>SecurityMetadataSource</code>提供了两个子接口 :</p><ul><li><p>```<br>MethodSecurityMetadataSource</p><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">  &gt; 由`Spring Security Core`定义，用于表示安全对象是方法调用(`MethodInvocation`)的安全元数据源。- ```  FilterInvocationSecurityMetadataSource</code></pre></div><blockquote><p>由<code>Spring Security Web</code>定义，用于表示安全对象是<code>Web</code>请求(<code>FilterInvocation</code>)的安全元数据源。</p></blockquote></li></ul><h3 id="FilterInvocationSecurityMetadataSource"><a href="#FilterInvocationSecurityMetadataSource" class="headerlink" title="FilterInvocationSecurityMetadataSource"></a>FilterInvocationSecurityMetadataSource</h3><p>一般情况下，我们如果需要自定义权限拦截，则需要涉及到<code>FilterInvocationSecurityMetadataSource</code>这个接口了。</p><p>这里有个坑爹的地方。如果用户未登录，但是已经设置了拦截白名单的URL，仍然会进入到权限验证里面来。起初，我以为不会进来，但后来跟踪源代码发现，还是会进来。只是此时的身份是一个匿名用户。其默认的实现为<code>DefaultFilterInvocationSecurityMetadataSource</code></p><p>spring security的认证和权限流程，大概就是有多个过滤器，一步步调用filter chain。它的身份认证其实是始于访问资源开始。如果一个用户已登录，那么访问受保护的资源，则会校验该用户是否有权限访问。如果没有权限，则会调用权限拒绝的处理器进行处理。如果有权限，则能顺利访问该资源；</p><p>一个用户未登录情况下，也即匿名用户，访问受保护的资源时，spring security会首先检查该资源是否需要权限，如果需要权限，然后再检查，该资源是否是白名单里面。如果是白名单，也能正常访问。如果是受保护的资源，则会提示该用户需要登录。</p><p>也即，当一个匿名用户，访问受保护的资源时，就会提示该用户需要登录。</p><p>所以说，在<code>FilterInvocationSecurityMetadataSource</code>中默认的实现类<code>DefaultFilterInvocationSecurityMetadataSource</code><strong>的主要功能就是通过当前的请求地址，获取该地址需要的用户角色</strong></p><p>我们可以参考这个实现类，自己也定义一个<code>FilterInvocationSecurityMetadataSource</code>，如下</p><p>主要工作为：</p><ul><li>从数据源中加载<code>ConfigAttribute</code>到<code>SecurityMetadataSource</code>资源器中</li><li>重写<code>getAttributes()</code>加载<code>ConfigAttribute</code>为<code>AccessDecisionManager.decide()</code>授权决策做准备。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomFilterInvocationSecurityMetadataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterInvocationSecurityMetadataSource</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MenuService menuService;    <span class="hljs-comment">//路径匹配</span>    AntPathMatcher antPathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAttributes</span><span class="hljs-params">(Object object)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;        <span class="hljs-comment">//获取请求的地址</span>        String requestUrl = ((FilterInvocation) object).getRequestUrl();        List&lt;Menu&gt; menus = menuService.getAllMenusWithRole();        <span class="hljs-keyword">for</span> (Menu menu : menus) &#123;            <span class="hljs-keyword">if</span> (antPathMatcher.match(menu.getUrl(), requestUrl)) &#123;                List&lt;Role&gt; roles = menu.getRoles();                String[] str = <span class="hljs-keyword">new</span> String[roles.size()];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; roles.size(); i++) &#123;                    str[i] = roles.get(i).getName();                &#125;                <span class="hljs-keyword">return</span> SecurityConfig.createList(str);            &#125;        &#125;        <span class="hljs-comment">//没有匹配上的资源，都是登录访问</span>        <span class="hljs-keyword">return</span> SecurityConfig.createList(<span class="hljs-string">&quot;ROLE_LOGIN&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAllConfigAttributes</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ul><li>一开始注入了<code>MenuService</code>，<code>MenuService</code>的作用是用来查询数据库中url pattern和role的对应关系（ <code>menuService.getAllMenu()</code>后面可用缓存来存），查询结果是一个List集合，集合中是Menu类，<strong>Menu类有两个核心属性，一个是url pattern，即匹配规则(比如<code>/admin/**</code>)，还有一个是List，即这种规则的路径需要哪些角色才能访问。</strong></li><li>我们可以从<code>getAttributes(Object o)</code>方法的参数o中提取出当前的请求url，然后将这个请求url和数据库中查询出来的所有url pattern一一对照，看符合哪一个url pattern，然后就获取到该url pattern所对应的角色，当然这个角色可能有多个，所以遍历角色，最后利用<code>SecurityConfig.createList</code>方法来创建一个角色集合。</li><li>第二步的操作中，涉及到一个优先级问题，比如我的地址是<code>/employee/basic/hello</code>,这个地址既能被<code>/employee/**</code>匹配，也能被<code>/employee/basic/**</code>匹配，这就要求我们从数据库查询的时候对数据进行排序，将<code>/employee/basic/**</code>类型的url pattern放在集合的前面去比较。</li><li>如果<code>getAttributes(Object o)</code>方法返回null的话，意味着当前这个请求不需要任何角色就能访问，甚至不需要登录。但是在我的整个业务中，并不存在这样的请求，我这里的要求是，<strong>所有未匹配到的路径，都是认证(登录)后可访问，因此我在这里返回一个<code>ROLE_LOGIN</code>的角色，这种角色在我的角色数据库中并不存在，因此我将在下一步的角色比对过程中特殊处理这种角色</strong>。</li><li>如果地址是<code>/login_p</code>，这个是登录页，不需要任何角色即可访问，直接返回null。</li><li><code>getAttributes(Object o)</code>方法返回的集合最终会来到<code>AccessDecisionManager</code>类中，接下来我们再来看<code>AccessDecisionManager</code>类</li></ul><h2 id="🔑-检查角色是否满足匹配"><a href="#🔑-检查角色是否满足匹配" class="headerlink" title="🔑  检查角色是否满足匹配"></a>🔑  检查角色是否满足匹配</h2><p>先引入一下<code>AccessDecisionManager</code>的概念：</p><h3 id="AccessDecisionManager"><a href="#AccessDecisionManager" class="headerlink" title="AccessDecisionManager"></a>AccessDecisionManager</h3><p><img src="https://oscimg.oschina.net/oscnet/fe299820424c5ead6a7f3bc97fa8dd957a5.jpg" alt="img"></p><p><strong>AccessDecisionManager</strong> 顾名思义，访问决策管理器。即做出最终的访问控制（授权）决定。</p><p>而常用的 <strong>AccessDecisionManager</strong> 有三个，这里我就使用最简单的一个<strong>AffirmativeBased</strong>中的思想，这是<strong>Spring Security</strong> 框架默认的 <strong>AccessDecisionManager</strong>：<strong>只要任一 AccessDecisionVoter 返回肯定的结果，便授予访问权限</strong>。</p><p>自定义<code>CustomUrlDecisionManager</code>类实现<code>AccessDecisionManager</code>接口，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUrlDecisionManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDecisionManager</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decide</span><span class="hljs-params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="hljs-keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;        <span class="hljs-keyword">for</span> (ConfigAttribute configAttribute : configAttributes) &#123;            <span class="hljs-comment">//当前请求需要的权限</span>            String needRole = configAttribute.getAttribute();            <span class="hljs-comment">//如果是匿名用户，抛异常</span>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ROLE_LOGIN&quot;</span>.equals(needRole)) &#123;                <span class="hljs-keyword">if</span> (authentication <span class="hljs-keyword">instanceof</span> AnonymousAuthenticationToken)&#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;尚未登录，请登录！&quot;</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            <span class="hljs-comment">//当前用户所具有的权限</span>            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();            <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;                <span class="hljs-comment">//需要的角色能被检测到</span>                <span class="hljs-keyword">if</span> (authority.getAuthority().equals(needRole))&#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;权限不足，请返回！&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><ul><li>decide方法接收三个参数，<strong>其中第一个参数中保存了当前登录用户的角色信息，第三个参数则是<code>CustomFilterInvocationSecurityMetadataSource</code>中的<code>getAttributes</code>方法传来的，表示当前请求需要的角色（可能有多个）</strong></li><li>如果当前请求需要的权限为<code>ROLE_LOGIN</code>则表示登录即可访问，和角色没有关系，此时我需要判断authentication是不是<code>AnonymousAuthenticationToken</code>的一个实例，如果是，则表示当前用户没有登录，没有登录就抛一个<code>BadCredentialsException</code>异常，登录了就直接返回，则这个请求将被成功执行。</li><li><strong>遍历collection，同时查看当前用户的角色列表中是否具备需要的权限</strong>，如果具备就直接返回，否则就抛异常。</li><li>这里涉及到一个all和any的问题：假设当前用户具备角色A、角色B，当前请求需要角色B、角色C，那么是要当前用户要包含所有请求角色才算授权成功还是只要包含一个就算授权成功？我这里采用了第二种方案，即只要包含一个即可</li></ul><p><strong>到目前为止，获取角色和判断角色是否满足匹配到部分已经分析结束，下面开始分析登录的验证和自定义登录过滤器的具体流程</strong></p><h2 id="🔍登录的验证"><a href="#🔍登录的验证" class="headerlink" title="🔍登录的验证"></a>🔍登录的验证</h2><p>下面就要针对于登录进行更深一步的说明，登录验证涉及到账号、密码、与验证码</p><h3 id="PasswordEncoder"><a href="#PasswordEncoder" class="headerlink" title="PasswordEncoder"></a>PasswordEncoder</h3><p><code>PasswordEncoder</code> 是Spring Scurity框架内处理密码加密与校验的接口。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.security.crypto.password;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PasswordEncoder</span> </span>&#123;   <span class="hljs-function">String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span></span>;   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span></span>;   <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">upgradeEncoding</span><span class="hljs-params">(String encodedPassword)</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;&#125;</code></pre></div><p>这个接口有三个方法</p><ul><li><code>encode</code>方法接受的参数是原始密码字符串，返回值是经过加密之后的hash值，hash值是不能被逆向解密的。这个方法通常在为系统添加用户，或者用户注册的时候使用。</li><li><code>matches</code>方法是用来校验用户输入密码rawPassword，和加密后的hash值encodedPassword是否匹配。如果能够匹配返回true，表示用户输入的密码rawPassword是正确的，反之返回fasle。也就是说虽然这个hash值不能被逆向解密，但是可以判断是否和原始密码匹配。<strong>这个方法通常在用户登录的时候进行用户输入密码的正确性校验。</strong></li><li><code>upgradeEncoding</code>设计的用意是，判断当前的密码是否需要升级。也就是是否需要重新加密？需要的话返回true，不需要的话返回fasle。默认实现是返回false。</li></ul><p> <strong><code>BCryptPasswordEncoder</code> 作为Spring Security推荐使用的 <code>PasswordEncoder</code>实现类 ，可以实现对密码的自动加密加盐</strong>，（盐是值即使相同的明文，生成的新的加密字符串都是不一样的），这样可以避免像在Shiro中那样我们自己配置密码的盐，而 <code>BCryptPasswordEncoder</code> 就是     <code>PasswordEncoder</code> 接口的实现类，只需要提供 <code>BCryptPasswordEncoder</code> 这个 Bean 的实例即可，SpringSecurity中使用<code>BCryptPasswordEncoder</code>的具体流程如下：</p><blockquote><p>BCryptPasswordEncoder 使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。</p></blockquote><p>在用户注册时，我们需要对密码进行处理，处理方式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hrReg</span><span class="hljs-params">(String username, String password)</span> </span>&#123;    <span class="hljs-comment">//如果用户名存在，返回错误</span>    <span class="hljs-keyword">if</span> (hrMapper.loadUserByUsername(username) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    BCryptPasswordEncoder encoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    String encode = encoder.encode(password);    <span class="hljs-keyword">return</span> hrMapper.hrReg(username, encode);&#125;</code></pre></div><p>用户将密码从前端传来之后，通过调用 <code>BCryptPasswordEncoder</code> 实例中的 encode 方法对密码进行加密处理，加密完成后将密文存入数据库。</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">$2a$10$zt6dUMTjNSyzINTGyiAgluna3mPm7qdgl26vj4tFpsFO6WlK5lXNm</span></code></pre></div><p>BCrypt加密后的密码有三个部分，由 $分隔：</p><ol><li>“2a”表示 BCrypt 算法版本</li><li>“10”表示算法的强度</li><li>“zt6dUMTjNSyzINTGyiAglu”部分实际上是随机生成的盐。通常来说前 22 个字符是盐，剩余部分是纯文本的实际哈希值。</li></ol><blockquote><p>BCrypt算法生成长度为 60 的字符串，因此我们需要确保密码将存储在可以容纳密码的数据库列中。</p></blockquote><p>当用户注册成功之后，存在数据库中的密码就像下面这样：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/p283.png" alt="p283"></p><p>假如明文都是 123。配置完成后，使用 admin/123 或者 sang/123 就可以实现登录。</p><p>密码加密处理之后，登录时候也要对密码进行处理，<strong>修改SecurityConfig类的configure(AuthenticationManagerBuilder auth)方法，</strong>改为下面这样即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    auth.userDetailsService(hrService);&#125;</code></pre></div><h3 id="验证码的校验"><a href="#验证码的校验" class="headerlink" title="验证码的校验"></a>验证码的校验</h3><p>验证码的生成接口十分多，这里不再提供，这个工具类很常见，网上也有很多，就是画一个简单的验证码，通过流将验证码写到前端页面，提供验证码的 Controller 如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/verifyCode&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyCode</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;  <span class="hljs-comment">//获取实例</span>    VerificationCode code = <span class="hljs-keyword">new</span> VerificationCode();    BufferedImage image = code.getImage();    String text = code.getText();    HttpSession session = request.getSession(<span class="hljs-keyword">true</span>);    session.setAttribute(<span class="hljs-string">&quot;verify_code&quot;</span>, text);    VerificationCode.output(image,resp.getOutputStream());&#125;</code></pre></div><p>同时需要在Spring Security配置类中配置不拦截此接口</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//防止访问登录页面死循环，不用进入Security拦截</span>    web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/img/**&quot;</span>, <span class="hljs-string">&quot;/fonts/**&quot;</span>, <span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;/verifyCode&quot;</span>);&#125;</code></pre></div><p>因为涉及到自定义登陆逻辑，所以需要自定义登陆过滤器，这里先不说明实现过滤器的详细流程，等到下面讲到JSON登陆的时候，统一处理</p><p>需要注意的是，过滤器自定义完成后，也需要在配置类中注入，这里才能能完成整个流程的配置。</p><h3 id="实现JSON格式登陆"><a href="#实现JSON格式登陆" class="headerlink" title="实现JSON格式登陆"></a>实现JSON格式登陆</h3><p>前后端分离这样的开发架构下，前后端的交互都是通过 JSON 来进行，无论登录成功还是失败，都不会有什么服务端跳转或者客户端跳转之类。</p><p>登录成功了，服务端就返回一段登录成功的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，就和后端没有关系了。</p><p>登录失败了，服务端就返回一段登录失败的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，也和后端没有关系了。</p><p>所以为了统一，我们需要在登录的时候，也实现JSON交互，但是我们首先得明白一个前提， 在使用 SpringSecurity 中，默认的登录数据是通过 <code>key/value</code> 的形式来传递的，<strong>默认情况下不支持 JSON格式的登录数据，如果有这种需求，就需要自己来解决，所以我们需要自定义过滤器</strong></p><p>首先大家知道，用户登录的用户名/密码是在 <code>UsernamePasswordAuthenticationFilter</code> 类中处理的，具体的处理代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;String username = obtainUsername(request);String password = obtainPassword(request);    <span class="hljs-comment">//省略</span>&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainPassword</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">return</span> request.getParameter(passwordParameter);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainUsername</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">return</span> request.getParameter(usernameParameter);&#125;</code></pre></div><p>从这段代码中，我们就可以看出来为什么 Spring Security 默认是通过 key/value 的形式来传递登录参数，因为它处理的方式就是<code> request.getParameter</code>。</p><p>所以我们要定义成 JSON 的，思路很简单，就是自定义来定义一个过滤器代替 <code>UsernamePasswordAuthenticationFilter</code>，然后在获取参数的时候，换一种方式就行了。</p><p>所以我们需要模仿源代码中的此部分来个性化定制：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809163840081.png" alt="image-20210809163840081"></p><p><strong>这里有一个额外的点需要注意，就是现在还有验证码的功能，所以如果自定义过滤器，要连同验证码一起处理掉。</strong></p><p>接下来我们来自定义一个过滤器代替 <code>UsernamePasswordAuthenticationFilter</code> ，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;  <span class="hljs-comment">//需要重写的方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;      <span class="hljs-comment">//此部分逻辑不变</span>        <span class="hljs-keyword">if</span> (!request.getMethod().equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(                    <span class="hljs-string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());        &#125;      <span class="hljs-comment">//拿到正确的验证码</span>        String verify_code = (String) request.getSession().getAttribute(<span class="hljs-string">&quot;verify_code&quot;</span>);      <span class="hljs-comment">//判断是Key/Value还是JSON传递</span>        <span class="hljs-keyword">if</span> (request.getContentType().contains(MediaType.APPLICATION_JSON_VALUE) || request.getContentType().contains(MediaType.APPLICATION_JSON_UTF8_VALUE)) &#123;          <span class="hljs-comment">//封装传来的数据</span>            Map&lt;String, String&gt; loginData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            <span class="hljs-keyword">try</span> &#123;                loginData = <span class="hljs-keyword">new</span> ObjectMapper().readValue(request.getInputStream(), Map.class);            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            &#125;<span class="hljs-keyword">finally</span> &#123;              <span class="hljs-comment">//浏览器传过来输入的</span>                String code = loginData.get(<span class="hljs-string">&quot;code&quot;</span>);                checkCode(response, code, verify_code);            &#125;            String username = loginData.get(getUsernameParameter());            String password = loginData.get(getPasswordParameter());            <span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;                username = <span class="hljs-string">&quot;&quot;</span>;            &#125;            <span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;                password = <span class="hljs-string">&quot;&quot;</span>;            &#125;            username = username.trim();            UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(                    username, password);            setDetails(request, authRequest);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);        &#125;       <span class="hljs-comment">//Key/Value直接用父类处理即可</span>      <span class="hljs-keyword">else</span> &#123;            checkCode(response, request.getParameter(<span class="hljs-string">&quot;code&quot;</span>), verify_code);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.attemptAuthentication(request, response);        &#125;    &#125;<span class="hljs-comment">//校验输入的和正确生成的是否匹配</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkCode</span><span class="hljs-params">(HttpServletResponse resp, String code, String verify_code)</span> </span>&#123;        <span class="hljs-keyword">if</span> (code == <span class="hljs-keyword">null</span> || verify_code == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(code) || !verify_code.toLowerCase().equals(code.toLowerCase())) &#123;            <span class="hljs-comment">//验证码不正确</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">&quot;验证码不正确&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>这段逻辑我们基本上是模仿官方提供的 <code>UsernamePasswordAuthenticationFilter</code> 来写的，稍微解释下：</p><ol><li>首先登录请求肯定是 POST，如果不是 POST ，直接抛出异常，后面的也不处理了。</li><li>因为要在这里处理验证码，所以第二步从 session 中把已经下发过的验证码的值拿出来。</li><li>接下来通过 contentType 来判断当前请求是否通过 JSON 来传递参数，如果是通过 JSON 传递参数，则按照 JSON 的方式解析，如果不是，则调用 <code>super.attemptAuthentication </code>方法，进入父类的处理逻辑中，也就是说，<strong>我们自定义的这个类，既支持 JSON 形式传递参数，也支持 key/value 形式传递参数。</strong></li><li>如果是 JSON 形式的数据，我们就通过读取 request 中的 I/O 流，将 JSON 映射到一个 Map 上。</li><li>从 Map 中取出 code，先去判断验证码是否正确，如果验证码有错，则直接抛出异常</li><li>接下来从 Map 中取出 username 和 password，构造 UsernamePasswordAuthenticationToken 对象并作校验。</li></ol><p><strong>接下来就是在Spring Security配置类中配置此过滤器即可</strong></p><h3 id="Spring-Security配置类"><a href="#Spring-Security配置类" class="headerlink" title="Spring Security配置类"></a>Spring Security配置类</h3><h4 id="基础注入"><a href="#基础注入" class="headerlink" title="基础注入"></a>基础注入</h4><p>结合以上所讲的，就能在配置类中整合所有需要用到的校验类，首先在Spring Security配置类中配置基础的信息</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<span class="hljs-comment">//UserDetial的校验</span>    <span class="hljs-meta">@Autowired</span>    HrService hrService;  <span class="hljs-comment">//根据请求地址获取角色的校验</span>    <span class="hljs-meta">@Autowired</span>    CustomFilterInvocationSecurityMetadataSource customFilterInvocationSecurityMetadataSource;<span class="hljs-comment">//检查角色的校验</span>    <span class="hljs-meta">@Autowired</span>    CustomUrlDecisionManager customUrlDecisionManager;<span class="hljs-comment">//密码的校验</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;<span class="hljs-comment">//密码加密处理后配置</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(hrService);    &#125;</code></pre></div><h4 id="登陆成功失败的回调"><a href="#登陆成功失败的回调" class="headerlink" title="登陆成功失败的回调"></a>登陆成功失败的回调</h4><p>接下来就需要针对刚定义好的过滤器进一步配置</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    LoginFilter loginFilter = <span class="hljs-keyword">new</span> LoginFilter();  <span class="hljs-comment">//成功回调</span>    loginFilter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;                response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                PrintWriter out = response.getWriter();                Hr hr = (Hr) authentication.getPrincipal();                hr.setPassword(<span class="hljs-keyword">null</span>);                RespBean ok = RespBean.ok(<span class="hljs-string">&quot;登录成功!&quot;</span>, hr);                String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok);                out.write(s);                out.flush();                out.close();            &#125;    );  <span class="hljs-comment">//失败回调</span>    loginFilter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;                response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                PrintWriter out = response.getWriter();                RespBean respBean = RespBean.error(exception.getMessage());                <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> LockedException) &#123;                    respBean.setMsg(<span class="hljs-string">&quot;账户被锁定，请联系管理员!&quot;</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;                    respBean.setMsg(<span class="hljs-string">&quot;密码过期，请联系管理员!&quot;</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;                    respBean.setMsg(<span class="hljs-string">&quot;账户过期，请联系管理员!&quot;</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> DisabledException) &#123;                    respBean.setMsg(<span class="hljs-string">&quot;账户被禁用，请联系管理员!&quot;</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;                    respBean.setMsg(<span class="hljs-string">&quot;用户名或者密码输入错误，请重新输入!&quot;</span>);                &#125;                out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));                out.flush();                out.close();            &#125;    );</code></pre></div><p><code>AuthenticationSuccessHandler</code>方法有三个参数，分别是：</p><ul><li><code>HttpServletRequest</code></li><li><code>HttpServletResponse</code></li><li><code>Authentication</code></li></ul><p>有了前两个参数，我们就可以在这里随心所欲的返回数据了。利用 <code>HttpServletRequest</code> 我们可以做服务端跳转，利用 <code>HttpServletResponse </code>我们可以做客户端跳转，当然，也可以返回 JSON 数据。</p><p>第三个 <code>Authentication</code> 参数则保存了我们刚刚登录成功的用户信息。</p><p>同理，失败的回调也是三个参数，前两个就不用说了，第三个是一个 Exception，对于登录失败，会有不同的原因，Exception 中则保存了登录失败的原因，我们可以将之通过 JSON 返回到前端。</p><h4 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h4><p>这里我还挨个去识别了一下异常的类型，根据不同的异常类型，我们可以给用户一个更加明确的提示，但是有一个需要注意的点：</p><p>当用户登录时，用户名或者密码输入错误，我们一般只给一个模糊的提示，即<strong>用户名或者密码输入错误，请重新输入</strong>，而不会给一个明确的诸如“用户名输入错误”或“密码输入错误”这样精确的提示，但是对于很多不懂行的新手小伙伴，他可能就会给一个明确的错误提示，这会给系统带来风险。</p><p>但是使用了 Spring Security 这样的安全管理框架之后，即使你是一个新手，也不会犯这样的错误。</p><p>在 Spring Security 中，用户名查找失败对应的异常是：</p><ul><li><code>UsernameNotFoundException</code></li></ul><p>密码匹配失败对应的异常是：</p><ul><li><code>BadCredentialsException</code></li></ul><p>但是我们在登录失败的回调中，却总是看不到 <code>UsernameNotFoundException </code>异常，无论用户名还是密码输入错误，抛出的异常都是 <code>BadCredentialsException</code></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<span class="hljs-keyword">try</span> &#123;user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);&#125;<span class="hljs-keyword">catch</span> (UsernameNotFoundException notFound) &#123;logger.debug(<span class="hljs-string">&quot;User &#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27; not found&quot;</span>);<span class="hljs-keyword">if</span> (hideUserNotFoundExceptions) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(<span class="hljs-string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>,<span class="hljs-string">&quot;Bad credentials&quot;</span>));&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">throw</span> notFound;&#125;&#125;&#125;</code></pre></div><p>从这段代码中，我们看出，在查找用户时，如果抛出了 <code>UsernameNotFoundException</code>，这个异常会被捕获，捕获之后，如果 <code>hideUserNotFoundExceptions</code> 属性的值为 true，就抛出一个 <code>BadCredentialsException</code>。相当于将 <code>UsernameNotFoundException </code>异常隐藏了，而默认情况下，<code>hideUserNotFoundExceptions</code> 的值就为 true。</p><h4 id="登陆未验证"><a href="#登陆未验证" class="headerlink" title="登陆未验证"></a>登陆未验证</h4><p>在前后端分离中，如果用户没有登录就访问一个需要认证后才能访问的页面，这个时候，我们不应该让用户重定向到登录页面，而是给用户一个尚未登录的提示，前端收到提示之后，再自行决定页面跳转。</p><p>要解决这个问题，就涉及到 Spring Security 中的一个接口 <code>AuthenticationEntryPoint</code> ，该接口有一个实现类：<code>LoginUrlAuthenticationEntryPoint</code> ，该类中有一个方法 <code>commence</code>，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Performs the redirect (or forward) to the login form URL.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span><span class="hljs-function"><span class="hljs-params">AuthenticationException authException)</span> </span>&#123;String redirectUrl = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (useForward) &#123;<span class="hljs-keyword">if</span> (forceHttps &amp;&amp; <span class="hljs-string">&quot;http&quot;</span>.equals(request.getScheme())) &#123;redirectUrl = buildHttpsRedirectUrlForRequest(request);&#125;<span class="hljs-keyword">if</span> (redirectUrl == <span class="hljs-keyword">null</span>) &#123;String loginForm = determineUrlToUseForThisRequest(request, response,authException);<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">&quot;Server side forward to: &quot;</span> + loginForm);&#125;RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);dispatcher.forward(request, response);<span class="hljs-keyword">return</span>;&#125;&#125;<span class="hljs-keyword">else</span> &#123;redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);&#125;redirectStrategy.sendRedirect(request, response, redirectUrl);&#125;</code></pre></div><p>首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。</p><p>那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;.csrf().disable().exceptionHandling()<span class="hljs-comment">//没有认证时，在这里处理结果，不要重定向</span>.authenticationEntryPoint((req, resp, authException) -&gt; &#123;            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);            resp.setStatus(<span class="hljs-number">401</span>);            PrintWriter out = resp.getWriter();            RespBean respBean = RespBean.error(<span class="hljs-string">&quot;访问失败!&quot;</span>);            <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;                respBean.setMsg(<span class="hljs-string">&quot;请求失败，请联系管理员!&quot;</span>);            &#125;            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));            out.flush();            out.close();        &#125;);</code></pre></div><p>在 Spring Security 的配置中加上自定义的 <code>AuthenticationEntryPoint</code> 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。</p><h4 id="注销登录"><a href="#注销登录" class="headerlink" title="注销登录"></a>注销登录</h4><p>注销登录我们前面说过，按照前面的配置，注销登录之后，系统自动跳转到登录页面，这也是不合适的，如果是前后端分离项目，注销登录成功后返回 JSON 即可，配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        .logout()        .logoutSuccessHandler((req, resp, authentication) -&gt; &#123;         resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);         PrintWriter out = resp.getWriter();         out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.ok(<span class="hljs-string">&quot;注销成功!&quot;</span>)));         out.flush();         out.close();         &#125;         )         .permitAll()&#125;</code></pre></div><h4 id="LoginFilter的配置"><a href="#LoginFilter的配置" class="headerlink" title="LoginFilter的配置"></a>LoginFilter的配置</h4><p>在自定义JSON过滤器后，LoginFilter也需要相应的配置到安全配置类中</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;...loginFilter.setAuthenticationManager(authenticationManagerBean());loginFilter.setFilterProcessesUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>);&#125;</code></pre></div><p>当我们代替了 <code>UsernamePasswordAuthenticationFilter</code> 之后，原本在 <code>SecurityConfig#configure</code>方法中关于 form 表单的配置就会失效，那些失效的属性，都可以在配置 <code>LoginFilter</code> 实例的时候配置。另外记得配置一个 <code>AuthenticationManager</code>，根据 <code>WebSecurityConfigurerAdapter</code> 中提供的配置即可。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809192541708.png" alt="image-20210809192541708"></p><p><code>FilterProcessUrl</code> 则可以根据实际情况配置，如果不配置，默认的就是 <code>/login</code>。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809192208902.png" alt="image-20210809192208902"></p><p>最后，我们用自定义的 <code>LoginFilter</code> 实例代替 <code>UsernamePasswordAuthenticationFilter</code>，调用 addFilterAt 方法完成替换操作</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()        ...        <span class="hljs-comment">//省略</span>    http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);&#125;</code></pre></div><p><strong>上面基本就已经实现了基于RBAC的登陆流程，这里附上整体的配置类代码：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">** * <span class="hljs-meta">@author</span> lucifer */<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HrService hrService;    <span class="hljs-meta">@Autowired</span>    CustomFilterInvocationSecurityMetadataSource customFilterInvocationSecurityMetadataSource;    <span class="hljs-meta">@Autowired</span>    CustomUrlDecisionManager customUrlDecisionManager;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(hrService);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//防止访问登录页面死循环，不用进入Security拦截</span>        web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/img/**&quot;</span>, <span class="hljs-string">&quot;/fonts/**&quot;</span>, <span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;/verifyCode&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        LoginFilter loginFilter = <span class="hljs-keyword">new</span> LoginFilter();        loginFilter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;                    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                    PrintWriter out = response.getWriter();                    Hr hr = (Hr) authentication.getPrincipal();                    hr.setPassword(<span class="hljs-keyword">null</span>);                    RespBean ok = RespBean.ok(<span class="hljs-string">&quot;登录成功!&quot;</span>, hr);                    String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok);                    out.write(s);                    out.flush();                    out.close();                &#125;        );        loginFilter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;                    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                    PrintWriter out = response.getWriter();                    RespBean respBean = RespBean.error(exception.getMessage());                    <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> LockedException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;账户被锁定，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;密码过期，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;账户过期，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> DisabledException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;账户被禁用，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;用户名或者密码输入错误，请重新输入!&quot;</span>);                    &#125;                    out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));                    out.flush();                    out.close();                &#125;        );        loginFilter.setAuthenticationManager(authenticationManagerBean());        loginFilter.setFilterProcessesUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>);        <span class="hljs-keyword">return</span> loginFilter;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;                        object.setAccessDecisionManager(customUrlDecisionManager);                        object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);                        <span class="hljs-keyword">return</span> object;                    &#125;                &#125;)                .and()                .logout()                .logoutSuccessHandler((req, resp, authentication) -&gt; &#123;                            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                            PrintWriter out = resp.getWriter();                            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.ok(<span class="hljs-string">&quot;注销成功!&quot;</span>)));                            out.flush();                            out.close();                        &#125;                )                .permitAll()                .and()                .csrf().disable().exceptionHandling()                <span class="hljs-comment">//没有认证时，在这里处理结果，不要重定向</span>                .authenticationEntryPoint((req, resp, authException) -&gt; &#123;                            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                            resp.setStatus(<span class="hljs-number">401</span>);                            PrintWriter out = resp.getWriter();                            RespBean respBean = RespBean.error(<span class="hljs-string">&quot;访问失败!&quot;</span>);                            <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;                                respBean.setMsg(<span class="hljs-string">&quot;请求失败，请联系管理员!&quot;</span>);                            &#125;                            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));                            out.flush();                            out.close();                        &#125;                );        http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);    &#125;&#125;</code></pre></div><h3 id="http-authorizeRequests"><a href="#http-authorizeRequests" class="headerlink" title="http.authorizeRequests()"></a>http.authorizeRequests()</h3><p>可以发现在配置中的开头有这样的配置，这个是干什么的？</p><p>这就涉及到 Spring Security 中过滤器链的配置问题了</p><blockquote><p>结合动态处理角色和资源的关系一起看</p></blockquote><h4 id="从过滤器开始"><a href="#从过滤器开始" class="headerlink" title="从过滤器开始"></a>从过滤器开始</h4><p>Spring Security 中一共提供了 32 个过滤器，其中默认使用的有 15 个，</p><p>在一个 Web 项目中，请求流程大概如下图所示：</p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220745044.png" alt="image-20210809220745044" style="zoom:50%;" /><p>请求从客户端发起（例如浏览器），然后穿过层层 Filter，最终来到 Servlet 上，被 Servlet 所处理。</p><p>那么，Spring Security 中默认的 15 个过滤器就是这样嵌套在 Client 和 Servlet 之间吗？</p><p>不是的！</p><p>上图中的 Filter 我们可以称之为 Web Filter，Spring Security 中的 Filter 我们可以称之为 Security Filter，它们之间的关系如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220801972.png" alt="image-20210809220801972"></p><p>可以看到，Spring Security Filter 并不是直接嵌入到 Web Filter 中的，而是通过 <code>FilterChainProxy</code> 来统一管理 Spring Security Filter，<code>FilterChainProxy</code> 本身则通过 Spring 提供的 <code>DelegatingFilterProxy </code>代理过滤器嵌入到 Web Filter 之中。</p><blockquote><p>DelegatingFilterProxy 很多小伙伴应该比较熟悉，在 Spring 中手工整合 Spring Session、Shiro 等工具时都离不开它，现在用了 Spring Boot，很多事情 Spring Boot 帮我们做了，所以有时候会感觉 DelegatingFilterProxy 的存在感有所降低，实际上它一直都在。</p></blockquote><h4 id="多个过滤器链"><a href="#多个过滤器链" class="headerlink" title="多个过滤器链"></a>多个过滤器链</h4><p>上面和大家介绍的是单个过滤器链，实际上，在 Spring Security 中，可能存在多个过滤器链。</p><p>有人会问，下面这种配置是不是就是多个过滤器链？</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            .antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)            .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasRole(<span class="hljs-string">&quot;user&quot;</span>)            .anyRequest().authenticated()            ...            .csrf().disable();&#125;</code></pre></div><p>这样的配置相信大家都见过，但是这并不是多个过滤器链，这是一个过滤器链。因为不管是 <code>/admin/**</code> 还是 <code>/user/**</code> ，走过的过滤器都是一样的，只是不同的路径判断条件不一样而已。</p><p>如果系统存在多个过滤器链，多个过滤器链会在 FilterChainProxy 中进行划分，如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220817060.png" alt="image-20210809220817060"></p><p>可以看到，当请求到达 <code>FilterChainProxy</code> 之后，<code>FilterChainProxy</code> 会根据请求的路径，将请求转发到不同的 Spring Security Filters 上面去，不同的 Spring Security Filters 对应了不同的过滤器，也就是不同的请求将经过不同的过滤器。</p><h4 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h4><p>最后，我们在回到一开始的问题。</p><p>首先，<code>http.authorizeRequests()</code> 配置并非总在第一行出现，如果只有一个过滤器链，他总是在第一行出现，表示该过滤器链的拦截规则是 <code>/**</code>（<strong>请求只有先被过滤器链拦截下来，接下来才会进入到不同的 Security Filters 中进行处理</strong>），如果存在多个过滤器链，就不一定了。</p><div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-meta">@Configuration</span>    <span class="hljs-meta">@Order(1)</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultWebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            http.antMatcher(<span class="hljs-string">&quot;/foo/**&quot;</span>)                    .authorizeRequests()                    .anyRequest().hasRole(<span class="hljs-string">&quot;admin&quot;</span>)                    .and()                    .csrf().disable();        &#125;    &#125;    <span class="hljs-meta">@Configuration</span>    <span class="hljs-meta">@Order(2)</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultWebSecurityConfig2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            http.antMatcher(<span class="hljs-string">&quot;/bar/**&quot;</span>)                    .authorizeRequests()                    .anyRequest().hasRole(<span class="hljs-string">&quot;user&quot;</span>)                    .and()                    .formLogin()                    .permitAll()                    .and()                    .csrf().disable();        &#125;    &#125;&#125;</code></pre></div><ol><li>注意在静态内部类里边，我没有使用 <code>http.authorizeRequests()</code> 开始，<code>http.authorizeRequests()</code> 配置表示该过滤器链过滤的路径是 <code>/**</code>。在静态内部类里边，我是用了 <code>http.antMatcher(&quot;/bar/**&quot;)</code> 开启配置，表示将当前过滤器链的拦截范围限定在 <code>/bar/**</code>。</li><li>当存在多个过滤器链的时候，必然会有一个优先级的问题，所以每一个过滤器链的配置类上通过 @Order(2) 注解来标记优先级。</li></ol><p>仅仅从字面意思来理解，<code>authorizeRequests()</code> 方法的返回值是 <code>ExpressionUrlAuthorizationConfigurer.ExpressionInterceptUrlRegistry，ExpressionUrlAuthorizationConfigurer</code> 可以为多组不同的 RequestMatcher 配置不同的权限规则，就是大家看到的 <code>.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;).antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;)</code>。</p><p><strong>对于配置中的一些细节（为什么要用这些来实现），将在下面用源码来进行分析，感兴趣的可以了解下</strong></p><h2 id="🔧加餐：源码剖析Spring-Security"><a href="#🔧加餐：源码剖析Spring-Security" class="headerlink" title="🔧加餐：源码剖析Spring Security"></a>🔧加餐：源码剖析Spring Security</h2><blockquote><p>本文基本上参考搬运了松哥的文章，松哥对Spring Security理解的十分透彻，推荐去学习，附上网站：<a href="http://www.javaboy.org/">http://www.javaboy.org</a></p></blockquote><p>本部分主要针对<code>HttpSecurity、SecurityConfigurer、AuthenticationManagerBuilder、WebSecurityConfigurerAdapter</code>四部分进行源码分析，其他关键的类已在前面的部分做了必要的阐述</p><h3 id="👀HttpSecurity"><a href="#👀HttpSecurity" class="headerlink" title="👀HttpSecurity"></a>👀HttpSecurity</h3><blockquote><p>此节建议结合登陆的验证中的配置类来看</p></blockquote><p><code>HttpSecurity</code> 也是 Spring Security 中的重要一环。我们平时所做的大部分 Spring Security 配置也都是基于 <code>HttpSecurity </code>来配置的。比如，刚才我们配置类中的<code>configure</code>就使用到了</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception</span></code></pre></div><p>首先我们来看下 HttpSecurity 的继承关系图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220933162.png" alt="image-20210809220933162"></p><p>可以看到，<code>HttpSecurity</code> 继承自 <code>AbstractConfiguredSecurityBuilder</code>，同时实现了 <code>SecurityBuilder </code>和 <code>HttpSecurityBuilder</code> 两个接口。</p><p>我们来看下 <code>HttpSecurity</code> 的定义：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpSecurity</span> <span class="hljs-keyword">extends</span></span><span class="hljs-class">  <span class="hljs-title">AbstractConfiguredSecurityBuilder</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">HttpSecurity</span>&gt;</span><span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>&gt;,</span><span class="hljs-class">  <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">HttpSecurity</span>&gt; </span>&#123;        <span class="hljs-comment">//...</span>&#125;</code></pre></div><p>这里每一个类都带有泛型，看得人有点眼花缭乱。</p><p>我把这个泛型类拿出来和大家讲一下，小伙伴们就明白了。</p><p>泛型主要是两个，<code>DefaultSecurityFilterChain</code> 和 <code>HttpSecurity</code>，<code>HttpSecurity</code> 就不用说了，这是我们今天的主角，那么 <code>DefaultSecurityFilterChain</code> 是干嘛的？</p><p>这我们就得从 <code>SecurityFilterChain</code> 说起了。</p><h4 id="SecurityFilterChain"><a href="#SecurityFilterChain" class="headerlink" title="SecurityFilterChain"></a>SecurityFilterChain</h4><p>先来看定义：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityFilterChain</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(HttpServletRequest request)</span></span>; <span class="hljs-function">List&lt;Filter&gt; <span class="hljs-title">getFilters</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p><code>SecurityFilterChain</code> 其实就是我们平时所说的 Spring Security 中的过滤器链，它里边定义了两个方法，一个是 matches 方法用来匹配请求，另外一个 getFilters 方法返回一个 List 集合，集合中放着 Filter 对象，当一个请求到来时，用 matches 方法去比较请求是否和当前链吻合，如果吻合，就返回 getFilters 方法中的过滤器，那么当前请求会逐个经过 List 集合中的过滤器。</p><p><code>SecurityFilterChain </code>接口只有一个实现类，那就是 <code>DefaultSecurityFilterChain</code>，<strong>那么从上面的介绍中，大家可以看到，<code>DefaultSecurityFilterChain</code> 其实就相当于是 Spring Security 中的过滤器链，一个 <code>DefaultSecurityFilterChain</code> 代表一个过滤器链，如果系统中存在多个过滤器链，则会存在多个 <code>DefaultSecurityFilterChain</code> 对象。</strong></p><p>接下来我们把 <code>HttpSecurity</code> 的这几个父类捋一捋。</p><h4 id="⚠️SecurityBuilder"><a href="#⚠️SecurityBuilder" class="headerlink" title="⚠️SecurityBuilder"></a>⚠️SecurityBuilder</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt; </span>&#123; <span class="hljs-function">O <span class="hljs-title">build</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><p><code>SecurityBuilder </code>就是用来构建过滤器链的，在 <code>HttpSecurity</code> 实现 <code>SecurityBuilder</code> 时，传入的泛型就是 <code>DefaultSecurityFilterChain</code>，所以 <code>SecurityBuilder#build</code> 方法的功能很明确，就是用来构建一个过滤器链出来。</p><h4 id="HttpSecurityBuilder"><a href="#HttpSecurityBuilder" class="headerlink" title="HttpSecurityBuilder"></a>HttpSecurityBuilder</h4><p><code>HttpSecurityBuilder</code> 看名字就是用来构建 <code>HttpSecurity</code> 的。不过它也只是一个接口，具体的实现在 <code>HttpSecurity </code>中，接口定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">H</span>&gt;&gt; <span class="hljs-keyword">extends</span></span><span class="hljs-class">  <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>&gt; </span>&#123; &lt;C extends SecurityConfigurer&lt;DefaultSecurityFilterChain, H&gt;&gt; <span class="hljs-function">C <span class="hljs-title">getConfigurer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">   Class&lt;C&gt; clazz)</span></span>; &lt;C extends SecurityConfigurer&lt;DefaultSecurityFilterChain, H&gt;&gt; <span class="hljs-function">C <span class="hljs-title">removeConfigurer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">   Class&lt;C&gt; clazz)</span></span>; &lt;C&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setSharedObject</span><span class="hljs-params">(Class&lt;C&gt; sharedType, C object)</span></span>; &lt;C&gt; <span class="hljs-function">C <span class="hljs-title">getSharedObject</span><span class="hljs-params">(Class&lt;C&gt; sharedType)</span></span>; <span class="hljs-function">H <span class="hljs-title">authenticationProvider</span><span class="hljs-params">(AuthenticationProvider authenticationProvider)</span></span>; <span class="hljs-function">H <span class="hljs-title">userDetailsService</span><span class="hljs-params">(UserDetailsService userDetailsService)</span> <span class="hljs-keyword">throws</span> Exception</span>; <span class="hljs-function">H <span class="hljs-title">addFilterAfter</span><span class="hljs-params">(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</span></span>; <span class="hljs-function">H <span class="hljs-title">addFilterBefore</span><span class="hljs-params">(Filter filter, Class&lt;? extends Filter&gt; beforeFilter)</span></span>; <span class="hljs-function">H <span class="hljs-title">addFilter</span><span class="hljs-params">(Filter filter)</span></span>;&#125;</code></pre></div><p>这里的方法比较简单：</p><ol><li><code>getConfigurer</code> 获取一个配置对象。Spring Security 过滤器链中的所有过滤器对象都是由 xxxConfigure 来进行配置的，这里就是获取这个 xxxConfigure 对象。</li><li><code>removeConfigurer</code> 移除一个配置对象。</li><li><code>setSharedObject/getSharedObject</code> 配置/获取由多个 <code>SecurityConfigurer</code> 共享的对象。</li><li><code>authenticationProvider</code> 方法表示配置验证器。</li><li><code>userDetailsService</code> 配置数据源接口。</li><li><code>addFilterAfter</code> 在某一个过滤器之前添加过滤器。</li><li><code>addFilterBefore</code> 在某一个过滤器之后添加过滤器。</li><li><code>addFilter</code> 添加一个过滤器，该过滤器必须是现有过滤器链中某一个过滤器或者其扩展。</li></ol><p>这便是 <code>HttpSecurityBuilder</code> 中的功能，这些接口在<code>HttpSecurity</code>中都将得到实现。</p><h4 id="AbstractSecurityBuilder"><a href="#AbstractSecurityBuilder" class="headerlink" title="AbstractSecurityBuilder"></a>AbstractSecurityBuilder</h4><p><code>AbstractSecurityBuilder </code>类实现了 <code>SecurityBuilder</code> 接口，该类中主要做了一件事，就是确保整个构建只被构建一次。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt; </span>&#123; <span class="hljs-keyword">private</span> AtomicBoolean building = <span class="hljs-keyword">new</span> AtomicBoolean(); <span class="hljs-keyword">private</span> O object; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> O <span class="hljs-title">build</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.building.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;   <span class="hljs-keyword">this</span>.object = doBuild();   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object;  &#125;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AlreadyBuiltException(<span class="hljs-string">&quot;This object has already been built&quot;</span>); &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> O <span class="hljs-title">getObject</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.building.get()) &#123;   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;This object has not been built&quot;</span>);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object; &#125; <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> O <span class="hljs-title">doBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><p>可以看到，这里重新定义了 build 方法，并设置 build 方法为 final 类型，无法被重写，在 build 方法中，通过 <code>AtomicBoolean</code> 实现该方法只被调用一次。具体的构建逻辑则定义了新的抽象方法 doBuild，将来在实现类中通过 doBuild 方法定义构建逻辑。</p><h4 id="AbstractConfiguredSecurityBuilder"><a href="#AbstractConfiguredSecurityBuilder" class="headerlink" title="AbstractConfiguredSecurityBuilder"></a>AbstractConfiguredSecurityBuilder</h4><p><code>AbstractSecurityBuilder</code> 方法的实现类就是 <code>AbstractConfiguredSecurityBuilder</code>。</p><p><code>AbstractConfiguredSecurityBuilder</code> 中所做的事情就比较多了，我们分别来看。</p><p>首先 <code>AbstractConfiguredSecurityBuilder</code> 中定义了一个枚举类，将整个构建过程分为 5 种状态，也可以理解为构建过程生命周期的五个阶段，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BuildState</span> </span>&#123; UNBUILT(<span class="hljs-number">0</span>), INITIALIZING(<span class="hljs-number">1</span>), CONFIGURING(<span class="hljs-number">2</span>), BUILDING(<span class="hljs-number">3</span>), BUILT(<span class="hljs-number">4</span>); <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> order; BuildState(<span class="hljs-keyword">int</span> order) &#123;  <span class="hljs-keyword">this</span>.order = order; &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInitializing</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> INITIALIZING.order == order; &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConfigured</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> order &gt;= CONFIGURING.order; &#125;&#125;</code></pre></div><p>五种状态分别是 UNBUILT、INITIALIZING、CONFIGURING、BUILDING 以及 BUILT。另外还提供了两个判断方法，isInitializing 判断是否正在初始化，isConfigured 表示是否已经配置完毕。</p><p><code>AbstractConfiguredSecurityBuilder</code> 中的方法比较多，在这里列出来两个关键的方法和大家分析：</p><ul><li>第一个就是这个 add 方法，这相当于是在收集所有的配置类。将所有的 xxxConfigure 收集起来存储到 configurers 中，将来再统一初始化并配置，configurers 本身是一个 LinkedHashMap ，key 是配置类的 class，value 是一个集合，集合里边放着 xxxConfigure 配置类。当需要对这些配置类进行集中配置的时候，会通过 getConfigurers 方法获取配置类，这个获取过程就是把 LinkedHashMap 中的 value 拿出来，放到一个集合中返回。</li><li>在 <code>AbstractSecurityBuilder</code> 类中，过滤器的构建被转移到 doBuild 方法上面了，不过在 <code>AbstractSecurityBuilder</code> 中只是定义了抽象的 doBuild 方法，具体的实现在<code>AbstractConfiguredSecurityBuilder</code>。doBuild 方法就是一边更新状态，进行进行初始化。</li></ul><h4 id="回到主题HttpSecurity"><a href="#回到主题HttpSecurity" class="headerlink" title="回到主题HttpSecurity"></a>回到主题HttpSecurity</h4><p><code>HttpSecurity</code> 做的事情，就是进行各种各样的 xxxConfigurer 配置。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CorsConfigurer&lt;HttpSecurity&gt; <span class="hljs-title">cors</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-keyword">return</span> getOrApply(<span class="hljs-keyword">new</span> CorsConfigurer&lt;&gt;());&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> CsrfConfigurer&lt;HttpSecurity&gt; <span class="hljs-title">csrf</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; ApplicationContext context = getContext(); <span class="hljs-keyword">return</span> getOrApply(<span class="hljs-keyword">new</span> CsrfConfigurer&lt;&gt;(context));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> ExceptionHandlingConfigurer&lt;HttpSecurity&gt; <span class="hljs-title">exceptionHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-keyword">return</span> getOrApply(<span class="hljs-keyword">new</span> ExceptionHandlingConfigurer&lt;&gt;());&#125;</code></pre></div><p><code>HttpSecurity</code> 中有大量类似的方法，过滤器链中的过滤器就是这样一个一个配置的。我就不一一介绍了。</p><p>每个配置方法的结尾都会来一句 getOrApply，这个是干嘛的？</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;C extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt;&gt; <span class="hljs-function">C <span class="hljs-title">getOrApply</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  C configurer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; C existingConfig = (C) getConfigurer(configurer.getClass()); <span class="hljs-keyword">if</span> (existingConfig != <span class="hljs-keyword">null</span>) &#123;  <span class="hljs-keyword">return</span> existingConfig; &#125; <span class="hljs-keyword">return</span> apply(configurer);&#125;</code></pre></div><p><code>getConfigurer</code> 方法是在它的父类 <code>AbstractConfiguredSecurityBuilder</code> 中定义的，目的就是去查看当前这个 xxxConfigurer 是否已经配置过了。</p><p>如果当前 xxxConfigurer 已经配置过了，则直接返回，否则调用 apply 方法，这个 apply 方法最终会调用到 <code>AbstractConfiguredSecurityBuilder#add</code> 方法，将当前配置 configurer 收集起来。</p><p><code>HttpSecurity</code> 中还有一个 <code>addFilter</code> 方法（上面也用到的）：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpSecurity <span class="hljs-title">addFilter</span><span class="hljs-params">(Filter filter)</span> </span>&#123; Class&lt;? extends Filter&gt; filterClass = filter.getClass(); <span class="hljs-keyword">if</span> (!comparator.isRegistered(filterClass)) &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(    <span class="hljs-string">&quot;The Filter class &quot;</span>      + filterClass.getName()      + <span class="hljs-string">&quot; does not have a registered order and cannot be added without a specified order. Consider using addFilterBefore or addFilterAfter instead.&quot;</span>); &#125; <span class="hljs-keyword">this</span>.filters.add(filter); <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre></div><p>这个 <code>addFilter</code> 方法的作用，主要是在各个 xxxConfigurer 进行配置的时候，会调用到这个方法，（xxxConfigurer 就是用来配置过滤器的），把 Filter 都添加到 fitlers 变量中。</p><p>最终在 <code>HttpSecurity</code> 的 <code>performBuild</code> 方法中，构建出来一个过滤器链：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> DefaultSecurityFilterChain <span class="hljs-title">performBuild</span><span class="hljs-params">()</span> </span>&#123; filters.sort(comparator); <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSecurityFilterChain(requestMatcher, filters);&#125;</code></pre></div><p>先给过滤器排序，然后构造 <code>DefaultSecurityFilterChain</code> 对象。</p><h3 id="👀SecurityConfigurer"><a href="#👀SecurityConfigurer" class="headerlink" title="👀SecurityConfigurer"></a>👀SecurityConfigurer</h3><blockquote><p>此节建议结合登陆的验证中的配置类来看</p></blockquote><p><code>SecurityConfigurer</code> 在 Spring Security 中是一个非常重要的角色。Spring Security 过滤器链中的每一个过滤器，都是通过 xxxConfigurer 来进行配置的（上面配置类中重写的configure就是这里的<code>SecurityConfigurer</code>），而这些 xxxConfigurer 实际上都是 <code>SecurityConfigurer </code>的实现。</p><p><code>SecurityConfigurer</code> 本身是一个接口，我们来看下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt;&gt; </span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception</span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><p>可以看到，<code>SecurityConfigurer</code> 中主要是两个方法，init 和 configure。</p><p>init 就是一个初始化方法。而 configure 则是一个配置方法。这里只是规范了方法的定义，具体的实现则在不同的实现类中。</p><p>需要注意的是这两个方法的参数类型都是一个泛型 B，也就是 <code>SecurityBuilder</code> 的子类，关于 <code>SecurityBuilder</code> ，它是用来构建过滤器链的。</p><p><code>SecurityConfigurer</code> 有三个实现类：</p><ul><li><code>SecurityConfigurerAdapter</code></li><li><code>GlobalAuthenticationConfigurerAdapter</code></li><li><code>WebSecurityConfigurer</code></li></ul><h4 id="SecurityConfigurerAdapter"><a href="#SecurityConfigurerAdapter" class="headerlink" title="SecurityConfigurerAdapter"></a>SecurityConfigurerAdapter</h4><p><code>SecurityConfigurerAdapter</code> 实现了 <code>SecurityConfigurer</code> 接口，我们所使用的大部分的 xxxConfigurer 也都是 <code>SecurityConfigurerAdapter</code> 的子类。</p><p><code>SecurityConfigurerAdapter</code> 在<code> SecurityConfigurer</code> 的基础上，还扩展出来了几个非常好用的方法，我们一起来看下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt;&gt;</span><span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span>&gt; </span>&#123; <span class="hljs-keyword">private</span> B securityBuilder; <span class="hljs-keyword">private</span> CompositeObjectPostProcessor objectPostProcessor = <span class="hljs-keyword">new</span> CompositeObjectPostProcessor(); <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">and</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> getBuilder(); &#125; <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> B <span class="hljs-title">getBuilder</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (securityBuilder == <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;securityBuilder cannot be null&quot;</span>);  &#125;  <span class="hljs-keyword">return</span> securityBuilder; &#125; <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">postProcess</span><span class="hljs-params">(T object)</span> </span>&#123;  <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">this</span>.objectPostProcessor.postProcess(object); &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObjectPostProcessor</span><span class="hljs-params">(ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> </span>&#123;  <span class="hljs-keyword">this</span>.objectPostProcessor.addObjectPostProcessor(objectPostProcessor); &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBuilder</span><span class="hljs-params">(B builder)</span> </span>&#123;  <span class="hljs-keyword">this</span>.securityBuilder = builder; &#125; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositeObjectPostProcessor</span> <span class="hljs-keyword">implements</span></span><span class="hljs-class">   <span class="hljs-title">ObjectPostProcessor</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;  <span class="hljs-keyword">private</span> List&lt;ObjectPostProcessor&lt;?&gt;&gt; postProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcess</span><span class="hljs-params">(Object object)</span> </span>&#123;   <span class="hljs-keyword">for</span> (ObjectPostProcessor opp : postProcessors) &#123;    Class&lt;?&gt; oppClass = opp.getClass();    Class&lt;?&gt; oppType = GenericTypeResolver.resolveTypeArgument(oppClass,      ObjectPostProcessor.class);    <span class="hljs-keyword">if</span> (oppType == <span class="hljs-keyword">null</span> || oppType.isAssignableFrom(object.getClass())) &#123;     object = opp.postProcess(object);    &#125;   &#125;   <span class="hljs-keyword">return</span> object;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addObjectPostProcessor</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> </span>&#123;   <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">this</span>.postProcessors.add(objectPostProcessor);   postProcessors.sort(AnnotationAwareOrderComparator.INSTANCE);   <span class="hljs-keyword">return</span> result;  &#125; &#125;&#125;</code></pre></div><ul><li><code>CompositeObjectPostProcessor</code> 首先一开始声明了一个 <code>CompositeObjectPostProcessor</code> 实例，<code>CompositeObjectPostProcessor</code> 是 <code>ObjectPostProcessor</code> 的一个实现，<code>ObjectPostProcessor</code> 本身是一个后置处理器，该后置处理器默认有两个实现，<code>AutowireBeanFactoryObjectPostProcessor</code> 和 <code>CompositeObjectPostProcessor</code>:<ul><li>其中 <code>AutowireBeanFactoryObjectPostProcessor </code>主要是利用了 <code>AutowireCapableBeanFactory</code> 对 Bean 进行手动注册，因为在 Spring Security 中，很多对象都是手动 new 出来的，这些 new 出来的对象和容器没有任何关系，利用 AutowireCapableBeanFactory 可以将这些手动 new 出来的对象注入到容器中，而 <code>AutowireBeanFactoryObjectPostProcessor</code> 的主要作用就是完成这件事</li><li><code>CompositeObjectPostProcessor</code> 则是一个复合的对象处理器，里边维护了一个 List 集合，这个 List 集合中，大部分情况下只存储一条数据，那就是 <code>AutowireBeanFactoryObjectPostProcessor</code>，用来完成对象注入到容器的操作，如果用户自己手动调用了 <code>addObjectPostProcessor</code> 方法，那么 <code>CompositeObjectPostProcessor</code> 集合中维护的数据就会多出来一条，在 <code>CompositeObjectPostProcessor#postProcess</code> 方法中，会遍历集合中的所有 ObjectPostProcessor，挨个调用其 postProcess 方法对对象进行后置处理。</li></ul></li><li>and 方法，该方法返回值是一个 <code>securityBuilder</code>，<code>securityBuilder</code> 实际上就是 <code>HttpSecurity</code>，我们在 <code>HttpSecurity</code> 中去配置不同的过滤器时，可以使用 and 方法进行链式配置，就是因为这里定义了 and 方法并返回了 <code>securityBuilder</code> 实例。</li></ul><p>这便是 <code>SecurityConfigurerAdapter</code> 的主要功能，后面大部分的 xxxConfigurer 都是基于此类来实现的。</p><p><code>SecurityConfigurerAdapter</code> 的实现主要也是三大类：</p><ul><li><code>UserDetailsAwareConfigurer</code></li><li><code>AbstractHttpConfigurer</code></li><li><code>LdapAuthenticationProviderConfigurer</code></li></ul><p>考虑到 LDAP 现在使用很少，所以这里我来和大家重点介绍下前两个。</p><h5 id="UserDetailsAwareConfigurer"><a href="#UserDetailsAwareConfigurer" class="headerlink" title="UserDetailsAwareConfigurer"></a>UserDetailsAwareConfigurer</h5><p>这个配置类看名字大概就知道这是用来配置用户类的。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809221022916.png" alt="image-20210809221022916"></p><blockquote><p><strong>AbstractDaoAuthenticationConfigurer</strong></p><p>AbstractDaoAuthenticationConfigurer 中所做的事情比较简单，主要是构造了一个默认的 DaoAuthenticationProvider，并为其配置 PasswordEncoder 和 UserDetailsService。</p><p><strong>UserDetailsServiceConfigurer</strong></p><p>UserDetailsServiceConfigurer 重写了 AbstractDaoAuthenticationConfigurer 中的 configure 方法，在 configure 方法执行之前加入了 initUserDetailsService 方法，以方便开发展按照自己的方式去初始化 UserDetailsService。不过这里的 initUserDetailsService 方法是空方法。</p><p><strong>UserDetailsManagerConfigurer</strong></p><p>UserDetailsManagerConfigurer 中实现了 UserDetailsServiceConfigurer 中定义的 initUserDetailsService 方法，具体的实现逻辑就是将 UserDetailsBuilder 所构建出来的 UserDetails 以及提前准备好的 UserDetails 中的用户存储到 UserDetailsService 中。</p><p>该类同时添加了 withUser 方法用来添加用户，同时还增加了一个 UserDetailsBuilder 用来构建用户，这些逻辑都比较简单，可以自行查看。</p><p><strong>JdbcUserDetailsManagerConfigurer</strong></p><p>JdbcUserDetailsManagerConfigurer 在父类的基础上补充了 DataSource 对象，同时还提供了相应的数据库查询方法。</p><p><strong>InMemoryUserDetailsManagerConfigurer</strong></p><p>InMemoryUserDetailsManagerConfigurer 在父类的基础上重写了构造方法，将父类中的 UserDetailsService 实例定义为 InMemoryUserDetailsManager。</p><p><strong>DaoAuthenticationConfigurer</strong></p><p>DaoAuthenticationConfigurer 继承自 AbstractDaoAuthenticationConfigurer，只是在构造方法中修改了一下 userDetailsService 而已。</p></blockquote><h5 id="⚠️AbstractHttpConfigurer"><a href="#⚠️AbstractHttpConfigurer" class="headerlink" title="⚠️AbstractHttpConfigurer"></a>⚠️AbstractHttpConfigurer</h5><p><code>AbstractHttpConfigurer </code>这一派中的东西非常多，我们所有的过滤器配置，都是它的子类，我们来看下都有哪些类？</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809221037144.png" alt="image-20210809221037144"></p><p><code>AbstractHttpConfigurer</code> 继承自 <code>SecurityConfigurerAdapter</code>，并增加了两个方法，disable 和 withObjectPostProcessor：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHttpConfigurer</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractHttpConfigurer</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">B</span>&gt;, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">B</span>&gt;&gt;</span><span class="hljs-class">  <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">B</span>&gt; </span>&#123; <span class="hljs-comment">/**</span><span class="hljs-comment">  * Disables the &#123;<span class="hljs-doctag">@link</span> AbstractHttpConfigurer&#125; by removing it. After doing so a fresh</span><span class="hljs-comment">  * version of the configuration can be applied.</span><span class="hljs-comment">  *</span><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> the &#123;<span class="hljs-doctag">@link</span> HttpSecurityBuilder&#125; for additional customizations</span><span class="hljs-comment">  */</span> <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">disable</span><span class="hljs-params">()</span> </span>&#123;  getBuilder().removeConfigurer(getClass());  <span class="hljs-keyword">return</span> getBuilder(); &#125; <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">withObjectPostProcessor</span><span class="hljs-params">(ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> </span>&#123;  addObjectPostProcessor(objectPostProcessor);  <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">this</span>; &#125;&#125;</code></pre></div><p>这两个方法之前都有给大家介绍过，disable 基本上是大家的老熟人了，我们常用的 <code>.csrf().disable()</code> 就是出自这里，那么从这里我们也可以看到 disable 的实现原理，就是从 getBuilder 中移除相关的 xxxConfigurer，getBuilder 方法获取到的实际上就是 HttpSecurity，所以移除掉 xxxConfigurer 实际上就是从过滤器链中移除掉某一个过滤器，例如 <code>.csrf().disable()</code> 就是移除掉处理 csrf 的过滤器。</p><p>另一个增加的方法是 <code>withObjectPostProcessor</code>，这是为配置类添加手动添加后置处理器的。在 <code>AbstractHttpConfigurer</code> 的父类中其实有一个类似的方法就是 <code>addObjectPostProcessor</code>，但是 <code>addObjectPostProcessor</code> 只是一个添加方法，返回值为 void，而 withObjectPostProcessor 的返回值是当前配置类，也就是 xxxConfigurer，所以如果使用 withObjectPostProcessor 的话，可以使用链式配置，事实上，上面的项目配置使用的也都是 <code>withObjectPostProcessor</code> 方法（当然，你也可以使用 addObjectPostProcessor，最终效果是一样的）。</p><h5 id="⚠️AbstractAuthenticationFilterConfigurer"><a href="#⚠️AbstractAuthenticationFilterConfigurer" class="headerlink" title="⚠️AbstractAuthenticationFilterConfigurer"></a>⚠️AbstractAuthenticationFilterConfigurer</h5><p><code>AbstractAuthenticationFilterConfigurer</code> 类的功能比较多，源码也是相当相当长。不过我们只需要抓住两点即可，<strong>init 方法和 configure 方法，因为这两个方法是所有 xxxConfigurer 的灵魂。</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; updateAuthenticationDefaults(); updateAccessDefaults(http); registerDefaultAuthenticationEntryPoint(http);&#125;</code></pre></div><p>init 方法主要干了三件事：</p><ol><li><code>updateAuthenticationDefaults</code> 主要是配置了登录处理地址，失败跳转地址，注销成功跳转地址。</li><li><code>updateAccessDefaults</code> 方法主要是对 loginPage、loginProcessingUrl、failureUrl 进行 permitAll 设置（如果用户配置了 permitAll 的话）。</li><li><code>registerDefaultAuthenticationEntryPoint</code> 则是注册异常的处理器。</li></ol><p>再来看 configure 方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; PortMapper portMapper = http.getSharedObject(PortMapper.class); <span class="hljs-keyword">if</span> (portMapper != <span class="hljs-keyword">null</span>) &#123;  authenticationEntryPoint.setPortMapper(portMapper); &#125; RequestCache requestCache = http.getSharedObject(RequestCache.class); <span class="hljs-keyword">if</span> (requestCache != <span class="hljs-keyword">null</span>) &#123;  <span class="hljs-keyword">this</span>.defaultSuccessHandler.setRequestCache(requestCache); &#125; authFilter.setAuthenticationManager(http   .getSharedObject(AuthenticationManager.class)); authFilter.setAuthenticationSuccessHandler(successHandler); authFilter.setAuthenticationFailureHandler(failureHandler); <span class="hljs-keyword">if</span> (authenticationDetailsSource != <span class="hljs-keyword">null</span>) &#123;  authFilter.setAuthenticationDetailsSource(authenticationDetailsSource); &#125; SessionAuthenticationStrategy sessionAuthenticationStrategy = http   .getSharedObject(SessionAuthenticationStrategy.class); <span class="hljs-keyword">if</span> (sessionAuthenticationStrategy != <span class="hljs-keyword">null</span>) &#123;  authFilter.setSessionAuthenticationStrategy(sessionAuthenticationStrategy); &#125; RememberMeServices rememberMeServices = http   .getSharedObject(RememberMeServices.class); <span class="hljs-keyword">if</span> (rememberMeServices != <span class="hljs-keyword">null</span>) &#123;  authFilter.setRememberMeServices(rememberMeServices); &#125; F filter = postProcess(authFilter); http.addFilter(filter);&#125;</code></pre></div><p>configure 中的逻辑就很简答了，构建各种各样的回调函数设置给 authFilter，authFilter 再去 postProcess 中走一圈注册到 Spring 容器中，最后再把 authFilter 添加到过滤器链中。</p><p>这便是 <code>AbstractAuthenticationFilterConfigurer</code> 的主要功能。需要提醒大家的是，我们日常配置的，如：</p><ul><li>loginPage</li><li>loginProcessingUrl</li><li>permitAll</li><li>defaultSuccessUrl</li><li>failureUrl</li></ul><p>等方法都是在这里定义的。</p><h5 id="⚠️FormLoginConfigurer"><a href="#⚠️FormLoginConfigurer" class="headerlink" title="⚠️FormLoginConfigurer"></a>⚠️FormLoginConfigurer</h5><p><code>FormLoginConfigurer</code> 在定义是，明确了<code> AbstractAuthenticationFilterConfigurer</code> 中的泛型是 <code>UsernamePasswordAuthenticationFilter</code>，也就是我们这里最终要配置的过滤是 <code>UsernamePasswordAuthenticationFilter</code></p><p>FormLoginConfigurer 重写了 init 方法，配置了一下默认的登录页面。其他的基本上都是从父类来的，未做太多改变。</p><p>另外我们日常配置的很多东西也是来自这里：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809221049974.png" alt="image-20210809221049974"></p><p>这就是 <code>FormLoginConfigurer</code> 这个配置类，<code>FormLoginConfigurer</code> 对应的过滤器是 <code>UsernamePasswordAuthenticationFilter</code>，可以自行分析其他的 xxxConfigurer，每一个 xxxConfigurer 都对应了一个 不同的 Filter。</p><h4 id="GlobalAuthenticationConfigurerAdapter"><a href="#GlobalAuthenticationConfigurerAdapter" class="headerlink" title="GlobalAuthenticationConfigurerAdapter"></a>GlobalAuthenticationConfigurerAdapter</h4><p><code>GlobalAuthenticationConfigurerAdapter</code> 看名字就知道是一个跟全局配置有关的东西，它本身实现了 <code>SecurityConfigurerAdapter</code> 接口，但是并未对方法做具体的实现，只是将泛型具体化了：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Order(100)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalAuthenticationConfigurerAdapter</span> <span class="hljs-keyword">implements</span></span><span class="hljs-class">  <span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">AuthenticationManager</span>, <span class="hljs-title">AuthenticationManagerBuilder</span>&gt; </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; &#125;&#125;</code></pre></div><p>可以看到，<code>SecurityConfigurer</code> 中的泛型，现在明确成了 <code>AuthenticationManager</code> 和 <code>AuthenticationManagerBuilder</code>。所以 <code>GlobalAuthenticationConfigurerAdapter</code> 的实现类将来主要是和配置 <code>AuthenticationManager</code> 有关。当然也包括默认的用户名密码也是由它的实现类来进行配置的。</p><p><strong>我们在 Spring Security 中使用的 <code>AuthenticationManager</code> 其实可以分为两种，一种是局部的，另一种是全局的，这里主要是全局的配置。</strong></p><h4 id="WebSecurityConfigurer"><a href="#WebSecurityConfigurer" class="headerlink" title="WebSecurityConfigurer"></a>WebSecurityConfigurer</h4><p>还有一个实现类就是 <code>WebSecurityConfigurer</code>，这个可能有的小伙伴比较陌生，其实他就是我们天天用的 <code>WebSecurityConfigurerAdapter</code> 的父接口。</p><p>所以 <code>WebSecurityConfigurer</code> 的作用就很明确了，用户扩展用户自定义的配置。</p><p><code>SecurityConfigurer</code> 默认主要是这三个实现，考虑到大多数的过滤器配置都是通过 <code>SecurityConfigurerAdapter</code> 进行扩展的，因此我们今天就通过这条线进行展开。</p><h3 id="👀AuthenticationManagerBuilder"><a href="#👀AuthenticationManagerBuilder" class="headerlink" title="👀AuthenticationManagerBuilder"></a>👀AuthenticationManagerBuilder</h3><blockquote><p>此节建议结合检查角色是否满足匹配来看</p></blockquote><p>前面和大家分享了 <code>SecurityBuilder</code> 以及它的一个重要实现 <code>HttpSecurity</code>，在 <code>SecurityBuilder</code> 的实现类里边，还有一个重要的分支，那就是 <code>AuthenticationManagerBuilder</code>，<code>AuthenticationManagerBuilder</code> 看名字就知道是用来构建 <code>AuthenticationManager</code> 的，所以我们就来看一看 <code>AuthenticationManager</code> 到底是怎么构建的。</p><h4 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h4><p>在 Spring Security 中，用来处理身份认证的类是 <code>AuthenticationManager</code>，我们也称之为认证管理器。<strong>也是我们上面检查角色是否满足匹配的重要一环</strong></p><p><code>AuthenticationManager</code> 中规范了 Spring Security 的过滤器要如何执行身份认证，并在身份认证成功后返回一个经过认证的 <code>Authentication </code>对象。<code>AuthenticationManager</code> 是一个接口，我们可以自定义它的实现，但是通常我们使用更多的是系统提供的 <code>ProviderManager</code></p><h4 id="ProviderManager"><a href="#ProviderManager" class="headerlink" title="ProviderManager"></a>ProviderManager</h4><p><code>ProviderManager</code> 是的最常用的<code> AuthenticationManager</code> 实现类。</p><p><code>ProviderManager</code> 管理了一个 <code>AuthenticationProvider</code> 列表，每个 <code>AuthenticationProvider</code> 都是一个认证器，不同的 <code>AuthenticationProvider</code> 用来处理不同的 <code>Authentication</code> 对象的认证。一次完整的身份认证流程可能会经过多个 <code>AuthenticationProvider</code></p><p><code>ProviderManager </code>相当于代理了多个 <code>AuthenticationProvider</code>，他们的关系如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809210416369.png" alt="image-20210809210416369"></p><h4 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h4><p><code>AuthenticationProvider</code> 定义了 Spring Security 中的验证逻辑，我们来看下 <code>AuthenticationProvider</code> 的定义：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;<span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException</span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span></span>;&#125;</code></pre></div><p>可以看到，<code>AuthenticationProvider</code> 中就两个方法：</p><ul><li>authenticate 方法用来做验证，就是验证用户身份。</li><li>supports 则用来判断当前的 <code>AuthenticationProvider</code> 是否支持对应的 <code>Authentication</code>。</li></ul><p>在一次完整的认证中，可能包含多个 <code>AuthenticationProvider</code>，而这多个 <code>AuthenticationProvider</code> 则由 <code>ProviderManager </code>进行统一管理，具体我会再出一篇文章来分析Spring Security 登录流程。</p><p>最常用的 <code>AuthenticationProvider</code> 实现类是 <code>DaoAuthenticationProvider</code>。</p><h4 id="Parent"><a href="#Parent" class="headerlink" title="Parent"></a>Parent</h4><p>每一个 <code>ProviderManager</code> 管理多个 <code>AuthenticationProvider</code>，同时每一个 <code>ProviderManager</code> 都可以配置一个 parent，如果当前的 <code>ProviderManager</code> 中认证失败了，还可以去它的 parent 中继续执行认证，所谓的 parent 实例，一般也是 <code>ProviderManager</code>，也就是 <code>ProviderManager</code> 的 parent 还是 <code>ProviderManager</code>。可以参考如下架构图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809210931119.png" alt="image-20210809210931119"></p><p><strong>从上面的分析中大家可以看出，<code>AuthenticationManager</code> 的初始化会分为两块，一个全局的 <code>AuthenticationManager</code>，也就是 parent，另一个则是局部的 <code>AuthenticationManager</code>。先给大家一个结论，一个系统中，我们可以配置多个 <code>HttpSecurity</code>，而每一个<code>HttpSecurity</code>都有一个对应的 <code>AuthenticationManager</code> 实例（局部 <code>AuthenticationManager</code>），这些局部的 <code>AuthenticationManager</code> 实例都有一个共同的 parent，那就是全局的 <code>AuthenticationManager</code>。</strong></p><h4 id="为什么每一个-HttpSecurity-都要绑定一个-AuthenticationManager？"><a href="#为什么每一个-HttpSecurity-都要绑定一个-AuthenticationManager？" class="headerlink" title="为什么每一个 HttpSecurity 都要绑定一个 AuthenticationManager？"></a>为什么每一个 HttpSecurity 都要绑定一个 AuthenticationManager？</h4><p>因为在同一个系统中，我们可以回配置多个 <code>HttpSecurity</code>，也就是多个不同的过滤器链，既然有多个过滤器链，每一个请求到来的时候，它需要进入到某一个过滤器链中去处理，每一个过滤器链中又会涉及到 <code>AuthenticationProvider </code>的管理，不同过滤器链中的 <code>AuthenticationProvider</code> 肯定是各自管理最为合适，也就是不同的过滤器链中都有一个绑定的 <code>AuthenticationManager</code>，即每一个 <code>HttpSecurity</code> 都要绑定一个 <code>AuthenticationManager</code></p><h3 id="👀WebSecurityConfigurerAdapter"><a href="#👀WebSecurityConfigurerAdapter" class="headerlink" title="👀WebSecurityConfigurerAdapter"></a>👀WebSecurityConfigurerAdapter</h3><blockquote><p>我们配置中继承的就是WebSecurityConfigurerAdapter，需要重点关注</p></blockquote><p>我们的自定义的<code>SecurityConfig</code>都是继承自 <code>WebSecurityConfigurerAdapter</code> 来实现的，首先看一张 <code>WebSecurityConfigurerAdapter</code> 的继承关系图：</p><p><a href="http://img.itboyhub.com/2020/07/WebSecurityConfigurerAdapter.png"><img src="http://img.itboyhub.com/2020/07/WebSecurityConfigurerAdapter.png" alt="img" style="zoom: 67%;" /></a></p><p>在这层继承关系中，有两个非常重要的类：</p><ul><li><p><strong>SecurityBuilder</strong></p></li><li><p><strong>SecurityConfigurer</strong></p></li></ul><p>上面已经分析了这两个类，下面着重分析其他的</p><h4 id="WebSecurityConfigurer-1"><a href="#WebSecurityConfigurer-1" class="headerlink" title="WebSecurityConfigurer"></a>WebSecurityConfigurer</h4><p>WebSecurityConfigurer 其实是一个空接口，但是它里边约束了一些泛型，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WebSecurityConfigurer</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>&gt;&gt; <span class="hljs-keyword">extends</span></span><span class="hljs-class"><span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">Filter</span>, <span class="hljs-title">T</span>&gt; </span>&#123;&#125;</code></pre></div><p>这里边的泛型很关键，这关乎到 <code>WebSecurityConfigurer</code> 的目的是啥！</p><ol><li><code>SecurityBuilder</code> 中的泛型 Filter，表示<code>SecurityBuilder</code>最终的目的是为了构建一个 Filter 对象出来。</li><li><code>SecurityConfigurer</code> 中两个泛型，第一个表示的含义也是 <code>SecurityBuilder</code> 最终构建的对象。</li></ol><p>同时这里还定义了新的泛型 T，T 需要继承自 <code>SecurityBuilder</code>，根据 <code>WebSecurityConfigurerAdapter</code> 中的定义，我们可以知道，T 就是 <code>WebSecurity</code>，我们也大概能猜出 <code>WebSecurity</code> 就是 <code>SecurityBuilder</code> 的子类。</p><p>所以 <code>WebSecurityConfigurer</code> 的目的我们可以理解为就是为了配置 <code>WebSecurity</code></p><h4 id="WebSecurity"><a href="#WebSecurity" class="headerlink" title="WebSecurity"></a>WebSecurity</h4><p>我们来看下 <code>WebSecurity</code> 的定义：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurity</span> <span class="hljs-keyword">extends</span></span><span class="hljs-class"><span class="hljs-title">AbstractConfiguredSecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>, <span class="hljs-title">WebSecurity</span>&gt; <span class="hljs-keyword">implements</span></span><span class="hljs-class"><span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>&gt;, <span class="hljs-title">ApplicationContextAware</span> </span>&#123;&#125;</code></pre></div><p>没错，确实是这样！<code>WebSecurity</code> 继承自 <code>AbstractConfiguredSecurityBuilder&lt;Filter, WebSecurity&gt;</code> 同时实现了 <code>SecurityBuilder</code> 接口。</p><p><code>WebSecurity</code> 的这些接口和继承类，上面的<code>HttpSecurity</code>中有分析，这里就不重复分析了</p><p><strong>SecurityBuilder</strong></p><p><code>SecurityBuilder </code>就是用来构建过滤器链的，在 <code>HttpSecurity</code> 实现 <code>SecurityBuilder</code> 时，传入的泛型就是 <code>DefaultSecurityFilterChain</code>，所以 <code>SecurityBuilder#build </code>方法的功能很明确，就是用来构建一个过滤器链出来，但是那个过滤器链是 Spring Security 中的。在 <code>WebSecurityConfigurerAdapter </code>中定义的泛型是 <code>SecurityBuilder</code>，所以最终构建的是一个普通 Filter，其实就是 <code>FilterChainProxy</code>，关于 <code>FilterChainProxy</code> ，可以参考<code>http.authorizeRequests()</code>中的说明。</p><p><code>WebSecurity</code> 的核心逻辑集中在 <code>performBuild</code> 构建方法上，我们一起来看下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> Filter <span class="hljs-title">performBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;Assert.state(!securityFilterChainBuilders.isEmpty(),() -&gt; <span class="hljs-string">&quot;At least one SecurityBuilder&lt;? extends SecurityFilterChain&gt; needs to be specified. &quot;</span>+ <span class="hljs-string">&quot;Typically this done by adding a @Configuration that extends WebSecurityConfigurerAdapter. &quot;</span>+ <span class="hljs-string">&quot;More advanced users can invoke &quot;</span>+ WebSecurity.class.getSimpleName()+ <span class="hljs-string">&quot;.addSecurityFilterChainBuilder directly&quot;</span>);<span class="hljs-keyword">int</span> chainSize = ignoredRequests.size() + securityFilterChainBuilders.size();List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(chainSize);<span class="hljs-keyword">for</span> (RequestMatcher ignoredRequest : ignoredRequests) &#123;securityFilterChains.add(<span class="hljs-keyword">new</span> DefaultSecurityFilterChain(ignoredRequest));&#125;<span class="hljs-keyword">for</span> (SecurityBuilder&lt;? extends SecurityFilterChain&gt; securityFilterChainBuilder : securityFilterChainBuilders) &#123;securityFilterChains.add(securityFilterChainBuilder.build());&#125;FilterChainProxy filterChainProxy = <span class="hljs-keyword">new</span> FilterChainProxy(securityFilterChains);<span class="hljs-keyword">if</span> (httpFirewall != <span class="hljs-keyword">null</span>) &#123;filterChainProxy.setFirewall(httpFirewall);&#125;filterChainProxy.afterPropertiesSet();Filter result = filterChainProxy;<span class="hljs-keyword">if</span> (debugEnabled) &#123;logger.warn(<span class="hljs-string">&quot;\n\n&quot;</span>+ <span class="hljs-string">&quot;********************************************************************\n&quot;</span>+ <span class="hljs-string">&quot;**********        Security debugging is enabled.       *************\n&quot;</span>+ <span class="hljs-string">&quot;**********    This may include sensitive information.  *************\n&quot;</span>+ <span class="hljs-string">&quot;**********      Do not use in a production system!     *************\n&quot;</span>+ <span class="hljs-string">&quot;********************************************************************\n\n&quot;</span>);result = <span class="hljs-keyword">new</span> DebugFilter(filterChainProxy);&#125;postBuildAction.run();<span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>先来说一句，这里的 performBuild 方法只有一个功能，那就是构建 <code>FilterChainProxy</code></p><p>把握住了这条主线，我们再来看方法的实现就很容易了。</p><ol><li><p>首先统计过滤器链的总条数，总条数包括两个方面，一个是 <code>ignoredRequests</code>，这是忽略的请求，通过 WebSecurity 配置的忽略请求，另一个则是 <code>securityFilterChainBuilders</code>，也就是我们通过 <code>HttpSecurity</code> 配置的过滤器链，有几个就算几个。</p><blockquote><p>前端静态资源放行时，可以直接不走 Spring Security 过滤器链，像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Override</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>,<span class="hljs-string">&quot;/js/**&quot;</span>,<span class="hljs-string">&quot;/index.html&quot;</span>,<span class="hljs-string">&quot;/img/**&quot;</span>,<span class="hljs-string">&quot;/fonts/**&quot;</span>,<span class="hljs-string">&quot;/favicon.ico&quot;</span>);&gt;&#125;</code></pre></div><p>后端的接口要额外放行，就需要仔细考虑场景了，不过一般来说，不建议使用上面这种方式，建议下面这种方式</p><div class="hljs code-wrapper"><pre><code class="hljs java">&gt;http.authorizeRequests()     .antMatchers(<span class="hljs-string">&quot;/hello&quot;</span>).permitAll()     .anyRequest().authenticated()</code></pre></div><p>因为，如果我们暴露登录接口的时候，使用了前面提到的第一种方式，没有走 Spring Security，过滤器链，则在登录成功后，就不会将登录用户信息存入 session 中，进而导致后来的请求都无法获取到登录用户信息（后来的请求在系统眼里也都是未认证的请求）</p><p>或者如果你的登录请求正常，走了 Spring Security 过滤器链，但是后来的 A 请求没走过滤器链（采用前面提到的第一种方式放行），那么 A 请求中，也是无法通过 SecurityContextHolder 获取到登录用户信息的，因为它一开始没经过 SecurityContextPersistenceFilter 过滤器链。</p></blockquote></li><li><p>创建 <code>securityFilterChains</code> 集合，并且遍历上面提到的两种类型的过滤器链，并将过滤器链放入 <code>securityFilterChains</code> 集合中。</p></li><li><p>在<code>HttpSecurity</code>介绍过，<code>HttpSecurity</code> 构建出来的过滤器链对象就是 <code>DefaultSecurityFilterChain</code>，所以可以直接将 build 结果放入 <code>securityFilterChains </code>中，而 <code>ignoredRequests</code> 中保存的则需要重构一下才可以存入 <code>securityFilterChains</code></p></li><li><p><code>securityFilterChains</code> 中有数据之后，接下来创建一个 <code>FilterChainProxy</code></p></li><li><p>给新建的<code>FilterChainProxy</code>配置上防火墙</p></li><li><p>最后我们返回的就是<code> FilterChainProxy</code> 的实例。</p></li></ol><p><strong>从这段分析中，我们可以看出来 <code>WebSecurity </code>和 <code>HttpSecurity </code>的区别：</strong></p><ol><li><code>HttpSecurity</code> 目的是构建过滤器链，一个 <code>HttpSecurity</code> 对象构建一条过滤器链，一个过滤器链中有 N 个过滤器，<code>HttpSecurity</code>所做的事情实际上就是在配置这 N 个过滤器。</li><li><code>WebSecurity</code> 目的是构建 <code>FilterChainProxy</code>，一个 <code>FilterChainProxy</code> 中包含有多个过滤器链和一个 Firewall。</li></ol><h4 id="回到WebSecurityConfigurerAdapter"><a href="#回到WebSecurityConfigurerAdapter" class="headerlink" title="回到WebSecurityConfigurerAdapter"></a>回到WebSecurityConfigurerAdapter</h4><p>最后我们再来看 <code>WebSecurityConfigurerAdapter</code>，由于 <code>WebSecurityConfigurer </code>只是一个空接口，<code>WebSecurityConfigurerAdapter</code> 就是针对这个空接口提供一个具体的实现，最终目的还是为了方便你配置 <code>WebSecurity</code>。</p><p><code>WebSecurityConfigurerAdapter</code> 中的方法比较多，但是根据我们前面的分析，提纲挈领的方法就两个，一个是 init，还有一个 configure(WebSecurity web)，其他方法都是为这两个方法服务的。那我们就来看下这两个方法，先看 init 方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">final</span> WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-keyword">final</span> HttpSecurity http = getHttp();web.addSecurityFilterChainBuilder(http).postBuildAction(() -&gt; &#123;FilterSecurityInterceptor securityInterceptor = http.getSharedObject(FilterSecurityInterceptor.class);web.securityInterceptor(securityInterceptor);&#125;);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> HttpSecurity <span class="hljs-title">getHttp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-keyword">if</span> (http != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> http;&#125;AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);AuthenticationManager authenticationManager = authenticationManager();authenticationBuilder.parentAuthenticationManager(authenticationManager);Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = createSharedObjects();http = <span class="hljs-keyword">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,sharedObjects);<span class="hljs-keyword">if</span> (!disableDefaults) &#123;<span class="hljs-comment">// @formatter:off</span>http.csrf().and().addFilter(<span class="hljs-keyword">new</span> WebAsyncManagerIntegrationFilter()).exceptionHandling().and().headers().and().sessionManagement().and().securityContext().and().requestCache().and().anonymous().and().servletApi().and().apply(<span class="hljs-keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and().logout();<span class="hljs-comment">// @formatter:on</span>ClassLoader classLoader = <span class="hljs-keyword">this</span>.context.getClassLoader();List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers =SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);<span class="hljs-keyword">for</span> (AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123;http.apply(configurer);&#125;&#125;configure(http);<span class="hljs-keyword">return</span> http;&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;logger.debug(<span class="hljs-string">&quot;Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity).&quot;</span>);http.authorizeRequests().anyRequest().authenticated().and().formLogin().and().httpBasic();&#125;</code></pre></div><p>init 方法可以算是这里的入口方法了：首先调用 getHttp 方法进行 <code>HttpSecurity </code>的初始化。<code>HttpSecurity</code> 的初始化，实际上就是配置了一堆默认的过滤器，配置完成后，最终还调用了 configure(http) 方法，该方法又配置了一些拦截器，不过在实际开发中，我们经常会重写 configure(http) 方法，<code>HttpSecurity</code> 配置完成后，再将 <code>HttpSecurity</code> 放入 <code>WebSecurity</code> 中，保存在 <code>WebSecurity</code> 的 <code>securityFilterChainBuilders</code> 集合里，具体参见上面的<code>HttpSecurity</code>部分</p><p>configure(WebSecurity web) 方法实际上是一个空方法，我们在实际开发中可能会重写该方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//防止访问登录页面死循环，不用进入Security拦截</span>    web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/img/**&quot;</span>, <span class="hljs-string">&quot;/fonts/**&quot;</span>, <span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;/verifyCode&quot;</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后台管理系统开发记录</title>
    <link href="/2021/08/05/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/05/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="人力资源管理系统"><a href="#人力资源管理系统" class="headerlink" title="人力资源管理系统"></a>人力资源管理系统</h1><blockquote><p>本文记录开发一个 SpringBoot+Vue 前后端分离的人力资源管理系统</p></blockquote><h1 id="一、技术栈"><a href="#一、技术栈" class="headerlink" title="一、技术栈"></a>一、技术栈</h1><h2 id="后端技术栈"><a href="#后端技术栈" class="headerlink" title="后端技术栈"></a>后端技术栈</h2><ul><li>Spring Boot</li><li>Spring Security</li><li>MyBatis</li><li>MySQL</li><li>Redis</li><li>RabbitMQ</li><li>Spring Cache</li><li>WebSocket</li></ul><h2 id="前端技术栈"><a href="#前端技术栈" class="headerlink" title="前端技术栈"></a>前端技术栈</h2><ul><li>Vue</li><li>ElementUI</li><li>axios</li><li>vue-router</li><li>Vuex</li><li>WebSocket</li><li>vue-cli4</li></ul><h3 id="为什么选用Vue？"><a href="#为什么选用Vue？" class="headerlink" title="为什么选用Vue？"></a>为什么选用Vue？</h3><p>Vue 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><ul><li>只关注视图层</li><li>MVVM 框架</li></ul><p>在使用 jQuery 过程中，掺杂了大量的 DOM 操作，修改视图或者获取 value ，都需要 DOM 操作，MVVM 是一种视图和数据模型双向绑定的框架，即数据发生变化，视图会跟着变化，视图发生变化，数据模型也会跟着变化，开发者再也不需要操作 DOM 节点</p><h3 id="MVC与MVVM"><a href="#MVC与MVVM" class="headerlink" title="MVC与MVVM"></a>MVC与MVVM</h3><p><strong>MVC</strong>中的<strong>M</strong>就是单纯的从网络获取回来的数据模型，<strong>V</strong>指的我们的视图界面，而<strong>C</strong>就是我们的ViewController。</p><p>在其中，ViewController负责View和Model之间调度，View发生交互事件会通过target-action或者delegate方式回调给ViewController，与此同时ViewController还要承担把Model通过KVO、Notification方式传来的数据传输给View用于展示的责任。<code>随着业务越来越复杂，视图交互越复杂，导致Controller越来越臃肿，负重前行。脏活累活都它干了，到头来还一点不讨好。福报修多了的结果就是，不行了就重构你，重构不了就换掉你</code>。来一张斯坦福老头经典的MVC架构图。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809000010550.png" alt="image-20210809000010550"></p><p>所以为了解决这个问题，MVVM就闪亮登场了。他把View和Contrller都放在了View层（相当于把Controller一部分逻辑抽离了出来），Model层依然是服务端返回的数据模型。<code>而ViewModel充当了一个UI适配器的角色，也就是说View中每个UI元素都应该在ViewModel找到与之对应的属性。除此之外，从Controller抽离出来的与UI有关的逻辑都放在了ViewModel中，这样就减轻了Controller的负担</code>。下面是网上经典的MVVM的架构图</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809000029611.png" alt="image-20210809000029611"></p><p>从以上的架构图中，我们可以很清晰的梳理出各自的分工。</p><ul><li><strong>View层</strong>：视图展示。包含UIView以及UIViewController，View层是可以持有ViewModel的。</li><li><strong>ViewModel层</strong>：视图适配器。暴露属性与View元素显示内容或者元素状态一一对应。一般情况下ViewModel暴露的属性建议是readOnly的。还有一点，ViewModel层是可以持有Model的，但是ViewModel不能持有View，1.ViewModel可测性，即单元测试方便进行。2.团队人员可分离开发（View和ViewModel开发可以是两个人同时进行）。</li><li><strong>Model层</strong>：数据模型与持久化抽象模型。数据模型很好理解，就是从服务器拉回来的JSON数据。而持久化抽象模型暂时放在Model层，是因为MVVM诞生之初就没有对这块进行很细致的描述。按照经验，我们通常把数据库、文件操作封装成Model，并对外提供操作接口。（有些公司把数据存取操作单拎出来一层，称之为<strong>DataAdapter层</strong>，所以在业内会有很多MVVM的变种，但其本质上都是MVVM）。</li><li><strong>Binder</strong>：MVVM的灵魂。可惜在MVVM这几个英文单词中并没有它的一席之地，它的最主要作用是在View和ViewModel之间做了双向数据绑定。如果MVVM没有Binder，那么它与MVC的差异不是很大。</li></ul><p>我们发现，正是因为View、ViewModel以及Model间的清晰的持有关系，所以在三个模块间的数据流转有了很好的控制</p><h1 id="二、SPA"><a href="#二、SPA" class="headerlink" title="二、SPA"></a>二、SPA</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong>单页应用</strong>（英语：single-page application，缩写<strong>SPA</strong>）是一种<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">网络应用程序</a>或<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%AB%99">网站</a>的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C">用户体验</a>，使应用程序更像一个<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6">桌面应用程序</a>。它将所有的活动局限于一个 Web 页面中，仅在该 Web 页面初始化时加载相应的 HTML、JavaScript、CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转，而是利用 JavaScript 动态的变换 HTML（采用的是 div 切换显示和隐藏），从而实现UI与用户的交互。在 SPA 应用中，应用加载之后就不会再有整页刷新。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>1) 有良好的交互体验</strong><br>能提升页面切换体验，用户在访问应用页面是不会频繁的去切换浏览页面，从而避免了页面的重新加载；<br><strong>2) 前后端分离开发</strong><br>单页Web应用可以和 RESTful 规约一起使用，通过 REST API 提供接口数据，并使用 Ajax 异步获取，这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分；<br><strong>3) 减轻服务器压力</strong><br>服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；<br><strong>4) 共用一套后端程序代码</strong><br>不用修改后端程序代码就可以同时用于 Web 界面、手机、平板等多种客户端；</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>1) SEO难度较高</strong><br>由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧；<br><strong>2) 前进、后退管理</strong><br>由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现；<br><strong>3) 初次加载耗时多</strong><br>为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理；</p><p><code>本项目是后台管理系统，因为不需要搜索引擎优化，所以选用了单页面应用的技术</code></p><h1 id="三、Vue的构建"><a href="#三、Vue的构建" class="headerlink" title="三、Vue的构建"></a>三、Vue的构建</h1><h3 id="安装NodeJS与npm"><a href="#安装NodeJS与npm" class="headerlink" title="安装NodeJS与npm"></a>安装NodeJS与npm</h3><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210528161005216.png" alt="image-20210528161005216"></p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><div class="hljs code-wrapper"><pre><code class="hljs shell">npm install -g vue-cli   # 只需要第一次安装时执行vue init webpack my-project  # 使用webpack模板创建一个vue项目cd my-project #进入到项目目录中npm install  # 下载依赖（如果在项目创建的最后一步选择了自动执行npm install，则该步骤可以省略）npm run dev # 启动项目</code></pre></div><h3 id="Vue-项目结构介绍"><a href="#Vue-项目结构介绍" class="headerlink" title="Vue 项目结构介绍"></a>Vue 项目结构介绍</h3><p>Vue 项目创建完成后，使用 Web Storm 打开项目，项目目录如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210528162924438.png" alt="image-20210528162924438"></p><ul><li>build 文件夹，用来存放项目构建脚本</li><li>config 中存放项目的一些基本配置信息，最常用的就是端口转发</li><li>node_modules 这个目录存放的是项目的所有依赖，即 npm install 命令下载下来的文件</li><li>src 这个目录下存放项目的源码，即开发者写的代码放在这里</li><li>static 用来存放静态资源</li><li>index.html 则是项目的首页，入口页，也是整个项目唯一的HTML页面</li><li>package.json 中定义了项目的所有依赖，包括开发时依赖和发布时依赖</li></ul><p>对于开发者来说，以后 99.99% 的工作都是在 src 中完成的，src 中的文件目录如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210528163055327.png" alt="image-20210528163055327"></p><ul><li>assets 目录用来存放资产文件</li><li>components 目录用来存放组件（一些可复用，非独立的页面），当然开发者也可以在 components 中直接创建完整页面。</li><li>推荐在 components 中存放组件，另外单独新建一个 page 文件夹，专门用来放完整页面。</li><li>router 目录中，存放了路由的js文件</li><li>App.vue 是一个Vue组件，也是项目的第一个Vue组件</li><li>main.js相当于Java中的main方法，是整个项目的入口js</li></ul><p><strong>main.js</strong> 内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span>Vue.config.productionTip = <span class="hljs-literal">false</span><span class="hljs-comment">/* eslint-disable no-new */</span><span class="hljs-keyword">new</span> Vue(&#123;  el: <span class="hljs-string">&#x27;#app&#x27;</span>,  router,  components: &#123; App &#125;,  template: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span>&#125;)</code></pre></div><ul><li>在main.js 中，首先导入 Vue 对象</li><li>导入 App.vue ，并且命名为 App</li><li>导入router，注意，由于router目录下路由默认文件名为 index.js ，因此可以省略</li><li>所有东西都导入成功后，创建一个Vue对象，设置要被Vue处理的节点是 ‘#app’，’#app’ 指提前在index.html 文件中定义的一个div</li><li>将 router 设置到 vue 对象中，这里是一个简化的写法，完整的写法是 router:router，如果 key/value 一模一样，则可以简写。</li><li>声明一个组件 App，App 这个组件在一开始已经导入到项目中了，但是直接导入的组件无法直接使用，必须要声明。</li><li>template 中定义了页面模板，即将 App 组件中的内容渲染到 ‘#app’ 这个div 中。</li></ul><p>因此，可以猜测，项目启动成功后，看到的页面效果定义在 <strong>App.vue</strong> 中</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;    &lt;router-view&#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &#39;App&#39;&#125;&lt;&#x2F;script&gt;&lt;style&gt;#app &#123;  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;&#x2F;style&gt;</code></pre></div><ul><li>App.vue 是一个vue组件，这个组件中包含三部分内容：<ul><li>页面模板（template）</li><li>页面脚本（script）；</li><li>页面样式（style）</li></ul></li><li>页面模板中，定义了页面的 HTML 元素，这里定义了两个，一个是一张图片，另一个则是一个 router-view</li><li>页面脚本主要用来实现当前页面数据初始化、事件处理等等操作</li><li>页面样式就是针对 template 中 HTML 元素的页面美化操作</li></ul><p>需要额外解释的是，<strong>router-view</strong>，这个指展示路由页面的位置，可以简单理解为一个占位符，这个占位符展示的内容将根据当前具体的 URL 地址来定。具体展示的内容，要参考路由表，即 <strong>router/index.js</strong> 文件，该文件如下：</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">import</span> HelloWorld <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/HelloWorld&#x27;</span>Vue.use(Router)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;  routes: [    &#123;      path: <span class="hljs-string">&#x27;/&#x27;</span>,      name: <span class="hljs-string">&#x27;HelloWorld&#x27;</span>,      component: HelloWorld    &#125;  ]&#125;)</code></pre></div><ul><li>这个文件中，首先导入了Vue对象、Router对象以及 HelloWorld 组件，</li><li>创建一个Router对象，并定义路由表</li><li>这里定义的路由表，path为 <code>/</code> ，对应的组件为 HelloWorld，即浏览器地址为 <code>/</code> 时，在router-view位置显示 HelloWorld 组件</li></ul><h3 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a>项目编译</h3><p>这么大一个前端项目，肯定没法直接发布运行，当开发者完成项目开发后，将 cmd 命令行定位到当前项目目录，然后执行如下命令对项目进行打包：</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm run build</span></code></pre></div><p>打包成功后，当前项目目录下会生成一个 dist 文件夹，这个文件夹中有两个文件，分别是 index.html 和 static ，index.html 页面就是我们 SPA 项目中唯一的 HTML 页面了，static 中则保存了编译后的 js、css等文件，项目发布时，可以使用 nginx 独立部署 dist 中的静态文件，也可以将静态文件拷贝到 Spring Boot 项目的 static 目录下，然后对 Spring Boot 项目进行编译打包发布。</p><h3 id="使用Vue-cli3构建项目"><a href="#使用Vue-cli3构建项目" class="headerlink" title="使用Vue-cli3构建项目"></a>使用Vue-cli3构建项目</h3><blockquote><p>Vue 提供了一个<a href="https://github.com/vuejs/vue-cli">官方的 CLI</a>，为单页面应用 (SPA) 快速搭建繁杂的脚手架。它为现代前端工作流提供了 batteries-included 的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span>npm install -g @vue/cli<span class="hljs-comment"># 创建项目</span>vue create vuehr$ <span class="hljs-built_in">cd</span> vuehr$ npm run serve</code></pre></div><p>整体项目变得更加简洁</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210528193634072.png" alt="image-20210528193634072"></p><p>至此，前端部分的准备工作已经结束，现在可以开始搭建项目</p><h1 id="四、前端的搭建"><a href="#四、前端的搭建" class="headerlink" title="四、前端的搭建"></a>四、前端的搭建</h1><p><strong>安装element</strong></p><div class="hljs code-wrapper"><pre><code class="hljs bash">npm i element-ui -S</code></pre></div><p><strong>引用element</strong></p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> ElementUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;Vue.use(ElementUI);</code></pre></div><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p><strong>main.js</strong></p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;postKeyValueRequest&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils/api&quot;</span>;<span class="hljs-keyword">import</span> &#123;putRequest&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils/api&quot;</span>;<span class="hljs-keyword">import</span> &#123;getRequest&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils/api&quot;</span>;<span class="hljs-keyword">import</span> &#123;deleteRequest&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils/api&quot;</span>;Vue.prototype.postRequest = postRequest;Vue.prototype.postKeyValueRequest = postKeyValueRequest;Vue.prototype.putRequest = putRequest;Vue.prototype.getRequest = getRequest;Vue.prototype.deleteRequest = deleteRequest;Vue.use(ElementUI);Vue.config.productionTip = <span class="hljs-literal">false</span><span class="hljs-keyword">new</span> Vue(&#123;  router,  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><p><strong>router里配置index.js</strong></p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Login.vue&#x27;</span><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span>Vue.use(VueRouter)<span class="hljs-keyword">const</span> routes = [    &#123;      path: <span class="hljs-string">&#x27;/&#x27;</span>,      name: <span class="hljs-string">&#x27;Login&#x27;</span>,      component: Login    &#125;,    &#123;      path: <span class="hljs-string">&#x27;/home&#x27;</span>,      name: <span class="hljs-string">&#x27;Home&#x27;</span>,      component: Home    &#125;]<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;  routes&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router</code></pre></div><h3 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h3><p><strong>Login.vue</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;&lt;div&gt;&lt;!--  v-model:rules&#x3D;:rules--&gt;  &lt;el-form :rules&#x3D;&quot;rules&quot; ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;loginForm&quot; class&#x3D;&quot;loginContainer&quot;&gt;    &lt;h3 class&#x3D;&quot;login-title&quot;&gt;系统登录&lt;&#x2F;h3&gt;    &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;      &lt;el-input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;loginForm.username&quot; auto-complete&#x3D;&quot;off&quot; placeholder&#x3D;&quot;请输入你的用户名&quot;&gt;&lt;&#x2F;el-input&gt;    &lt;&#x2F;el-form-item&gt;    &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;      &lt;el-input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;loginForm.password&quot; auto-complete&#x3D;&quot;off&quot; placeholder&#x3D;&quot;请输入密码&quot;&gt;&lt;&#x2F;el-input&gt;    &lt;&#x2F;el-form-item&gt;    &lt;el-checkbox class&#x3D;&quot;loginRemember&quot; v-model&#x3D;&quot;checked&quot;&gt;&lt;&#x2F;el-checkbox&gt;    &lt;el-button type&#x3D;&quot;primary&quot; style&#x3D;&quot;width:100%;&quot; @click&#x3D;&quot;submitLogin&quot;&gt;登录&lt;&#x2F;el-button&gt;  &lt;&#x2F;el-form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &quot;Login&quot;,  data()&#123;    return &#123;      loginForm:&#123;        username:&#39;admin&#39;,        password:&#39;123&#39;      &#125;,      checked: true,      rules:&#123;        username:[&#123;required: true, message:&quot;请输入你的用户名&quot;,trigger:&quot;blur&quot;&#125;],        password:[&#123;required: true, message:&quot;请输入密码&quot;,trigger:&quot;blur&quot;&#125;]      &#125;    &#125;  &#125;,  methods:&#123;    submitLogin()&#123;      this.$refs.loginForm.validate((valid) &#x3D;&gt; &#123;        if (valid) &#123;          this.postKeyValueRequest(&#39;&#x2F;doLogin&#39;,this.loginForm).then(resp &#x3D;&gt; &#123;            if (resp)&#123;              window.sessionStorage.setItem(&quot;user&quot;, JSON.stringify(resp.obj));              this.$router.replace(&#39;&#x2F;home&#39;)            &#125;          &#125;)          &#x2F;&#x2F; alert(&#39;提交成功!&#39;);        &#125; else &#123;          this.$message.error(&#39;请输入所有字段&#39;);          return false;        &#125;      &#125;);    &#125;  &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;.loginContainer&#123;  border-radius: 15px;  background-clip: padding-box;  margin: 180px auto;  width:350px;  padding:35px 35px 15px 35px;  background: #fff;  border: 1px solid #eaeaea;  box-shadow: 0 0 25px #cac6c6;&#125;.login-title&#123;  margin:10px auto 20px auto;  text-align:center;  color: #000000;&#125;.loginRemember&#123;  text-align:left;  margin:0 0 15px 0;&#125;&lt;&#x2F;style&gt;</code></pre></div><h3 id="制作基本页面"><a href="#制作基本页面" class="headerlink" title="制作基本页面"></a>制作基本页面</h3><p><strong>Home.vue</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;    &lt;div&gt;        &lt;el-container&gt;            &lt;el-header class&#x3D;&quot;homeHeader&quot;&gt;                &lt;div class&#x3D;&quot;title&quot;&gt;微人事&lt;&#x2F;div&gt;                &lt;div&gt;                    &lt;el-button icon&#x3D;&quot;el-icon-bell&quot; type&#x3D;&quot;text&quot; style&#x3D;&quot;margin-right: 8px;color: #000000;&quot; size&#x3D;&quot;normal&quot; @click&#x3D;&quot;goChat&quot;&gt;&lt;&#x2F;el-button&gt;                    &lt;el-dropdown class&#x3D;&quot;userInfo&quot; @command&#x3D;&quot;commandHandler&quot;&gt;  &lt;span class&#x3D;&quot;el-dropdown-link&quot;&gt;    &#123;&#123;user.name&#125;&#125;&lt;i&gt;&lt;img :src&#x3D;&quot;user.userface&quot; alt&#x3D;&quot;&quot;&gt;&lt;&#x2F;i&gt;  &lt;&#x2F;span&gt;                        &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;                            &lt;el-dropdown-item command&#x3D;&quot;userinfo&quot;&gt;个人中心&lt;&#x2F;el-dropdown-item&gt;                            &lt;el-dropdown-item command&#x3D;&quot;setting&quot;&gt;设置&lt;&#x2F;el-dropdown-item&gt;                            &lt;el-dropdown-item command&#x3D;&quot;logout&quot; divided&gt;注销登录&lt;&#x2F;el-dropdown-item&gt;                        &lt;&#x2F;el-dropdown-menu&gt;                    &lt;&#x2F;el-dropdown&gt;                &lt;&#x2F;div&gt;            &lt;&#x2F;el-header&gt;            &lt;el-container&gt;                &lt;el-aside width&#x3D;&quot;200px&quot;&gt;                    &lt;el-menu router unique-opened&gt;                        &lt;el-submenu :index&#x3D;&quot;index+&#39;&#39;&quot; v-for&#x3D;&quot;(item,index) in routes&quot; v-if&#x3D;&quot;!item.hidden&quot; :key&#x3D;&quot;index&quot;&gt;                            &lt;template slot&#x3D;&quot;title&quot;&gt;                                &lt;i style&#x3D;&quot;color: #409eff;margin-right: 5px&quot; :class&#x3D;&quot;item.iconCls&quot;&gt;&lt;&#x2F;i&gt;                                &lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;span&gt;                            &lt;&#x2F;template&gt;                            &lt;el-menu-item :index&#x3D;&quot;child.path&quot; v-for&#x3D;&quot;(child,indexj) in item.children&quot; :key&#x3D;&quot;indexj&quot;&gt;                                &#123;&#123;child.name&#125;&#125;                            &lt;&#x2F;el-menu-item&gt;                        &lt;&#x2F;el-submenu&gt;                    &lt;&#x2F;el-menu&gt;                &lt;&#x2F;el-aside&gt;                &lt;el-main&gt;                    &lt;el-breadcrumb separator-class&#x3D;&quot;el-icon-arrow-right&quot; v-if&#x3D;&quot;this.$router.currentRoute.path!&#x3D;&#39;&#x2F;home&#39;&quot;&gt;                        &lt;el-breadcrumb-item :to&#x3D;&quot;&#123; path: &#39;&#x2F;home&#39; &#125;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;                        &lt;el-breadcrumb-item&gt;&#123;&#123;this.$router.currentRoute.name&#125;&#125;&lt;&#x2F;el-breadcrumb-item&gt;                    &lt;&#x2F;el-breadcrumb&gt;                    &lt;div class&#x3D;&quot;homeWelcome&quot; v-if&#x3D;&quot;this.$router.currentRoute.path&#x3D;&#x3D;&#39;&#x2F;home&#39;&quot;&gt;                        欢迎来到微人事！                    &lt;&#x2F;div&gt;                    &lt;router-view class&#x3D;&quot;homeRouterView&quot;&#x2F;&gt;                &lt;&#x2F;el-main&gt;            &lt;&#x2F;el-container&gt;        &lt;&#x2F;el-container&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default &#123;        name: &quot;Home&quot;,        data() &#123;            return &#123;                &#x2F;&#x2F; user: JSON.parse(window.sessionStorage.getItem(&quot;user&quot;))            &#125;        &#125;,        computed: &#123;            routes() &#123;                return this.$store.state.routes;            &#125;,            user() &#123;                return this.$store.state.currentHr;            &#125;        &#125;,        methods: &#123;            goChat() &#123;                this.$router.push(&quot;&#x2F;chat&quot;);            &#125;,            commandHandler(cmd) &#123;                if (cmd &#x3D;&#x3D; &#39;logout&#39;) &#123;                    this.$confirm(&#39;此操作将注销登录, 是否继续?&#39;, &#39;提示&#39;, &#123;                        confirmButtonText: &#39;确定&#39;,                        cancelButtonText: &#39;取消&#39;,                        type: &#39;warning&#39;                    &#125;).then(() &#x3D;&gt; &#123;                        this.getRequest(&quot;&#x2F;logout&quot;);                        window.sessionStorage.removeItem(&quot;user&quot;)                        this.$store.commit(&#39;initRoutes&#39;, []);                        this.$router.replace(&quot;&#x2F;&quot;);                    &#125;).catch(() &#x3D;&gt; &#123;                        this.$message(&#123;                            type: &#39;info&#39;,                            message: &#39;已取消操作&#39;                        &#125;);                    &#125;);                &#125;else if (cmd &#x3D;&#x3D; &#39;userinfo&#39;) &#123;                    this.$router.push(&#39;&#x2F;hrinfo&#39;);                &#125;            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;&lt;style&gt;    .homeRouterView &#123;        margin-top: 10px;    &#125;    .homeWelcome &#123;        text-align: center;        font-size: 30px;        font-family: 华文行楷;        color: #409eff;        padding-top: 50px;    &#125;    .homeHeader &#123;        background-color: #409eff;        display: flex;        align-items: center;        justify-content: space-between;        padding: 0px 15px;        box-sizing: border-box;    &#125;    .homeHeader .title &#123;        font-size: 30px;        font-family: 华文行楷;        color: #ffffff    &#125;    .homeHeader .userInfo &#123;        cursor: pointer;    &#125;    .el-dropdown-link img &#123;        width: 48px;        height: 48px;        border-radius: 24px;        margin-left: 8px;    &#125;    .el-dropdown-link &#123;        display: flex;        align-items: center;    &#125;&lt;&#x2F;style&gt;</code></pre></div><h3 id="制作Menu菜单"><a href="#制作Menu菜单" class="headerlink" title="制作Menu菜单"></a>制作Menu菜单</h3><p><strong>Home.vue</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;div&gt;  &lt;el-container&gt;    &lt;el-header class&#x3D;&quot;homeHeader&quot;&gt;      &lt;div class&#x3D;&quot;title&quot;&gt;后台管理系统&lt;&#x2F;div&gt;            &lt;el-dropdown class&#x3D;&quot;userInfo&quot; @command&#x3D;&quot;commandHandler&quot;&gt;      &lt;span class&#x3D;&quot;el-dropdown-link&quot;&gt;        &#123;&#123;user.name&#125;&#125;&lt;i&gt;&lt;img :src&#x3D;&quot;user.userface&quot; alt&#x3D;&quot;&quot;&gt;&lt;&#x2F;i&gt;      &lt;&#x2F;span&gt;              &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;                &lt;el-dropdown-item command&#x3D;&quot;userinfo&quot;&gt;个人中心&lt;&#x2F;el-dropdown-item&gt;                &lt;el-dropdown-item command&#x3D;&quot;setting&quot;&gt;设置&lt;&#x2F;el-dropdown-item&gt;                &lt;el-dropdown-item command&#x3D;&quot;logout&quot; divided&gt;注销登录&lt;&#x2F;el-dropdown-item&gt;              &lt;&#x2F;el-dropdown-menu&gt;            &lt;&#x2F;el-dropdown&gt;    &lt;&#x2F;el-header&gt;    &lt;el-container&gt;      &lt;el-aside width&#x3D;&quot;200px&quot;&gt;        &lt;el-menu router&gt;          &lt;el-submenu index&#x3D;&quot;1&quot; v-for&#x3D;&quot;(item,index) in this.$router.options.routes&quot; v-if&#x3D;&quot;!item.hidden&quot; :key&#x3D;&quot;index&quot;&gt;            &lt;template slot&#x3D;&quot;title&quot;&gt;              &lt;i class&#x3D;&quot;el-icon-location&quot;&gt;&lt;&#x2F;i&gt;              &lt;span&gt;导航一&lt;&#x2F;span&gt;            &lt;&#x2F;template&gt;              &lt;el-menu-item :index&#x3D;&quot;child.path&quot; v-for&#x3D;&quot;(child,indexj) in item.children&quot; :key&#x3D;&quot;indexj&quot;&gt;                &#123;&#123;child.name&#125;&#125;              &lt;&#x2F;el-menu-item&gt;          &lt;&#x2F;el-submenu&gt;        &lt;&#x2F;el-menu&gt;      &lt;&#x2F;el-aside&gt;      &lt;el-main&gt;        &lt;router-view&#x2F;&gt;      &lt;&#x2F;el-main&gt;    &lt;&#x2F;el-container&gt;  &lt;&#x2F;el-container&gt;&lt;&#x2F;div&gt;</code></pre></div><p>新增router中的跳转<strong>index.js</strong></p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Login.vue&#x27;</span><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span><span class="hljs-keyword">import</span> Test1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Test1.vue&#x27;</span><span class="hljs-keyword">import</span> Test2 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Test2.vue&#x27;</span>Vue.use(VueRouter)<span class="hljs-keyword">const</span> routes = [    &#123;      path: <span class="hljs-string">&#x27;/&#x27;</span>,      name: <span class="hljs-string">&#x27;Login&#x27;</span>,      component: Login,      hidden:<span class="hljs-literal">true</span>    &#125;,    &#123;      path: <span class="hljs-string">&#x27;/home&#x27;</span>,      name: <span class="hljs-string">&#x27;Home&#x27;</span>,      component: Home,      hidden:<span class="hljs-literal">true</span>    &#125;,    &#123;        path: <span class="hljs-string">&#x27;/home&#x27;</span>,        name: <span class="hljs-string">&#x27;导航一&#x27;</span>,        component: Home,        children: [            &#123;                path: <span class="hljs-string">&#x27;/test1&#x27;</span>,                name: <span class="hljs-string">&#x27;选项1&#x27;</span>,                component: Test1            &#125;,            &#123;                path: <span class="hljs-string">&#x27;/test2&#x27;</span>,                name: <span class="hljs-string">&#x27;选项2&#x27;</span>,                component: Test2            &#125;        ]    &#125;]<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;  routes&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router</code></pre></div><p>根据数据库中存储的menu表</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602172047103.png" alt="image-20210602172047103"></p><p>可以给每个角色分配不同的menu访问权限</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602172709842.png" alt="image-20210602172709842"></p><p>这样就不用去router中自己定义每个menu的名字和显示的类别，通过读取数据库，当前用户根据不同的权限去访问不同的menu，[此部分在后端搭建部分补充](# 数据库驱动Menu菜单)</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>下一步引入<code>Vuex</code>来做状态管理，是所有状态都放在一个公共的位置，实现状态实时转换，首先安装</p><div class="hljs code-wrapper"><pre><code class="hljs shell">npm install vuex</code></pre></div><p>建立组件store下的<strong>index.js</strong>实现vuex</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>Vue.use(Vuex)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store(&#123;    state:&#123;        routes:[]    &#125;,    mutations:&#123;        <span class="hljs-function"><span class="hljs-title">initRoutes</span>(<span class="hljs-params">state, data</span>)</span>&#123;            state.routes = data;        &#125;    &#125;,    actions:&#123;    &#125;&#125;)</code></pre></div><p>配置工具类<strong>menus.js</strong></p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;getRequest&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/api&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> initMenu=<span class="hljs-function">(<span class="hljs-params">router,store</span>)=&gt;</span>&#123;    <span class="hljs-comment">//正常的跳转</span>    <span class="hljs-keyword">if</span> (store.state.routes.length &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//F5刷新</span>    getRequest(<span class="hljs-string">&quot;/system/config/menu&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (data)&#123;            <span class="hljs-keyword">let</span> fmtRoutes = formatRoutes(data);            router.addRoutes(fmtRoutes);            store.commit(<span class="hljs-string">&#x27;initRoutes&#x27;</span>, fmtRoutes)        &#125;    &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> formatRoutes = <span class="hljs-function">(<span class="hljs-params">routes</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> fmRoutes = [];    routes.forEach(<span class="hljs-function"><span class="hljs-params">router</span> =&gt;</span> &#123;        <span class="hljs-keyword">let</span>  &#123;            path,            component,            name,            meta,            iconCls,            children        &#125; = router;        <span class="hljs-keyword">if</span> (children &amp;&amp; children <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)&#123;            children = formatRoutes(children);        &#125;        <span class="hljs-keyword">let</span> fmRouter = &#123;            path:path,            name:name,            iconCls:iconCls,            meta:meta,            children: children,            <span class="hljs-function"><span class="hljs-title">component</span>(<span class="hljs-params">resolve</span>)</span> &#123;                <span class="hljs-keyword">if</span> (component.startsWith(<span class="hljs-string">&quot;Emp&quot;</span>))&#123;                    <span class="hljs-built_in">require</span> ([<span class="hljs-string">&#x27;../views/emp/&#x27;</span> + component + <span class="hljs-string">&#x27;.vue&#x27;</span>], resolve)                &#125;                <span class="hljs-keyword">if</span> (component.startsWith(<span class="hljs-string">&quot;Per&quot;</span>))&#123;                    <span class="hljs-built_in">require</span> ([<span class="hljs-string">&#x27;../views/per/&#x27;</span> + component + <span class="hljs-string">&#x27;.vue&#x27;</span>], resolve)                &#125;                <span class="hljs-keyword">if</span> (component.startsWith(<span class="hljs-string">&quot;Sal&quot;</span>))&#123;                    <span class="hljs-built_in">require</span> ([<span class="hljs-string">&#x27;../views/sal/&#x27;</span> + component + <span class="hljs-string">&#x27;.vue&#x27;</span>], resolve)                &#125;                <span class="hljs-keyword">if</span> (component.startsWith(<span class="hljs-string">&quot;Sta&quot;</span>))&#123;                    <span class="hljs-built_in">require</span> ([<span class="hljs-string">&#x27;../views/sta/&#x27;</span> + component + <span class="hljs-string">&#x27;.vue&#x27;</span>], resolve)                &#125;                <span class="hljs-keyword">if</span> (component.startsWith(<span class="hljs-string">&quot;Sys&quot;</span>))&#123;                    <span class="hljs-built_in">require</span> ([<span class="hljs-string">&#x27;../views/sys/&#x27;</span> + component + <span class="hljs-string">&#x27;.vue&#x27;</span>], resolve)                &#125;            &#125;        &#125;        fmRoutes.push(fmRouter)    &#125;)    <span class="hljs-keyword">return</span> fmRoutes;&#125;</code></pre></div><p>最后在<strong>main.js</strong>中配置跳转</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;initMenu&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/menus&quot;</span>;router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (to.path == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;    next();  &#125; <span class="hljs-keyword">else</span> &#123;    initMenu(router, store);    next();  &#125;&#125;)</code></pre></div><p>在<strong>Home.vue</strong>中加载</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script&gt;export default &#123;computed : &#123;  routes() &#123;    return this.$store.state.routes  &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><p><strong>安装图表库</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">npm install font-awesome</code></pre></div><p>在<strong>main.js</strong>中引入</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;font-awesome/css/font-awesome.min.css&#x27;</span></code></pre></div><p><strong>Home.vue</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;i style&#x3D;&quot;color: #409eff; margin-right: 8px&quot; :class&#x3D;&quot;item.iconCls&quot;&gt;&lt;&#x2F;i&gt;</code></pre></div><h3 id="配置权限的跳转"><a href="#配置权限的跳转" class="headerlink" title="配置权限的跳转"></a>配置权限的跳转</h3><p><strong>main.js</strong>中</p><div class="hljs code-wrapper"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (to.path == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;    next();  &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.sessionStorage.getItem(<span class="hljs-string">&quot;user&quot;</span>))&#123;        initMenu(router, store);        next();      &#125; <span class="hljs-keyword">else</span> &#123;        next(<span class="hljs-string">&#x27;/?redirect=&#x27;</span> + to.path);      &#125;  &#125;&#125;)</code></pre></div><p>为了让登录时的url在登录后同样适用，配置<strong>Login.vue</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vue">let path &#x3D; this.$route.query.redirect;this.$router.replace((path &#x3D;&#x3D; &#39;&#x2F;home&#39; || path &#x3D;&#x3D; undefined)? &#39;&#x2F;home&#39; : path)</code></pre></div><h1 id="五、前后端对接"><a href="#五、前后端对接" class="headerlink" title="五、前后端对接"></a>五、前后端对接</h1><h3 id="基础连接"><a href="#基础连接" class="headerlink" title="基础连接"></a>基础连接</h3><p><strong>安装axios</strong></p><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install axios</code></pre></div><p>封装工具类<code>api.js</code>，处理登录请求的状态码信息</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><span class="hljs-keyword">import</span> &#123; Message &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../router&#x27;</span>axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">success</span>=&gt;</span>&#123;    <span class="hljs-keyword">if</span> (success.status &amp;&amp; success.status ==<span class="hljs-number">200</span> &amp;&amp; success.data.status ==<span class="hljs-number">500</span>)&#123;        Message.error(&#123;<span class="hljs-attr">message</span>:success.data.msg&#125;)        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (success.data.msg)&#123;        Message.success(&#123;<span class="hljs-attr">message</span>:success.data.msg&#125;)    &#125;    <span class="hljs-keyword">return</span> success.data;&#125;,<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (error.response.status == <span class="hljs-number">504</span> || error.response.status == <span class="hljs-number">404</span>)&#123;        Message.error(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;服务器GG了哦　╮(￣▽￣&quot;&quot;)╭&#x27;</span>&#125;)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.response.status == <span class="hljs-number">403</span>) &#123;        Message.error(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;您的权限不够哦　╮(￣▽￣&quot;&quot;)╭&#x27;</span>&#125;)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.response.status == <span class="hljs-number">401</span>)&#123;        Message.error(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;尚未登录，请登录&#x27;</span>&#125;)        router.replace(<span class="hljs-string">&#x27;/&#x27;</span>)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (error.response.data.msg)&#123;            Message.error(&#123;<span class="hljs-attr">message</span>:error.response.data.msg&#125;)        &#125; <span class="hljs-keyword">else</span> &#123;            Message.error(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;未知错误（；゜０゜）&#x27;</span>&#125;)        &#125;    &#125;    <span class="hljs-keyword">return</span>;&#125;)<span class="hljs-keyword">let</span> base = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> postKeyValueRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span>&#123;    <span class="hljs-keyword">return</span> axios(&#123;        method:<span class="hljs-string">&#x27;POST&#x27;</span>,        url:<span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,        data:params,        transformRequest:[<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)</span>&#123;            <span class="hljs-keyword">let</span> ret = <span class="hljs-string">&#x27;&#x27;</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> data)&#123;                ret+=<span class="hljs-built_in">encodeURIComponent</span>(i) + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[i]) + <span class="hljs-string">&#x27;&amp;&#x27;</span>            &#125;            <span class="hljs-built_in">console</span>.log(ret);            <span class="hljs-keyword">return</span> ret;        &#125;],        headers:&#123;            <span class="hljs-string">&#x27;Content-Type&#x27;</span>:<span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>        &#125;    &#125;);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> postRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> axios (&#123;        method : <span class="hljs-string">&#x27;post&#x27;</span>,        url:<span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,        data:params    &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> putRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> axios (&#123;        method : <span class="hljs-string">&#x27;put&#x27;</span>,        url:<span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,        data:params    &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> axios (&#123;        method : <span class="hljs-string">&#x27;get&#x27;</span>,        url:<span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,        data:params    &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deleteRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> axios (&#123;        method : <span class="hljs-string">&#x27;delete&#x27;</span>,        url:<span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,        data:params    &#125;)&#125;</code></pre></div><p>在<code>Login.vue</code>下引入</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script&gt;import &#123;postKeyValueRequest&#125; from &quot;@&#x2F;utils&#x2F;api&quot;;  export default &#123;  name: &quot;Login&quot;,  data()&#123;    return &#123;      loginForm:&#123;        username:&#39;admin&#39;,        password:&#39;123&#39;      &#125;,      checked: true,      rules:&#123;        username:[&#123;required: true, message:&quot;请输入你的用户名&quot;,trigger:&quot;blur&quot;&#125;],        password:[&#123;required: true, message:&quot;请输入密码&quot;,trigger:&quot;blur&quot;&#125;]      &#125;    &#125;  &#125;,  methods:&#123;    submitLogin()&#123;      this.$refs.loginForm.validate((valid) &#x3D;&gt; &#123;        if (valid) &#123;          postKeyValueRequest(&#39;&#x2F;doLogin&#39;,this.loginForm).then(resp &#x3D;&gt; &#123;            if (resp)&#123;              alert(JSON.stringify(resp))            &#125;          &#125;)          &#x2F;&#x2F; alert(&#39;提交成功!&#39;);        &#125; else &#123;          this.$message.error(&#39;请输入所有字段&#39;);          return false;        &#125;      &#125;);    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><p><strong>前后端连接配置vue.config.js</strong></p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> proxyObj = &#123;&#125;;proxyObj [<span class="hljs-string">&#x27;/&#x27;</span>] = &#123;    ws:<span class="hljs-literal">false</span>,    target:<span class="hljs-string">&#x27;http://localhost:8081&#x27;</span>,    changeOrigin:<span class="hljs-literal">true</span>,    pathRewrite:&#123;        <span class="hljs-string">&#x27;^/&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>    &#125;&#125;<span class="hljs-built_in">module</span>.exports=&#123;    devServer:&#123;        host:<span class="hljs-string">&#x27;localhost&#x27;</span>,        port:<span class="hljs-number">8080</span>,        proxy:proxyObj    &#125;&#125;</code></pre></div><p><strong>登录成功</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210531134218777.png" alt="image-20210531134218777"></p><p>返回的是从数据库中读取到的JSON信息</p><p><strong>登录失败</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210531134244306.png" alt="image-20210531134244306"></p><p>对应着后端配置类中的failureHandle中的处理字段，到目前为止，前后端已经对接成功</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>在传统的前后端不分的开发中，权限管理主要通过过滤器或者拦截器来进行（权限管理框架本身也是通过过滤器来实现功能），如果用户不具备某一个角色或者某一个权限，则无法访问某一个页面。</p><p>但是在前后端分离中，页面的跳转统统交给前端去做，后端只提供数据，这种时候，权限管理不能再按照之前的思路来。</p><p>首先要明确一点，<code>前端是展示给用户看的，所有的菜单显示或者隐藏目的不是为了实现权限管理，而是为了给用户一个良好的体验，不能依靠前端隐藏控件来实现权限管理，即数据安全不能依靠前端</code>。</p><p>这点就像普通的表单提交一样，前端做数据校验是为了提高效率，提高用户体验，后端才是真正的确保数据完整性。</p><p>所以，<code>真正的数据安全管理是在后端实现的，后端在接口设计的过程中，就要确保每一个接口都是在满足某种权限的基础上才能访问，也就是说，不怕将后端数据接口地址暴露出来，即使暴露出来，只要你没有相应的角色，也是访问不了的</code>。</p><p>前端为了良好的用户体验，需要将用户不能访问的接口或者菜单隐藏起来。</p><p>有人说，如果用户直接在地址拦输入某一个页面的路径，怎么办？此时，如果没有做任何额外的处理的话，用户确实可以通过直接输入某一个路径进入到系统中的某一个页面中，但是，不用担心数据泄露问题，因为没有相关的角色，就无法访问相关的接口。</p><p>但是，如果用户非这样操作，进入到一个空白的页面，用户体验不好，此时，我们可以使用 Vue 中的前置路由导航守卫，来监听页面跳转，如果用户想要去一个未获授权的页面，则直接在前置路由导航守卫中将之拦截下来，重定向到登录页，或者直接就停留在当前页，不让用户跳转，也可以顺手再给用户一点点未获授权的提示信息。</p><p>总而言之一句话，前端的所有操作，都是为了提高用户体验，不是为了数据安全，真正的权限校验要在后端来做，后端如果是 SSM 架构，建议使用 Shiro ，如果是 <code>Spring Boot + 微服务</code>，建议使用 <code>Spring Security</code>，本系统就是利用 Spring Security 来实现的</p><h1 id="六、后端的搭建"><a href="#六、后端的搭建" class="headerlink" title="六、后端的搭建"></a>六、后端的搭建</h1><h3 id="服务器环境的搭建"><a href="#服务器环境的搭建" class="headerlink" title="服务器环境的搭建"></a>服务器环境的搭建</h3><p>创建项目，添加依赖</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210529222859839.png" alt="image-20210529222859839"></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>权限数据库主要包含了五张表，分别是资源表、角色表、用户表、资源角色表、用户角色表，数据库关系模型如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/p274.png" alt="p274"></p><ul><li>hr表是用户表，存放了用户的基本信息。</li><li>role是角色表，name字段表示角色的英文名称，按照SpringSecurity的规范，将以<code>ROLE_</code>开始，nameZh字段表示角色的中文名称。</li><li>menu表是一个资源表，该表涉及到的字段有点多，由于我的前端采用了Vue来做，因此当用户登录成功之后，系统将根据用户的角色动态加载需要的模块，所有模块的信息将保存在menu表中，menu表中的path、component、iconCls、keepAlive、requireAuth等字段都是Vue-Router中需要的字段，也就是说menu中的数据到时候会以json的形式返回给前端，再由vue动态更新router，menu中还有一个字段url，表示一个url pattern，即路径匹配规则，假设有一个路径匹配规则为<code>/admin/**</code>,那么当用户在客户端发起一个<code>/admin/user</code>的请求，将被<code>/admin/**</code>拦截到，系统再去查看这个规则对应的角色是哪些，然后再去查看该用户是否具备相应的角色，进而判断该请求是否合法</li></ul><p><code>共有22个表</code></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210529225927805.png" alt="image-20210529225927805"></p><p>同时导入mapper和model模板文件，见项目中代码<code>model</code>和<code>mapper</code></p><p>配置mapper扫描和pom文件</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(basePackages=&quot;org.lucifer.vbluciferpro.mapper&quot;)</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>并完成JDBC的相关配置</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">Root!123</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/vhr?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><span class="hljs-comment"># 前端Vue的接口为8080</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span></code></pre></div><h3 id="简单的测试"><a href="#简单的测试" class="headerlink" title="简单的测试"></a>简单的测试</h3><p>这里先简单的测试一个接口的效果</p><p><strong>用户类配置</strong></p><p>为了使用<code>SpringSecurity</code>，需要实现<code>UserDetails</code>接口并重写方法，因为重写了<code>isEnabled</code>方法，需要删除生成的<code>getEnabled</code>方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String phone;    <span class="hljs-keyword">private</span> String telephone;    <span class="hljs-keyword">private</span> String address;    <span class="hljs-keyword">private</span> Boolean enabled;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> String userface;    <span class="hljs-keyword">private</span> String remark;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> enabled;    &#125;      <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p><strong>Service</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HrService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HrMapper hrMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        Hr hr = hrMapper.loadUserByUsername(username);        <span class="hljs-keyword">if</span> (hr == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;用户名不存在！&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> hr;    &#125;&#125;</code></pre></div><p><strong>Mapper接口</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HrMapper</span> </span>&#123;    <span class="hljs-function">Hr <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span></span>;&#125;</code></pre></div><p><strong>Mapper.xml</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.mapper.HrMapper&quot;</span> &gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Hr&quot;</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;CHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;telephone&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;telephone&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;enabled&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;enabled&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIT&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;userface&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userface&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;remark&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;remark&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loadUserByUsername&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  select * from hr where username=#&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p><strong>Security配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HrService hrService;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(hrService);    &#125;&#125;</code></pre></div><p><strong>Controller</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;&#125;</code></pre></div><p>这样通过登录就能访问到hello了，接下来，我们开始对<code>Security</code>进行登录成功失败相关配置，首先创建响应实体类(实体类都有<code>setter/getter</code>方法，只不过为了优雅，在这里就不展示)</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RespBean</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer status;    <span class="hljs-keyword">private</span> String msg;    <span class="hljs-keyword">private</span> Object obj;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">ok</span><span class="hljs-params">(String msg)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">200</span>, msg,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">ok</span><span class="hljs-params">(String msg, Object obj)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">200</span>, msg, obj);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">error</span><span class="hljs-params">(String msg)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">500</span>,msg,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">error</span><span class="hljs-params">(String msg, Object obj)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">500</span>, msg, obj);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RespBean</span><span class="hljs-params">(Integer status, String msg, Object obj)</span> </span>&#123;        <span class="hljs-keyword">this</span>.status = status;        <span class="hljs-keyword">this</span>.msg = msg;        <span class="hljs-keyword">this</span>.obj = obj;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RespBean</span><span class="hljs-params">()</span> </span>&#123;    &#125;    &#125;</code></pre></div><p>接着继续完善配置类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HrService hrService;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(hrService);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .anyRequest().authenticated()                .and()                .formLogin()                .usernameParameter(<span class="hljs-string">&quot;username&quot;</span>)                .passwordParameter(<span class="hljs-string">&quot;password&quot;</span>)                .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)                .loginPage(<span class="hljs-string">&quot;/login&quot;</span>)                .successHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = resp.getWriter();                        Hr hr = (Hr) authentication.getPrincipal();                        hr.setPassword(<span class="hljs-keyword">null</span>);                        RespBean ok = RespBean.ok(<span class="hljs-string">&quot;登录成功&quot;</span>, hr);                        String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok);                        out.write(s);                        out.flush();                        out.close();                    &#125;                &#125;)                .failureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = resp.getWriter();                        RespBean respBean = RespBean.error(<span class="hljs-string">&quot;登录失败&quot;</span>);                        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> LockedException)&#123;                            respBean.setMsg(<span class="hljs-string">&quot;账户被锁定，请联系管理员&quot;</span>);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> CredentialsExpiredException)&#123;                            respBean.setMsg(<span class="hljs-string">&quot;密码已过期，请联系管理员&quot;</span>);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccountExpiredException)&#123;                            respBean.setMsg(<span class="hljs-string">&quot;账号已过期，请联系管理员&quot;</span>);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> DisabledException)&#123;                            respBean.setMsg(<span class="hljs-string">&quot;账户被禁用，请联系管理员&quot;</span>);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BadCredentialsException)&#123;                            respBean.setMsg(<span class="hljs-string">&quot;用户名或者密码输入错误&quot;</span>);                        &#125;                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));                        out.flush();                        out.close();                    &#125;                &#125;)                .permitAll()                .and()                .logout()                .logoutSuccessHandler(<span class="hljs-keyword">new</span> LogoutSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = resp.getWriter();                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.ok(<span class="hljs-string">&quot;注销成功&quot;</span>)));                        out.flush();                        out.close();                    &#125;                &#125;)                .permitAll()                .and()                .csrf().disable();    &#125;&#125;</code></pre></div><p>设置登录的接口</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;尚未登录，请登录&quot;</span>);    &#125;&#125;</code></pre></div><h3 id="数据库驱动Menu菜单"><a href="#数据库驱动Menu菜单" class="headerlink" title="数据库驱动Menu菜单"></a>数据库驱动Menu菜单</h3><p>新建实体类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String url;    <span class="hljs-keyword">private</span> String path;    <span class="hljs-keyword">private</span> String component;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String iconCls;    <span class="hljs-keyword">private</span> Meta meta;    <span class="hljs-comment">//对应router中的子级菜单</span>    <span class="hljs-keyword">private</span> List&lt;Menu&gt; children;    <span class="hljs-keyword">private</span> Integer parentId;    <span class="hljs-keyword">private</span> Boolean enabled;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span> </span>&#123;    <span class="hljs-keyword">private</span> Boolean keepAlive;    <span class="hljs-keyword">private</span> Boolean requireAuth;&#125;</code></pre></div><p>创建Service</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MenuMapper menuMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getMenusByHrId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> menuMapper.getMenusByHrId(((Hr) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).getId());    &#125;&#125;</code></pre></div><p>调用Mapper</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MenuMapper</span> </span>&#123;<span class="hljs-function">List&lt;Menu&gt; <span class="hljs-title">getMenusByHrId</span><span class="hljs-params">(Integer hrid)</span></span>;&#125;</code></pre></div><p>根据数据库的id，设计SQL</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Menu&quot;</span> &gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;path&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;path&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;component&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;component&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;iconCls&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;iconCls&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;parentId&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;parentId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;enabled&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;enabled&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIT&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;meta&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Meta&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;keepAlive&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;keepAlive&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIT&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;requireAuth&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;requireAuth&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIT&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span> &gt;</span>  id, url, path, component, name, iconCls, keepAlive, requireAuth, parentId, enabled<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Menus2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Menu&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;children&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Menu&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;url2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;path2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;path&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;component2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;component&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;iconCls2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;iconCls&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;parentId2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;parentId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;enabled2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;enabled&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIT&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;meta&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Meta&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;keepAlive2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;keepAlive&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIT&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;requireAuth2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;requireAuth&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIT&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getMenusByHrId&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;Menus2&quot;</span>&gt;</span>  SELECT DISTINCT  m1.*, m2.`id` as id2, m2.`component` as component2, m2.`enabled` as enabled2,         m2.`iconCls` as iconCls2, m2.`keepAlive` as keepAlive2, m2.`name` as name2,         m2.`parentId` as parentId2, m2.`requireAuth` as requireAuth2, m2.`path` as path2  FROM menu m1,menu m2, hr_role hrr,menu_role mr  where m1.`id`=m2.`parentId` and hrr.`hrid`=#&#123;hrid&#125; and hrr.`rid`=mr.`rid` and mr.`mid`=m2.`id` and m2.`enabled`=true  ORDER BY m1.`id`,m2.`id`<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>测试用Controller</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/system/config&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemConfigController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MenuService menuService;    <span class="hljs-meta">@GetMapping(&quot;/menu&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getMenusByHrId</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> menuService.getMenusByHrId();    &#125;&#125;</code></pre></div><h3 id="后端接口权限设计"><a href="#后端接口权限设计" class="headerlink" title="后端接口权限设计"></a>后端接口权限设计</h3><p>根据<code>Menu</code>表中的<code>path/id/name</code>可以确定前端发过来的请求的url访问的名字以及id</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210604171529329.png" alt="image-20210604171529329"></p><p>然后在<code>Menu_role</code>表中可以发现那些role具有当前mid的权限rid，去检查rid是否为当前登录的角色</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210604171656534.png" alt="image-20210604171656534"></p><p>新增配置类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lucifer</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 根据用户传来的请求地址，分析出请求需要的角色</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomFilterInvocationSecurityMetadataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterInvocationSecurityMetadataSource</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MenuService menuService;    AntPathMatcher antPathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAttributes</span><span class="hljs-params">(Object object)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;        String requestUrl = ((FilterInvocation) object).getRequestUrl();        List&lt;Menu&gt; menus = menuService.getAllMenusWithRole();        <span class="hljs-keyword">for</span> (Menu menu : menus) &#123;            <span class="hljs-keyword">if</span> (antPathMatcher.match(menu.getUrl(), requestUrl)) &#123;                List&lt;Role&gt; roles = menu.getRoles();                String[] str = <span class="hljs-keyword">new</span> String[roles.size()];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; roles.size(); i++) &#123;                    str[i] = roles.get(i).getName();                &#125;                <span class="hljs-keyword">return</span> SecurityConfig.createList(str);            &#125;        &#125;        <span class="hljs-keyword">return</span> SecurityConfig.createList(<span class="hljs-string">&quot;ROLE_LOGIN&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAllConfigAttributes</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUrlDecisionManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDecisionManager</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decide</span><span class="hljs-params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="hljs-keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;        <span class="hljs-keyword">for</span> (ConfigAttribute configAttribute : configAttributes) &#123;            String needRole = configAttribute.getAttribute();            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ROLE_LOGIN&quot;</span>.equals(needRole)) &#123;                <span class="hljs-keyword">if</span> (authentication <span class="hljs-keyword">instanceof</span> AnonymousAuthenticationToken)&#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;尚未登录，请登录！&quot;</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();            <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;                <span class="hljs-comment">//需要的角色能被检测到</span>                <span class="hljs-keyword">if</span> (authority.getAuthority().equals(needRole))&#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;权限不足，请返回！&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><p>在<strong>Security</strong>配置类中注入</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>CustomFilterInvocationSecurityMetadataSource customFilterInvocationSecurityMetadataSource;<span class="hljs-meta">@Autowired</span>CustomUrlDecisionManager customUrlDecisionManager; <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//防止访问登录页面死循环，不用进入Security拦截</span>        web.ignoring().antMatchers(<span class="hljs-string">&quot;/login&quot;</span>);    &#125; <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;                        object.setAccessDecisionManager(customUrlDecisionManager);                        object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);                        <span class="hljs-keyword">return</span> object;                    &#125;                &#125;)                <span class="hljs-comment">//.anyRequest().authenticated()</span>                                                <span class="hljs-comment">//解决没登录时，重定向的跨域问题，这里直接处理，不重定向</span>                .csrf().disable().exceptionHandling().authenticationEntryPoint(<span class="hljs-keyword">new</span> AuthenticationEntryPoint() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);              <span class="hljs-comment">//重启服务器的时候，设置状态码，跳转登录页面</span>              resp.setStatus(<span class="hljs-number">401</span>);                PrintWriter out = resp.getWriter();                RespBean respBean = RespBean.error(<span class="hljs-string">&quot;访问失败&quot;</span>);                <span class="hljs-comment">//session失效，跳转登录页面</span>                <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException)&#123;                    respBean.setMsg(<span class="hljs-string">&quot;请求失败，请联系管理员！&quot;</span>);                &#125;                out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));                out.flush();            &#125;</code></pre></div><p>实体类Hr新增Role属性</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Role&gt; roles;</code></pre></div><p>实体类Menu同样新增Role属性</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Role&gt; roles;</code></pre></div><p><strong>MenuService</strong>新增方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//@Cacheable</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getAllMenusWithRole</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> menuMapper.getAllMenusWithRole();&#125;</code></pre></div><p><strong>MenuMapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;MenuWithRole&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Menu&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roles&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Role&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rnameZh&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;nameZh&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllMenusWithRole&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;MenuWithRole&quot;</span>&gt;</span>  SELECT m.*, r.`id` as rid, r.`name` as rname, r.`nameZh` as rnameZh  FROM menu m, menu_role mr, role r  WHERE m.`id` = mr.`mid` AND mr.`rid` = r.`id`  ORDER BY m.`id`;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p><strong>HrService</strong>中需要添加注入角色的字段，不然为null</p><div class="hljs code-wrapper"><pre><code class="hljs java">hr.setRoles(hrMapper.getHrRolesById(hr.getId()));</code></pre></div><p><strong>HrMapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getHrRolesById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Role&quot;</span>&gt;</span>  SELECT r.* FROM role r, hr_role hrr WHERE hrr.`rid` = r.`id` AND hrr.`hrid` = #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>测试类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/employee/basic/hello&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/employee/basic/hello&quot;</span>;&#125;<span class="hljs-meta">@GetMapping(&quot;/employee/advanced/hello&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/employee/advanced/hello&quot;</span>;&#125;</code></pre></div><h1 id="七、业务模块"><a href="#七、业务模块" class="headerlink" title="七、业务模块"></a>七、业务模块</h1><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="基础信息设置"><a href="#基础信息设置" class="headerlink" title="基础信息设置"></a>基础信息设置</h3><p><code>views/sys/SysBasic.vue</code>下定义每个标签</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;    &lt;div&gt;      &lt;el-tabs v-model&#x3D;&quot;activeName&quot; type&#x3D;&quot;card&quot;&gt;        &lt;el-tab-pane label&#x3D;&quot;部门管理&quot; name&#x3D;&quot;first&quot;&gt;&lt;DepMana&gt;&lt;&#x2F;DepMana&gt;&lt;&#x2F;el-tab-pane&gt;        &lt;el-tab-pane label&#x3D;&quot;职位管理&quot; name&#x3D;&quot;second&quot;&gt;&lt;PosMana&gt;&lt;&#x2F;PosMana&gt;&lt;&#x2F;el-tab-pane&gt;        &lt;el-tab-pane label&#x3D;&quot;职称管理&quot; name&#x3D;&quot;third&quot;&gt;&lt;JobLevelMana&gt;&lt;&#x2F;JobLevelMana&gt;&lt;&#x2F;el-tab-pane&gt;        &lt;el-tab-pane label&#x3D;&quot;奖惩规则&quot; name&#x3D;&quot;fourth&quot;&gt;&lt;EcMana&gt;&lt;&#x2F;EcMana&gt;&lt;&#x2F;el-tab-pane&gt;        &lt;el-tab-pane label&#x3D;&quot;权限组&quot; name&#x3D;&quot;fifth&quot;&gt;&lt;PermissMana&gt;&lt;&#x2F;PermissMana&gt;&lt;&#x2F;el-tab-pane&gt;      &lt;&#x2F;el-tabs&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;    import DepMana from &quot;@&#x2F;components&#x2F;sys&#x2F;basic&#x2F;DepMana&quot;;    import EcMana from &quot;@&#x2F;components&#x2F;sys&#x2F;basic&#x2F;EcMana&quot;;    import JobLevelMana from &quot;@&#x2F;components&#x2F;sys&#x2F;basic&#x2F;JobLevelMana&quot;;    import PermissMana from &quot;@&#x2F;components&#x2F;sys&#x2F;basic&#x2F;PermissMana&quot;;    import PosMana from &quot;@&#x2F;components&#x2F;sys&#x2F;basic&#x2F;PosMana&quot;;    export default &#123;        name: &quot;SysBasic&quot;,        data()&#123;            return &#123;              activeName: &#39;&#39;            &#125;        &#125;,        components:&#123;          DepMana,          EcMana,          JobLevelMana,          PermissMana,          PosMana        &#125;    &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><p>其中的<code>&lt;DepMana&gt;</code>等标签，对应<code>components/sys/basic/DepMana.vue</code>，这样就可以对不同的标签进行开发</p><h4 id="职位管理"><a href="#职位管理" class="headerlink" title="职位管理"></a>职位管理</h4><h5 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h5><p><strong>PosMana.vue</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;div&gt;      &lt;el-input          size&#x3D;&quot;small&quot;          class&#x3D;&quot;addPosInput&quot;          placeholder&#x3D;&quot;添加职位&quot;          prefix-icon&#x3D;&quot;el-icon-plus&quot;          v-model&#x3D;&quot;pos.name&quot;&gt;      &lt;&#x2F;el-input&gt;      &lt;el-button icon&#x3D;&quot;el-icon-plus&quot; size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot;&gt;添加&lt;&#x2F;el-button&gt;    &lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;posManaMain&quot;&gt;    &lt;el-table          :data&#x3D;&quot;positions&quot;          border          stripe          style&#x3D;&quot;width: 70%&quot;&gt;        &lt;el-table-column            prop&#x3D;&quot;id&quot;            label&#x3D;&quot;编号&quot;            width&#x3D;&quot;55&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;name&quot;            label&#x3D;&quot;职位名称&quot;            width&#x3D;&quot;120&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;createDate&quot;            label&#x3D;&quot;创建时间&quot;&gt;        &lt;&#x2F;el-table-column&gt;      &lt;&#x2F;el-table&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &quot;PosMana&quot;,  data()&#123;    return &#123;      pos: &#123;        name: &#39;&#39;      &#125;,      positions: []    &#125;&#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;.addPosInput &#123;  width: 300px;  margin-right: 8px&#125;.posManaMain &#123;  margin-top: 10px;&#125;&lt;&#x2F;style&gt;</code></pre></div><h5 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h5><p>先写测试接口</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/system/basic/pos&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PositionController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    PositionService positionService;    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Position&gt; <span class="hljs-title">getAllPositions</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> positionService.getAllPositions();    &#125;    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">addPosition</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Position position)</span></span>&#123;        <span class="hljs-keyword">if</span> (positionService.addPosition(position) == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;添加成功&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;添加失败&quot;</span>);    &#125;    <span class="hljs-meta">@PutMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updatePositions</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Position position)</span> </span>&#123;        <span class="hljs-keyword">if</span> (positionService.updatePositions(position) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deletePositionById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;        <span class="hljs-keyword">if</span> (positionService.deletePositionById(id) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;删除成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;删除失败!&quot;</span>);    &#125;</code></pre></div><p><strong>Service</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PositionService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    PositionMapper positionMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Position&gt; <span class="hljs-title">getAllPositions</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> positionMapper.getAllPositions();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">addPosition</span><span class="hljs-params">(Position position)</span> </span>&#123;        position.setEnabled(<span class="hljs-keyword">true</span>);        position.setCreateDate(<span class="hljs-keyword">new</span> Date());        <span class="hljs-keyword">return</span> positionMapper.insertSelective(position);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">updatePositions</span><span class="hljs-params">(Position position)</span> </span>&#123;        <span class="hljs-keyword">return</span> positionMapper.updateByPrimaryKeySelective(position);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">deletePositionById</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">return</span> positionMapper.deleteByPrimaryKey(id);    &#125;&#125;</code></pre></div><p><strong>Mapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PositionMapper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Position record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(Position record)</span></span>;    <span class="hljs-function">Position <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(Position record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(Position record)</span></span>;    <span class="hljs-function">List&lt;Position&gt; <span class="hljs-title">getAllPositions</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>对应的xml文件</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllPositions&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  SELECT * FROM position;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>这样就完成了对职位管理的添加，更新，删除操作</p><h5 id="前后端对接"><a href="#前后端对接" class="headerlink" title="前后端对接"></a>前后端对接</h5><p>先针对PosMana进行删除添加相关的补充</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;div&gt;      &lt;el-input          size&#x3D;&quot;small&quot;          class&#x3D;&quot;addPosInput&quot;          placeholder&#x3D;&quot;添加职位&quot;          prefix-icon&#x3D;&quot;el-icon-plus&quot;          @keydown.enter.native&#x3D;&quot;addPosition&quot;          v-model&#x3D;&quot;pos.name&quot;&gt;      &lt;&#x2F;el-input&gt;      &lt;el-button icon&#x3D;&quot;el-icon-plus&quot; size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addPosition&quot;&gt;添加&lt;&#x2F;el-button&gt;    &lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;posManaMain&quot;&gt;    &lt;el-table          :data&#x3D;&quot;positions&quot;          @selection-change&#x3D;&quot;handleSelectionChange&quot;          border          stripe          style&#x3D;&quot;width: 70%&quot;&gt;      &lt;el-table-column          type&#x3D;&quot;selection&quot;          width&#x3D;&quot;55&quot;&gt;      &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;id&quot;            label&#x3D;&quot;编号&quot;            width&#x3D;&quot;55&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;name&quot;            label&#x3D;&quot;职位名称&quot;            width&#x3D;&quot;150&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;createDate&quot;            width&#x3D;&quot;150&quot;            label&#x3D;&quot;创建时间&quot;&gt;        &lt;&#x2F;el-table-column&gt;      &lt;el-table-column label&#x3D;&quot;操作&quot;&gt;        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;          &lt;el-button              size&#x3D;&quot;mini&quot;              @click&#x3D;&quot;showEditView(scope.$index, scope.row)&quot;&gt;编辑          &lt;&#x2F;el-button&gt;          &lt;el-button              size&#x3D;&quot;mini&quot;              type&#x3D;&quot;danger&quot;              @click&#x3D;&quot;handleDelete(scope.$index, scope.row)&quot;&gt;删除          &lt;&#x2F;el-button&gt;        &lt;&#x2F;template&gt;      &lt;&#x2F;el-table-column&gt;      &lt;&#x2F;el-table&gt;      &lt;el-button @click&#x3D;&quot;deleteMany&quot; type&#x3D;&quot;danger&quot; size&#x3D;&quot;small&quot; style&#x3D;&quot;margin-top: 8px&quot;                 :disabled&#x3D;&quot;multipleSelection.length&#x3D;&#x3D;0&quot;&gt;批量删除      &lt;&#x2F;el-button&gt;    &lt;&#x2F;div&gt;    &lt;el-dialog        title&#x3D;&quot;修改职位&quot;        :visible.sync&#x3D;&quot;dialogVisible&quot;        width&#x3D;&quot;30%&quot;&gt;      &lt;div&gt;        &lt;el-tag&gt;职位名称&lt;&#x2F;el-tag&gt;        &lt;el-input class&#x3D;&quot;updatePosInput&quot; size&#x3D;&quot;small&quot; v-model&#x3D;&quot;updatePos.name&quot;&gt;&lt;&#x2F;el-input&gt;      &lt;&#x2F;div&gt;      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt; &lt;el-button size&#x3D;&quot;small&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;    &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;doUpdate&quot;&gt;确 定&lt;&#x2F;el-button&gt;  &lt;&#x2F;span&gt;    &lt;&#x2F;el-dialog&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &quot;PosMana&quot;,  data() &#123;    return &#123;      pos: &#123;        name: &#39;&#39;      &#125;,      dialogVisible: false,      updatePos: &#123;        name: &#39;&#39;,        enabled: false      &#125;,      positions: [],      multipleSelection: [],    &#125;  &#125;,  &#x2F;&#x2F; 钩子函数  mounted() &#123;    this.initPositions();  &#125;,  methods:&#123;    initPositions() &#123;      this.getRequest(&quot;&#x2F;system&#x2F;basic&#x2F;pos&#x2F;&quot;).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.positions &#x3D; resp;        &#125;      &#125;)    &#125;,    handleSelectionChange(val) &#123;      this.multipleSelection &#x3D; val;    &#125;,    showEditView(index, data) &#123;      Object.assign(this.updatePos, data);      this.dialogVisible &#x3D; true;    &#125;,    handleDelete(index, data) &#123;      this.$confirm(&#39;此操作将永久删除【&#39; + data.name + &#39;】职位, 是否继续?&#39;, &#39;提示&#39;, &#123;        confirmButtonText: &#39;确定&#39;,        cancelButtonText: &#39;取消&#39;,        type: &#39;warning&#39;      &#125;).then(() &#x3D;&gt; &#123;        this.deleteRequest(&quot;&#x2F;system&#x2F;basic&#x2F;pos&#x2F;&quot; + data.id).then(resp &#x3D;&gt; &#123;          if (resp) &#123;            this.initPositions();          &#125;        &#125;)      &#125;).catch(() &#x3D;&gt; &#123;        this.$message(&#123;          type: &#39;info&#39;,          message: &#39;已取消删除&#39;        &#125;);      &#125;);    &#125;,    addPosition() &#123;      if (this.pos.name) &#123;        this.postRequest(&quot;&#x2F;system&#x2F;basic&#x2F;pos&#x2F;&quot;, this.pos).then(resp &#x3D;&gt; &#123;          if (resp) &#123;            this.initPositions();            this.pos.name &#x3D; &#39;&#39;;          &#125;        &#125;)      &#125; else &#123;        this.$message.error(&#39;职位名称不可以为空&#39;);      &#125;    &#125;,    doUpdate() &#123;      this.putRequest(&quot;&#x2F;system&#x2F;basic&#x2F;pos&#x2F;&quot;, this.updatePos).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.initPositions();          this.updatePos.name &#x3D; &#39;&#39;;          this.dialogVisible &#x3D; false;        &#125;      &#125;)    &#125;,    deleteMany() &#123;      this.$confirm(&#39;此操作将永久删除 &#39; + this.multipleSelection.length + &#39; 条记录, 是否继续?&#39;, &#39;提示&#39;, &#123;        confirmButtonText: &#39;确定&#39;,        cancelButtonText: &#39;取消&#39;,        type: &#39;warning&#39;      &#125;).then(() &#x3D;&gt; &#123;        let ids &#x3D; &#39;?&#39;;        this.multipleSelection.forEach(item &#x3D;&gt; &#123;          ids +&#x3D; &#39;ids&#x3D;&#39; + item.id + &#39;&amp;&#39;;        &#125;)        this.deleteRequest(&quot;&#x2F;system&#x2F;basic&#x2F;pos&#x2F;&quot; + ids).then(resp &#x3D;&gt; &#123;          if (resp) &#123;            this.initPositions();          &#125;        &#125;)      &#125;).catch(() &#x3D;&gt; &#123;        this.$message(&#123;          type: &#39;info&#39;,          message: &#39;已取消删除&#39;        &#125;);      &#125;);    &#125;,  &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;.addPosInput &#123;  width: 300px;  margin-right: 8px&#125;.posManaMain &#123;  margin-top: 10px;&#125;.updatePosInput &#123;  width: 200px;  margin-left: 8px;&#125;&lt;&#x2F;style&gt;</code></pre></div><p>删除的时候，有些职位并不能删除，需要做全局异常处理</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler(SQLException.class)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">sqlException</span><span class="hljs-params">(SQLException e)</span></span>&#123;        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> MySQLIntegrityConstraintViolationException)&#123;            <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;该数据有关联数据，操作失败！&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;数据库异常，操作失败！&quot;</span>);    &#125;&#125;</code></pre></div><p>并添加批量删除的接口</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping(&quot;/&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deletePositionsByIds</span><span class="hljs-params">(Integer[] ids)</span> </span>&#123;    <span class="hljs-keyword">if</span> (positionService.deletePositionsByIds(ids) == ids.length) &#123;        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;删除成功!&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;删除失败!&quot;</span>);&#125;</code></pre></div><p>并生成相应的Service和Mapper接口，最终在mapper.xml文件中完善sql语句</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deletePositionsByIds&quot;</span>&gt;</span>  DELETE FROM position WHERE id in  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>    #&#123;id&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span></code></pre></div><h4 id="职称管理"><a href="#职称管理" class="headerlink" title="职称管理"></a>职称管理</h4><h5 id="前端部分-1"><a href="#前端部分-1" class="headerlink" title="前端部分"></a>前端部分</h5><p><strong>JobLevelMana.vue</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;div&gt;      &lt;el-input size&#x3D;&quot;small&quot; v-model&#x3D;&quot;jl.name&quot; style&#x3D;&quot;width: 300px;&quot; prefix-icon&#x3D;&quot;el-icon-plus&quot;                placeholder&#x3D;&quot;添加职称&quot;&gt;      &lt;&#x2F;el-input&gt;      &lt;el-select v-model&#x3D;&quot;jl.titleLevel&quot; placeholder&#x3D;&quot;职称等级&quot; size&#x3D;&quot;small&quot;                 style&#x3D;&quot;margin-left: 5px;margin-right: 5px&quot;&gt;        &lt;el-option            v-for&#x3D;&quot;item in titleLevels&quot;            :key&#x3D;&quot;item&quot;            :label&#x3D;&quot;item&quot;            :value&#x3D;&quot;item&quot;&gt;        &lt;&#x2F;el-option&gt;      &lt;&#x2F;el-select&gt;      &lt;el-button icon&#x3D;&quot;el-icon-plus&quot; type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot;&gt;添加&lt;&#x2F;el-button&gt;      &lt;&#x2F;div&gt;    &lt;div style&#x3D;&quot;margin-top: 10px&quot;&gt;      &lt;el-table          :data&#x3D;&quot;jls&quot;          border          size&#x3D;&quot;small&quot;          style&#x3D;&quot;width: 80%&quot;&gt;        &lt;el-table-column            type&#x3D;&quot;selection&quot;            width&#x3D;&quot;55&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;id&quot;            label&#x3D;&quot;编号&quot;            width&#x3D;&quot;55&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;name&quot;            label&#x3D;&quot;职称名称&quot;            width&#x3D;&quot;150&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;titleLevel&quot;            label&#x3D;&quot;职称级别&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;createDate&quot;            label&#x3D;&quot;创建时间&quot;&gt;        &lt;&#x2F;el-table-column&gt;&lt;!--        &lt;el-table-column            label&#x3D;&quot;是否启用&quot;&gt;          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &lt;el-tag type&#x3D;&quot;success&quot; v-if&#x3D;&quot;scope.row.enabled&quot;&gt;已启用&lt;&#x2F;el-tag&gt;            &lt;el-tag type&#x3D;&quot;danger&quot; v-else&gt;未启用&lt;&#x2F;el-tag&gt;          &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;--&gt;        &lt;el-table-column            label&#x3D;&quot;操作&quot;&gt;          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &lt;el-button size&#x3D;&quot;small&quot; &gt;编辑&lt;&#x2F;el-button&gt;            &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;danger&quot; &gt;删除&lt;&#x2F;el-button&gt;          &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;      &lt;&#x2F;el-table&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &quot;JobLevelMana&quot;,  data() &#123;    return &#123;      jl: &#123;        name: &#39;&#39;,        titleLevel: &#39;&#39;      &#125;,      jls: [],      titleLevels: [        &#39;正高级&#39;,        &#39;副高级&#39;,        &#39;中级&#39;,        &#39;初级&#39;,        &#39;员级&#39;,      ]    &#125;  &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><h5 id="后端部分-1"><a href="#后端部分-1" class="headerlink" title="后端部分"></a>后端部分</h5><p><strong>接口</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/system/basic/joblevel&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobLevelController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    JobLevelService jobLevelService;    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Position&gt; <span class="hljs-title">getAllJobLevels</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> jobLevelService.getAllJobLevels();    &#125;    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">addJobLevel</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> JobLevel jobLevel)</span> </span>&#123;        <span class="hljs-keyword">if</span> (jobLevelService.addJobLevel(jobLevel) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;添加成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;添加失败!&quot;</span>);    &#125;    <span class="hljs-meta">@PutMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateJobLevelById</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> JobLevel jobLevel)</span> </span>&#123;        <span class="hljs-keyword">if</span> (jobLevelService.updateJobLevelById(jobLevel) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deleteJobLevelById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;        <span class="hljs-keyword">if</span> (jobLevelService.deleteJobLevelById(id) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;删除成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;删除失败!&quot;</span>);    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deleteJobLevelsByIds</span><span class="hljs-params">(Integer[] ids)</span> </span>&#123;        <span class="hljs-keyword">if</span> (jobLevelService.deleteJobLevelsByIds(ids) == ids.length) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;删除成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;删除失败!&quot;</span>);    &#125;&#125;</code></pre></div><p>业务类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JobLevelService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    JobLevelMapper jobLevelMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Position&gt; <span class="hljs-title">getAllJobLevels</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> jobLevelMapper.getAllJobLevels();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">addJobLevel</span><span class="hljs-params">(JobLevel jobLevel)</span> </span>&#123;        jobLevel.setCreateDate(<span class="hljs-keyword">new</span> Date());        jobLevel.setEnabled(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> jobLevelMapper.insertSelective(jobLevel);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">updateJobLevelById</span><span class="hljs-params">(JobLevel jobLevel)</span> </span>&#123;        <span class="hljs-keyword">return</span> jobLevelMapper.updateByPrimaryKeySelective(jobLevel);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">deleteJobLevelById</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">return</span> jobLevelMapper.deleteByPrimaryKey(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">deleteJobLevelsByIds</span><span class="hljs-params">(Integer[] ids)</span> </span>&#123;        <span class="hljs-keyword">return</span> jobLevelMapper.deleteJobLevelsByIds(ids);    &#125;&#125;</code></pre></div><p><strong>Mapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JobLevelMapper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(JobLevel record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(JobLevel record)</span></span>;    <span class="hljs-function">JobLevel <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(JobLevel record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(JobLevel record)</span></span>;    <span class="hljs-function">List&lt;Position&gt; <span class="hljs-title">getAllJobLevels</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Integer <span class="hljs-title">deleteJobLevelsByIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> Integer[] ids)</span></span>;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllJobLevels&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  SELECT * FROM joblevel;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteJobLevelsByIds&quot;</span>&gt;</span>  delete from joblevel where id in  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span>    #&#123;id&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span></code></pre></div><h5 id="前后端对接-1"><a href="#前后端对接-1" class="headerlink" title="前后端对接"></a>前后端对接</h5><p>主要对添加，编辑，删除按钮进行设计</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;div&gt;      &lt;el-input size&#x3D;&quot;small&quot; v-model&#x3D;&quot;jl.name&quot; style&#x3D;&quot;width: 300px;&quot; prefix-icon&#x3D;&quot;el-icon-plus&quot;                placeholder&#x3D;&quot;添加职称&quot;&gt;      &lt;&#x2F;el-input&gt;      &lt;el-select v-model&#x3D;&quot;jl.titleLevel&quot; placeholder&#x3D;&quot;职称等级&quot; size&#x3D;&quot;small&quot;                 style&#x3D;&quot;margin-left: 5px;margin-right: 5px&quot;&gt;        &lt;el-option            v-for&#x3D;&quot;item in titleLevels&quot;            :key&#x3D;&quot;item&quot;            :label&#x3D;&quot;item&quot;            :value&#x3D;&quot;item&quot;&gt;        &lt;&#x2F;el-option&gt;      &lt;&#x2F;el-select&gt;      &lt;el-button icon&#x3D;&quot;el-icon-plus&quot; type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot; @click&#x3D;&quot;addJobLevel&quot;&gt;添加&lt;&#x2F;el-button&gt;      &lt;&#x2F;div&gt;    &lt;div style&#x3D;&quot;margin-top: 10px&quot;&gt;      &lt;el-table          :data&#x3D;&quot;jls&quot;          border          size&#x3D;&quot;small&quot;          @selection-change&#x3D;&quot;handleSelectionChange&quot;          style&#x3D;&quot;width: 80%&quot;&gt;        &lt;el-table-column            type&#x3D;&quot;selection&quot;            width&#x3D;&quot;55&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;id&quot;            label&#x3D;&quot;编号&quot;            width&#x3D;&quot;55&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;name&quot;            label&#x3D;&quot;职称名称&quot;            width&#x3D;&quot;150&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;titleLevel&quot;            label&#x3D;&quot;职称级别&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            prop&#x3D;&quot;createDate&quot;            label&#x3D;&quot;创建时间&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            label&#x3D;&quot;是否启用&quot;&gt;          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &lt;el-tag type&#x3D;&quot;success&quot; v-if&#x3D;&quot;scope.row.enabled&quot;&gt;已启用&lt;&#x2F;el-tag&gt;            &lt;el-tag type&#x3D;&quot;info&quot; v-else&gt;未启用&lt;&#x2F;el-tag&gt;          &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column            label&#x3D;&quot;操作&quot;&gt;          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &lt;el-button size&#x3D;&quot;small&quot; @click&#x3D;&quot;showEditView(scope.row)&quot;&gt;编辑&lt;&#x2F;el-button&gt;            &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;danger&quot; @click&#x3D;&quot;deleteHandler(scope.row)&quot;&gt;删除&lt;&#x2F;el-button&gt;          &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;      &lt;&#x2F;el-table&gt;      &lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;small&quot; style&#x3D;&quot;margin-top: 10px&quot; :disabled&#x3D;&quot;multipleSelection.length&#x3D;&#x3D;0&quot;                 @click&#x3D;&quot;deleteMany&quot;&gt;批量删除      &lt;&#x2F;el-button&gt;    &lt;&#x2F;div&gt;    &lt;el-dialog        title&#x3D;&quot;修改职称&quot;        :visible.sync&#x3D;&quot;dialogVisible&quot;        width&#x3D;&quot;30%&quot;&gt;      &lt;div&gt;        &lt;table&gt;          &lt;tr&gt;            &lt;td&gt;              &lt;el-tag&gt;职称名&lt;&#x2F;el-tag&gt;            &lt;&#x2F;td&gt;            &lt;td&gt;              &lt;el-input size&#x3D;&quot;small&quot; v-model&#x3D;&quot;updateJl.name&quot;&gt;&lt;&#x2F;el-input&gt;            &lt;&#x2F;td&gt;          &lt;&#x2F;tr&gt;          &lt;tr&gt;            &lt;td&gt;              &lt;el-tag&gt;职称级别&lt;&#x2F;el-tag&gt;            &lt;&#x2F;td&gt;            &lt;td&gt;              &lt;el-select v-model&#x3D;&quot;updateJl.titleLevel&quot; placeholder&#x3D;&quot;职称等级&quot; size&#x3D;&quot;small&quot;                         style&#x3D;&quot;margin-left: 5px;margin-right: 5px&quot;&gt;                &lt;el-option                    v-for&#x3D;&quot;item in titleLevels&quot;                    :key&#x3D;&quot;item&quot;                    :label&#x3D;&quot;item&quot;                    :value&#x3D;&quot;item&quot;&gt;                &lt;&#x2F;el-option&gt;              &lt;&#x2F;el-select&gt;            &lt;&#x2F;td&gt;          &lt;&#x2F;tr&gt;          &lt;tr&gt;            &lt;td&gt;              &lt;el-tag&gt;是否启用&lt;&#x2F;el-tag&gt;            &lt;&#x2F;td&gt;            &lt;td&gt;              &lt;el-switch                  v-model&#x3D;&quot;updateJl.enabled&quot;                  active-text&#x3D;&quot;启用&quot;                  inactive-text&#x3D;&quot;禁用&quot;&gt;              &lt;&#x2F;el-switch&gt;            &lt;&#x2F;td&gt;          &lt;&#x2F;tr&gt;        &lt;&#x2F;table&gt;      &lt;&#x2F;div&gt;      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;    &lt;el-button size&#x3D;&quot;small&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;    &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;doUpdate&quot;&gt;确 定&lt;&#x2F;el-button&gt;  &lt;&#x2F;span&gt;    &lt;&#x2F;el-dialog&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &quot;JobLevelMana&quot;,  data() &#123;    return &#123;      multipleSelection: [],      dialogVisible: false,      updateJl: &#123;        name: &#39;&#39;,        titleLevel: &#39;&#39;,        enabled: false      &#125;,      jl: &#123;        name: &#39;&#39;,        titleLevel: &#39;&#39;      &#125;,      jls: [],      titleLevels: [        &#39;正高级&#39;,        &#39;副高级&#39;,        &#39;中级&#39;,        &#39;初级&#39;,        &#39;员级&#39;,      ]    &#125;  &#125;,  mounted() &#123;    this.initJls();  &#125;,  methods: &#123;    handleSelectionChange(val) &#123;      this.multipleSelection &#x3D; val;    &#125;,    deleteMany() &#123;      this.$confirm(&#39;此操作将永久删除 &#39; + this.multipleSelection.length + &#39; 条记录, 是否继续?&#39;, &#39;提示&#39;, &#123;        confirmButtonText: &#39;确定&#39;,        cancelButtonText: &#39;取消&#39;,        type: &#39;warning&#39;      &#125;).then(() &#x3D;&gt; &#123;        let ids &#x3D; &#39;?&#39;;        this.multipleSelection.forEach(item &#x3D;&gt; &#123;          ids +&#x3D; &#39;ids&#x3D;&#39; + item.id + &#39;&amp;&#39;;        &#125;)        this.deleteRequest(&quot;&#x2F;system&#x2F;basic&#x2F;joblevel&#x2F;&quot; + ids).then(resp &#x3D;&gt; &#123;          if (resp) &#123;            this.initJls();          &#125;        &#125;)      &#125;).catch(() &#x3D;&gt; &#123;        this.$message(&#123;          type: &#39;info&#39;,          message: &#39;已取消删除&#39;        &#125;);      &#125;);    &#125;,    doUpdate() &#123;      this.putRequest(&quot;&#x2F;system&#x2F;basic&#x2F;joblevel&#x2F;&quot;, this.updateJl).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.initJls();          this.dialogVisible &#x3D; false;        &#125;      &#125;)    &#125;,    showEditView(data) &#123;      Object.assign(this.updateJl, data);      this.dialogVisible &#x3D; true;    &#125;,    deleteHandler(data) &#123;      this.$confirm(&#39;此操作将永久 &#39; + data.name + &#39; 职称, 是否继续?&#39;, &#39;提示&#39;, &#123;        confirmButtonText: &#39;确定&#39;,        cancelButtonText: &#39;取消&#39;,        type: &#39;warning&#39;      &#125;).then(() &#x3D;&gt; &#123;        this.deleteRequest(&quot;&#x2F;system&#x2F;basic&#x2F;joblevel&#x2F;&quot; + data.id).then(resp &#x3D;&gt; &#123;          if (resp) &#123;            this.initJls();          &#125;        &#125;)      &#125;).catch(() &#x3D;&gt; &#123;        this.$message(&#123;          type: &#39;info&#39;,          message: &#39;已取消删除&#39;        &#125;);      &#125;);    &#125;,    addJobLevel() &#123;      if (this.jl.name &amp;&amp; this.jl.titleLevel) &#123;        this.postRequest(&quot;&#x2F;system&#x2F;basic&#x2F;joblevel&#x2F;&quot;, this.jl).then(resp &#x3D;&gt; &#123;          if (resp) &#123;            this.initJls();          &#125;        &#125;);      &#125; else &#123;        this.$message.error(&quot;添加字段不可以为空!&quot;);      &#125;    &#125;,    initJls() &#123;      this.getRequest(&quot;&#x2F;system&#x2F;basic&#x2F;joblevel&#x2F;&quot;).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.jls &#x3D; resp;          this.jl &#x3D; &#123;            name: &#39;&#39;,            titleLevel: &#39;&#39;          &#125;;        &#125;      &#125;)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><h4 id="权限组"><a href="#权限组" class="headerlink" title="权限组"></a>权限组</h4><h5 id="前端部分-2"><a href="#前端部分-2" class="headerlink" title="前端部分"></a>前端部分</h5><p><strong>PermissMana.vue</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;div class&#x3D;&quot;permissManaTool&quot;&gt;      &lt;el-input size&#x3D;&quot;small&quot; placeholder&#x3D;&quot;请输入角色英文名&quot; v-model&#x3D;&quot;role.name&quot;&gt;        &lt;template slot&#x3D;&quot;prepend&quot;&gt;ROLE_&lt;&#x2F;template&gt;      &lt;&#x2F;el-input&gt;      &lt;el-input size&#x3D;&quot;small&quot; placeholder&#x3D;&quot;请输入角色中文名&quot; v-model&#x3D;&quot;role.nameZh&quot;                @keydown.enter.native&#x3D;&quot;doAddRole&quot;&gt;      &lt;&#x2F;el-input&gt;      &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot; icon&#x3D;&quot;el-icon-plus&quot; @click&#x3D;&quot;doAddRole&quot;&gt;添加角色&lt;&#x2F;el-button&gt;    &lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;permissManaMain&quot;&gt;      &lt;el-collapse v-model&#x3D;&quot;activeName&quot; @change&#x3D;&quot;change&quot;&gt;        &lt;el-collapse-item :title&#x3D;&quot;r.nameZh&quot; :name&#x3D;&quot;r.id&quot; v-for&#x3D;&quot;(r,index) in roles&quot; :key&#x3D;&quot;index&quot;&gt;          &lt;el-card class&#x3D;&quot;box-card&quot;&gt;            &lt;div slot&#x3D;&quot;header&quot; class&#x3D;&quot;clearfix&quot;&gt;              &lt;span&gt;可访问的资源&lt;&#x2F;span&gt;              &lt;el-button style&#x3D;&quot;float: right; padding: 3px 0;color: #ff0000;&quot; icon&#x3D;&quot;el-icon-delete&quot;                         type&#x3D;&quot;text&quot; @click&#x3D;&quot;deleteRole(r)&quot;&gt;&lt;&#x2F;el-button&gt;            &lt;&#x2F;div&gt;            &lt;div&gt;              &lt;el-tree                  show-checkbox                  node-key&#x3D;&quot;id&quot;                  ref&#x3D;&quot;tree&quot;                  :key&#x3D;&quot;index&quot;                  :default-checked-keys&#x3D;&quot;selectedMenus&quot;                  :data&#x3D;&quot;allmenus&quot; :props&#x3D;&quot;defaultProps&quot;&gt;              &lt;&#x2F;el-tree&gt;              &lt;div style&#x3D;&quot;display: flex;justify-content: flex-end&quot;&gt;                &lt;el-button size&#x3D;&quot;small&quot; @click&#x3D;&quot;cancelUpdate&quot;&gt;取消修改&lt;&#x2F;el-button&gt;                &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;doUpdate(r.id,index)&quot;&gt;确认修改&lt;&#x2F;el-button&gt;              &lt;&#x2F;div&gt;            &lt;&#x2F;div&gt;          &lt;&#x2F;el-card&gt;        &lt;&#x2F;el-collapse-item&gt;      &lt;&#x2F;el-collapse&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &quot;PermissMana&quot;,  data() &#123;    return &#123;      role: &#123;        name: &#39;&#39;,        nameZh: &#39;&#39;      &#125;,      activeName: -1,      roles: [],      allmenus: [],      selectedMenus: [],      defaultProps: &#123;        children: &#39;children&#39;,        label: &#39;name&#39;      &#125;    &#125;  &#125;,  mounted() &#123;    this.initRoles();  &#125;,  methods: &#123;    initRoles() &#123;      this.getRequest(&quot;&#x2F;system&#x2F;basic&#x2F;permiss&#x2F;&quot;).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.roles &#x3D; resp;        &#125;      &#125;)    &#125;,    change(rid) &#123;      if (rid) &#123;        this.initAllMenus();        this.initSelectedMenus(rid);      &#125;    &#125;,    doUpdate(rid, index) &#123;      let tree &#x3D; this.$refs.tree[index];      let selectedKeys &#x3D; tree.getCheckedKeys(true);      let url &#x3D; &#39;&#x2F;system&#x2F;basic&#x2F;permiss&#x2F;?rid&#x3D;&#39; + rid;      selectedKeys.forEach(key &#x3D;&gt; &#123;        url +&#x3D; &#39;&amp;mids&#x3D;&#39; + key;      &#125;)      this.putRequest(url).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.activeName &#x3D; -1;        &#125;      &#125;)    &#125;,    cancelUpdate() &#123;      this.activeName &#x3D; -1;    &#125;,    initAllMenus() &#123;      this.getRequest(&quot;&#x2F;system&#x2F;basic&#x2F;permiss&#x2F;menus&quot;).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.allmenus &#x3D; resp;        &#125;      &#125;)    &#125;,    initSelectedMenus(rid) &#123;      this.getRequest(&quot;&#x2F;system&#x2F;basic&#x2F;permiss&#x2F;mids&#x2F;&quot; + rid).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.selectedMenus &#x3D; resp;        &#125;      &#125;)    &#125;,    doAddRole() &#123;      if (this.role.name &amp;&amp; this.role.nameZh) &#123;        this.postRequest(&quot;&#x2F;system&#x2F;basic&#x2F;permiss&#x2F;role&quot;, this.role).then(resp &#x3D;&gt; &#123;          if (resp) &#123;            this.role.name &#x3D; &#39;&#39;;            this.role.nameZh &#x3D; &#39;&#39;;            this.initRoles();          &#125;        &#125;)      &#125; else &#123;        this.$message.error(&#39;数据不可以为空&#39;);      &#125;    &#125;,    deleteRole(role) &#123;      this.$confirm(&#39;此操作将永久删除 &#39; + role.nameZh + &#39; 角色, 是否继续?&#39;, &#39;提示&#39;, &#123;        confirmButtonText: &#39;确定&#39;,        cancelButtonText: &#39;取消&#39;,        type: &#39;warning&#39;      &#125;).then(() &#x3D;&gt; &#123;        this.deleteRequest(&quot;&#x2F;system&#x2F;basic&#x2F;permiss&#x2F;role&#x2F;&quot; + role.id).then(resp &#x3D;&gt; &#123;          if (resp) &#123;            this.initRoles();          &#125;        &#125;)      &#125;).catch(() &#x3D;&gt; &#123;        this.$message(&#123;          type: &#39;info&#39;,          message: &#39;已取消删除&#39;        &#125;);      &#125;);    &#125;,  &#125;  &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;.permissManaTool &#123;  display: flex;  justify-content: flex-start;&#125;.permissManaTool .el-input &#123;  width: 300px;  margin-right: 6px;&#125;.permissManaMain &#123;  margin-top: 10px;  width: 700px;&#125;&lt;&#x2F;style&gt;</code></pre></div><h5 id="后端部分-2"><a href="#后端部分-2" class="headerlink" title="后端部分"></a>后端部分</h5><p><strong>测试接口类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/system/basic/permiss&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PermissController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RoleService roleService;    <span class="hljs-meta">@Autowired</span>    MenuService menuService;    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">getAllRoles</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> roleService.getAllRoles();    &#125;    <span class="hljs-meta">@GetMapping(&quot;/menus&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getAllMenus</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> menuService.getAllMenus();    &#125;    <span class="hljs-meta">@GetMapping(&quot;/mids/&#123;rid&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getMidsByRid</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer rid)</span> </span>&#123;        <span class="hljs-keyword">return</span> menuService.getMidsByRid(rid);    &#125;    <span class="hljs-meta">@PutMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateMenuRole</span><span class="hljs-params">(Integer rid, Integer[] mids)</span> </span>&#123;        <span class="hljs-keyword">if</span> (menuService.updateMenuRole(rid, mids)) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);    &#125;    <span class="hljs-meta">@PostMapping(&quot;/role&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">addRole</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Role role)</span> </span>&#123;        <span class="hljs-keyword">if</span> (roleService.addRole(role) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;添加成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;添加失败!&quot;</span>);    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/role/&#123;rid&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deleteRoleById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer rid)</span> </span>&#123;        <span class="hljs-keyword">if</span> (roleService.deleteRoleById(rid) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;删除成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;删除失败!&quot;</span>);    &#125;&#125;</code></pre></div><p>用户绑定菜单的权限，所以定义<strong>MenuService</strong>和<strong>RoleService</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MenuMapper menuMapper;    <span class="hljs-meta">@Autowired</span>    MenuRoleMapper menuRoleMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getMenusByHrId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> menuMapper.getMenusByHrId(((Hr) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).getId());    &#125;    <span class="hljs-comment">//@Cacheable</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getAllMenusWithRole</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> menuMapper.getAllMenusWithRole();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getAllMenus</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> menuMapper.getAllMenus();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getMidsByRid</span><span class="hljs-params">(Integer rid)</span> </span>&#123;        <span class="hljs-keyword">return</span> menuMapper.getMidsByRid(rid);    &#125;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updateMenuRole</span><span class="hljs-params">(Integer rid, Integer[] mids)</span> </span>&#123;        menuRoleMapper.deleteByRid(rid);        <span class="hljs-keyword">if</span> (mids == <span class="hljs-keyword">null</span> || mids.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        Integer result = menuRoleMapper.insertRecord(rid, mids);        <span class="hljs-keyword">return</span> result==mids.length;    &#125;&#125;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RoleMapper roleMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">getAllRoles</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> roleMapper.getAllRoles();    &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">addRole</span><span class="hljs-params">(Role role)</span> </span>&#123;      <span class="hljs-keyword">if</span> (!role.getName().startsWith(<span class="hljs-string">&quot;ROLE_&quot;</span>))&#123;        role.setName(<span class="hljs-string">&quot;ROLE_&quot;</span> + role.getName());      &#125;      <span class="hljs-keyword">return</span> roleMapper.insert(role);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">deleteRoleById</span><span class="hljs-params">(Integer rid)</span> </span>&#123;        <span class="hljs-keyword">return</span> roleMapper.deleteByPrimaryKey(rid);    &#125;&#125;</code></pre></div><p><strong>Menumapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;MenuWithChildren&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Menu&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id1&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name1&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;children&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Menu&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name2&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;children&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Menu&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id3&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name3&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllMenus&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;MenuWithChildren&quot;</span>&gt;</span>    SELECT m1.`id` as id1,m1.`name` as name1,m2.`id` as id2,m2.`name` as name2,m3.`id` as id3,m3.`name` as name3    FROM menu m1,menu m2,menu m3    WHERE m1.`id`=m2.`parentId` AND m2.`id`=m3.`parentId` AND m3.`enabled`=true    ORDER BY m1.`id`,m2.`id`,m3.`id`  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getMidsByRid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span>    select mid from menu_role where rid=#&#123;rid&#125;;  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p><strong>Rolemapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllRoles&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  select * from role;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>由于需要更新每个<strong>Role</strong>的管理权限，所以还要更新<strong>MenuRoleMapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByRid&quot;</span>&gt;</span>  delete from menu_role where rid=#&#123;rid&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertRecord&quot;</span>&gt;</span>insert into menu_role (mid,rid) values<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;mids&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;mid&quot;</span>&gt;</span>(#&#123;mid&#125;,#&#123;rid&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><h4 id="部门管理"><a href="#部门管理" class="headerlink" title="部门管理"></a>部门管理</h4><h5 id="前端部分-3"><a href="#前端部分-3" class="headerlink" title="前端部分"></a>前端部分</h5><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div style&#x3D;&quot;width: 500px;&quot;&gt;    &lt;el-input        placeholder&#x3D;&quot;请输入部门名称进行搜索...&quot;        prefix-icon&#x3D;&quot;el-icon-search&quot;        v-model&#x3D;&quot;filterText&quot;&gt;    &lt;&#x2F;el-input&gt;    &lt;el-tree        style&#x3D;&quot;margin-top: 10px;&quot;        :data&#x3D;&quot;deps&quot;        :props&#x3D;&quot;defaultProps&quot;        :expand-on-click-node&#x3D;&quot;false&quot;        :filter-node-method&#x3D;&quot;filterNode&quot;        ref&#x3D;&quot;tree&quot;&gt;      &lt;span class&#x3D;&quot;custom-tree-node&quot; style&#x3D;&quot;display: flex;justify-content:space-between;width: 100%;&quot;                  slot-scope&#x3D;&quot;&#123; node, data &#125;&quot;&gt;        &lt;span&gt;&#123;&#123;data.name &#125;&#125;&lt;&#x2F;span&gt;        &lt;span&gt;          &lt;el-button              type&#x3D;&quot;primary&quot;              size&#x3D;&quot;small&quot;              class&#x3D;&quot;depBtn&quot;              @click&#x3D;&quot;() &#x3D;&gt; showAddDepView(data)&quot;&gt;            添加部门          &lt;&#x2F;el-button&gt;          &lt;el-button              type&#x3D;&quot;danger&quot;              size&#x3D;&quot;small&quot;              class&#x3D;&quot;depBtn&quot;              @click&#x3D;&quot;() &#x3D;&gt; deleteDep(data)&quot;&gt;            删除部门          &lt;&#x2F;el-button&gt;        &lt;&#x2F;span&gt;      &lt;&#x2F;span&gt;    &lt;&#x2F;el-tree&gt;    &lt;el-dialog        title&#x3D;&quot;添加部门&quot;        :visible.sync&#x3D;&quot;dialogVisible&quot;        width&#x3D;&quot;30%&quot;&gt;      &lt;div&gt;        &lt;table&gt;          &lt;tr&gt;            &lt;td&gt;              &lt;el-tag&gt;上级部门&lt;&#x2F;el-tag&gt;            &lt;&#x2F;td&gt;            &lt;td&gt;&#123;&#123;pname&#125;&#125;&lt;&#x2F;td&gt;          &lt;&#x2F;tr&gt;          &lt;tr&gt;            &lt;td&gt;              &lt;el-tag&gt;部门名称&lt;&#x2F;el-tag&gt;            &lt;&#x2F;td&gt;            &lt;td&gt;              &lt;el-input v-model&#x3D;&quot;dep.name&quot; placeholder&#x3D;&quot;请输入部门名称...&quot;&gt;&lt;&#x2F;el-input&gt;            &lt;&#x2F;td&gt;          &lt;&#x2F;tr&gt;        &lt;&#x2F;table&gt;      &lt;&#x2F;div&gt;      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;    &lt;el-button @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;doAddDep&quot;&gt;确 定&lt;&#x2F;el-button&gt;      &lt;&#x2F;span&gt;  &lt;&#x2F;el-dialog&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &quot;DepMana&quot;,  data() &#123;    return &#123;      filterText: &#39;&#39;,      deps: [],      defaultProps: &#123;        children: &#39;children&#39;,        label: &#39;name&#39;      &#125;,      pname: &#39;&#39;,      dep: &#123;        name: &#39;&#39;,        parentId: -1      &#125;,      dialogVisible: false,    &#125;  &#125;,  watch: &#123;    filterText(val) &#123;      this.$refs.tree.filter(val);    &#125;  &#125;,  mounted() &#123;    this.initDeps();  &#125;,  methods : &#123;    initDeps() &#123;      this.getRequest(&quot;&#x2F;system&#x2F;basic&#x2F;department&#x2F;&quot;).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.deps &#x3D; resp;        &#125;      &#125;)    &#125;,    filterNode(value, data) &#123;      if (!value) return true;      return data.name.indexOf(value) !&#x3D;&#x3D; -1;    &#125;,    showAddDepView(data) &#123;      this.pname &#x3D; data.name;      this.dep.parentId &#x3D; data.id;      this.dialogVisible &#x3D; true;    &#125;,    initDep() &#123;      this.dep &#x3D; &#123;        name: &#39;&#39;,        parentId: -1      &#125;      this.pname &#x3D; &#39;&#39;;    &#125;,    doAddDep() &#123;      this.postRequest(&quot;&#x2F;system&#x2F;basic&#x2F;department&#x2F;&quot;, this.dep).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.addDep2Deps(this.deps, resp.obj);          this.dialogVisible &#x3D; false;          &#x2F;&#x2F;初始化变量          this.initDep();        &#125;      &#125;)    &#125;,    addDep2Deps(deps, dep) &#123;      for (let i &#x3D; 0; i &lt; deps.length; i++) &#123;        let d &#x3D; deps[i];        if (d.id &#x3D;&#x3D; dep.parentId) &#123;          d.children &#x3D; d.children.concat(dep);          if (d.children.length &gt; 0) &#123;            d.parent &#x3D; true;          &#125;          return;        &#125; else &#123;          this.addDep2Deps(d.children, dep);        &#125;      &#125;    &#125;,    deleteDep(data) &#123;      if (data.parent) &#123;        this.$message.error(&quot;父部门删除失败&quot;);      &#125; else &#123;        this.$confirm(&#39;此操作将永久删除 &#39; + data.name + &#39; 部门, 是否继续?&#39;, &#39;提示&#39;, &#123;          confirmButtonText: &#39;确定&#39;,          cancelButtonText: &#39;取消&#39;,          type: &#39;warning&#39;        &#125;).then(() &#x3D;&gt; &#123;          this.deleteRequest(&quot;&#x2F;system&#x2F;basic&#x2F;department&#x2F;&quot;+data.id).then(resp&#x3D;&gt;&#123;            if (resp) &#123;              this.removeDepFromDeps(null,this.deps,data.id);            &#125;          &#125;)        &#125;).catch(() &#x3D;&gt; &#123;          this.$message(&#123;            type: &#39;info&#39;,            message: &#39;已取消删除&#39;          &#125;);        &#125;);      &#125;    &#125;,    removeDepFromDeps(p,deps, id) &#123;      for(let i &#x3D; 0;i &lt; deps.length;i++)&#123;        let d &#x3D; deps[i];        if (d.id &#x3D;&#x3D; id) &#123;          deps.splice(i, 1);          if (deps.length &#x3D;&#x3D; 0) &#123;            p.parent &#x3D; false;          &#125;          return;        &#125;else&#123;          this.removeDepFromDeps(d,d.children, id);        &#125;      &#125;    &#125;,  &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;  .depBtn &#123;    padding: 2px;  &#125;&lt;&#x2F;style&gt;</code></pre></div><h5 id="后端部分-3"><a href="#后端部分-3" class="headerlink" title="后端部分"></a>后端部分</h5><p>因为这部分SQL代码比较多，所以这里使用存储过程，生成添加和删除部门的存储过程</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#添加<span class="hljs-keyword">create</span>    definer <span class="hljs-operator">=</span> root@`<span class="hljs-number">172.16</span><span class="hljs-number">.211</span><span class="hljs-number">.4</span>` <span class="hljs-keyword">procedure</span> addDep(<span class="hljs-keyword">IN</span> depName <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>), <span class="hljs-keyword">IN</span> parentId <span class="hljs-type">int</span>, <span class="hljs-keyword">IN</span> enabled tinyint(<span class="hljs-number">1</span>),                                                   <span class="hljs-keyword">OUT</span> <span class="hljs-keyword">result</span> <span class="hljs-type">int</span>, <span class="hljs-keyword">OUT</span> result2 <span class="hljs-type">int</span>)<span class="hljs-keyword">begin</span>  <span class="hljs-keyword">declare</span> did <span class="hljs-type">int</span>;  <span class="hljs-keyword">declare</span> pDepPath <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>);  <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> department <span class="hljs-keyword">set</span> name<span class="hljs-operator">=</span>depName,parentId<span class="hljs-operator">=</span>parentId,enabled<span class="hljs-operator">=</span>enabled;  <span class="hljs-keyword">select</span> row_count() <span class="hljs-keyword">into</span> <span class="hljs-keyword">result</span>;  <span class="hljs-keyword">select</span> last_insert_id() <span class="hljs-keyword">into</span> did;  <span class="hljs-keyword">set</span> result2<span class="hljs-operator">=</span>did;  <span class="hljs-keyword">select</span> depPath <span class="hljs-keyword">into</span> pDepPath <span class="hljs-keyword">from</span> department <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>parentId;  update department <span class="hljs-keyword">set</span> depPath<span class="hljs-operator">=</span>concat(pDepPath,<span class="hljs-string">&#x27;.&#x27;</span>,did) <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>did;  update department <span class="hljs-keyword">set</span> isParent<span class="hljs-operator">=</span><span class="hljs-literal">true</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>parentId;<span class="hljs-keyword">end</span>;#删除<span class="hljs-keyword">create</span>    definer <span class="hljs-operator">=</span> root@`<span class="hljs-number">172.16</span><span class="hljs-number">.211</span><span class="hljs-number">.4</span>` <span class="hljs-keyword">procedure</span> deleteDep(<span class="hljs-keyword">IN</span> did <span class="hljs-type">int</span>, <span class="hljs-keyword">OUT</span> <span class="hljs-keyword">result</span> <span class="hljs-type">int</span>)<span class="hljs-keyword">begin</span>  <span class="hljs-keyword">declare</span> ecount <span class="hljs-type">int</span>;  <span class="hljs-keyword">declare</span> pid <span class="hljs-type">int</span>;  <span class="hljs-keyword">declare</span> pcount <span class="hljs-type">int</span>;  <span class="hljs-keyword">declare</span> a <span class="hljs-type">int</span>;  <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> a <span class="hljs-keyword">from</span> department <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>did <span class="hljs-keyword">and</span> isParent<span class="hljs-operator">=</span><span class="hljs-literal">false</span>;  if a<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span><span class="hljs-operator">=</span><span class="hljs-number">-2</span>;  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> ecount <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> departmentId<span class="hljs-operator">=</span>did;  if ecount<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span><span class="hljs-operator">=</span><span class="hljs-number">-1</span>;  <span class="hljs-keyword">else</span>  <span class="hljs-keyword">select</span> parentId <span class="hljs-keyword">into</span> pid <span class="hljs-keyword">from</span> department <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>did;  <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> department <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>did <span class="hljs-keyword">and</span> isParent<span class="hljs-operator">=</span><span class="hljs-literal">false</span>;  <span class="hljs-keyword">select</span> row_count() <span class="hljs-keyword">into</span> <span class="hljs-keyword">result</span>;  <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> pcount <span class="hljs-keyword">from</span> department <span class="hljs-keyword">where</span> parentId<span class="hljs-operator">=</span>pid;  if pcount<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">then</span> update department <span class="hljs-keyword">set</span> isParent<span class="hljs-operator">=</span><span class="hljs-literal">false</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>pid;  <span class="hljs-keyword">end</span> if;  <span class="hljs-keyword">end</span> if;  <span class="hljs-keyword">end</span> if;<span class="hljs-keyword">end</span>;</code></pre></div><p>对<strong>Department</strong>实体类进行修改</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer parentId;    <span class="hljs-keyword">private</span> String depPath;    <span class="hljs-keyword">private</span> Boolean enabled;    <span class="hljs-keyword">private</span> Boolean isParent;    <span class="hljs-keyword">private</span> List&lt;Department&gt; children = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">private</span> Integer result;&#125;</code></pre></div><p><strong>Controller</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/system/basic/department&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepartmentController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    DepartmentService departmentService;    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Department&gt; <span class="hljs-title">getAllDepartments</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> departmentService.getAllDepartments();    &#125;    <span class="hljs-comment">//调用存储过程</span>    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">addDep</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Department dep)</span> </span>&#123;        departmentService.addDep(dep);        <span class="hljs-keyword">if</span> (dep.getResult() == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;添加成功&quot;</span>, dep);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;添加失败&quot;</span>);    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deleteDepById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;        Department dep = <span class="hljs-keyword">new</span> Department();        dep.setId(id);        departmentService.deleteDepById(dep);        <span class="hljs-keyword">if</span> (dep.getResult() == -<span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;该部门下有子部门，删除失败&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dep.getResult() == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;该部门下有员工，删除失败&quot;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dep.getResult() == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;删除成功&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;删除失败&quot;</span>);    &#125;&#125;</code></pre></div><p><strong>Service</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepartmentService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    DepartmentMapper departmentMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Department&gt; <span class="hljs-title">getAllDepartments</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> departmentMapper.getAllDepartmentsByParentId(-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addDep</span><span class="hljs-params">(Department dep)</span> </span>&#123;        dep.setEnabled(<span class="hljs-keyword">true</span>);        departmentMapper.addDep(dep);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteDepById</span><span class="hljs-params">(Department dep)</span> </span>&#123;        departmentMapper.deleteDepById(dep);    &#125;&#125;</code></pre></div><p><strong>Mapper接口</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DepartmentMapper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Department record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(Department record)</span></span>;    <span class="hljs-function">Department <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(Department record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(Department record)</span></span>;    <span class="hljs-function">List&lt;Department&gt; <span class="hljs-title">getAllDepartmentsByParentId</span><span class="hljs-params">(Integer pid)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDep</span><span class="hljs-params">(Department dep)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteDepById</span><span class="hljs-params">(Department dep)</span></span>;    <span class="hljs-function">List&lt;Department&gt; <span class="hljs-title">getAllDepartmentsWithOutChildren</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p><strong>Mapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--调用存储过程--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addDep&quot;</span> <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;CALLABLE&quot;</span>&gt;</span>    call addDep(#&#123;name,mode=IN,jdbcType=VARCHAR&#125;,#&#123;parentId,mode=IN,jdbcType=INTEGER&#125;,        #&#123;enabled,mode=IN,jdbcType=BOOLEAN&#125;,#&#123;result,mode=OUT,jdbcType=INTEGER&#125;,#&#123;id,mode=OUT,jdbcType=INTEGER&#125;)  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteDepById&quot;</span> <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;CALLABLE&quot;</span>&gt;</span>    call deleteDep(#&#123;id,mode=IN,jdbcType=INTEGER&#125;,#&#123;result,mode=OUT,jdbcType=INTEGER&#125;)  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h3 id="操作员管理"><a href="#操作员管理" class="headerlink" title="操作员管理"></a>操作员管理</h3><h4 id="前端部分-4"><a href="#前端部分-4" class="headerlink" title="前端部分"></a>前端部分</h4><p>在<strong>SysHr.vue</strong>中完善以下部分</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;div style&#x3D;&quot;margin-top: 10px;display: flex;justify-content: center&quot;&gt;      &lt;el-input v-model&#x3D;&quot;keywords&quot; placeholder&#x3D;&quot;通过用户名搜索用户&quot; prefix-icon&#x3D;&quot;el-icon-search&quot;                style&#x3D;&quot;width: 400px;margin-right: 10px&quot; @keydown.enter.native&#x3D;&quot;doSearch&quot;&gt;&lt;&#x2F;el-input&gt;      &lt;el-button icon&#x3D;&quot;el-icon-search&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;doSearch&quot;&gt;搜索&lt;&#x2F;el-button&gt;    &lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;hr-container&quot;&gt;      &lt;el-card class&#x3D;&quot;hr-card&quot; v-for&#x3D;&quot;(hr,index) in hrs&quot; :key&#x3D;&quot;index&quot;&gt;        &lt;div slot&#x3D;&quot;header&quot; class&#x3D;&quot;clearfix&quot;&gt;          &lt;span&gt;&#123;&#123;hr.name&#125;&#125;&lt;&#x2F;span&gt;          &lt;el-button style&#x3D;&quot;float: right; padding: 3px 0;color: #e30007;&quot; type&#x3D;&quot;text&quot;                     icon&#x3D;&quot;el-icon-delete&quot; @click&#x3D;&quot;deleteHr(hr)&quot;&gt;&lt;&#x2F;el-button&gt;        &lt;&#x2F;div&gt;        &lt;div&gt;          &lt;div class&#x3D;&quot;img-container&quot;&gt;            &lt;img :src&#x3D;&quot;hr.userface&quot; :alt&#x3D;&quot;hr.name&quot; :title&#x3D;&quot;hr.name&quot; class&#x3D;&quot;userface-img&quot;&gt;          &lt;&#x2F;div&gt;          &lt;div class&#x3D;&quot;userinfo-container&quot;&gt;            &lt;div&gt;用户名：&#123;&#123;hr.name&#125;&#125;&lt;&#x2F;div&gt;            &lt;div&gt;手机号码：&#123;&#123;hr.phone&#125;&#125;&lt;&#x2F;div&gt;            &lt;div&gt;电话号码：&#123;&#123;hr.telephone&#125;&#125;&lt;&#x2F;div&gt;            &lt;div&gt;地址：&#123;&#123;hr.address&#125;&#125;&lt;&#x2F;div&gt;            &lt;div&gt;用户状态：              &lt;el-switch                  v-model&#x3D;&quot;hr.enabled&quot;                  active-text&#x3D;&quot;启用&quot;                  @change&#x3D;&quot;enabledChange(hr)&quot;                  active-color&#x3D;&quot;#13ce66&quot;                  inactive-color&#x3D;&quot;#ff4949&quot;                  inactive-text&#x3D;&quot;禁用&quot;&gt;              &lt;&#x2F;el-switch&gt;            &lt;&#x2F;div&gt;            &lt;div&gt;用户角色：              &lt;el-tag type&#x3D;&quot;success&quot; style&#x3D;&quot;margin-right: 6px&quot;                      v-for&#x3D;&quot;(role,indexj) in hr.roles&quot; :key&#x3D;&quot;indexj&quot;&gt;                &#123;&#123;role.nameZh&#125;&#125;              &lt;&#x2F;el-tag&gt;              &lt;el-popover                  placement&#x3D;&quot;right&quot;                  title&#x3D;&quot;角色列表&quot;                  @show&#x3D;&quot;showPop(hr)&quot;                  @hide&#x3D;&quot;hidePop(hr)&quot;                  width&#x3D;&quot;150&quot;                  trigger&#x3D;&quot;click&quot;&gt;                &lt;el-select v-model&#x3D;&quot;selectedRoles&quot; multiple placeholder&#x3D;&quot;请选择&quot;&gt;                  &lt;el-option                      v-for&#x3D;&quot;(r,indexk) in allroles&quot;                      :key&#x3D;&quot;indexk&quot;                      :label&#x3D;&quot;r.nameZh&quot;                      :value&#x3D;&quot;r.id&quot;&gt;                  &lt;&#x2F;el-option&gt;                &lt;&#x2F;el-select&gt;                &lt;el-button slot&#x3D;&quot;reference&quot; icon&#x3D;&quot;el-icon-more&quot; type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;el-button&gt;              &lt;&#x2F;el-popover&gt;            &lt;&#x2F;div&gt;            &lt;div&gt;备注：&#123;&#123;hr.remark&#125;&#125;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;      &lt;&#x2F;el-card&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &quot;SysHr&quot;,  data() &#123;    return &#123;      keywords: &#39;&#39;,      hrs: [],      selectedRoles: [],      allroles: []    &#125;  &#125;,  mounted() &#123;    this.initHrs();  &#125;,  methods: &#123;    initHrs() &#123;      this.getRequest(&quot;&#x2F;system&#x2F;hr&#x2F;?keywords&#x3D;&quot;+this.keywords).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.hrs &#x3D; resp;        &#125;      &#125;)    &#125;,    enabledChange(hr) &#123;      delete hr.roles;      this.putRequest(&quot;&#x2F;system&#x2F;hr&#x2F;&quot;, hr).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.initHrs();        &#125;      &#125;)    &#125;,    showPop(hr) &#123;      this.initAllRoles();      let roles &#x3D; hr.roles;      this.selectedRoles &#x3D; [];      roles.forEach(r &#x3D;&gt; &#123;        this.selectedRoles.push(r.id);      &#125;)    &#125;,    initAllRoles() &#123;      this.getRequest(&quot;&#x2F;system&#x2F;hr&#x2F;roles&quot;).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.allroles &#x3D; resp;        &#125;      &#125;)    &#125;,    hidePop(hr) &#123;      let roles &#x3D; [];      &#x2F;&#x2F;拷贝一份      Object.assign(roles, hr.roles);      let flag &#x3D; false;      if (roles.length !&#x3D; this.selectedRoles.length) &#123;        flag &#x3D; true;      &#125; else &#123;        for (let i &#x3D; 0; i &lt; roles.length; i++) &#123;          let role &#x3D; roles[i];          for (let j &#x3D; 0; j &lt; this.selectedRoles.length; j++) &#123;            let sr &#x3D; this.selectedRoles[j];            if (role.id &#x3D;&#x3D; sr) &#123;              roles.splice(i, 1);              i--;              break;            &#125;          &#125;        &#125;        if (roles.length !&#x3D; 0) &#123;          flag &#x3D; true;        &#125;      &#125;      if (flag) &#123;        let url &#x3D; &#39;&#x2F;system&#x2F;hr&#x2F;role?hrid&#x3D;&#39; + hr.id;        this.selectedRoles.forEach(sr &#x3D;&gt; &#123;          url +&#x3D; &#39;&amp;rids&#x3D;&#39; + sr;        &#125;);        this.putRequest(url).then(resp &#x3D;&gt; &#123;          if (resp) &#123;            this.initHrs();          &#125;        &#125;);      &#125;    &#125;,    doSearch() &#123;      this.initHrs();    &#125;,    deleteHr(hr) &#123;      this.$confirm(&#39;此操作将永久删除 &#39;+hr.name+&#39; , 是否继续?&#39;, &#39;提示&#39;, &#123;        confirmButtonText: &#39;确定&#39;,        cancelButtonText: &#39;取消&#39;,        type: &#39;warning&#39;      &#125;).then(() &#x3D;&gt; &#123;        this.deleteRequest(&quot;&#x2F;system&#x2F;hr&#x2F;&quot;+hr.id).then(resp&#x3D;&gt;&#123;          if (resp) &#123;            this.initHrs();          &#125;        &#125;)      &#125;).catch(() &#x3D;&gt; &#123;        this.$message(&#123;          type: &#39;info&#39;,          message: &#39;已取消删除&#39;        &#125;);      &#125;);    &#125;,  &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;.hr-container &#123;  margin-top: 10px;  display: flex;  flex-wrap: wrap;  justify-content: space-around;&#125;.hr-card &#123;  width: 350px;  margin-bottom: 20px;&#125;.img-container &#123;  width: 100%;  display: flex;  justify-content: center;&#125;.userface-img &#123;  width: 72px;  height: 72px;  border-radius: 72px;&#125;.userinfo-container &#123;  margin-top: 20px;&#125;.userinfo-container div &#123;  font-size: 12px;  color: #409eff;&#125;&lt;&#x2F;style&gt;</code></pre></div><h4 id="后端部分-4"><a href="#后端部分-4" class="headerlink" title="后端部分"></a>后端部分</h4><p><strong>接口设计</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/system/hr&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HrController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HrService hrService;    <span class="hljs-meta">@Autowired</span>    RoleService roleService;    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Hr&gt; <span class="hljs-title">getAllHrs</span><span class="hljs-params">(String keywords)</span> </span>&#123;        <span class="hljs-keyword">return</span> hrService.getAllHrs(keywords);    &#125;    <span class="hljs-meta">@PutMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateHr</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Hr hr)</span> </span>&#123;        <span class="hljs-keyword">if</span> (hrService.updateHr(hr) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/roles&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">getAllRoles</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> roleService.getAllRoles();    &#125;    <span class="hljs-meta">@PutMapping(&quot;/role&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateHrRole</span><span class="hljs-params">(Integer hrid, Integer[] rids)</span> </span>&#123;        <span class="hljs-keyword">if</span> (hrService.updateHrRole(hrid, rids)) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deleteHrById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;        <span class="hljs-keyword">if</span> (hrService.deleteHrById(id) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;删除成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;删除失败!&quot;</span>);    &#125;</code></pre></div><p>继续在<strong>Service</strong>层完善</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HrService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HrMapper hrMapper;    <span class="hljs-meta">@Autowired</span>    HrRoleMapper hrRoleMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        Hr hr = hrMapper.loadUserByUsername(username);        <span class="hljs-keyword">if</span> (hr == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;用户名不存在！&quot;</span>);        &#125;        hr.setRoles(hrMapper.getHrRolesById(hr.getId()));        <span class="hljs-keyword">return</span> hr;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Hr&gt; <span class="hljs-title">getAllHrs</span><span class="hljs-params">(String keywords)</span> </span>&#123;        <span class="hljs-keyword">return</span> hrMapper.getAllHrs(HrUtils.getCurrentHr().getId(),keywords);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">updateHr</span><span class="hljs-params">(Hr hr)</span> </span>&#123;        <span class="hljs-keyword">return</span> hrMapper.updateByPrimaryKeySelective(hr);    &#125;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updateHrRole</span><span class="hljs-params">(Integer hrid, Integer[] rids)</span> </span>&#123;        hrRoleMapper.deleteByHrid(hrid);        <span class="hljs-keyword">return</span> hrRoleMapper.addRole(hrid,rids) == rids.length;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">deleteHrById</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">return</span> hrMapper.deleteByPrimaryKey(id);    &#125;&#125;</code></pre></div><p>在实体类Hr中忽略传入的role的Json</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@JsonIgnore</span><span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;    List&lt;SimpleGrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(roles.size());    <span class="hljs-keyword">for</span> (Role role : roles) &#123;        authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));    &#125;    <span class="hljs-keyword">return</span> authorities;&#125;</code></pre></div><p><strong>HrRoleMapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByHrid&quot;</span>&gt;</span>  delete from hr_role where hrid=#&#123;hrid&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addRole&quot;</span>&gt;</span>  insert into hr_role (hrid,rid) values  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;rids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;rid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span>    (#&#123;hrid&#125;,#&#123;rid&#125;)  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><p><strong>HrMapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;HrWithRoles&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Hr&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roles&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Role&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rnameZh&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;nameZh&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllHrs&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;HrWithRoles&quot;</span>&gt;</span>  SELECT hr.id, hr.name, hr.phone, hr.telephone, hr.address, hr.enabled,  hr.username, hr.password, hr.userface, hr.remark, r.id as rid, r.name as rname, r.nameZh as rnameZh  FROM hr LEFT JOIN hr_role hrr ON hr.id = hrr.hrid  LEFT JOIN role r ON hrr.rid = r.id  WHERE hr.id != #&#123;hrid&#125;  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;keywords!=null&quot;</span>&gt;</span>    and hr.name like concat(&#x27;%&#x27;,#&#123;keywords&#125;,&#x27;%&#x27;)  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  ORDER BY hr.id<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h2 id="员工资料"><a href="#员工资料" class="headerlink" title="员工资料"></a>员工资料</h2><p>此部分代码较多，但实现的功能和上面类似，不再展示</p><p>具体可去<a href="https://github.com/Lucifer2u/x-luciferpro%E4%B8%AD%E7%9A%84%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B">https://github.com/Lucifer2u/x-luciferpro中的版本信息查看</a></p><p><strong>这里补充设计到的新知识点，导入和导出数据到Excel</strong></p><h3 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h3><p>先引入依赖</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>后端代码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/employee/basic&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmpBasicController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/export&quot;)</span>    <span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; exportData() &#123;        List&lt;Employee&gt; list = (List&lt;Employee&gt;) employeeService.getEmployeeByPage(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>).getData();        <span class="hljs-keyword">return</span> POIUtils.employee2Excel(list);    &#125;&#125;</code></pre></div><p><strong>生成Excel的工具类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">POIUtils</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; employee2Excel(List&lt;Employee&gt; list) &#123;        <span class="hljs-comment">//1. 创建一个 Excel 文档</span>        HSSFWorkbook workbook = <span class="hljs-keyword">new</span> HSSFWorkbook();        <span class="hljs-comment">//2. 创建文档摘要</span>        workbook.createInformationProperties();        <span class="hljs-comment">//3. 获取并配置文档信息</span>        DocumentSummaryInformation docInfo = workbook.getDocumentSummaryInformation();        <span class="hljs-comment">//文档类别</span>        docInfo.setCategory(<span class="hljs-string">&quot;员工信息&quot;</span>);        <span class="hljs-comment">//文档管理员</span>        docInfo.setManager(<span class="hljs-string">&quot;lucifer&quot;</span>);        <span class="hljs-comment">//设置公司信息</span>        docInfo.setCompany(<span class="hljs-string">&quot;www.lucifer.org&quot;</span>);        <span class="hljs-comment">//4. 获取文档摘要信息</span>        SummaryInformation summInfo = workbook.getSummaryInformation();        <span class="hljs-comment">//文档标题</span>        summInfo.setTitle(<span class="hljs-string">&quot;员工信息表&quot;</span>);        <span class="hljs-comment">//文档作者</span>        summInfo.setAuthor(<span class="hljs-string">&quot;lucifer&quot;</span>);        <span class="hljs-comment">// 文档备注</span>        summInfo.setComments(<span class="hljs-string">&quot;本文档由 lucifer 提供&quot;</span>);        <span class="hljs-comment">//5. 创建样式</span>        <span class="hljs-comment">//创建标题行的样式</span>        HSSFCellStyle headerStyle = workbook.createCellStyle();        headerStyle.setFillForegroundColor(IndexedColors.YELLOW.index);        headerStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);        <span class="hljs-comment">//设置日期格式</span>        HSSFCellStyle dateCellStyle = workbook.createCellStyle();        dateCellStyle.setDataFormat(HSSFDataFormat.getBuiltinFormat(<span class="hljs-string">&quot;m/d/yy&quot;</span>));        HSSFSheet sheet = workbook.createSheet(<span class="hljs-string">&quot;员工信息表&quot;</span>);        <span class="hljs-comment">//设置列的宽度</span>        sheet.setColumnWidth(<span class="hljs-number">0</span>, <span class="hljs-number">5</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">1</span>, <span class="hljs-number">12</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">2</span>, <span class="hljs-number">10</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">3</span>, <span class="hljs-number">5</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">4</span>, <span class="hljs-number">12</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">5</span>, <span class="hljs-number">20</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">6</span>, <span class="hljs-number">10</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">7</span>, <span class="hljs-number">10</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">8</span>, <span class="hljs-number">16</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">9</span>, <span class="hljs-number">12</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">10</span>, <span class="hljs-number">15</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">11</span>, <span class="hljs-number">20</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">12</span>, <span class="hljs-number">16</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">13</span>, <span class="hljs-number">14</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">14</span>, <span class="hljs-number">14</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">15</span>, <span class="hljs-number">12</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">16</span>, <span class="hljs-number">8</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">17</span>, <span class="hljs-number">20</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">18</span>, <span class="hljs-number">20</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">19</span>, <span class="hljs-number">15</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">20</span>, <span class="hljs-number">8</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">21</span>, <span class="hljs-number">25</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">22</span>, <span class="hljs-number">14</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">23</span>, <span class="hljs-number">15</span> * <span class="hljs-number">256</span>);        sheet.setColumnWidth(<span class="hljs-number">24</span>, <span class="hljs-number">15</span> * <span class="hljs-number">256</span>);        <span class="hljs-comment">//6. 创建标题行</span>        HSSFRow r0 = sheet.createRow(<span class="hljs-number">0</span>);        HSSFCell c0 = r0.createCell(<span class="hljs-number">0</span>);        c0.setCellValue(<span class="hljs-string">&quot;编号&quot;</span>);        c0.setCellStyle(headerStyle);        HSSFCell c1 = r0.createCell(<span class="hljs-number">1</span>);        c1.setCellStyle(headerStyle);        c1.setCellValue(<span class="hljs-string">&quot;姓名&quot;</span>);        HSSFCell c2 = r0.createCell(<span class="hljs-number">2</span>);        c2.setCellStyle(headerStyle);        c2.setCellValue(<span class="hljs-string">&quot;工号&quot;</span>);        HSSFCell c3 = r0.createCell(<span class="hljs-number">3</span>);        c3.setCellStyle(headerStyle);        c3.setCellValue(<span class="hljs-string">&quot;性别&quot;</span>);        HSSFCell c4 = r0.createCell(<span class="hljs-number">4</span>);        c4.setCellStyle(headerStyle);        c4.setCellValue(<span class="hljs-string">&quot;出生日期&quot;</span>);        HSSFCell c5 = r0.createCell(<span class="hljs-number">5</span>);        c5.setCellStyle(headerStyle);        c5.setCellValue(<span class="hljs-string">&quot;身份证号码&quot;</span>);        HSSFCell c6 = r0.createCell(<span class="hljs-number">6</span>);        c6.setCellStyle(headerStyle);        c6.setCellValue(<span class="hljs-string">&quot;婚姻状况&quot;</span>);        HSSFCell c7 = r0.createCell(<span class="hljs-number">7</span>);        c7.setCellStyle(headerStyle);        c7.setCellValue(<span class="hljs-string">&quot;民族&quot;</span>);        HSSFCell c8 = r0.createCell(<span class="hljs-number">8</span>);        c8.setCellStyle(headerStyle);        c8.setCellValue(<span class="hljs-string">&quot;籍贯&quot;</span>);        HSSFCell c9 = r0.createCell(<span class="hljs-number">9</span>);        c9.setCellStyle(headerStyle);        c9.setCellValue(<span class="hljs-string">&quot;政治面貌&quot;</span>);        HSSFCell c10 = r0.createCell(<span class="hljs-number">10</span>);        c10.setCellStyle(headerStyle);        c10.setCellValue(<span class="hljs-string">&quot;电话号码&quot;</span>);        HSSFCell c11 = r0.createCell(<span class="hljs-number">11</span>);        c11.setCellStyle(headerStyle);        c11.setCellValue(<span class="hljs-string">&quot;联系地址&quot;</span>);        HSSFCell c12 = r0.createCell(<span class="hljs-number">12</span>);        c12.setCellStyle(headerStyle);        c12.setCellValue(<span class="hljs-string">&quot;所属部门&quot;</span>);        HSSFCell c13 = r0.createCell(<span class="hljs-number">13</span>);        c13.setCellStyle(headerStyle);        c13.setCellValue(<span class="hljs-string">&quot;职称&quot;</span>);        HSSFCell c14 = r0.createCell(<span class="hljs-number">14</span>);        c14.setCellStyle(headerStyle);        c14.setCellValue(<span class="hljs-string">&quot;职位&quot;</span>);        HSSFCell c15 = r0.createCell(<span class="hljs-number">15</span>);        c15.setCellStyle(headerStyle);        c15.setCellValue(<span class="hljs-string">&quot;聘用形式&quot;</span>);        HSSFCell c16 = r0.createCell(<span class="hljs-number">16</span>);        c16.setCellStyle(headerStyle);        c16.setCellValue(<span class="hljs-string">&quot;最高学历&quot;</span>);        HSSFCell c17 = r0.createCell(<span class="hljs-number">17</span>);        c17.setCellStyle(headerStyle);        c17.setCellValue(<span class="hljs-string">&quot;专业&quot;</span>);        HSSFCell c18 = r0.createCell(<span class="hljs-number">18</span>);        c18.setCellStyle(headerStyle);        c18.setCellValue(<span class="hljs-string">&quot;毕业院校&quot;</span>);        HSSFCell c19 = r0.createCell(<span class="hljs-number">19</span>);        c19.setCellStyle(headerStyle);        c19.setCellValue(<span class="hljs-string">&quot;入职日期&quot;</span>);        HSSFCell c20 = r0.createCell(<span class="hljs-number">20</span>);        c20.setCellStyle(headerStyle);        c20.setCellValue(<span class="hljs-string">&quot;在职状态&quot;</span>);        HSSFCell c21 = r0.createCell(<span class="hljs-number">21</span>);        c21.setCellStyle(headerStyle);        c21.setCellValue(<span class="hljs-string">&quot;邮箱&quot;</span>);        HSSFCell c22 = r0.createCell(<span class="hljs-number">22</span>);        c22.setCellStyle(headerStyle);        c22.setCellValue(<span class="hljs-string">&quot;合同期限(年)&quot;</span>);        HSSFCell c23 = r0.createCell(<span class="hljs-number">23</span>);        c23.setCellStyle(headerStyle);        c23.setCellValue(<span class="hljs-string">&quot;合同起始日期&quot;</span>);        HSSFCell c24 = r0.createCell(<span class="hljs-number">24</span>);        c24.setCellStyle(headerStyle);        c24.setCellValue(<span class="hljs-string">&quot;合同终止日期&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;            Employee emp = list.get(i);            HSSFRow row = sheet.createRow(i + <span class="hljs-number">1</span>);            row.createCell(<span class="hljs-number">0</span>).setCellValue(emp.getId());            row.createCell(<span class="hljs-number">1</span>).setCellValue(emp.getName());            row.createCell(<span class="hljs-number">2</span>).setCellValue(emp.getWorkID());            row.createCell(<span class="hljs-number">3</span>).setCellValue(emp.getGender());            HSSFCell cell4 = row.createCell(<span class="hljs-number">4</span>);            cell4.setCellStyle(dateCellStyle);            cell4.setCellValue(emp.getBirthday());            row.createCell(<span class="hljs-number">5</span>).setCellValue(emp.getIdCard());            row.createCell(<span class="hljs-number">6</span>).setCellValue(emp.getWedlock());            row.createCell(<span class="hljs-number">7</span>).setCellValue(emp.getNation().getName());            row.createCell(<span class="hljs-number">8</span>).setCellValue(emp.getNativePlace());            row.createCell(<span class="hljs-number">9</span>).setCellValue(emp.getPoliticsstatus().getName());            row.createCell(<span class="hljs-number">10</span>).setCellValue(emp.getPhone());            row.createCell(<span class="hljs-number">11</span>).setCellValue(emp.getAddress());            row.createCell(<span class="hljs-number">12</span>).setCellValue(emp.getDepartment().getName());            row.createCell(<span class="hljs-number">13</span>).setCellValue(emp.getJobLevel().getName());            row.createCell(<span class="hljs-number">14</span>).setCellValue(emp.getPosition().getName());            row.createCell(<span class="hljs-number">15</span>).setCellValue(emp.getEngageForm());            row.createCell(<span class="hljs-number">16</span>).setCellValue(emp.getTiptopDegree());            row.createCell(<span class="hljs-number">17</span>).setCellValue(emp.getSpecialty());            row.createCell(<span class="hljs-number">18</span>).setCellValue(emp.getSchool());            HSSFCell cell19 = row.createCell(<span class="hljs-number">19</span>);            cell19.setCellStyle(dateCellStyle);            cell19.setCellValue(emp.getBeginDate());            row.createCell(<span class="hljs-number">20</span>).setCellValue(emp.getWorkState());            row.createCell(<span class="hljs-number">21</span>).setCellValue(emp.getEmail());            row.createCell(<span class="hljs-number">22</span>).setCellValue(emp.getContractTerm());            HSSFCell cell23 = row.createCell(<span class="hljs-number">23</span>);            cell23.setCellStyle(dateCellStyle);            cell23.setCellValue(emp.getBeginContract());            HSSFCell cell24 = row.createCell(<span class="hljs-number">24</span>);            cell24.setCellStyle(dateCellStyle);            cell24.setCellValue(emp.getEndContract());<span class="hljs-comment">/*            HSSFCell cell25 = row.createCell(25);</span><span class="hljs-comment">            cell25.setCellStyle(dateCellStyle);</span><span class="hljs-comment">            cell25.setCellValue(emp.getConversionTime());*/</span>        &#125;        ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();        HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();        <span class="hljs-keyword">try</span> &#123;            headers.setContentDispositionFormData(<span class="hljs-string">&quot;attachment&quot;</span>, <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;员工表.xls&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>), <span class="hljs-string">&quot;ISO-8859-1&quot;</span>));            headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);            workbook.write(baos);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt;(baos.toByteArray(), headers, HttpStatus.CREATED);    &#125;&#125;</code></pre></div><p><strong>前端在EmpBasic.vue填写方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script&gt;export default &#123;  methods: &#123;exportData() &#123;  window.open(&#39;&#x2F;employee&#x2F;basic&#x2F;export&#39;, &#39;_parent&#39;);&#125;  &#125;&lt;&#x2F;script&gt;</code></pre></div><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>定义接口</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/import&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">importData</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    List&lt;Employee&gt; list = POIUtils.excel2Employee(file, nationService.getAllNations(), politicsstatusService.getAllPoliticsstatus(), departmentService.getAllDepartmentsWithOutChildren(), positionService.getAllPositions(), jobLevelService.getAllJobLevels());    <span class="hljs-keyword">if</span> (employeeService.addEmps(list) == list.size()) &#123;        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;上传成功&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;上传失败&quot;</span>);&#125;</code></pre></div><p>后端添加工具类中的代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Excel 解析成员工数据集合</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Employee&gt; <span class="hljs-title">excel2Employee</span><span class="hljs-params">(MultipartFile file, List&lt;Nation&gt; allNations, List&lt;Politicsstatus&gt; allPoliticsstatus, List&lt;Department&gt; allDepartments, List&lt;Position&gt; allPositions, List&lt;JobLevel&gt; allJobLevels)</span> </span>&#123;    List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Employee employee = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//1. 创建一个 workbook 对象</span>        HSSFWorkbook workbook = <span class="hljs-keyword">new</span> HSSFWorkbook(file.getInputStream());        <span class="hljs-comment">//2. 获取 workbook 中表单的数量</span>        <span class="hljs-keyword">int</span> numberOfSheets = workbook.getNumberOfSheets();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numberOfSheets; i++) &#123;            <span class="hljs-comment">//3. 获取表单</span>            HSSFSheet sheet = workbook.getSheetAt(i);            <span class="hljs-comment">//4. 获取表单中的行数</span>            <span class="hljs-keyword">int</span> physicalNumberOfRows = sheet.getPhysicalNumberOfRows();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; physicalNumberOfRows; j++) &#123;                <span class="hljs-comment">//5. 跳过标题行</span>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//跳过标题行</span>                &#125;                <span class="hljs-comment">//6. 获取行</span>                HSSFRow row = sheet.getRow(j);                <span class="hljs-keyword">if</span> (row == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//防止数据中间有空行</span>                &#125;                <span class="hljs-comment">//7. 获取列数</span>                <span class="hljs-keyword">int</span> physicalNumberOfCells = row.getPhysicalNumberOfCells();                employee = <span class="hljs-keyword">new</span> Employee();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; physicalNumberOfCells; k++) &#123;                    HSSFCell cell = row.getCell(k);                    <span class="hljs-keyword">if</span> (cell.getCellType() == CellType.STRING) &#123;                        String cellValue = cell.getStringCellValue();                        <span class="hljs-keyword">switch</span> (k) &#123;                            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                                employee.setName(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                                employee.setWorkID(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                                employee.setGender(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                                employee.setIdCard(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:                                employee.setWedlock(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:                                <span class="hljs-keyword">int</span> nationIndex = allNations.indexOf(<span class="hljs-keyword">new</span> Nation(cellValue));                                employee.setNationId(allNations.get(nationIndex).getId());                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:                                employee.setNativePlace(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:                                <span class="hljs-keyword">int</span> politicstatusIndex = allPoliticsstatus.indexOf(<span class="hljs-keyword">new</span> Politicsstatus(cellValue));                                employee.setPoliticId(allPoliticsstatus.get(politicstatusIndex).getId());                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:                                employee.setPhone(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:                                employee.setAddress(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:                                <span class="hljs-keyword">int</span> departmentIndex = allDepartments.indexOf(<span class="hljs-keyword">new</span> Department(cellValue));                                employee.setDepartmentId(allDepartments.get(departmentIndex).getId());                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:                                <span class="hljs-keyword">int</span> jobLevelIndex = allJobLevels.indexOf(<span class="hljs-keyword">new</span> JobLevel(cellValue));                                employee.setJobLevelId(allJobLevels.get(jobLevelIndex).getId());                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>:                                <span class="hljs-keyword">int</span> positionIndex = allPositions.indexOf(<span class="hljs-keyword">new</span> Position(cellValue));                                employee.setPosId(allPositions.get(positionIndex).getId());                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>:                                employee.setEngageForm(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>:                                employee.setTiptopDegree(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">17</span>:                                employee.setSpecialty(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>:                                employee.setSchool(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>:                                employee.setWorkState(cellValue);                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">21</span>:                                employee.setEmail(cellValue);                                <span class="hljs-keyword">break</span>;                        &#125;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">switch</span> (k) &#123;                            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                                employee.setBirthday(cell.getDateCellValue());                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">19</span>:                                employee.setBeginDate(cell.getDateCellValue());                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">23</span>:                                employee.setBeginContract(cell.getDateCellValue());                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">24</span>:                                employee.setEndContract(cell.getDateCellValue());                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">22</span>:                                employee.setContractTerm(cell.getNumericCellValue());                                <span class="hljs-keyword">break</span>;                            <span class="hljs-keyword">case</span> <span class="hljs-number">25</span>:                                employee.setConversionTime(cell.getDateCellValue());                                <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                &#125;                list.add(employee);            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></div><p>注意：在<code>new Nation(cellValue)</code>里判断<code>nationIndex</code>的时候，重写hashcode和equals，同理于<code>Politicsstatus、Department、JobLevel、Position</code></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//只用name来判断，不使用id（按理来说应该id和name都一致）</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    Nation nation = (Nation) o;    <span class="hljs-keyword">return</span> Objects.equals(name, nation.name);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Objects.hash(name);&#125;</code></pre></div><p><strong>Service</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">addEmps</span><span class="hljs-params">(List&lt;Employee&gt; list)</span> </span>&#123;    <span class="hljs-keyword">return</span> employeeMapper.addEmps(list);&#125;</code></pre></div><p>Mapper代码可以参考插入</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmps&quot;</span>&gt;</span>  insert into employee (name, gender,  birthday, idCard, wedlock, nationId,  nativePlace, politicId, email,  phone, address, departmentId,  jobLevelId, posId, engageForm,  tiptopDegree, specialty, school,  beginDate, workState, workID,  contractTerm, conversionTime, notWorkDate,  beginContract, endContract, workAge  )  values  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span>&gt;</span>    (#&#123;emp.name,jdbcType=VARCHAR&#125;, #&#123;emp.gender,jdbcType=CHAR&#125;,    #&#123;emp.birthday,jdbcType=DATE&#125;, #&#123;emp.idCard,jdbcType=CHAR&#125;, #&#123;emp.wedlock,jdbcType=CHAR&#125;,    #&#123;emp.nationId,jdbcType=INTEGER&#125;,    #&#123;emp.nativePlace,jdbcType=VARCHAR&#125;, #&#123;emp.politicId,jdbcType=INTEGER&#125;, #&#123;emp.email,jdbcType=VARCHAR&#125;,    #&#123;emp.phone,jdbcType=VARCHAR&#125;, #&#123;emp.address,jdbcType=VARCHAR&#125;, #&#123;emp.departmentId,jdbcType=INTEGER&#125;,    #&#123;emp.jobLevelId,jdbcType=INTEGER&#125;, #&#123;emp.posId,jdbcType=INTEGER&#125;, #&#123;emp.engageForm,jdbcType=VARCHAR&#125;,    #&#123;emp.tiptopDegree,jdbcType=CHAR&#125;, #&#123;emp.specialty,jdbcType=VARCHAR&#125;, #&#123;emp.school,jdbcType=VARCHAR&#125;,    #&#123;emp.beginDate,jdbcType=DATE&#125;, #&#123;emp.workState,jdbcType=CHAR&#125;, #&#123;emp.workID,jdbcType=CHAR&#125;,    #&#123;emp.contractTerm,jdbcType=DOUBLE&#125;, #&#123;emp.conversionTime,jdbcType=DATE&#125;, #&#123;emp.notWorkDate,jdbcType=DATE&#125;,    #&#123;emp.beginContract,jdbcType=DATE&#125;, #&#123;emp.endContract,jdbcType=DATE&#125;, #&#123;emp.workAge,jdbcType=INTEGER&#125;    )  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><h3 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h3><h4 id="后端部分-5"><a href="#后端部分-5" class="headerlink" title="后端部分"></a>后端部分</h4><p>针对搜索接口优化，不再简单使用关键词搜索，加入employee，beginDateScope等高级搜索需要用到的信息</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RespPageBean <span class="hljs-title">getEmployeeByPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(defaultValue = &quot;1&quot;)</span>Integer page, <span class="hljs-meta">@RequestParam(defaultValue = &quot;10&quot;)</span>Integer size, Employee employee, Date[] beginDateScope)</span></span>&#123;    <span class="hljs-keyword">return</span> employeeService.getEmployeeByPage(page, size, employee, beginDateScope);&#125;</code></pre></div><p>这里需要注意的是，Date需要转换器才能直接传入，在converter包下定义日期转换器</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String source)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> sdf.parse(source);        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p>Service优化</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RespPageBean <span class="hljs-title">getEmployeeByPage</span><span class="hljs-params">(Integer page, Integer size,  Employee employee, Date[] beginDateScope)</span> </span>&#123;    <span class="hljs-keyword">if</span> (page != <span class="hljs-keyword">null</span> &amp;&amp; size != <span class="hljs-keyword">null</span>) &#123;        page = (page - <span class="hljs-number">1</span>) * size;    &#125;    List&lt;Employee&gt; data = employeeMapper.getEmployeeByPage(page, size, employee, beginDateScope);    Long total = employeeMapper.getTotal(employee, beginDateScope);    RespPageBean bean = <span class="hljs-keyword">new</span> RespPageBean();    bean.setData(data);    bean.setTotal(total);    <span class="hljs-keyword">return</span> bean;&#125;</code></pre></div><p>加入Mapper</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmployeeByPage&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;AllEmployeeInfo&quot;</span>&gt;</span>  select e.*,p.`id` as pid,p.`name` as pname,n.`id` as nid,n.`name` as nname,d.`id` as did,d.`name` as  dname,j.`id` as jid,j.`name` as jname,pos.`id` as posid,pos.`name` as posname from employee e,nation  n,politicsstatus p,department d,joblevel j,position pos where e.`nationId`=n.`id` and e.`politicId`=p.`id` and  e.`departmentId`=d.`id` and e.`jobLevelId`=j.`id` and e.`posId`=pos.`id`  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.name !=null and emp.name!=&#x27;&#x27;&quot;</span>&gt;</span>    and e.name like concat(&#x27;%&#x27;,#&#123;emp.name&#125;,&#x27;%&#x27;)  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.politicId !=null&quot;</span>&gt;</span>    and e.politicId =#&#123;emp.politicId&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.nationId !=null&quot;</span>&gt;</span>    and e.nationId =#&#123;emp.nationId&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.departmentId !=null&quot;</span>&gt;</span>    and e.departmentId =#&#123;emp.departmentId&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.jobLevelId !=null&quot;</span>&gt;</span>    and e.jobLevelId =#&#123;emp.jobLevelId&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.engageForm !=null and emp.engageForm!=&#x27;&#x27;&quot;</span>&gt;</span>    and e.engageForm =#&#123;emp.engageForm&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.posId !=null&quot;</span>&gt;</span>    and e.posId =#&#123;emp.posId&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;beginDateScope !=null&quot;</span>&gt;</span>    and e.beginDate between #&#123;beginDateScope[0]&#125; and #&#123;beginDateScope[1]&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;page !=null and size!=null&quot;</span>&gt;</span>    limit #&#123;page&#125;,#&#123;size&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTotal&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span>    select count(*) from employee e    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp!=null&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.name !=null and emp.name!=&#x27;&#x27;&quot;</span>&gt;</span>          and e.name like concat(&#x27;%&#x27;,#&#123;emp.name&#125;,&#x27;%&#x27;)        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.politicId !=null&quot;</span>&gt;</span>          and e.politicId =#&#123;emp.politicId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.nationId !=null&quot;</span>&gt;</span>          and e.nationId =#&#123;emp.nationId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.jobLevelId !=null&quot;</span>&gt;</span>          and e.jobLevelId =#&#123;emp.jobLevelId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.departmentId !=null&quot;</span>&gt;</span>          and e.departmentId =#&#123;emp.departmentId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.engageForm !=null and emp.engageForm!=&#x27;&#x27;&quot;</span>&gt;</span>          and e.engageForm =#&#123;emp.engageForm&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;emp.posId !=null&quot;</span>&gt;</span>          and e.posId =#&#123;emp.posId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;beginDateScope !=null&quot;</span>&gt;</span>        and e.beginDate between #&#123;beginDateScope[0]&#125; and #&#123;beginDateScope[1]&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h4 id="前端部分-5"><a href="#前端部分-5" class="headerlink" title="前端部分"></a>前端部分</h4><p>在原代码上继续进行添加，加入高级搜索框的编写：</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;transition name&#x3D;&quot;slide-fade&quot;&gt;&lt;div v-show&#x3D;&quot;showAdvanceSearchView&quot;    style&#x3D;&quot;border: 1px solid #409eff;border-radius: 5px;box-sizing: border-box;padding: 5px;margin: 10px 0px;&quot;&gt;  &lt;el-row&gt;    &lt;el-col :span&#x3D;&quot;5&quot;&gt;      政治面貌:      &lt;el-select v-model&#x3D;&quot;searchValue.politicId&quot; placeholder&#x3D;&quot;政治面貌&quot; size&#x3D;&quot;mini&quot;                 style&#x3D;&quot;width: 130px;&quot;&gt;        &lt;el-option            v-for&#x3D;&quot;item in politicsstatus&quot;            :key&#x3D;&quot;item.id&quot;            :label&#x3D;&quot;item.name&quot;            :value&#x3D;&quot;item.id&quot;&gt;        &lt;&#x2F;el-option&gt;      &lt;&#x2F;el-select&gt;    &lt;&#x2F;el-col&gt;    &lt;el-col :span&#x3D;&quot;4&quot;&gt;      民族:      &lt;el-select v-model&#x3D;&quot;searchValue.nationId&quot; placeholder&#x3D;&quot;民族&quot; size&#x3D;&quot;mini&quot;                 style&#x3D;&quot;width: 130px;&quot;&gt;        &lt;el-option            v-for&#x3D;&quot;item in nations&quot;            :key&#x3D;&quot;item.id&quot;            :label&#x3D;&quot;item.name&quot;            :value&#x3D;&quot;item.id&quot;&gt;        &lt;&#x2F;el-option&gt;      &lt;&#x2F;el-select&gt;    &lt;&#x2F;el-col&gt;    &lt;el-col :span&#x3D;&quot;4&quot;&gt;      职位:      &lt;el-select v-model&#x3D;&quot;searchValue.posId&quot; placeholder&#x3D;&quot;职位&quot; size&#x3D;&quot;mini&quot; style&#x3D;&quot;width: 130px;&quot;&gt;        &lt;el-option            v-for&#x3D;&quot;item in positions&quot;            :key&#x3D;&quot;item.id&quot;            :label&#x3D;&quot;item.name&quot;            :value&#x3D;&quot;item.id&quot;&gt;        &lt;&#x2F;el-option&gt;      &lt;&#x2F;el-select&gt;    &lt;&#x2F;el-col&gt;    &lt;el-col :span&#x3D;&quot;4&quot;&gt;      职称:      &lt;el-select v-model&#x3D;&quot;searchValue.jobLevelId&quot; placeholder&#x3D;&quot;职称&quot; size&#x3D;&quot;mini&quot;                 style&#x3D;&quot;width: 130px;&quot;&gt;        &lt;el-option            v-for&#x3D;&quot;item in joblevels&quot;            :key&#x3D;&quot;item.id&quot;            :label&#x3D;&quot;item.name&quot;            :value&#x3D;&quot;item.id&quot;&gt;        &lt;&#x2F;el-option&gt;      &lt;&#x2F;el-select&gt;    &lt;&#x2F;el-col&gt;    &lt;el-col :span&#x3D;&quot;7&quot;&gt;      聘用形式:      &lt;el-radio-group v-model&#x3D;&quot;searchValue.engageForm&quot;&gt;        &lt;el-radio label&#x3D;&quot;劳动合同&quot;&gt;劳动合同&lt;&#x2F;el-radio&gt;        &lt;el-radio label&#x3D;&quot;劳务合同&quot;&gt;劳务合同&lt;&#x2F;el-radio&gt;      &lt;&#x2F;el-radio-group&gt;    &lt;&#x2F;el-col&gt;  &lt;&#x2F;el-row&gt;  &lt;el-row style&#x3D;&quot;margin-top: 10px&quot;&gt;    &lt;el-col :span&#x3D;&quot;5&quot;&gt;      所属部门:      &lt;el-popover          placement&#x3D;&quot;right&quot;          title&#x3D;&quot;请选择部门&quot;          width&#x3D;&quot;200&quot;          trigger&#x3D;&quot;manual&quot;          v-model&#x3D;&quot;popVisible&quot;&gt;        &lt;el-tree default-expand-all :data&#x3D;&quot;allDeps&quot; :props&#x3D;&quot;defaultProps&quot;                 @node-click&#x3D;&quot;searvhViewHandleNodeClick&quot;&gt;&lt;&#x2F;el-tree&gt;        &lt;div slot&#x3D;&quot;reference&quot;             style&#x3D;&quot;width: 130px;display: inline-flex;font-size: 13px;border: 1px solid #dedede;height: 26px;border-radius: 5px;cursor: pointer;align-items: center;padding-left: 8px;box-sizing: border-box;margin-left: 3px&quot;             @click&#x3D;&quot;showDepView&quot;&gt;&#123;&#123;inputDepName&#125;&#125;        &lt;&#x2F;div&gt;      &lt;&#x2F;el-popover&gt;    &lt;&#x2F;el-col&gt;    &lt;el-col :span&#x3D;&quot;10&quot;&gt;      入职日期:      &lt;el-date-picker          v-model&#x3D;&quot;searchValue.beginDateScope&quot;          type&#x3D;&quot;daterange&quot;          size&#x3D;&quot;mini&quot;          unlink-panels          value-format&#x3D;&quot;yyyy-MM-dd&quot;          range-separator&#x3D;&quot;至&quot;          start-placeholder&#x3D;&quot;开始日期&quot;          end-placeholder&#x3D;&quot;结束日期&quot;&gt;      &lt;&#x2F;el-date-picker&gt;    &lt;&#x2F;el-col&gt;    &lt;el-col :span&#x3D;&quot;5&quot; :offset&#x3D;&quot;4&quot;&gt;      &lt;el-button size&#x3D;&quot;mini&quot; @click&#x3D;&quot;showAdvanceSearchView &#x3D; !showAdvanceSearchView&quot;&gt;取消&lt;&#x2F;el-button&gt;      &lt;el-button size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-search&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;initEmps(&#39;advanced&#39;)&quot;&gt;搜索&lt;&#x2F;el-button&gt;      &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; @click&#x3D;&quot;resetForm&quot;&gt;重置&lt;&#x2F;el-button&gt;    &lt;&#x2F;el-col&gt;  &lt;&#x2F;el-row&gt;&lt;&#x2F;div&gt;&lt;&#x2F;transition&gt;&lt;script&gt;  methods: &#123;    searvhViewHandleNodeClick(data) &#123;      this.inputDepName &#x3D; data.name;      this.searchValue.departmentId &#x3D; data.id;      this.popVisible &#x3D; !this.popVisible;    &#125;,&#125;&lt;&#x2F;script&gt;</code></pre></div><p>更多细节的代码见github中的源代码</p><h2 id="模块化改造"><a href="#模块化改造" class="headerlink" title="模块化改造"></a>模块化改造</h2><p>为了方便以后的业务需求，针对原项目进行改造，变成</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210630211157577.png" alt="image-20210630211157577"></p><p>server里存的是目前为止的业务代码，以后会添加邮件模块，和server区分，具体的代码划分见<a href="https://github.com/Lucifer2u/xm-luciferpro">代码</a></p><h2 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h2><p>引入RabbitMQ后启动</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210702154401698.png" alt="image-20210702154401698"></p><p>新建模块</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210702160148393.png" alt="image-20210702160148393"></p><p>引入依赖</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.lucifer<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>luciferpro-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8082</span><span class="hljs-comment">#邮件相关</span><span class="hljs-meta">spring.mail.host</span>=<span class="hljs-string">smtp.qq.com</span><span class="hljs-meta">spring.mail.protocol</span>=<span class="hljs-string">smtp</span><span class="hljs-meta">spring.mail.default-encoding</span>=<span class="hljs-string">UTF-8</span><span class="hljs-meta">spring.mail.password</span>=<span class="hljs-string">cxpuqalzrctubdib</span><span class="hljs-meta">spring.mail.username</span>=<span class="hljs-string">xiaoweliang@qq.com</span><span class="hljs-meta">spring.mail.port</span>=<span class="hljs-string">587</span><span class="hljs-meta">spring.mail.properties.mail.stmp.socketFactory.class</span>=<span class="hljs-string">javax.net.ssl.SSLSocketFactory</span><span class="hljs-meta">spring.mail.properties.mail.debug</span>=<span class="hljs-string">true</span><span class="hljs-comment">#消息中间价</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">172.16.211.4</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span></code></pre></div><p>给员工发送邮件，所以需要序列化</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span></code></pre></div><p>它里面包含的对象，同样也需要序列化</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Nation nation;<span class="hljs-keyword">private</span> Politicsstatus politicsstatus;<span class="hljs-keyword">private</span> Department department;<span class="hljs-keyword">private</span> JobLevel jobLevel;<span class="hljs-keyword">private</span> Position position;</code></pre></div><h3 id="建立模版"><a href="#建立模版" class="headerlink" title="建立模版"></a>建立模版</h3><p>在<code>templates</code>下建立模版</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>入职欢迎邮件<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>欢迎 <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> 加入 Shelby 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>职位<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;posName&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>职称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;joblevelName&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>部门<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;departmentName&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.core.Queue;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailserverApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(MailserverApplication.class, args);    &#125;    <span class="hljs-comment">//引入的队列是rabbitmq的</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;lucifer.mail.welcome&quot;</span>);    &#125;&#125;</code></pre></div><h3 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h3><p>这里用到的包有很多重名的情况，需要注意</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.lucifer.mailserver.receiver;<span class="hljs-keyword">import</span> org.lucifer.vbluciferpro.model.Employee;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.mail.MailProperties;<span class="hljs-keyword">import</span> org.springframework.mail.javamail.JavaMailSender;<span class="hljs-keyword">import</span> org.springframework.mail.javamail.MimeMessageHelper;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.thymeleaf.TemplateEngine;<span class="hljs-keyword">import</span> org.thymeleaf.context.Context;<span class="hljs-keyword">import</span> javax.mail.MessagingException;<span class="hljs-keyword">import</span> javax.mail.internet.MimeMessage;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailReceiver</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(MailReceiver.class);        <span class="hljs-meta">@Autowired</span>    JavaMailSender javaMailSender;    <span class="hljs-meta">@Autowired</span>    MailProperties mailProperties;    <span class="hljs-meta">@Autowired</span>    TemplateEngine templateEngine;    <span class="hljs-meta">@RabbitListener(queues =  &quot;lucifer.mail.welcome&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Employee employee)</span></span>&#123;        <span class="hljs-comment">//收到消息，发送邮件</span>        MimeMessage msg = javaMailSender.createMimeMessage();        MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(msg);        <span class="hljs-keyword">try</span> &#123;            helper.setTo(employee.getEmail());            helper.setFrom(mailProperties.getUsername());            helper.setSubject(<span class="hljs-string">&quot;入职欢迎!&quot;</span>);            helper.setSentDate(<span class="hljs-keyword">new</span> Date());            Context context = <span class="hljs-keyword">new</span> Context();            context.setVariable(<span class="hljs-string">&quot;name&quot;</span>, employee.getName());            context.setVariable(<span class="hljs-string">&quot;posName&quot;</span>, employee.getPosition().getName());            context.setVariable(<span class="hljs-string">&quot;joblevelName&quot;</span>, employee.getJobLevel().getName());            context.setVariable(<span class="hljs-string">&quot;departmentName&quot;</span>, employee.getDepartment().getName());            <span class="hljs-comment">//对应mail.html</span>            String mail = templateEngine.process(<span class="hljs-string">&quot;mail&quot;</span>, context);            helper.setText(mail, <span class="hljs-keyword">true</span>);            javaMailSender.send(msg);        &#125; <span class="hljs-keyword">catch</span> (MessagingException e) &#123;            e.printStackTrace();            <span class="hljs-comment">//发送失败，返回日志</span>            logger.error(<span class="hljs-string">&quot;邮件发送失败：&quot;</span> + e.getMessage());        &#125;    &#125;&#125;</code></pre></div><h3 id="发送执行"><a href="#发送执行" class="headerlink" title="发送执行"></a>发送执行</h3><p>在Service模块中需要用到rabbitmq，所以引入依赖</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>同时web需要连上rabbitmq，所以需要加上配置</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#消息中间价</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">172.16.211.4</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span></code></pre></div><p><strong>Service层</strong>执行具体的操作</p><p>在添加的时候还没有id，想要拿到id，必须主键回填</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">addEmp</span><span class="hljs-params">(Employee employee)</span> </span>&#123;Employee emp = employeeMapper.getEmployeeById(employee.getId());&#125;</code></pre></div><p>首先在<code>EmployeeMapper</code>中针对<code>int insertSelective(Employee record);</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertSelective&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Employee&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span></code></pre></div><p>让id能主键回填，这样在Service就能拿到id了</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> result = employeeMapper.insertSelective(employee);</code></pre></div><p><strong>最终Service代码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">addEmp</span><span class="hljs-params">(Employee employee)</span> </span>&#123;    Date beginContract = employee.getBeginContract();    Date endContract = employee.getEndContract();    <span class="hljs-keyword">double</span> month = (Double.parseDouble(yearFormat.format(endContract)) - Double.parseDouble(yearFormat.format(beginContract))) * <span class="hljs-number">12</span>            + (Double.parseDouble(monthFormat.format(endContract)) - Double.parseDouble(monthFormat.format(beginContract)));    employee.setContractTerm(Double.parseDouble(decimalFormat.format(month / <span class="hljs-number">12</span>)));    <span class="hljs-comment">//邮件发送</span>    <span class="hljs-keyword">int</span> result = employeeMapper.insertSelective(employee);    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">1</span>) &#123;        Employee emp = employeeMapper.getEmployeeById(employee.getId());        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;lucifer.mail.welcome&quot;</span>, emp);    &#125;        <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>相应的Mapper</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmployeeById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;AllEmployeeInfo&quot;</span>&gt;</span>  select e.*,p.`id` as pid,p.`name` as pname,n.`id` as nid,n.`name` as nname,d.`id` as did,d.`name` as  dname,j.`id` as jid,j.`name` as jname,pos.`id` as posid,pos.`name` as posname  from employee e,nation n,politicsstatus p,department d,joblevel j,position pos  where e.`nationId`=n.`id` and e.`politicId`=p.`id` and    e.`departmentId`=d.`id` and e.`jobLevelId`=j.`id` and e.`posId`=pos.`id` and e.`id`=#&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h2 id="薪资管理"><a href="#薪资管理" class="headerlink" title="薪资管理"></a>薪资管理</h2><h3 id="工资套账管理"><a href="#工资套账管理" class="headerlink" title="工资套账管理"></a>工资套账管理</h3><h4 id="后端部分-6"><a href="#后端部分-6" class="headerlink" title="后端部分"></a>后端部分</h4><p>接口</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/salary/sob&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalaryController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SalaryService salaryService;    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Salary&gt; <span class="hljs-title">getAllSalaries</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> salaryService.getAllSalaries();    &#125;    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">addSalary</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Salary salary)</span> </span>&#123;        <span class="hljs-keyword">if</span> (salaryService.addSalary(salary) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;添加成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;添加失败!&quot;</span>);    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deleteSalaryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;        <span class="hljs-keyword">if</span> (salaryService.deleteSalaryById(id) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;删除成功！&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;删除失败！&quot;</span>);    &#125;    <span class="hljs-meta">@PutMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateSalaryById</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Salary salary)</span> </span>&#123;        <span class="hljs-keyword">if</span> (salaryService.updateSalaryById(salary) == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);    &#125;&#125;</code></pre></div><p><strong>Service</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalaryService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SalaryMapper salaryMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Salary&gt; <span class="hljs-title">getAllSalaries</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> salaryMapper.getAllSalaries();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">addSalary</span><span class="hljs-params">(Salary salary)</span> </span>&#123;        salary.setCreateDate(<span class="hljs-keyword">new</span> Date());        <span class="hljs-keyword">return</span> salaryMapper.insertSelective(salary);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">deleteSalaryById</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">return</span> salaryMapper.deleteByPrimaryKey(id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">updateSalaryById</span><span class="hljs-params">(Salary salary)</span> </span>&#123;        <span class="hljs-keyword">return</span> salaryMapper.updateByPrimaryKeySelective(salary);    &#125;&#125;</code></pre></div><p><strong>Mapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllSalaries&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  select  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span>/&gt;</span>  from salary<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h4 id="前端部分-6"><a href="#前端部分-6" class="headerlink" title="前端部分"></a>前端部分</h4><p><strong>SalSob.vue</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;div style&#x3D;&quot;display: flex;justify-content: space-between&quot;&gt;      &lt;el-button icon&#x3D;&quot;el-icon-plus&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;showAddSalaryView&quot;&gt;添加工资账套&lt;&#x2F;el-button&gt;      &lt;el-button icon&#x3D;&quot;el-icon-refresh&quot; type&#x3D;&quot;success&quot; @click&#x3D;&quot;initSalaries&quot;&gt;刷新&lt;&#x2F;el-button&gt;    &lt;&#x2F;div&gt;    &lt;div style&#x3D;&quot;margin-top: 10px&quot;&gt;      &lt;el-table :data&#x3D;&quot;salaries&quot; border stripe&gt;        &lt;el-table-column type&#x3D;&quot;selection&quot; width&#x3D;&quot;55&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column width&#x3D;&quot;120&quot; prop&#x3D;&quot;name&quot; label&#x3D;&quot;账套名称&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column width&#x3D;&quot;70&quot; prop&#x3D;&quot;basicSalary&quot; label&#x3D;&quot;基本工资&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column width&#x3D;&quot;70&quot; prop&#x3D;&quot;trafficSalary&quot; label&#x3D;&quot;交通补助&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column width&#x3D;&quot;70&quot; prop&#x3D;&quot;lunchSalary&quot; label&#x3D;&quot;午餐补助&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column width&#x3D;&quot;70&quot; prop&#x3D;&quot;bonus&quot; label&#x3D;&quot;奖金&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column width&#x3D;&quot;100&quot; prop&#x3D;&quot;createDate&quot; label&#x3D;&quot;启用时间&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;el-table-column label&#x3D;&quot;养老金&quot; align&#x3D;&quot;center&quot;&gt;          &lt;el-table-column width&#x3D;&quot;70&quot; prop&#x3D;&quot;pensionPer&quot; label&#x3D;&quot;比率&quot;&gt;&lt;&#x2F;el-table-column&gt;          &lt;el-table-column width&#x3D;&quot;70&quot; prop&#x3D;&quot;pensionBase&quot; label&#x3D;&quot;基数&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column label&#x3D;&quot;医疗保险&quot; align&#x3D;&quot;center&quot;&gt;          &lt;el-table-column width&#x3D;&quot;70&quot; prop&#x3D;&quot;medicalPer&quot; label&#x3D;&quot;比率&quot;&gt;&lt;&#x2F;el-table-column&gt;          &lt;el-table-column width&#x3D;&quot;70&quot; prop&#x3D;&quot;medicalBase&quot; label&#x3D;&quot;基数&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column label&#x3D;&quot;公积金&quot; align&#x3D;&quot;center&quot;&gt;          &lt;el-table-column width&#x3D;&quot;70&quot; prop&#x3D;&quot;accumulationFundPer&quot; label&#x3D;&quot;比率&quot;&gt;&lt;&#x2F;el-table-column&gt;          &lt;el-table-column width&#x3D;&quot;70&quot; prop&#x3D;&quot;accumulationFundBase&quot; label&#x3D;&quot;基数&quot;&gt;&lt;&#x2F;el-table-column&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column label&#x3D;&quot;操作&quot;&gt;          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &lt;el-button @click&#x3D;&quot;showEditSalaryView(scope.row)&quot;&gt;编辑&lt;&#x2F;el-button&gt;            &lt;el-button type&#x3D;&quot;danger&quot; @click&#x3D;&quot;deleteSalary(scope.row)&quot;&gt;删除&lt;&#x2F;el-button&gt;          &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;      &lt;&#x2F;el-table&gt;    &lt;&#x2F;div&gt;    &lt;el-dialog        :title&#x3D;&quot;dialogTitle&quot;        :visible.sync&#x3D;&quot;dialogVisible&quot;        width&#x3D;&quot;50%&quot;&gt;      &lt;div style&#x3D;&quot;display: flex;justify-content: space-around;align-items: center&quot;&gt;        &lt;el-steps direction&#x3D;&quot;vertical&quot; :active&#x3D;&quot;activeItemIndex&quot;&gt;          &lt;el-step :title&#x3D;&quot;itemName&quot; v-for&#x3D;&quot;(itemName,index) in salaryItemName&quot; :key&#x3D;&quot;index&quot;&gt;&lt;&#x2F;el-step&gt;        &lt;&#x2F;el-steps&gt;        &lt;el-input v-model&#x3D;&quot;salary[title]&quot; :placeholder&#x3D;&quot;&#39;请输入&#39;+salaryItemName[index]+&#39;...&#39;&quot;                  v-for&#x3D;&quot;(value,title,index) in salary&quot;                  :key&#x3D;&quot;index&quot; v-show&#x3D;&quot;activeItemIndex&#x3D;&#x3D;index&quot; style&#x3D;&quot;width: 200px&quot;&gt;        &lt;&#x2F;el-input&gt;      &lt;&#x2F;div&gt;      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;      &lt;el-button @click&#x3D;&quot;cancel&quot;&gt;&#123;&#123;&#39;取消&#39;&#125;&#125;&lt;&#x2F;el-button&gt;    &lt;el-button @click&#x3D;&quot;preStep&quot;&gt;&#123;&#123;&#39;上一步&#39;&#125;&#125;&lt;&#x2F;el-button&gt;    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;nextStep&quot;&gt;&#123;&#123;activeItemIndex&#x3D;&#x3D;10?&#39;完成&#39;:&#39;下一步&#39;&#125;&#125;&lt;&#x2F;el-button&gt;  &lt;&#x2F;span&gt;    &lt;&#x2F;el-dialog&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &quot;SalSob&quot;,  data() &#123;    return &#123;      dialogVisible: false,      dialogTitle: &#39;添加工资账套&#39;,      salaries: [],      activeItemIndex: 0,      salaryItemName: [        &#39;基本工资&#39;,        &#39;交通补助&#39;,        &#39;午餐补助&#39;,        &#39;奖金&#39;,        &#39;养老金比率&#39;,        &#39;养老金基数&#39;,        &#39;医疗保险比率&#39;,        &#39;医疗保险基数&#39;,        &#39;公积金比率&#39;,        &#39;公积金基数&#39;,        &#39;账套名称&#39;      ],      salary: &#123;        basicSalary: 0,        trafficSalary: 0,        lunchSalary: 0,        bonus: 0,        pensionPer: 0,        pensionBase: 0,        medicalPer: 0,        medicalBase: 0,        accumulationFundPer: 0,        accumulationFundBase: 0,        name: &#39;&#39;      &#125;    &#125;  &#125;,  mounted() &#123;    this.initSalaries();  &#125;,  methods: &#123;    initSalaries() &#123;      this.getRequest(&quot;&#x2F;salary&#x2F;sob&#x2F;&quot;).then(resp &#x3D;&gt; &#123;        if (resp) &#123;          this.salaries &#x3D; resp;        &#125;      &#125;)    &#125;,    showAddSalaryView() &#123;      &#x2F;&#x2F;数据初始化      this.salary &#x3D; &#123;        basicSalary: &#39;&#39;,        trafficSalary: &#39;&#39;,        lunchSalary:  &#39;&#39;,        bonus:  &#39;&#39;,        pensionPer:  &#39;&#39;,        pensionBase:  &#39;&#39;,        medicalPer:  &#39;&#39;,        medicalBase:  &#39;&#39;,        accumulationFundPer:  &#39;&#39;,        accumulationFundBase:  &#39;&#39;,        name: &#39;&#39;      &#125;      this.dialogTitle &#x3D; &#39;添加工资账套&#39;;      this.activeItemIndex &#x3D; 0;      this.dialogVisible &#x3D; true;    &#125;,    nextStep() &#123;      if (this.activeItemIndex &#x3D;&#x3D; 10) &#123;        &#x2F;&#x2F;id存在是更新操作，否则是添加操作        if (this.salary.id) &#123;          this.putRequest(&quot;&#x2F;salary&#x2F;sob&#x2F;&quot;, this.salary).then(resp&#x3D;&gt;&#123;            if (resp) &#123;              this.initSalaries();              this.dialogVisible &#x3D; false;            &#125;          &#125;)        &#125; else &#123;          this.postRequest(&quot;&#x2F;salary&#x2F;sob&#x2F;&quot;, this.salary).then(resp &#x3D;&gt; &#123;            if (resp) &#123;              this.initSalaries();              this.dialogVisible &#x3D; false;            &#125;          &#125;);        &#125;        return;      &#125;      this.activeItemIndex++;    &#125;,    cancel() &#123;      &#x2F;&#x2F;关闭对话框      this.dialogVisible &#x3D; false;      return;    &#125;,    preStep() &#123;      if (this.activeItemIndex &#x3D;&#x3D; 0) &#123;        return;      &#125;      this.activeItemIndex--;    &#125;,    deleteSalary(data) &#123;      this.$confirm(&#39;此操作将删除 &#39; + data.name + &#39; 账套，是否继续？&#39;, &#39;提示&#39;, &#123;        cancelButtonText: &#39;取消&#39;,        confirmButtonText: &#39;确定&#39;      &#125;).then(() &#x3D;&gt; &#123;        this.deleteRequest(&quot;&#x2F;salary&#x2F;sob&#x2F;&quot; + data.id).then(resp &#x3D;&gt; &#123;          if (resp) &#123;            this.initSalaries();          &#125;        &#125;)      &#125;).catch(() &#x3D;&gt; &#123;        this.$message.info(&quot;取消删除!&quot;);      &#125;)    &#125;,    showEditSalaryView(data) &#123;      this.dialogTitle &#x3D; &#39;修改工资账套&#39;;      this.dialogVisible &#x3D; true;      this.salary.basicSalary &#x3D; data.basicSalary;      this.salary.trafficSalary &#x3D; data.trafficSalary;      this.salary.lunchSalary &#x3D; data.lunchSalary;      this.salary.bonus &#x3D; data.bonus;      this.salary.pensionPer &#x3D; data.pensionPer;      this.salary.pensionBase &#x3D; data.pensionBase;      this.salary.medicalPer &#x3D; data.medicalPer;      this.salary.medicalBase &#x3D; data.medicalBase;      this.salary.accumulationFundPer &#x3D; data.accumulationFundPer;      this.salary.accumulationFundBase &#x3D; data.accumulationFundBase;      this.salary.name &#x3D; data.name;      this.salary.id &#x3D; data.id;    &#125;,  &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><h3 id="员工工资套账管理"><a href="#员工工资套账管理" class="headerlink" title="员工工资套账管理"></a>员工工资套账管理</h3><h4 id="后端部分-7"><a href="#后端部分-7" class="headerlink" title="后端部分"></a>后端部分</h4><p>在Employee实体类上补充工资属性</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Salary salary;</code></pre></div><p>接口</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/salary/sobcfg&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SobConfigController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    EmployeeService employeeService;    <span class="hljs-meta">@Autowired</span>    SalaryService salaryService;    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespPageBean <span class="hljs-title">getEmployeeByPageWithSalary</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(defaultValue = &quot;1&quot;)</span> Integer page, <span class="hljs-meta">@RequestParam(defaultValue = &quot;10&quot;)</span> Integer size)</span> </span>&#123;        <span class="hljs-keyword">return</span> employeeService.getEmployeeByPageWithSalary(page, size);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/salaries&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Salary&gt; <span class="hljs-title">getAllSalaries</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> salaryService.getAllSalaries();    &#125;    <span class="hljs-meta">@PutMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateEmployeeSalaryById</span><span class="hljs-params">(Integer eid, Integer sid)</span> </span>&#123;        Integer result = employeeService.updateEmployeeSalaryById(eid, sid);        <span class="hljs-comment">// REPLACE INTO 关键词 更新为1，插入为2</span>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">1</span> || result == <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败&quot;</span>);    &#125;&#125;</code></pre></div><p>在原先EmployeeService的基础上补充即可</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RespPageBean <span class="hljs-title">getEmployeeByPageWithSalary</span><span class="hljs-params">(Integer page, Integer size)</span> </span>&#123;    <span class="hljs-keyword">if</span> (page != <span class="hljs-keyword">null</span> &amp;&amp; size != <span class="hljs-keyword">null</span>) &#123;        page = (page - <span class="hljs-number">1</span>) * size;    &#125;    List&lt;Employee&gt; list = employeeMapper.getEmployeeByPageWithSalary(page, size);    RespPageBean respPageBean = <span class="hljs-keyword">new</span> RespPageBean();    respPageBean.setData(list);    respPageBean.setTotal(employeeMapper.getTotal(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>));    <span class="hljs-keyword">return</span> respPageBean;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">updateEmployeeSalaryById</span><span class="hljs-params">(Integer eid, Integer sid)</span> </span>&#123;    <span class="hljs-keyword">return</span> employeeMapper.updateEmployeeSalaryById(eid, sid);&#125;</code></pre></div><p><strong>Mapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;EmployeeWithSalary&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Employee&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;salary&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Salary&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sbasicSalary&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;basicSalary&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sbonus&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;bonus&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;slunchSalary&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;lunchSalary&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;strafficSalary&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;trafficSalary&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sallSalary&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;allSalary&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;spensionBase&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;pensionBase&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;spensionPer&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;pensionPer&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;REAL&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;screateDate&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createDate&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;TIMESTAMP&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;smedicalBase&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;medicalBase&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;smedicalPer&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;medicalPer&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;REAL&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;saccumulationFundBase&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;accumulationFundBase&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;saccumulationFundPer&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;accumulationFundPer&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;REAL&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;department&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.Department&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getEmployeeByPageWithSalary&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;EmployeeWithSalary&quot;</span>&gt;</span>  SELECT e.*,d.`name` AS dname,s.`id` AS sid,s.`accumulationFundBase` AS  saccumulationFundBase,s.`accumulationFundPer` AS saccumulationFundPer,s.`allSalary` AS  sallSalary,s.`basicSalary` AS sbasicSalary,s.`bonus` AS sbonus,s.`createDate` AS screateDate,s.`lunchSalary` AS  slunchSalary,s.`medicalBase` AS smedicalBase,s.`medicalPer` AS smedicalPer,s.`name` AS sname,s.`pensionBase` AS  spensionBase,s.`pensionPer` AS spensionPer,s.`trafficSalary` AS strafficSalary  FROM employee e  LEFT JOIN empsalary es  ON e.`id`=es.`eid`  LEFT JOIN salary s  ON es.`sid`=s.`id`  LEFT JOIN department d  ON e.`departmentId`=d.`id`  order by e.id  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;page !=null and size !=null&quot;</span>&gt;</span>    limit #&#123;page&#125;,#&#123;size&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateEmployeeSalaryById&quot;</span>&gt;</span>  REPLACE INTO empsalary (eid,sid) VALUES(#&#123;eid&#125;,#&#123;sid&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><h2 id="聊天功能"><a href="#聊天功能" class="headerlink" title="聊天功能"></a>聊天功能</h2><h3 id="基本页面搭建"><a href="#基本页面搭建" class="headerlink" title="基本页面搭建"></a>基本页面搭建</h3><p>将<a href="https://github.com/is-liyiwei/vue-Chat-demo">Github上的脚手架</a>引入自己的项目中，首先安装依赖</p><div class="hljs code-wrapper"><pre><code class="hljs shell">npm install sass-loader@7.3.1 --save-devnpm install style-loader --save-devnpm i node-sass@4.14.1 --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ --save-dev</code></pre></div><p>在<code>views/chat</code>下创建<code>FriendChat.vue</code>，在组件<code>components/chat</code>下新建脚手架中的四个组件：<code>card、list、message、usertext</code>，在首页中引入进入聊天的快捷按钮</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;div&gt;  &lt;el-button icon&#x3D;&quot;el-icon-bell&quot; type&#x3D;&quot;text&quot; style&#x3D;&quot;margin-right: 8px;color: #000000;&quot; size&#x3D;&quot;normal&quot; @click&#x3D;&quot;goChat&quot;&gt;Chat&lt;&#x2F;el-button&gt;  &lt;el-dropdown class&#x3D;&quot;userInfo&quot; @command&#x3D;&quot;commandHandler&quot;&gt;                &lt;span class&#x3D;&quot;el-dropdown-link&quot; style&#x3D;&quot;color: #000000;&quot;&gt;                  &#123;&#123;user.name&#125;&#125;&lt;i&gt;&lt;img :src&#x3D;&quot;user.userface&quot; alt&#x3D;&quot;&quot;&gt;&lt;&#x2F;i&gt;                &lt;&#x2F;span&gt;    &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;      &lt;el-dropdown-item command&#x3D;&quot;userinfo&quot;&gt;个人中心&lt;&#x2F;el-dropdown-item&gt;      &lt;el-dropdown-item command&#x3D;&quot;setting&quot;&gt;设置&lt;&#x2F;el-dropdown-item&gt;      &lt;el-dropdown-item command&#x3D;&quot;logout&quot; divided&gt;注销登录&lt;&#x2F;el-dropdown-item&gt;    &lt;&#x2F;el-dropdown-menu&gt;  &lt;&#x2F;el-dropdown&gt;&lt;&#x2F;div&gt;goChat() &#123;this.$router.push(&quot;&#x2F;chat&quot;);&#125;,</code></pre></div><p>完善<code>router</code>，实现跳转</p><div class="hljs code-wrapper"><pre><code class="hljs js">&#123;  path: <span class="hljs-string">&#x27;/home&#x27;</span>,  name: <span class="hljs-string">&#x27;Home&#x27;</span>,  component: Home,  hidden:<span class="hljs-literal">true</span>,children: [    &#123;        path: <span class="hljs-string">&#x27;/chat&#x27;</span>,        name: <span class="hljs-string">&#x27;在线聊天&#x27;</span>,        component: FriendChat,        hidden: <span class="hljs-literal">true</span>    &#125;,]&#125;,</code></pre></div><p>完善<code>store</code>下的<code>index.js</code>文件</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>Vue.use(Vuex)<span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;    state:&#123;        routes:[],        sessions:[&#123;            id:<span class="hljs-number">1</span>,            user:&#123;                name:<span class="hljs-string">&#x27;示例介绍&#x27;</span>,                img:<span class="hljs-string">&#x27;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F842eea2fef4be992c14222abf3df84af576f8d0d21049-YmLxJv_fw658&amp;refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1628337952&amp;t=02ebc923420e56695dadbe2933151ca0&#x27;</span>            &#125;,            messages:[&#123;                content:<span class="hljs-string">&#x27;Hello，这是一个基于Vue + Vuex + Webpack构建的简单chat示例，聊天记录保存在localStorge, 有什么问题可以通过Github Issue问我。&#x27;</span>,                date:now            &#125;,&#123;                content:<span class="hljs-string">&#x27;项目地址(原作者): https://github.com/coffcer/vue-chat&#x27;</span>,                date:now            &#125;,&#123;                content:<span class="hljs-string">&#x27;本项目地址(重构): https://github.com/is-liyiwei&#x27;</span>,                date:now            &#125;]        &#125;,&#123;            id:<span class="hljs-number">2</span>,            user:&#123;                name:<span class="hljs-string">&#x27;webpack&#x27;</span>,                img:<span class="hljs-string">&#x27;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20181113%2F23%2F1542122451-kZaRlqfLyK.jpg&amp;refer=http%3A%2F%2Fimage.biaobaiju.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1628338001&amp;t=8d7e0245528edff2b25393d4573fd6ef&#x27;</span>            &#125;,            messages:[&#123;                content:<span class="hljs-string">&#x27;Hi，我是webpack哦&#x27;</span>,                date:now            &#125;]        &#125;],        currentSessionId:<span class="hljs-number">1</span>,        filterKey:<span class="hljs-string">&#x27;&#x27;</span>    &#125;,    mutations:&#123;        <span class="hljs-function"><span class="hljs-title">initRoutes</span>(<span class="hljs-params">state, data</span>)</span>&#123;            state.routes = data;        &#125;,        changeCurrentSessionId (state,id) &#123;            state.currentSessionId = id;        &#125;,        addMessage (state,msg) &#123;            state.sessions[state.currentSessionId-<span class="hljs-number">1</span>].messages.push(&#123;                content:msg,                date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),                self:<span class="hljs-literal">true</span>            &#125;)        &#125;,        INIT_DATA (state) &#123;            <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;vue-chat-session&#x27;</span>);            <span class="hljs-comment">//console.log(data)</span>            <span class="hljs-keyword">if</span> (data) &#123;                state.sessions = <span class="hljs-built_in">JSON</span>.parse(data);            &#125;        &#125;    &#125;,    actions:&#123;        initData (context) &#123;            context.commit(<span class="hljs-string">&#x27;INIT_DATA&#x27;</span>)        &#125;    &#125;&#125;)store.watch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>&#123;    <span class="hljs-keyword">return</span> state.sessions&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;    <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;vue-chat-session&#x27;</span>, <span class="hljs-built_in">JSON</span>.stringify(val));&#125;, &#123;    deep: <span class="hljs-literal">true</span><span class="hljs-comment">/*这个貌似是开启watch监测的判断,官方说明也比较模糊*/</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;</code></pre></div><h3 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h3><p>在<code>card.vue</code>和<code>message.vue</code>中从数据库读取用户信息和头像地址，不再写死到前端代码中</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;script&gt;data () &#123;    return &#123;      user: JSON.parse(window.sessionStorage.getItem(&quot;user&quot;))    &#125;  &#125;&lt;&#x2F;script&gt;</code></pre></div><p>这样<code>user.userface</code>就可以调用图片，<code>user.name</code>就可以调用用户名称，然后<strong>后端加载数据库内容</strong></p><p><strong>ChatController</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/chat&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HrService hrService;    <span class="hljs-meta">@GetMapping(&quot;/hrs&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Hr&gt; <span class="hljs-title">getAllHrs</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> hrService.getAllHrsExceptCurrentHr();    &#125;&#125;</code></pre></div><p><strong>HrService</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Hr&gt; <span class="hljs-title">getAllHrsExceptCurrentHr</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> hrMapper.getAllHrsExceptCurrentHr(HrUtils.getCurrentHr().getId());&#125;</code></pre></div><p><strong>Mapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllHrsExceptCurrentHr&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>  select * from hr where id !=#&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h3 id="引入WebSocket"><a href="#引入WebSocket" class="headerlink" title="引入WebSocket"></a>引入WebSocket</h3><p><strong>引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSocketMessageBroker</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebSocketMessageBrokerConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerStompEndpoints</span><span class="hljs-params">(StompEndpointRegistry registry)</span> </span>&#123;        registry.addEndpoint(<span class="hljs-string">&quot;/ws/ep&quot;</span>)                <span class="hljs-comment">//允许前端发送</span>                .setAllowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)                .withSockJS();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageBroker</span><span class="hljs-params">(MessageBrokerRegistry registry)</span> </span>&#123;        registry.enableSimpleBroker(<span class="hljs-string">&quot;/queue&quot;</span>);    &#125;&#125;</code></pre></div><p><strong>Controller</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WsController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SimpMessagingTemplate simpMessagingTemplate;    <span class="hljs-meta">@MessageMapping(&quot;/ws/chat&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMsg</span><span class="hljs-params">(Principal principal, ChatMsg chatMsg)</span> </span>&#123;        chatMsg.setFrom(principal.getName());        chatMsg.setDate(<span class="hljs-keyword">new</span> Date());        simpMessagingTemplate.convertAndSendToUser(chatMsg.getTo(), <span class="hljs-string">&quot;/queue/chat&quot;</span>, chatMsg);    &#125;&#125;</code></pre></div><p>实体类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatMsg</span> </span>&#123;    <span class="hljs-keyword">private</span> String from;    <span class="hljs-keyword">private</span> String to;    <span class="hljs-keyword">private</span> String content;    <span class="hljs-keyword">private</span> Date date;    <span class="hljs-keyword">private</span> String fromNickname;&#125;</code></pre></div><h3 id="消息的发送"><a href="#消息的发送" class="headerlink" title="消息的发送"></a>消息的发送</h3><p>在<code>usertext.vue</code>中将输入的内容发送</p><div class="hljs code-wrapper"><pre><code class="hljs js">addMessage (e) &#123; <span class="hljs-keyword">if</span> (e.ctrlKey &amp;&amp; e.keyCode ===<span class="hljs-number">13</span> &amp;&amp; <span class="hljs-built_in">this</span>.content.length) &#123;   <span class="hljs-keyword">let</span> msgObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    msgObj.to = <span class="hljs-built_in">this</span>.currentSession.username;     msgObj.content = <span class="hljs-built_in">this</span>.content;   <span class="hljs-built_in">this</span>.$store.state.stomp.send(<span class="hljs-string">&#x27;ws/chat&#x27;</span>,&#123;&#125;,<span class="hljs-built_in">JSON</span>.stringify(msgObj));  <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;addMessage&#x27;</span>, msgObj);  <span class="hljs-built_in">this</span>.content=<span class="hljs-string">&#x27;&#x27;</span>; &#125;&#125;</code></pre></div><p>在<code>router.js</code>中执行发送</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//消息发送</span>        addMessage (state,msg) &#123;            <span class="hljs-keyword">let</span> mss = state.sessions[state.currentHr.username + <span class="hljs-string">&#x27;#&#x27;</span> + msg.to];            <span class="hljs-keyword">if</span> (!mss) &#123;                <span class="hljs-comment">// 此处消息不能自动刷新，需要用Vue.set</span>                <span class="hljs-comment">// state.sessions[state.currentHr.username+&#x27;#&#x27;+msg.to] = [];</span>            Vue.set(state.sessions, state.currentHr.username + <span class="hljs-string">&#x27;#&#x27;</span> + msg.to, []);            &#125;            state.sessions[state.currentHr.username + <span class="hljs-string">&#x27;#&#x27;</span> + msg.to].push(&#123;                content: msg.content,                date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),                self: !msg.notSelf            &#125;)        &#125;,</code></pre></div><h3 id="消息的接收"><a href="#消息的接收" class="headerlink" title="消息的接收"></a>消息的接收</h3><p>在<code>router.js</code>中接收消息</p><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//消息接收</span><span class="hljs-function"><span class="hljs-title">connect</span>(<span class="hljs-params">context</span>)</span> &#123;  context.state.stomp = Stomp.over(<span class="hljs-keyword">new</span> SockJS(<span class="hljs-string">&#x27;/ws/ep&#x27;</span>));  context.state.stomp.connect(&#123;&#125;, <span class="hljs-function"><span class="hljs-params">success</span> =&gt;</span> &#123;    context.state.stomp.subscribe(<span class="hljs-string">&#x27;/user/queue/chat&#x27;</span>, <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> &#123;      <span class="hljs-keyword">let</span> receiveMsg = <span class="hljs-built_in">JSON</span>.parse(msg.body);      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;receiveMsg&#x27;</span> + receiveMsg);      <span class="hljs-keyword">if</span> (!context.state.currentSession || receiveMsg.from != context.state.currentSession.username) &#123;        Notification.info(&#123;          title: <span class="hljs-string">&#x27;【&#x27;</span> + receiveMsg.fromNickname + <span class="hljs-string">&#x27;】发来一条消息&#x27;</span>,          message: receiveMsg.content.length &gt; <span class="hljs-number">10</span> ? receiveMsg.content.substr(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>) : receiveMsg.content,          position: <span class="hljs-string">&#x27;bottom-right&#x27;</span>        &#125;)        Vue.set(context.state.isDot, context.state.currentHr.username + <span class="hljs-string">&#x27;#&#x27;</span> + receiveMsg.from, <span class="hljs-literal">true</span>);      &#125;      receiveMsg.notSelf = <span class="hljs-literal">true</span>;      receiveMsg.to = receiveMsg.from;      context.commit(<span class="hljs-string">&#x27;addMessage&#x27;</span>, receiveMsg);    &#125;)  &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;  &#125;)&#125;,</code></pre></div><h3 id="消息的展示"><a href="#消息的展示" class="headerlink" title="消息的展示"></a>消息的展示</h3><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div id&#x3D;&quot;message&quot; v-scroll-bottom&#x3D;&quot;sessions&quot;&gt;   &lt;ul v-if&#x3D;&quot;currentSession&quot;&gt;      &lt;li v-for&#x3D;&quot;entry in sessions[user.username+&#39;#&#39;+currentSession.username]&quot;&gt;      &lt;p class&#x3D;&quot;time&quot;&gt;      &lt;span&gt;&#123;&#123;entry.date | time&#125;&#125;&lt;&#x2F;span&gt;     &lt;&#x2F;p&gt;     &lt;div class&#x3D;&quot;main&quot; :class&#x3D;&quot;&#123;self:entry.self&#125;&quot;&gt;          &lt;img class&#x3D;&quot;avatar&quot; :src&#x3D;&quot;entry.self ? user.userface : currentSession.userface&quot; alt&#x3D;&quot;&quot;&gt;          &lt;p class&#x3D;&quot;text&quot;&gt;&#123;&#123;entry.content&#125;&#125;&lt;&#x2F;p&gt;     &lt;&#x2F;div&gt;    &lt;&#x2F;li&gt;   &lt;&#x2F;ul&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></div><h1 id="八、补充内容"><a href="#八、补充内容" class="headerlink" title="八、补充内容"></a>八、补充内容</h1><h2 id="登录生成验证码"><a href="#登录生成验证码" class="headerlink" title="登录生成验证码"></a>登录生成验证码</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><h4 id="生成验证码"><a href="#生成验证码" class="headerlink" title="生成验证码"></a>生成验证码</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerificationCode</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width = <span class="hljs-number">100</span>;<span class="hljs-comment">// 生成验证码图片的宽度</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height = <span class="hljs-number">30</span>;<span class="hljs-comment">// 生成验证码图片的高度</span>   <span class="hljs-keyword">private</span> String[] fontNames = &#123; <span class="hljs-string">&quot;宋体&quot;</span>, <span class="hljs-string">&quot;楷体&quot;</span>, <span class="hljs-string">&quot;隶书&quot;</span>, <span class="hljs-string">&quot;微软雅黑&quot;</span> &#125;;   <span class="hljs-keyword">private</span> Color bgColor = <span class="hljs-keyword">new</span> Color(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<span class="hljs-comment">// 定义验证码图片的背景颜色为白色</span>   <span class="hljs-keyword">private</span> Random random = <span class="hljs-keyword">new</span> Random();   <span class="hljs-keyword">private</span> String codes = <span class="hljs-string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;   <span class="hljs-keyword">private</span> String text;<span class="hljs-comment">// 记录随机字符串</span>   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 获取一个随意颜色</span><span class="hljs-comment">    * </span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> Color <span class="hljs-title">randomColor</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> red = random.nextInt(<span class="hljs-number">150</span>);      <span class="hljs-keyword">int</span> green = random.nextInt(<span class="hljs-number">150</span>);      <span class="hljs-keyword">int</span> blue = random.nextInt(<span class="hljs-number">150</span>);      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Color(red, green, blue);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 获取一个随机字体</span><span class="hljs-comment">    * </span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> Font <span class="hljs-title">randomFont</span><span class="hljs-params">()</span> </span>&#123;      String name = fontNames[random.nextInt(fontNames.length)];      <span class="hljs-keyword">int</span> style = random.nextInt(<span class="hljs-number">4</span>);      <span class="hljs-keyword">int</span> size = random.nextInt(<span class="hljs-number">5</span>) + <span class="hljs-number">24</span>;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Font(name, style, size);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 获取一个随机字符</span><span class="hljs-comment">    * </span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> <span class="hljs-title">randomChar</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> codes.charAt(random.nextInt(codes.length()));   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 创建一个空白的BufferedImage对象</span><span class="hljs-comment">    * </span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> BufferedImage <span class="hljs-title">createImage</span><span class="hljs-params">()</span> </span>&#123;      BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);      Graphics2D g2 = (Graphics2D) image.getGraphics();      g2.setColor(bgColor);<span class="hljs-comment">// 设置验证码图片的背景颜色</span>      g2.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);      <span class="hljs-keyword">return</span> image;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> BufferedImage <span class="hljs-title">getImage</span><span class="hljs-params">()</span> </span>&#123;      BufferedImage image = createImage();      Graphics2D g2 = (Graphics2D) image.getGraphics();      StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;         String s = randomChar() + <span class="hljs-string">&quot;&quot;</span>;         sb.append(s);         g2.setColor(randomColor());         g2.setFont(randomFont());         <span class="hljs-keyword">float</span> x = i * width * <span class="hljs-number">1.0f</span> / <span class="hljs-number">4</span>;         g2.drawString(s, x, height - <span class="hljs-number">8</span>);      &#125;      <span class="hljs-keyword">this</span>.text = sb.toString();      drawLine(image);      <span class="hljs-keyword">return</span> image;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 绘制干扰线</span><span class="hljs-comment">    * </span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> image</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(BufferedImage image)</span> </span>&#123;      Graphics2D g2 = (Graphics2D) image.getGraphics();      <span class="hljs-keyword">int</span> num = <span class="hljs-number">5</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;         <span class="hljs-keyword">int</span> x1 = random.nextInt(width);         <span class="hljs-keyword">int</span> y1 = random.nextInt(height);         <span class="hljs-keyword">int</span> x2 = random.nextInt(width);         <span class="hljs-keyword">int</span> y2 = random.nextInt(height);         g2.setColor(randomColor());         g2.setStroke(<span class="hljs-keyword">new</span> BasicStroke(<span class="hljs-number">1.5f</span>));         g2.drawLine(x1, y1, x2, y2);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getText</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> text;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(BufferedImage image, OutputStream out)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      ImageIO.write(image, <span class="hljs-string">&quot;JPEG&quot;</span>, out);   &#125;&#125;</code></pre></div><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/verifyCode&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyCode</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    VerificationCode code = <span class="hljs-keyword">new</span> VerificationCode();    BufferedImage image = code.getImage();    String text = code.getText();    HttpSession session = request.getSession(<span class="hljs-keyword">true</span>);    session.setAttribute(<span class="hljs-string">&quot;verify_code&quot;</span>, text);    VerificationCode.output(image,resp.getOutputStream());&#125;</code></pre></div><h4 id="Security不拦截"><a href="#Security不拦截" class="headerlink" title="Security不拦截"></a>Security不拦截</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//防止访问登录页面死循环，不用进入Security拦截</span>    web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/img/**&quot;</span>, <span class="hljs-string">&quot;/fonts/**&quot;</span>, <span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;/verifyCode&quot;</span>);&#125;</code></pre></div><h4 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h4><p>登录前需要先校验验证码，所以需要自定义过滤器</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SessionRegistry sessionRegistry;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-keyword">if</span> (!request.getMethod().equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(                    <span class="hljs-string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());        &#125;        String verify_code = (String) request.getSession().getAttribute(<span class="hljs-string">&quot;verify_code&quot;</span>);        <span class="hljs-keyword">if</span> (request.getContentType().contains(MediaType.APPLICATION_JSON_VALUE) || request.getContentType().contains(MediaType.APPLICATION_JSON_UTF8_VALUE)) &#123;            Map&lt;String, String&gt; loginData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            <span class="hljs-keyword">try</span> &#123;                loginData = <span class="hljs-keyword">new</span> ObjectMapper().readValue(request.getInputStream(), Map.class);            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            &#125;<span class="hljs-keyword">finally</span> &#123;                String code = loginData.get(<span class="hljs-string">&quot;code&quot;</span>);                checkCode(response, code, verify_code);            &#125;            String username = loginData.get(getUsernameParameter());            String password = loginData.get(getPasswordParameter());            <span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;                username = <span class="hljs-string">&quot;&quot;</span>;            &#125;            <span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;                password = <span class="hljs-string">&quot;&quot;</span>;            &#125;            username = username.trim();            UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(                    username, password);            setDetails(request, authRequest);            Hr principal = <span class="hljs-keyword">new</span> Hr();            principal.setUsername(username);            sessionRegistry.registerNewSession(request.getSession(<span class="hljs-keyword">true</span>).getId(), principal);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);        &#125; <span class="hljs-keyword">else</span> &#123;            checkCode(response, request.getParameter(<span class="hljs-string">&quot;code&quot;</span>), verify_code);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.attemptAuthentication(request, response);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkCode</span><span class="hljs-params">(HttpServletResponse resp, String code, String verify_code)</span> </span>&#123;        <span class="hljs-keyword">if</span> (code == <span class="hljs-keyword">null</span> || verify_code == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(code) || !verify_code.toLowerCase().equals(code.toLowerCase())) &#123;            <span class="hljs-comment">//验证码不正确</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">&quot;验证码不正确&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>同时需要更改一下SecurityConfig，这里通过一个过滤器，同时检验用户名，密码和验证码</p><div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        LoginFilter loginFilter = <span class="hljs-keyword">new</span> LoginFilter();        loginFilter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;                    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                    PrintWriter out = response.getWriter();                    Hr hr = (Hr) authentication.getPrincipal();                    hr.setPassword(<span class="hljs-keyword">null</span>);                    RespBean ok = RespBean.ok(<span class="hljs-string">&quot;登录成功!&quot;</span>, hr);                    String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok);                    out.write(s);                    out.flush();                    out.close();                &#125;        );        loginFilter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;                    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                    PrintWriter out = response.getWriter();                    RespBean respBean = RespBean.error(exception.getMessage());                    <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> LockedException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;账户被锁定，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;密码过期，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;账户过期，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> DisabledException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;账户被禁用，请联系管理员!&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;                        respBean.setMsg(<span class="hljs-string">&quot;用户名或者密码输入错误，请重新输入!&quot;</span>);                    &#125;                    out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));                    out.flush();                    out.close();                &#125;        );        loginFilter.setAuthenticationManager(authenticationManagerBean());        loginFilter.setFilterProcessesUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>);        ConcurrentSessionControlAuthenticationStrategy sessionStrategy = <span class="hljs-keyword">new</span> ConcurrentSessionControlAuthenticationStrategy(sessionRegistry());        sessionStrategy.setMaximumSessions(<span class="hljs-number">1</span>);        loginFilter.setSessionAuthenticationStrategy(sessionStrategy);        <span class="hljs-keyword">return</span> loginFilter;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">SessionRegistryImpl <span class="hljs-title">sessionRegistry</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SessionRegistryImpl();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;                        object.setAccessDecisionManager(customUrlDecisionManager);                        object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);                        <span class="hljs-keyword">return</span> object;                    &#125;                &#125;)                .and()                .logout()                .logoutSuccessHandler((req, resp, authentication) -&gt; &#123;                            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                            PrintWriter out = resp.getWriter();                            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.ok(<span class="hljs-string">&quot;注销成功!&quot;</span>)));                            out.flush();                            out.close();                        &#125;                )                .permitAll()                .and()                .csrf().disable().exceptionHandling()                <span class="hljs-comment">//没有认证时，在这里处理结果，不要重定向</span>                .authenticationEntryPoint((req, resp, authException) -&gt; &#123;                            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                            resp.setStatus(<span class="hljs-number">401</span>);                            PrintWriter out = resp.getWriter();                            RespBean respBean = RespBean.error(<span class="hljs-string">&quot;访问失败!&quot;</span>);                            <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;                                respBean.setMsg(<span class="hljs-string">&quot;请求失败，请联系管理员!&quot;</span>);                            &#125;                            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));                            out.flush();                            out.close();                        &#125;                );        http.addFilterAt(<span class="hljs-keyword">new</span> ConcurrentSessionFilter(sessionRegistry(), event -&gt; &#123;            HttpServletResponse resp = event.getResponse();            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);            resp.setStatus(<span class="hljs-number">401</span>);            PrintWriter out = resp.getWriter();            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.error(<span class="hljs-string">&quot;您已在另一台设备登录，本次登录已下线!&quot;</span>)));            out.flush();            out.close();        &#125;), ConcurrentSessionFilter.class);        http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);    &#125;&#125;</code></pre></div><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端直接展示即可</p><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;el-form-item prop&#x3D;&quot;code&quot;&gt;  &lt;el-input size&#x3D;&quot;normal&quot; type&#x3D;&quot;text&quot; v-model&#x3D;&quot;loginForm.code&quot; auto-complete&#x3D;&quot;off&quot;            placeholder&#x3D;&quot;点击图片更换验证码&quot; @keydown.enter.native&#x3D;&quot;submitLogin&quot; style&#x3D;&quot;width: 250px&quot;&gt;&lt;&#x2F;el-input&gt;  &lt;img :src&#x3D;&quot;vcUrl&quot; @click&#x3D;&quot;updateVerifyCode&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;cursor: pointer;&quot;&gt;&lt;&#x2F;el-form-item&gt;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs js">methods:&#123;  <span class="hljs-function"><span class="hljs-title">updateVerifyCode</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.vcUrl = <span class="hljs-string">&#x27;/verifyCode?time=&#x27;</span>+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();  &#125;&#125;</code></pre></div><h2 id="文件上传FastDFS"><a href="#文件上传FastDFS" class="headerlink" title="文件上传FastDFS"></a>文件上传FastDFS</h2><p>安装过程略，先说明一下安全的问题</p><p>现在，任何人都可以访问我们服务器上传文件，这肯定是不行的，这个问题好解决，加一个上传时候的令牌即可。</p><p>首先我们在服务端开启令牌校验：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>fdfs/http.conf</code></pre></div><p><a href="http://img.itboyhub.com/2020/03/fastdfs-6.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/fastdfs-6.png" alt="img"></a></p><p>配置完成后，记得重启服务端：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./nginx</span> -s stop<span class="hljs-string">./nginx</span></code></pre></div><p>接下来，在前端准备一个获取令牌的方法，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">int</span> ts = (<span class="hljs-keyword">int</span>) Instant.now().getEpochSecond();    String token = ProtoCommon.getToken(<span class="hljs-string">&quot;M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png&quot;</span>, ts, <span class="hljs-string">&quot;FastDFS1234567890&quot;</span>);    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();  sb.append(<span class="hljs-string">&quot;http:172.16.211.4&quot;</span>)      .append(<span class="hljs-string">&quot;group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png&quot;</span>)    sb.append(<span class="hljs-string">&quot;?token=&quot;</span>).append(token);    sb.append(<span class="hljs-string">&quot;&amp;ts=&quot;</span>).append(ts);    System.out.println(sb.toString());&#125;</code></pre></div><p>这里，我们主要是根据 ProtoCommon.getToken 方法来获取令牌，注意这个方法的第一个参数是你要访问的文件 id，<strong>注意，这个地址里边不包含 group，千万别搞错了；</strong>第二个参数是时间戳，第三个参数是密钥，密钥要和服务端的配置一致。将生成的字符串拼接，追加到访问路径后面，如：<code>http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png?token=7e329cc50307000283a3ad3592bb6d32&amp;ts=1582975854</code>。<strong>此时访问路径里边如果没有令牌，会访问失败。</strong></p><h2 id="个人中心"><a href="#个人中心" class="headerlink" title="个人中心"></a>个人中心</h2><h3 id="如何获取用户信息"><a href="#如何获取用户信息" class="headerlink" title="如何获取用户信息"></a>如何获取用户信息</h3><p>在Spring Security中提供了Authentication，可以直接在Controller中直接注入就可以使用</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/hr/info&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Hr <span class="hljs-title">getCurrentHr</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;    <span class="hljs-keyword">return</span> ((Hr) authentication.getPrincipal());&#125;</code></pre></div><h3 id="如何修改用户信息"><a href="#如何修改用户信息" class="headerlink" title="如何修改用户信息"></a>如何修改用户信息</h3><p>相当于重新构建一个Authentication实例放到Context中去</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping(&quot;/hr/info&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateHr</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Hr hr, Authentication authentication)</span> </span>&#123;    <span class="hljs-keyword">if</span> (hrService.updateHr(hr) == <span class="hljs-number">1</span>) &#123;        SecurityContextHolder.getContext().setAuthentication(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(hr, authentication.getCredentials(), authentication.getAuthorities()));        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);&#125;</code></pre></div><p>又分为修改用户的基础信息，不需要重新登录，修改密码后需要重新登录，先定义接口</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/hr/info&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Hr <span class="hljs-title">getCurrentHr</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;    <span class="hljs-keyword">return</span> ((Hr) authentication.getPrincipal());&#125;<span class="hljs-meta">@PutMapping(&quot;/hr/info&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateHr</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Hr hr, Authentication authentication)</span> </span>&#123;    <span class="hljs-keyword">if</span> (hrService.updateHr(hr) == <span class="hljs-number">1</span>) &#123;        SecurityContextHolder.getContext().setAuthentication(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(hr, authentication.getCredentials(), authentication.getAuthorities()));        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);&#125;<span class="hljs-meta">@PutMapping(&quot;/hr/pass&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateHrPasswd</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Map&lt;String, Object&gt; info)</span> </span>&#123;    String oldpass = (String) info.get(<span class="hljs-string">&quot;oldpass&quot;</span>);    String pass = (String) info.get(<span class="hljs-string">&quot;pass&quot;</span>);    Integer hrid = (Integer) info.get(<span class="hljs-string">&quot;hrid&quot;</span>);    <span class="hljs-keyword">if</span> (hrService.updateHrPasswd(oldpass, pass, hrid)) &#123;        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);&#125;</code></pre></div><p><strong>Service</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updateHrPasswd</span><span class="hljs-params">(String oldpass, String pass, Integer hrid)</span> </span>&#123;    Hr hr = hrMapper.selectByPrimaryKey(hrid);    BCryptPasswordEncoder encoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    <span class="hljs-keyword">if</span> (encoder.matches(oldpass, hr.getPassword())) &#123;        String encodePass = encoder.encode(pass);        Integer result = hrMapper.updatePasswd(hrid, encodePass);        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><p><strong>Mapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updatePasswd&quot;</span>&gt;</span>  update hr set password = #&#123;encodePass&#125; where id=#&#123;hrid&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></div><h3 id="上传头像（FastDFS）"><a href="#上传头像（FastDFS）" class="headerlink" title="上传头像（FastDFS）"></a>上传头像（FastDFS）</h3><p><strong>开启FastDFS（Tracker Server、Storage Server、Nginx）</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start/usr/bin/fdfs_storaged /etc/fdfs/storage.conf start/usr/local/nginx/sbin/.nginx</code></pre></div><p><strong>添加依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.oschina.zcx7878<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastdfs-client-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.27.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>配置文件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">## application.properties</span><span class="hljs-meta">fastdfs.nginx.host</span> = <span class="hljs-string">http://172.16.211.4/</span><span class="hljs-comment">## fastdfs-client.properties</span><span class="hljs-meta">fastdfs.connect_timeout_in_seconds</span> = <span class="hljs-string">5</span><span class="hljs-meta">fastdfs.network_timeout_in_seconds</span> = <span class="hljs-string">30</span><span class="hljs-meta">fastdfs.charset</span> = <span class="hljs-string">UTF-8</span><span class="hljs-meta">fastdfs.http_anti_steal_token</span> = <span class="hljs-string">false</span><span class="hljs-meta">fastdfs.http_secret_key</span> = <span class="hljs-string">lucifer1234567890</span><span class="hljs-meta">fastdfs.http_tracker_http_port</span> = <span class="hljs-string">80</span><span class="hljs-meta">fastdfs.tracker_servers</span> = <span class="hljs-string">172.16.211.4:22122</span><span class="hljs-comment">## Whether to open the connection pool, if not, create a new connection every time</span><span class="hljs-meta">fastdfs.connection_pool.enabled</span> = <span class="hljs-string">true</span><span class="hljs-comment">## max_count_per_entry: max connection count per host:port , 0 is not limit</span><span class="hljs-meta">fastdfs.connection_pool.max_count_per_entry</span> = <span class="hljs-string">500</span><span class="hljs-comment">## connections whose the idle time exceeds this time will be closed, unit: second, default value is 3600</span><span class="hljs-meta">fastdfs.connection_pool.max_idle_time</span> = <span class="hljs-string">3600</span><span class="hljs-comment">## Maximum waiting time when the maximum number of connections is reached, unit: millisecond, default value is 1000</span><span class="hljs-meta">fastdfs.connection_pool.max_wait_time_in_ms</span> = <span class="hljs-string">1000</span></code></pre></div><p><strong>工具类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastDFSUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StorageClient1 client1;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            ClientGlobal.initByProperties(<span class="hljs-string">&quot;fastdfs-client.properties&quot;</span>);            TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();            TrackerServer trackerServer = trackerClient.getConnection();            client1 = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, <span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (MyException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile file)</span> </span>&#123;        String oldName = file.getOriginalFilename();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> client1.upload_file1(file.getBytes(), oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>), <span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (MyException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p><strong>Controller</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/hr/userface&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateHrUserface</span><span class="hljs-params">(MultipartFile file, Integer id,Authentication authentication)</span> </span>&#123;    String fileId = FastDFSUtils.upload(file);    String url = nginxHost + fileId;    <span class="hljs-keyword">if</span> (hrService.updateUserface(url, id) == <span class="hljs-number">1</span>) &#123;        Hr hr = (Hr) authentication.getPrincipal();        hr.setUserface(url);        SecurityContextHolder.getContext().setAuthentication(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(hr, authentication.getCredentials(), authentication.getAuthorities()));        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">&quot;更新成功!&quot;</span>, url);    &#125;    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;更新失败!&quot;</span>);&#125;</code></pre></div><p><strong>Service</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">updateUserface</span><span class="hljs-params">(String url, Integer id)</span> </span>&#123;    <span class="hljs-keyword">return</span> hrMapper.updateUserface(url, id);&#125;</code></pre></div><p><strong>Mapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUserface&quot;</span>&gt;</span>  update hr set userface = #&#123;url&#125; where id=#&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></div><h2 id="RabbitMQ保证邮箱发送的可靠性"><a href="#RabbitMQ保证邮箱发送的可靠性" class="headerlink" title="RabbitMQ保证邮箱发送的可靠性"></a>RabbitMQ保证邮箱发送的可靠性</h2><h3 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h3><p>生成表记录消息发送的日志</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210714152747045.png" alt="image-20210714152747045"></p><p>生成对应实体类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSendLog</span> </span>&#123;    <span class="hljs-keyword">private</span> String msgId;    <span class="hljs-keyword">private</span> Integer empId;    <span class="hljs-comment">//0 消息投递中   1 投递成功   2投递失败</span>    <span class="hljs-keyword">private</span> Integer status;    <span class="hljs-comment">//RabbbitMQ相关</span>    <span class="hljs-keyword">private</span> String routeKey;    <span class="hljs-keyword">private</span> String exchange;    <span class="hljs-comment">//发送失败重试次数</span>    <span class="hljs-keyword">private</span> Integer count;    <span class="hljs-comment">//发送失败重试时间</span>    <span class="hljs-keyword">private</span> Date tryTime;    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-keyword">private</span> Date updateTime;&#125;</code></pre></div><p>最开始使用的是SpringBoot提供的RabbitTemplate直接发送消息</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>RabbitTemplate rabbitTemplate;</code></pre></div><p>这里自己配置RabbitConfig，不再使用系统提供的</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitConfig</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(RabbitConfig.class);    <span class="hljs-meta">@Autowired</span>    CachingConnectionFactory cachingConnectionFactory;    <span class="hljs-meta">@Autowired</span>    MailSendLogService mailSendLogService;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">RabbitTemplate <span class="hljs-title">rabbitTemplate</span><span class="hljs-params">()</span> </span>&#123;        RabbitTemplate rabbitTemplate = <span class="hljs-keyword">new</span> RabbitTemplate(cachingConnectionFactory);        rabbitTemplate.setConfirmCallback((data, ack, cause) -&gt; &#123;            String msgId = data.getId();            <span class="hljs-keyword">if</span> (ack) &#123;                logger.info(msgId + <span class="hljs-string">&quot;:消息发送成功&quot;</span>);                mailSendLogService.updateMailSendLogStatus(msgId, <span class="hljs-number">1</span>);<span class="hljs-comment">//修改数据库中的记录，消息投递成功</span>            &#125; <span class="hljs-keyword">else</span> &#123;                logger.info(msgId + <span class="hljs-string">&quot;:消息发送失败&quot;</span>);            &#125;        &#125;);        rabbitTemplate.setReturnCallback((msg, repCode, repText, exchange, routingkey) -&gt; &#123;            logger.info(<span class="hljs-string">&quot;消息发送失败&quot;</span>);        &#125;);        <span class="hljs-keyword">return</span> rabbitTemplate;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">mailQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(MailConstants.MAIL_QUEUE_NAME, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">DirectExchange <span class="hljs-title">mailExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(MailConstants.MAIL_EXCHANGE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">mailBinding</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(mailQueue()).to(mailExchange()).with(MailConstants.MAIL_ROUTING_KEY_NAME);    &#125;&#125;</code></pre></div><p>定义的消息常量实体类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailConstants</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer DELIVERING = <span class="hljs-number">0</span>;<span class="hljs-comment">//消息投递中</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer SUCCESS = <span class="hljs-number">1</span>;<span class="hljs-comment">//消息投递成功</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer FAILURE = <span class="hljs-number">2</span>;<span class="hljs-comment">//消息投递失败</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer MAX_TRY_COUNT = <span class="hljs-number">3</span>;<span class="hljs-comment">//最大重试次数</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer MSG_TIMEOUT = <span class="hljs-number">1</span>;<span class="hljs-comment">//消息超时时间</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAIL_QUEUE_NAME = <span class="hljs-string">&quot;lucifer.mail.queue&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAIL_EXCHANGE_NAME = <span class="hljs-string">&quot;lucifer.mail.exchange&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAIL_ROUTING_KEY_NAME = <span class="hljs-string">&quot;lucifer.mail.routing.key&quot;</span>;&#125;</code></pre></div><p>对应Service</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSendLogService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MailSendLogMapper mailSendLogMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">updateMailSendLogStatus</span><span class="hljs-params">(String msgId, Integer status)</span> </span>&#123;        <span class="hljs-keyword">return</span> mailSendLogMapper.updateMailSendLogStatus(msgId, status);    &#125;&#125;</code></pre></div><p><strong>Mapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateMailSendLogStatus&quot;</span>&gt;</span>    update mail_send_log set status = #&#123;status&#125; where msgId=#&#123;msgId&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></div><p>此时针对<strong>EmployeeService</strong>需要进行一定的改造，在添加员工发送邮件的时候，利用自己的配置来进行</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">addEmp</span><span class="hljs-params">(Employee employee)</span> </span>&#123;        Date beginContract = employee.getBeginContract();        Date endContract = employee.getEndContract();        <span class="hljs-keyword">double</span> month = (Double.parseDouble(yearFormat.format(endContract)) - Double.parseDouble(yearFormat.format(beginContract))) * <span class="hljs-number">12</span>                + (Double.parseDouble(monthFormat.format(endContract)) - Double.parseDouble(monthFormat.format(beginContract)));        employee.setContractTerm(Double.parseDouble(decimalFormat.format(month / <span class="hljs-number">12</span>)));        <span class="hljs-comment">//邮件发送</span>        <span class="hljs-keyword">int</span> result = employeeMapper.insertSelective(employee);        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">1</span>) &#123;            Employee emp = employeeMapper.getEmployeeById(employee.getId());            <span class="hljs-comment">//生成消息的唯一id</span>            String msgId = UUID.randomUUID().toString();            MailSendLog mailSendLog = <span class="hljs-keyword">new</span> MailSendLog();            mailSendLog.setMsgId(msgId);            mailSendLog.setCreateTime(<span class="hljs-keyword">new</span> Date());            mailSendLog.setExchange(MailConstants.MAIL_EXCHANGE_NAME);            mailSendLog.setRouteKey(MailConstants.MAIL_ROUTING_KEY_NAME);            mailSendLog.setEmpId(emp.getId());            mailSendLog.setTryTime(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * MailConstants.MSG_TIMEOUT));            mailSendLogService.insert(mailSendLog);<span class="hljs-comment">//            rabbitTemplate.convertAndSend(&quot;lucifer.mail.welcome&quot;, emp);</span>            rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME, MailConstants.MAIL_ROUTING_KEY_NAME, emp, <span class="hljs-keyword">new</span> CorrelationData(msgId));        &#125;            <span class="hljs-keyword">return</span> result;    &#125;</code></pre></div><p>添加Service方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">insert</span><span class="hljs-params">(MailSendLog mailSendLog)</span> </span>&#123;    <span class="hljs-keyword">return</span> mailSendLogMapper.insert(mailSendLog);&#125;</code></pre></div><p>Mapper，数据库记录每个消息发送的状态</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.MailSendLog&quot;</span>&gt;</span>    insert into mail_send_log (msgId,empId,routeKey,exchange,tryTime,createTime) values (#&#123;msgId&#125;,#&#123;empId&#125;,#&#123;routeKey&#125;,#&#123;exchange&#125;,#&#123;tryTime&#125;,#&#123;createTime&#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><p>最后需要更改<code>MailReceiver</code>和<code>MailserverApplication</code>中的</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = MailConstants.MAIL_QUEUE_NAME)</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(MailConstants.MAIL_QUEUE_NAME);    &#125;</code></pre></div><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>当消息发送失败的时候，需要检测是否需要定时重发，首先在Service里定义task</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSendTask</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MailSendLogService mailSendLogService;    <span class="hljs-meta">@Autowired</span>    RabbitTemplate rabbitTemplate;    <span class="hljs-meta">@Autowired</span>    EmployeeService employeeService;    <span class="hljs-comment">//每隔10s执行一次</span>    <span class="hljs-meta">@Scheduled(cron = &quot;0/10 * * * * ?&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailResendTask</span><span class="hljs-params">()</span> </span>&#123;        List&lt;MailSendLog&gt; logs = mailSendLogService.getMailSendLogsByStatus();        <span class="hljs-keyword">if</span> (logs == <span class="hljs-keyword">null</span> || logs.size() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        logs.forEach(mailSendLog-&gt;&#123;            <span class="hljs-keyword">if</span> (mailSendLog.getCount() &gt;= <span class="hljs-number">3</span>) &#123;                mailSendLogService.updateMailSendLogStatus(mailSendLog.getMsgId(), <span class="hljs-number">2</span>);<span class="hljs-comment">//直接设置该条消息发送失败</span>            &#125;<span class="hljs-keyword">else</span>&#123;                mailSendLogService.updateCount(mailSendLog.getMsgId(), <span class="hljs-keyword">new</span> Date());                Employee emp = employeeService.getEmployeeById(mailSendLog.getEmpId());                rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME, MailConstants.MAIL_ROUTING_KEY_NAME, emp, <span class="hljs-keyword">new</span> CorrelationData(mailSendLog.getMsgId()));            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>需要注意的是，需要在启动类上加上注解<code>@EnableScheduling</code></p><p>添加对应Service方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;MailSendLog&gt; <span class="hljs-title">getMailSendLogsByStatus</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> mailSendLogMapper.getMailSendLogsByStatus();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">updateCount</span><span class="hljs-params">(String msgId, Date date)</span> </span>&#123;    <span class="hljs-keyword">return</span> mailSendLogMapper.updateCount(msgId,date);&#125;</code></pre></div><p>Mapper</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getMailSendLogsByStatus&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.lucifer.vbluciferpro.model.MailSendLog&quot;</span>&gt;</span>    # 尝试的时间小于当前时间，需要重新处理    select * from mail_send_log where status=0 and tryTime <span class="hljs-symbol">&amp;lt;</span> sysdate()<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateCount&quot;</span>&gt;</span>    update mail_send_log set count=count+1,updateTime=#&#123;date&#125; where msgId=#&#123;msgId&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></div><p>在配置文件中配置回调</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#开启confirms回调</span><span class="hljs-comment">#spring.rabbitmq.publisher-confirms=true</span><span class="hljs-comment">#开启returnedMessage回调</span><span class="hljs-comment">#spring.rabbitmq.publisher-returns=true</span><span class="hljs-comment">#新版springboot需要这样配置</span><span class="hljs-meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="hljs-string">correlated</span></code></pre></div><blockquote><p>spring.rabbitmq.publisher-confirm在springboot2.2.0.RELEASE版本之前是amqp正式支持的属性，用来配置消息发送到交换器之后是否触发回调方法，在2.2.0及之后使用spring.rabbitmq.publisher-confirm-type属性配置代替，用来配置更多的确认类型；</p><p>其中：</p><ul><li>NONE值是禁用发布确认模式，是默认值</li><li>CORRELATED值是发布消息成功到交换器后会触发回调方法</li><li>SIMPLE值经测试有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果返回false则会关闭channel，则接下来无法发送消息到broker;</li></ul></blockquote><h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><p>利用Redis，当有多个相同的消息发送的时候，只被消费一次，不产生重复消费，因为每个消息有唯一id，每次把id存到redis中去，然后查这个消息是否被消费过，如果被消费过，就不再重复消费</p><p><strong>首先在mail模块添加依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>配置redis</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#开启手动确认</span><span class="hljs-meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="hljs-string">manual</span><span class="hljs-comment">#redis</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">172.16.211.4</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span></code></pre></div><blockquote><p>注意，redis需要开启远程访问</p></blockquote><p>每次需要手动确认消息，更改消息接收类</p><p>主要是利用<code>channel.basicAck</code>和<code>channel.basicNack</code>来确认是否被消费过</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailReceiver</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(MailReceiver.class);    <span class="hljs-meta">@Autowired</span>    JavaMailSender javaMailSender;    <span class="hljs-meta">@Autowired</span>    MailProperties mailProperties;    <span class="hljs-meta">@Autowired</span>    TemplateEngine templateEngine;    <span class="hljs-meta">@Autowired</span>    StringRedisTemplate redisTemplate;    <span class="hljs-meta">@RabbitListener(queues =  MailConstants.MAIL_QUEUE_NAME)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//利用redis完成消息消费</span>        Employee employee = (Employee) message.getPayload();        MessageHeaders headers = message.getHeaders();        Long tag = (Long) headers.get(AmqpHeaders.DELIVERY_TAG);        String msgId = (String) headers.get(<span class="hljs-string">&quot;spring_returned_message_correlation&quot;</span>);        <span class="hljs-keyword">if</span> (redisTemplate.opsForHash().entries(<span class="hljs-string">&quot;mail_log&quot;</span>).containsKey(msgId)) &#123;            <span class="hljs-comment">//redis 中包含该 key，说明该消息已经被消费过</span>            logger.info(msgId + <span class="hljs-string">&quot;:消息已经被消费&quot;</span>);            channel.basicAck(tag, <span class="hljs-keyword">false</span>);<span class="hljs-comment">//确认消息已消费</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//收到消息，发送邮件</span>        MimeMessage msg = javaMailSender.createMimeMessage();        MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(msg);        <span class="hljs-keyword">try</span> &#123;            helper.setTo(employee.getEmail());            helper.setFrom(mailProperties.getUsername());            helper.setSubject(<span class="hljs-string">&quot;入职欢迎!&quot;</span>);            helper.setSentDate(<span class="hljs-keyword">new</span> Date());            Context context = <span class="hljs-keyword">new</span> Context();            context.setVariable(<span class="hljs-string">&quot;name&quot;</span>, employee.getName());            context.setVariable(<span class="hljs-string">&quot;posName&quot;</span>, employee.getPosition().getName());            context.setVariable(<span class="hljs-string">&quot;joblevelName&quot;</span>, employee.getJobLevel().getName());            context.setVariable(<span class="hljs-string">&quot;departmentName&quot;</span>, employee.getDepartment().getName());            <span class="hljs-comment">//对应mail.html</span>            String mail = templateEngine.process(<span class="hljs-string">&quot;mail&quot;</span>, context);            helper.setText(mail, <span class="hljs-keyword">true</span>);            javaMailSender.send(msg);            redisTemplate.opsForHash().put(<span class="hljs-string">&quot;mail_log&quot;</span>, msgId, <span class="hljs-string">&quot;lucifer&quot;</span>);            channel.basicAck(tag, <span class="hljs-keyword">false</span>);            logger.info(msgId + <span class="hljs-string">&quot;:邮件发送成功&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (MessagingException e) &#123;            channel.basicNack(tag, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);            e.printStackTrace();            <span class="hljs-comment">//发送失败，返回日志</span>            logger.error(<span class="hljs-string">&quot;邮件发送失败：&quot;</span> + e.getMessage());        &#125;    &#125;&#125;</code></pre></div><h2 id="Spring-Cache缓存菜单"><a href="#Spring-Cache缓存菜单" class="headerlink" title="Spring Cache缓存菜单"></a>Spring Cache缓存菜单</h2><p>在Spring Boot中，使用Redis缓存，既可以使用RedisTemplate自己来实现，也可以使用使用这种方式，这种方式是Spring Cache提供的统一接口，实现既可以是Redis，也可以是Ehcache或者其他支持这种规范的缓存框架。从这个角度来说，Spring Cache和Redis、Ehcache的关系就像JDBC与各种数据库驱动的关系。</p><p><strong>在web模块中引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>配置文件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#开启redis+cache缓存</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">172.16.211.4</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span><span class="hljs-meta">spring.cache.cache-names</span>=<span class="hljs-string">menus_cache</span></code></pre></div><p><strong>启动类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableCaching</span><span class="hljs-meta">@MapperScan(basePackages=&quot;org.lucifer.vbluciferpro.mapper&quot;)</span><span class="hljs-meta">@EnableScheduling</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuciferproWebApplication</span> </span>&#123;</code></pre></div><p>EnableCaching注解里</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210716171759970.png" alt="image-20210716171759970"></p><p>默认使用JDK代理，如果设为true，将使用cglaib</p><p><strong>引入Service</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@CacheConfig(cacheNames = &quot;menus_cache&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuService</span> </span>&#123;    <span class="hljs-meta">@Cacheable</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getAllMenusWithRole</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> menuMapper.getAllMenusWithRole();  &#125;   &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring Security</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>MyBatis</tag>
      
      <tag>MySQL</tag>
      
      <tag>WebSocket</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot合集</title>
    <link href="/2021/08/05/SpringBoot/"/>
    <url>/2021/08/05/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><blockquote><p>本文整理了SpingBoot整合主流开发模块的知识，参考来自<a href="http://www.javaboy.org/">松哥系列博客</a>，供学习</p></blockquote><h1 id="SpringBoot基础配置"><a href="#SpringBoot基础配置" class="headerlink" title="SpringBoot基础配置"></a>SpringBoot基础配置</h1><h2 id="1-Maven"><a href="#1-Maven" class="headerlink" title="1. Maven"></a>1. Maven</h2><p>我们刚开始学习 JavaWeb 的时候，使用 Servlet/JSP 做开发，一个接口搞一个 Servlet ，很头大，后来我们通过隐藏域或者反射等方式，可以减少 Servlet 的创建，但是依然不方便，再后来，我们引入 Struts2/SpringMVC 这一类的框架，来简化我们的开发 ，和 Servlet/JSP 相比，引入框架之后，生产力确实提高了不少，但是用久了，又发现了新的问题，即配置繁琐易出错，要做一个新项目，先搭建环境，环境搭建来搭建去，就是那几行配置，不同的项目，可能就是包不同，其他大部分的配置都是一样的，Java 总是被人诟病配置繁琐代码量巨大，这就是其中一个表现。那么怎么办？Spring Boot 应运而生，Spring Boot 主要提供了如下功能：</p><ul><li>为所有基于 Spring 的 Java 开发提供方便快捷的入门体验。</li><li>开箱即用，有自己自定义的配置就是用自己的，没有就使用官方提供的默认的。</li><li>提供了一系列通用的非功能性的功能，例如嵌入式服务器、安全管理、健康检测等。</li><li>绝对没有代码生成，也不需要XML配置。</li></ul><blockquote><p>在创建SpringBoot项目时，如果官方的<a href="https://start.spring.io无法访问,可以访问https//start.aliyun.io">https://start.spring.io无法访问，可以访问https://start.aliyun.io</a></p></blockquote><p><strong>创建成功后，pom.xml 坐标</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></div><h3 id="1-1-基本功能"><a href="#1-1-基本功能" class="headerlink" title="1.1 基本功能"></a>1.1 基本功能</h3><p>当我们创建一个 Spring Boot 工程时，可以继承自一个 <code>spring-boot-starter-parent</code> ，也可以不继承自它，我们先来看第一种情况。先来看 parent 的基本功能有哪些？</p><ul><li>定义了 Java 编译版本为 1.8 。</li><li>使用 UTF-8 格式编码。</li><li>继承自 <code>spring-boot-dependencies</code>，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li><li>执行打包操作的配置。</li><li>自动化的资源过滤。</li><li>自动化的插件配置。</li><li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml</li></ul><blockquote><p>请注意，由于<code>application.properties</code>和<code>application.yml</code>文件接受Spring样式占位符 <code>$ &#123;...&#125;</code> ，因此 Maven 过滤更改为使用 <code>@ .. @</code> 占位符，当然开发者可以通过设置名为<code> resource.delimiter</code> 的Maven 属性来覆盖 <code>@ .. @</code> 占位符</p></blockquote><h3 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2 源码分析"></a>1.2 源码分析</h3><p>当我们创建一个 Spring Boot 项目后，我们可以在本地 Maven 仓库中看到这个具体的 parent 文件，以 2.1.4 这个版本为例，这里的路径是 <code>C:\Users\sang\.m2\repository\org\springframework\boot\spring-boot-starter-parent\2.1.4.RELEASE\spring-boot-starter-parent-2.1.4.RELEASE.pom</code> ,打开这个文件，快速阅读文件源码，基本上就可以证实我们前面说的功能，如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/2-1-20210521101059250.png" alt="img"></p><p>我们可以看到，它继承自 <code>spring-boot-dependencies</code> ，这里保存了基本的依赖信息，另外我们也可以看到项目的编码格式，JDK 的版本等信息，当然也有我们前面提到的数据过滤信息。最后，我们再根据它的 parent 中指定的 <code>spring-boot-dependencies</code> 位置，来看看 <code>spring-boot-dependencies</code> 中的定义：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/2-2.png" alt="img"></p><p>在这里，我们看到了版本的定义以及<code>dependencyManagement</code>节点，明白了为啥 Spring Boot 项目中部分依赖不需要写版本号了。</p><h3 id="1-3-不用-parent"><a href="#1-3-不用-parent" class="headerlink" title="1.3 不用 parent"></a>1.3 不用 parent</h3><p>但是并非所有的公司都需要这个 parent ，有的时候，公司里边会有自己定义的 parent ，我们的 Spring Boot 项目要继承自公司内部的 parent ，这个时候该怎么办呢？</p><p>一个简单的办法就是我们自行定义<code>dependencyManagement</code>节点，然后在里边定义好版本号，再接下来在引用依赖时也就不用写版本号了，像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre></div><p>这样写之后，依赖的版本号问题虽然解决了，但是关于打包的插件、编译的 JDK 版本、文件的编码格式等等这些配置，在没有 parent 的时候，这些统统要自己去配置</p><h3 id="1-4-lt-resources-gt"><a href="#1-4-lt-resources-gt" class="headerlink" title="1.4 &lt;resources/&gt;"></a>1.4 <code>&lt;resources/&gt;</code></h3><p><code>pom.xml</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">javaboy.name</span>&gt;</span>www.lucifer.org<span class="hljs-tag">&lt;/<span class="hljs-name">javaboy.name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>          <span class="hljs-comment">&lt;!-- 要处理a的，但只写这个会忽略其他的--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>a.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>          <span class="hljs-comment">&lt;!-- 所以加上此语句，表示除了a，其他的不要处理 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>a.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p><code>a.properties</code>文件的定义</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">a.name</span>=<span class="hljs-string">$&#123;javaboy.name&#125;</span></code></pre></div><p>在打包的时候，<code>a.name</code>会直接从<code>&lt;properties&gt;</code>拿取值，得到<a href="http://www.lucifer.org/">www.lucifer.org</a></p><h2 id="2-SpringBootApplication"><a href="#2-SpringBootApplication" class="headerlink" title="2.  @SpringBootApplication"></a>2.  @SpringBootApplication</h2><h3 id="2-1-SpringBootConfiguration"><a href="#2-1-SpringBootConfiguration" class="headerlink" title="2.1 @SpringBootConfiguration"></a>2.1 @SpringBootConfiguration</h3><p>启动类上的注解 <code>@SpringBootApplication</code>引用了<code>@SpringBootConfiguration</code></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521102815674.png" alt="image-20210521102815674"></p><p>这里面又直接调用了<code>@Configuration</code>，这就引出了另一个问题，在普通的配置类MyConfig中，<code>@Configuration</code>和<code>@Component</code>看似功能相同，为什么要用<code>@Configuration</code>，通过以下配置</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Author <span class="hljs-title">author</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Author();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Book <span class="hljs-title">book</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Book(author());    &#125;&#125;</code></pre></div><p>发现使用<code>@Configuration</code>创建出来了的Author对象通过代理对象了的，而<code>@Component</code>没有，其中<code>Book(author())</code>如果Book里的Author之前已经创建，就会直接使用，并不会重复创建，这里就不会</p><h3 id="2-2-EnableAutoConfiguration"><a href="#2-2-EnableAutoConfiguration" class="headerlink" title="2.2 EnableAutoConfiguration"></a>2.2 EnableAutoConfiguration</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@AutoConfigurationPackage</span><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;    String ENABLED_OVERRIDE_PROPERTY = <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;&#125;</code></pre></div><p>在原生的Spring框架中，组件装配有三个阶段：</p><ul><li>Spring2.5，@Component</li><li>Spring3.0+，使用@Configuration+@Bean</li><li>Spring3.1+，@EnableXXX+@Import</li></ul><p>为了说明<code>@EnableXXX+@Import</code>，先定义实体类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Banana</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre></div><p><strong>有四种定义注解的方式</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;Apple.class.getName(), Banana.class.getName()&#125;;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitImportDefinitionRegistar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;        registry.registerBeanDefinition(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-keyword">new</span> RootBeanDefinition(Apple.class));        registry.registerBeanDefinition(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-keyword">new</span> RootBeanDefinition(Banana.class));    &#125;&#125;<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Target(ElementType.TYPE)</span><span class="hljs-comment">//1.@Import(&#123;Apple.class, Banana.class&#125;)</span><span class="hljs-comment">//2.可以直接导入配置类</span><span class="hljs-comment">//3.@Import(&#123;FruitImportSelector.class&#125;)</span><span class="hljs-meta">@Import(&#123;FruitImportDefinitionRegistar.class&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableFruit &#123;&#125;</code></pre></div><p>从而可以发现</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521105018844.png" alt="image-20210521105018844"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521105101247.png" alt="image-20210521105101247"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521105547266.png" alt="image-20210521105547266"></p><h2 id="3-基础配置"><a href="#3-基础配置" class="headerlink" title="3. 基础配置"></a>3. 基础配置</h2><h3 id="3-1-Tomcat配置"><a href="#3-1-Tomcat配置" class="headerlink" title="3.1 Tomcat配置"></a>3.1 Tomcat配置</h3><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>更改<code>pom.xml</code>文件排除自带的Tomcat后就能自定义自己所需的</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>可以任何容器，在配置文件中</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#不要开启web容器，以普通SE项目运行</span><span class="hljs-meta">spring.main.web-application-type</span>=<span class="hljs-string">none</span><span class="hljs-comment">#更改端口</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8888</span><span class="hljs-comment">#关闭所有的 http 端点</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">-1</span><span class="hljs-comment">#随机端口</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">0</span><span class="hljs-comment">#端口压缩</span><span class="hljs-meta">server.compression.enabled</span>=<span class="hljs-string">true</span></code></pre></div><p>随机端口需要通过监听器获取</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">WebServerInitializedEvent</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(WebServerInitializedEvent event)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;event.getWebServer().getPort() = &quot;</span> + event.getWebServer().getPort());    &#125;&#125;</code></pre></div><h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 生成的访问日志将在该目录下</span><span class="hljs-meta">server.tomcat.basedir</span>=<span class="hljs-string">my-tomcat</span><span class="hljs-comment"># 开启访问日志，默认的日志位置在项目运行的临时目录中，默认生成的日志格式 access_log.2021-05-12.log</span><span class="hljs-meta">server.tomcat.accesslog.enabled</span>=<span class="hljs-string">true</span><span class="hljs-comment"># 生成日志文件名的前缀，默认是 access_log</span><span class="hljs-meta">server.tomcat.accesslog.prefix</span>=<span class="hljs-string">tomcat_log</span><span class="hljs-comment"># 生成的日志文件后缀</span><span class="hljs-meta">server.tomcat.accesslog.suffix</span>=<span class="hljs-string">.log</span><span class="hljs-comment"># 日志文件名中的日期格式</span><span class="hljs-meta">server.tomcat.accesslog.file-date-format</span>=<span class="hljs-string">.yyyyMMdd</span><span class="hljs-comment"># 生成的日志文件内容格式也是可以调整的</span><span class="hljs-comment"># %h 请求的客户端 IP</span><span class="hljs-comment"># %l 用户的身份</span><span class="hljs-comment"># %u 用户名</span><span class="hljs-comment"># %t 请求时间</span><span class="hljs-comment"># %r 请求地址</span><span class="hljs-comment"># %s 响应的状态码</span><span class="hljs-comment"># %b 响应的大小</span><span class="hljs-meta">server.tomcat.accesslog.pattern</span>=<span class="hljs-string">%h %l %u %t \&quot;%r\&quot; %s %b</span><span class="hljs-comment"># 服务器内部日志开启</span><span class="hljs-meta">logging.level.org.apache.tomcat</span>=<span class="hljs-string">debug</span><span class="hljs-meta">logging.level.org.apache.catalina</span>=<span class="hljs-string">debug</span></code></pre></div><h4 id="HTTPS证书"><a href="#HTTPS证书" class="headerlink" title="HTTPS证书"></a>HTTPS证书</h4><p>首先我们需要有一个 https 证书，我们可以从各个云服务厂商处申请一个免费的，不过自己做实验没有必要这么麻烦，我们可以直接借助 Java 自带的 JDK 管理工具 keytool 来生成一个免费的 https 证书。</p><p>进入到 <code>%JAVVA_HOME%\bin</code> 目录下，执行如下命令生成一个数字证书：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">keytool -genkey -alias tomcathttps -keyalg RSA -keysize 2048  -keystore lucifer.p12 -validity 365</code></pre></div><p>命令含义如下：</p><ul><li>genkey 表示要创建一个新的密钥。</li><li>alias 表示 keystore 的别名。</li><li>keyalg 表示使用的加密算法是 RSA ，一种非对称加密算法。</li><li>keysize 表示密钥的长度。</li><li>keystore 表示生成的密钥存放位置。</li><li>validity 表示密钥的有效时间，单位为天。</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521155752252.png" alt="image-20210521155752252"></p><p>配置<code>application.properties</code></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.ssl.key-alias</span>=<span class="hljs-string">myhttps</span><span class="hljs-meta">server.ssl.key-store</span>=<span class="hljs-string">classpath:lucifer.p12</span><span class="hljs-meta">server.ssl.key-store-password</span>=<span class="hljs-string">123456</span></code></pre></div><p><strong>配置https跳转</strong></p><p>考虑到 Spring Boot 不支持同时启动 HTTP 和 HTTPS ，为了解决这个问题，我们这里可以配置一个请求转发，当用户发起 HTTP 调用时，自动转发到 HTTPS 上</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">TomcatServletWebServerFactory <span class="hljs-title">tomcatServletWebServerFactory</span><span class="hljs-params">()</span> </span>&#123;        TomcatServletWebServerFactory factory = <span class="hljs-keyword">new</span> TomcatServletWebServerFactory()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessContext</span><span class="hljs-params">(Context context)</span> </span>&#123;                SecurityConstraint securityConstraint = <span class="hljs-keyword">new</span> SecurityConstraint();                securityConstraint.setUserConstraint(<span class="hljs-string">&quot;CONFIDENTIAL&quot;</span>);                SecurityCollection collection = <span class="hljs-keyword">new</span> SecurityCollection();                collection.addPattern(<span class="hljs-string">&quot;/*&quot;</span>);                securityConstraint.addCollection(collection);                context.addConstraint(securityConstraint);            &#125;        &#125;;        factory.addAdditionalTomcatConnectors(myConnectors());        <span class="hljs-keyword">return</span> factory;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> Connector <span class="hljs-title">myConnectors</span><span class="hljs-params">()</span> </span>&#123;        Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);        connector.setScheme(<span class="hljs-string">&quot;http&quot;</span>);        <span class="hljs-comment">//http和默认的8080不能占用同一个端口</span>        connector.setPort(<span class="hljs-number">8081</span>);        connector.setSecure(<span class="hljs-keyword">false</span>);        connector.setRedirectPort(<span class="hljs-number">8080</span>);        <span class="hljs-keyword">return</span> connector;    &#125;&#125;</code></pre></div><h3 id="3-2-application-properties"><a href="#3-2-application-properties" class="headerlink" title="3.2 application.properties"></a>3.2 <strong>application.properties</strong></h3><p>首先，当我们创建一个 Spring Boot 工程时，默认 resources 目录下就有一个 application.properties 文件，可以在 application.properties 文件中进行项目配置，但是这个文件并非唯一的配置文件，在 Spring Boot 中，一共有 4 个地方可以存放 application.properties 文件</p><ul><li>当前项目根目录下的 config 目录下</li><li>当前项目的根目录下</li><li>resources 目录下的 config 目录下</li><li>resources 目录下</li></ul><p>按如上顺序，四个配置文件的优先级依次降低。如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/11-1.png" alt="img"></p><p>这四个位置是默认位置，即 Spring Boot 启动，默认会从这四个位置按顺序去查找相关属性并加载。但是，这也不是绝对的，我们也可以在项目启动时自定义配置文件位置。</p><p>例如，现在在 resources 目录下创建一个 javaboy 目录，目录中存放一个 application.properties 文件，那么正常情况下，当我们启动 Spring Boot 项目时，这个配置文件是不会被自动加载的。我们可以通过 spring.config.location 属性来手动的指定配置文件位置，指定完成后，系统就会自动去指定目录下查找 application.properties 文件。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/11-2.png" alt="img"></p><p>此时启动项目，就会发现，项目以 <code>classpath:/javaboy/application.propertie</code> 配置文件启动。</p><p>这是在开发工具中配置了启动位置，如果项目已经打包成 jar ，在启动命令中加入位置参数即可：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">java -jar properties-0.0.1-SNAPSHOT.jar --spring.config.location=classpath:/javaboy/</code></pre></div><h4 id="文件名问题"><a href="#文件名问题" class="headerlink" title="文件名问题"></a>文件名问题</h4><p>对于 application.properties 而言，它不一定非要叫 application ，但是项目默认是去加载名为 application 的配置文件，如果我们的配置文件不叫 application ，也是可以的，但是，需要明确指定配置文件的文件名。</p><p>方式和指定路径一致，只不过此时的 key 是 spring.config.name 。</p><p>首先我们在 resources 目录下创建一个 app.properties 文件，然后在 IDEA 中指定配置文件的文件名：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/11-3.png" alt="img"></p><p>指定完配置文件名之后，再次启动项目，此时系统会自动去默认的四个位置下面分别查找名为 app.properties 的配置文件。当然，允许自定义文件名的配置文件不放在四个默认位置，而是放在自定义目录下，此时就需要明确指定 spring.config.location </p><p>配置文件位置和文件名称可以同时自定义。</p><h4 id="普通的属性注入"><a href="#普通的属性注入" class="headerlink" title="普通的属性注入"></a>普通的属性注入</h4><p>由于 Spring Boot 源自 Spring ，所以 Spring 中存在的属性注入，在 Spring Boot 中一样也存在。由于 Spring Boot 中，默认会自动加载 application.properties 文件，所以简单的属性注入可以直接在这个配置文件中写。</p><p>例如，现在定义一个 Book 类：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String author;    <span class="hljs-comment">//省略 getter/setter</span>&#125;</code></pre></div><p>然后，在 application.properties 文件中定义属性：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">book.name</span>=<span class="hljs-string">三国演义</span><span class="hljs-meta">book.author</span>=<span class="hljs-string">罗贯中</span><span class="hljs-meta">book.id</span>=<span class="hljs-string">1</span></code></pre></div><p>按照传统的方式（Spring中的方式），可以直接通过 @Value 注解将这些属性注入到 Book 对象中：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;book.id&#125;&quot;)</span>    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Value(&quot;$&#123;book.author&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String author;    <span class="hljs-comment">//省略getter/setter</span>&#125;</code></pre></div><p><strong>注意</strong></p><p>Book 对象本身也要交给 Spring 容器去管理，如果 Book 没有交给 Spring 容器，那么 Book 中的属性也无法从 Spring 容器中获取到值。</p><p>配置完成后，在 Controller 或者单元测试中注入 Book 对象，启动项目，就可以看到属性已经注入到对象中了。</p><p>一般来说，我们在 application.properties 文件中主要存放系统配置，这种自定义配置不建议放在该文件中，可以自定义 properties 文件来存在自定义配置。</p><p>例如在 resources 目录下，自定义 book.properties 文件，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">book.name</span>=<span class="hljs-string">三国演义</span><span class="hljs-meta">book.author</span>=<span class="hljs-string">罗贯中</span><span class="hljs-meta">book.id</span>=<span class="hljs-string">1</span></code></pre></div><p>此时，项目启动并不会自动的加载该配置文件，如果是在 XML 配置中，可以通过如下方式引用该 properties 文件：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:book.properties&quot;</span>/&gt;</span></code></pre></div><p>如果是在 Java 配置中，可以通过<code>@PropertySource</code>来引入配置：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@PropertySource(&quot;classpath:book.properties&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;book.id&#125;&quot;)</span>    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Value(&quot;$&#123;book.author&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String author;    <span class="hljs-comment">//getter/setter</span>&#125;</code></pre></div><p>这样，当项目启动时，就会自动加载 book.properties 文件。</p><p>这只是 Spring 中属性注入的一个简单用法，和 Spring Boot 没有任何关系。</p><h4 id="类型安全的属性注入"><a href="#类型安全的属性注入" class="headerlink" title="类型安全的属性注入"></a>类型安全的属性注入</h4><p>Spring Boot 引入了类型安全的属性注入，如果采用 Spring 中的配置方式，当配置的属性非常多的时候，工作量就很大了，而且容易出错。</p><p>使用类型安全的属性注入，可以有效的解决这个问题。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@PropertySource(&quot;classpath:book.properties&quot;)</span><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;book&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String author;    <span class="hljs-comment">//省略getter/setter</span>&#125;</code></pre></div><p>这里，主要是引入<code>@ConfigurationProperties(prefix = “book”)</code>注解，并且配置了属性的前缀，此时会自动将 Spring 容器中对应的数据注入到对象对应的属性中，就不用通过 <code>@Value</code> 注解挨个注入了，减少工作量并且避免出错</p><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>在实际开发配置中，要分环境开发</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521163450670.png" alt="image-20210521163450670"></p><p>配置 application.properties 选择特定的开发端口</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.profiles.active</span>=<span class="hljs-string">prod</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># application-prod.properties</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8088</span><span class="hljs-comment"># application-dev.properties</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8080</span><span class="hljs-comment"># application-test.properties</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8888</span></code></pre></div><h3 id="3-3-Yaml配置"><a href="#3-3-Yaml配置" class="headerlink" title="3.3 Yaml配置"></a>3.3 Yaml配置</h3><p>首先application.yaml在Spring Boot中可以写在四个不同的位置，分别是如下位置：</p><ul><li>项目根目录下的config目录中</li><li>项目根目录下</li><li>classpath下的config目录中</li><li>classpath目录下</li></ul><p>四个位置中的application.yaml文件的优先级按照上面列出的顺序依次降低。即如果有同一个属性在四个文件中都出现了，以优先级高的为准。</p><p>那么application.yaml是不是必须叫application.yaml这个名字呢？当然不是必须的。开发者可以自己定义yaml名字，自己定义的话，需要在项目启动时指定配置文件的名字，像下面这样：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/9-1.png" alt="img"></p><p>当然这是在IntelliJ IDEA中直接配置的，如果项目已经打成jar包了，则在项目启动时加入如下参数：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">java -jar myproject.jar --spring.config.name=app</code></pre></div><p>这样配置之后，在项目启动时，就会按照上面所说的四个位置按顺序去查找一个名为app.yaml的文件。当然这四个位置也不是一成不变的，也可以自己定义，有两种方式，一个是使用<code>spring.config.location</code>属性，另一个则是使用<code>spring.config.additional-location</code>这个属性，在第一个属性中，表示自己重新定义配置文件的位置，项目启动时就按照定义的位置去查找配置文件，这种定义方式会覆盖掉默认的四个位置，也可以使用第二种方式，第二种方式则表示在四个位置的基础上，再添加几个位置，新添加的位置的优先级大于原本的位置。</p><p>配置方式如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/9-2.png" alt="img"></p><p>这里要注意，配置文件位置时，值一定要以/结尾。</p><h4 id="数组注入"><a href="#数组注入" class="headerlink" title="数组注入"></a>数组注入</h4><p>yaml也支持数组注入，例如</p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">my:</span>  <span class="hljs-attr">servers:</span><span class="hljs-bullet">-</span> <span class="hljs-string">dev.example.com</span><span class="hljs-bullet">-</span> <span class="hljs-string">another.example.com</span></code></pre></div><p>这段数据可以绑定到一个带Bean的数组中：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix=&quot;my&quot;)</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>&#123;<span class="hljs-keyword">private</span> List&lt;String&gt; servers = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getServers</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.servers;&#125;&#125;</code></pre></div><p>项目启动后，配置中的数组会自动存储到servers集合中。当然，yaml不仅可以存储这种简单数据，也可以在集合中存储对象。例如下面这种：</p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">redis:</span>  <span class="hljs-attr">redisConfigs:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.66</span><span class="hljs-number">.128</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.66</span><span class="hljs-number">.129</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">6380</span></code></pre></div><p>这个可以被注入到如下类中：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;redis&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCluster</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;SingleRedisConfig&gt; redisConfigs;<span class="hljs-comment">//省略getter/setter</span>&#125;</code></pre></div><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>不同于properties文件的无序，yaml配置是有序的，这一点在有些配置中是非常有用的，例如在Spring Cloud Zuul的配置中，当我们配置代理规则时，顺序就显得尤为重要了。当然yaml配置也不是万能的，例如，yaml配置目前不支持<code>@PropertySource</code>注解</p><h2 id="4-日志详解"><a href="#4-日志详解" class="headerlink" title="4. 日志详解"></a>4. 日志详解</h2><h3 id="1-Java-日志概览"><a href="#1-Java-日志概览" class="headerlink" title="1. Java 日志概览"></a>1. Java 日志概览</h3><p>说到 Java 日志，很多初学者可能都比较懵，因为这里涉及到太多东西了：<code>Apache Commons Logging</code>、<code>Slf4j</code>、<code>Log4j</code>、<code>Log4j2</code>、<code>Logback</code>、<code>Java Util Logging</code> 等等，这些框架各自有什么作用？他们之间有什么区别？</p><h4 id="1-1-总体概览"><a href="#1-1-总体概览" class="headerlink" title="1.1 总体概览"></a>1.1 总体概览</h4><p>下面这张图很好的展示了 Java 中的日志体系：</p><p><a href="http://img.itboyhub.com/2020/20201213205509.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201213205509.png" alt="img"></a></p><p>可以看到，Java 中的日志框架主要分为两大类：<strong>日志门面</strong>和<strong>日志实现</strong>。</p><p><strong>日志门面</strong></p><p>日志门面定义了一组日志的接口规范，它并不提供底层具体的实现逻辑。<code>Apache Commons Logging</code> 和 <code>Slf4j</code> 就属于这一类。</p><p><strong>日志实现</strong></p><p>日志实现则是日志具体的实现，包括日志级别控制、日志打印格式、日志输出形式（输出到数据库、输出到文件、输出到控制台等）。<code>Log4j</code>、<code>Log4j2</code>、<code>Logback</code> 以及 <code>Java Util Logging</code> 则属于这一类。</p><p>将日志门面和日志实现分离其实是一种典型的门面模式，这种方式可以让具体业务在不同的日志实现框架之间自由切换，而不需要改动任何代码，开发者只需要掌握日志门面的 API 即可。</p><p>日志门面是不能单独使用的，它必须和一种具体的日志实现框架相结合使用。</p><p>那么日志框架是否可以单独使用呢？</p><p>技术上来说当然没问题，但是我们一般不会这样做，因为这样做可维护性很差，而且后期扩展不易。例如 A 开发了一个工具包使用 Log4j 打印日志，B 引用了这个工具包，但是 B 喜欢使用 Logback 打印日志，此时就会出现一个业务使用两个甚至多个日志框架，开发者也需要维护多个日志的配置文件。因此我们都是用日志门面打印日志。</p><h4 id="1-2-日志级别"><a href="#1-2-日志级别" class="headerlink" title="1.2 日志级别"></a>1.2 日志级别</h4><p>使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。不同的日志实现定义的日志级别不太一样，不过也都大同小异。</p><p><strong>Java Util Logging</strong></p><p><code>Java Util Logging</code> 定义了 7 个日志级别，从严重到普通依次是：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>因为默认级别是 INFO，因此 INFO 级别以下的日志，不会被打印出来。</p><p><strong>Log4j</strong></p><p><code>Log4j</code> 定义了 8 个日志级别（除去 OFF 和 ALL，可以说分为 6 个级别），从严重到普通依次是：</p><ul><li>OFF：最高等级的，用于关闭所有日志记录。</li><li>FATAL：重大错误，这种级别可以直接停止程序了。</li><li>ERROR：打印错误和异常信息，如果不想输出太多的日志，可以使用这个级别。</li><li>WARN：警告提示。</li><li>INFO：用于生产环境中输出程序运行的一些重要信息，不能滥用。</li><li>DEBUG：用于开发过程中打印一些运行信息。</li><li>TRACE</li><li>ALL 最低等级的，用于打开所有日志记录。</li></ul><p><strong>Logback</strong></p><p><code>Logback</code> 日志级别比较简单，从严重到普通依次是：</p><ul><li>ERROR</li><li>WARN</li><li>INFO</li><li>DEBUG</li><li>TRACE</li></ul><h4 id="1-3-综合对比"><a href="#1-3-综合对比" class="headerlink" title="1.3 综合对比"></a>1.3 综合对比</h4><p><code>Java Util Logging</code> 系统在 <code>JVM</code> 启动时读取配置文件并完成初始化，一旦应用程序开始运行，就无法修改配置。另外，这种日志实现配置也不太方便，只能在 <code>JVM</code> 启动时传递参数，像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs xml">-Djava.util.logging.config.file=<span class="hljs-tag">&lt;<span class="hljs-name">config-file-name</span>&gt;</span>。</code></pre></div><p>由于这些局限性，导致 <code>Java Util Logging</code> 并未广泛使用。</p><p><code>Log4j</code> 虽然配置繁琐，但是一旦配置完成，使用起来就非常方便，只需要将相关的配置文件放到 <code>classpath</code> 下即可。在很多情况下，<code>Log4j</code> 的配置文件我们可以在不同的项目中反复使用。</p><p><code>Log4j</code> 可以和 <code>Apache Commons Logging</code> 搭配使用，<code>Apache Commons Logging</code> 会自动搜索并使用 <code>Log4j</code>，如果没有找到 <code>Log4j</code>，再使用 <code>Java Util Logging</code>。</p><p>比 <code>Log4j</code> + <code>Apache Commons Logging</code> 组合更得人心的是 <code>Slf4j</code> + <code>Logback</code> 组合。</p><p><code>Logback</code> 是 <code>Slf4j</code> 的原生实现框架，它也出自 <code>Log4j</code> 作者（Ceki Gülcü）之手，但是相比 <code>Log4j</code>，它拥有更多的优点、特性以及更强的性能。</p><h4 id="1-4-最佳实践"><a href="#1-4-最佳实践" class="headerlink" title="1.4 最佳实践"></a>1.4 最佳实践</h4><ul><li>如果不想添加任何依赖，使用 <code>Java Util Logging</code> 或框架容器已经提供的日志接口。</li><li>如果比较在意性能，推荐：<code>Slf4j</code> + <code>Logback</code>。</li><li>如果项目中已经使用了 <code>Log4j</code> 且没有发现性能问题，推荐组合为：<code>Slf4j</code> + <code>Log4j2</code>。</li></ul><h3 id="2-Spring-Boot-日志实现"><a href="#2-Spring-Boot-日志实现" class="headerlink" title="2. Spring Boot 日志实现"></a>2. Spring Boot 日志实现</h3><p>Spring Boot 使用 <code>Apache Commons Logging</code> 作为内部的日志框架门面，它只是一个日志接口，在实际应用中需要为该接口来指定相应的日志实现。</p><p>Spring Boot 默认的日志实现是 <code>Logback</code>。这个很好查看：随便启动一个 Spring Boot 项目，从控制台找一行日志，例如下面这样：</p><p><a href="http://img.itboyhub.com/2020/20201214092816.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201214092816.png" alt="img"></a></p><p>考虑到最后的 prod 是一个可以变化的字符，我们在项目中全局搜索：<code>The following profiles are active</code>，结果如下：</p><p><a href="http://img.itboyhub.com/2020/20201214092956.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201214092956.png" alt="img"></a></p><p>在日志输出的那一行 debug。然后再次启动项目，如下图：</p><p><a href="http://img.itboyhub.com/2020/20201214093147.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201214093147.png" alt="img"></a></p><p>此时我们就可以看到真正的日志实现是 <code>Logback</code>。</p><p>其他的诸如 <code>Java Util Logging</code>、<code>Log4j</code> 等框架，Spring Boot 也有很好的支持。</p><p>在 Spring Boot 项目中，只要添加了如下 web 依赖，日志依赖就自动添加进来了：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="2-1-Spring-Boot-日志配置"><a href="#2-1-Spring-Boot-日志配置" class="headerlink" title="2.1 Spring Boot 日志配置"></a>2.1 Spring Boot 日志配置</h4><p>Spring Boot 的日志系统会自动根据 classpath 下的内容选择合适的日志配置，在这个过程中首选 Logback。</p><p>如果开发者需要修改日志级别，只需要在 application.properties 文件中通过 <code>logging.level 前缀+包名</code> 的形式进行配置即可，例如下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.level.org.springframework.web</span>=<span class="hljs-string">debug</span><span class="hljs-meta">logging.level.org.hibernate</span>=<span class="hljs-string">error</span></code></pre></div><p>如果你想将日志输出到文件，可以通过如下配置指定日志文件名：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.file.name</span>=<span class="hljs-string">javaboy.log</span></code></pre></div><p>logging.file.name 可以只指定日志文件名，也可以指定日志文件全路径，例如下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.file.name</span>=<span class="hljs-string">/Users/sang/Documents/javaboy/javaboy.log</span></code></pre></div><p>如果你只是想重新定义输出日志文件的路径，也可以使用 <code>logging.file.path</code> 属性，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.file.path</span>=<span class="hljs-string">/Users/sang/Documents/javaboy</span></code></pre></div><p>如果想对输出到文件中的日志进行精细化管理，还有如下一些属性可以配置：</p><ul><li>logging.logback.rollingpolicy.file-name-pattern：日志归档的文件名，日志文件达到一定大小之后，自动进行压缩归档。</li><li>logging.logback.rollingpolicy.clean-history-on-start：是否在应用启动时进行归档管理。</li><li>logging.logback.rollingpolicy.max-file-size：日志文件大小上限，达到该上限后，会自动压缩。</li><li>logging.logback.rollingpolicy.total-size-cap：日志文件被删除之前，可以容纳的最大大小。</li><li>logging.logback.rollingpolicy.max-history：日志文件保存的天数。</li></ul><p>日志文件归档这块，小伙伴们感兴趣可以自己试下，可以首先将 max-file-size 属性调小，这样方便看到效果：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.logback.rollingpolicy.max-file-size</span>=<span class="hljs-string">1MB</span></code></pre></div><p>然后添加如下接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = getLogger(HelloController.class);    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;            logger.info(<span class="hljs-string">&quot;hello javaboy&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>访问该接口，可以看到最终生成的日志文件被自动压缩了：</p><p><a href="http://img.itboyhub.com/2020/20201214115027.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201214115027.png" alt="img"></a></p><p>application.properties 中还可以配置日志分组。</p><p>日志分组能够把相关的 logger 放到一个组统一管理。</p><p>例如我们可以定义一个 tomcat 组：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.group.tomcat</span>=<span class="hljs-string">org.apache.catalina,org.apache.coyote, org.apache.tomcat</span></code></pre></div><p>然后统一管理 tomcat 组中的所有 logger：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.level.tomcat</span>=<span class="hljs-string">TRACE</span></code></pre></div><p>Spring Boot 中还预定义了两个日志分组 web 和 sql，如下：</p><p><a href="http://img.itboyhub.com/2020/20201214124953.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201214124953.png" alt="img"></a></p><p>不过在 application.properties 中只能实现对日志一些非常简单的配置，如果想实现更加细粒度的日志配置，那就需要使用日志实现的原生配置，例如 <code>Logback</code> 的 <code>classpath:logback.xml</code>，<code>Log4j</code> 的 <code>classpath:log4j.xml</code> 等。如果这些日志配置文件存在于 classpath 下，那么默认情况下，Spring Boot 就会自动加载这些配置文件。</p><h4 id="2-2-Logback-配置"><a href="#2-2-Logback-配置" class="headerlink" title="2.2 Logback 配置"></a>2.2 Logback 配置</h4><h5 id="2-2-1-基本配置"><a href="#2-2-1-基本配置" class="headerlink" title="2.2.1 基本配置"></a>2.2.1 基本配置</h5><p>默认的 <code>Logback</code> 配置文件名有两种：</p><ul><li><code>logback.xml</code>：这种配置文件会直接被日志框架加载。</li><li><code>logback-spring.xml</code>：这种配置文件不会被日志框架直接加载，而是由 Spring Boot 去解析日志配置，可以使用 Spring Boot 的高级 Profile 功能。</li></ul><p>Spring Boot 中为 <code>Logback</code> 提供了四个默认的配置文件，位置在 <code>org/springframework/boot/logging/logback/</code>，分别是：</p><ul><li>defaults.xml：提供了公共的日志配置，日志输出规则等。</li><li>console-appender.xml：使用 CONSOLE_LOG_PATTERN 添加一个ConsoleAppender。</li><li>file-appender.xml：添加一个 RollingFileAppender。</li><li>base.xml：为了兼容旧版 Spring Boot 而提供的。</li></ul><p>如果需要自定义 <code>logback.xml</code> 文件，可以在自定义时使用这些默认的配置文件，也可以不使用。一个典型的 <code>logback.xml</code> 文件如下（resources/logback.xml）：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/console-appender.xml&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.web&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><p>可以通过 include 引入 Spring Boot 已经提供的配置文件，也可以自定义。</p><h5 id="2-2-2-输出到文件"><a href="#2-2-2-输出到文件" class="headerlink" title="2.2.2 输出到文件"></a>2.2.2 输出到文件</h5><p>如果想禁止控制台的日志输出，转而将日志内容输出到一个文件，我们可以自定义一个 <code>logback-spring.xml</code> 文件，并引入前面所说的 <code>file-appender.xml</code> 文件。</p><p>像下面这样（<code>resources/logback-spring.xml</code>）：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_FILE&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;/&#125;spring.log&#125;&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/file-appender.xml&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><h4 id="2-3-Log4j-配置"><a href="#2-3-Log4j-配置" class="headerlink" title="2.3 Log4j 配置"></a>2.3 Log4j 配置</h4><p>如果 classpath 下存在 <code>Log4j2</code> 的依赖，Spring Boot 会自动进行配置。</p><p>默认情况下 classpath 下当然不存在 <code>Log4j2</code> 的依赖，如果想使用 <code>Log4j2</code>，可以排除已有的 <code>Logback</code>，然后再引入 <code>Log4j2</code>，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><code>Log4j2</code> 的配置就比较容易了，在 reources 目录下新建 log4j2.xml 文件，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;warn&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;app_name&quot;</span>&gt;</span>logging<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log_path&quot;</span>&gt;</span>logs/$&#123;app_name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appenders</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d][%t][%p][%l] %m%n&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">console</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileInfo&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/info.log&quot;</span></span><span class="hljs-tag">                     <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Filters</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;DENY&quot;</span></span><span class="hljs-tag">                                 <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;NEUTRAL&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Filters</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d][%t][%p][%c:%L] %m%n&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;2 MB&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">compressionLevel</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileWarn&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/warn.log&quot;</span></span><span class="hljs-tag">                     <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Filters</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;DENY&quot;</span></span><span class="hljs-tag">                                 <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;NEUTRAL&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Filters</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d][%t][%p][%c:%L] %m%n&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;2 MB&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">compressionLevel</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileError&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/error.log&quot;</span></span><span class="hljs-tag">                     <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d][%t][%p][%c:%L] %m%n&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;2 MB&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">compressionLevel</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appenders</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">loggers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileInfo&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileWarn&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileError&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">loggers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><p>首先在 properties 节点中指定了应用名称以及日志文件位置。</p><p>然后通过几个不同的 RollingFile 对不同级别的日志分别处理，不同级别的日志将输出到不同的文件，并按照各自的命名方式进行压缩。</p><p>这段配置比较程式化，小伙伴们可以保存下来做成 IntelliJ IDEA 模版以便日常使用。</p><h1 id="SpringBoot整合视图层"><a href="#SpringBoot整合视图层" class="headerlink" title="SpringBoot整合视图层"></a>SpringBoot整合视图层</h1><h2 id="1-Thymeleaf"><a href="#1-Thymeleaf" class="headerlink" title="1. Thymeleaf"></a>1. Thymeleaf</h2><p>Thymeleaf 是新一代 Java 模板引擎，它类似于 Velocity、FreeMarker 等传统 Java 模板引擎，但是与传统 Java 模板引擎不同的是，Thymeleaf 支持 HTML 原型。</p><p>它既可以让前端工程师在浏览器中直接打开查看样式，也可以让后端工程师结合真实数据查看显示效果，同时，SpringBoot 提供了 Thymeleaf 自动化配置解决方案，因此在 SpringBoot 中使用 Thymeleaf 非常方便。</p><p>事实上， Thymeleaf 除了展示基本的 HTML ，进行页面渲染之外，也可以作为一个 HTML 片段进行渲染，例如我们在做邮件发送时，可以使用 Thymeleaf 作为邮件发送模板。</p><p>另外，由于 Thymeleaf 模板后缀为 <code>.html</code>，可以直接被浏览器打开，因此，预览时非常方便。</p><h3 id="1-1-整合"><a href="#1-1-整合" class="headerlink" title="1.1 整合"></a>1.1 整合</h3><ul><li>创建项目</li></ul><p>Spring Boot 中整合 Thymeleaf 非常容易，只需要创建项目时添加 Thymeleaf 即可：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/18-1.png" alt="img"></p><p>创建完成后，pom.xml 依赖如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>当然，Thymeleaf 不仅仅能在 Spring Boot 中使用，也可以使用在其他地方，只不过 Spring Boot 针对 Thymeleaf 提供了一整套的自动化配置方案，这一套配置类的属性在 <code>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafProperties</code> 中，部分源码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafProperties</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">&quot;.html&quot;</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> checkTemplate = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> checkTemplateLocation = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">private</span> String prefix = DEFAULT_PREFIX;        <span class="hljs-keyword">private</span> String suffix = DEFAULT_SUFFIX;        <span class="hljs-keyword">private</span> String mode = <span class="hljs-string">&quot;HTML&quot;</span>;        <span class="hljs-keyword">private</span> Charset encoding = DEFAULT_ENCODING;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> cache = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">//...</span>&#125;</code></pre></div><ul><li>首先通过 <code>@ConfigurationProperties</code> 注解，将 <code>application.properties</code> 前缀为 <code>spring.thymeleaf</code> 的配置和这个类中的属性绑定。</li><li>前三个 <code>static</code> 变量定义了默认的编码格式、视图解析器的前缀、后缀等。</li><li>从前三行配置中，可以看出来，<code>Thymeleaf</code> 模板的默认位置在 <code>resources/templates</code> 目录下，默认的后缀是 <code>html</code>。</li><li>这些配置，如果开发者不自己提供，则使用 默认的，如果自己提供，则在 <code>application.properties</code> 中以 <code>spring.thymeleaf</code> 开始相关的配置。</li></ul><p>而我们刚刚提到的，Spring Boot 为 Thymeleaf 提供的自动化配置类，则是 <code>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration</code> ，部分源码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties(ThymeleafProperties.class)</span><span class="hljs-meta">@ConditionalOnClass(&#123; TemplateMode.class, SpringTemplateEngine.class &#125;)</span><span class="hljs-meta">@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class &#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafAutoConfiguration</span> </span>&#123;&#125;</code></pre></div><p>可以看到，在这个自动化配置类中，首先导入 <code>ThymeleafProperties</code> ，然后 <code>@ConditionalOnClass</code> 注解表示当当前系统中存在 <code>TemplateMode</code> 和 <code>SpringTemplateEngine</code> 类时，当前的自动化配置类才会生效，即只要项目中引入了 <code>Thymeleaf</code> 相关的依赖，这个配置就会生效。</p><p>这些默认的配置我们几乎不需要做任何更改就可以直接使用了。如果开发者有特殊需求，则可以在 application.properties 中配置以 spring.thymeleaf 开头的属性即可。</p><ul><li><strong>创建 Controller</strong></li></ul><p>接下来我们就可以创建 Controller 了，实际上引入 Thymeleaf 依赖之后，我们可以不做任何配置。新建的 IndexController 如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/index&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            User u = <span class="hljs-keyword">new</span> User();            u.setId((<span class="hljs-keyword">long</span>) i);            u.setName(<span class="hljs-string">&quot;javaboy:&quot;</span> + i);            u.setAddress(<span class="hljs-string">&quot;深圳:&quot;</span> + i);            users.add(u);        &#125;        model.addAttribute(<span class="hljs-string">&quot;users&quot;</span>, users);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String address;    <span class="hljs-comment">//省略 getter/setter</span>&#125;</code></pre></div><p>在 <code>IndexController</code> 中返回逻辑视图名+数据，逻辑视图名为 <code>index</code> ，意思我们需要在 <code>resources/templates</code> 目录下提供一个名为 <code>index.html</code> 的 <code>Thymeleaf</code> 模板文件。</p><ul><li><strong>创建 Thymeleaf</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>编号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;user : $&#123;users&#125;&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>在 <code>Thymeleaf</code> 中，通过 <code>th:each</code> 指令来遍历一个集合，数据的展示通过 <code>th:text</code> 指令来实现，</p><p>注意 <code>index.html</code> 最上面要引入 <code>thymeleaf</code> 名称空间。</p><p>配置完成后，就可以启动项目了，访问 /index 接口，就能看到集合中的数据了：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/18-2.png" alt="img"></p><p>另外，<code>Thymeleaf</code> 支持在 <code>js</code> 中直接获取 <code>Model</code> 中的变量。例如，在 <code>IndexController</code> 中有一个变量 <code>username</code> ：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/index&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span> </span>&#123;        model.addAttribute(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;    &#125;&#125;</code></pre></div><p>在页面模板中，可以直接在 js 中获取到这个变量：</p><div class="hljs code-wrapper"><pre><code class="hljs js">&lt;script th:inline=<span class="hljs-string">&quot;javascript&quot;</span>&gt;    <span class="hljs-keyword">var</span> username = [[$&#123;username&#125;]];    <span class="hljs-built_in">console</span>.log(username)&lt;/script&gt;</code></pre></div><p>这个功能算是 Thymeleaf 的特色之一吧。</p><h3 id="1-2-手动渲染"><a href="#1-2-手动渲染" class="headerlink" title="1.2 手动渲染"></a>1.2 手动渲染</h3><p>前面我们说的是返回一个 Thymeleaf 模板，我们也可以手动渲染 Thymeleaf 模板，这个一般在邮件发送时候有用，例如我在 resources/templates 目录下新建一个邮件模板，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎 <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>加入 XXX 集团，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>职位<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;position&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;salary&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.javaboy.org/images/sb/javaboy.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>这一个 HTML 模板中，有几个变量，我们要将这个 HTML 模板渲染成一个 String 字符串，再把这个字符串通过邮件发送出去，那么如何手动渲染呢？</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>TemplateEngine templateEngine;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;    Context context = <span class="hljs-keyword">new</span> Context();    context.setVariable(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);    context.setVariable(<span class="hljs-string">&quot;position&quot;</span>, <span class="hljs-string">&quot;Java工程师&quot;</span>);    context.setVariable(<span class="hljs-string">&quot;salary&quot;</span>, <span class="hljs-number">99999</span>);    String mail = templateEngine.process(<span class="hljs-string">&quot;mail&quot;</span>, context);    <span class="hljs-comment">//省略邮件发送</span>&#125;</code></pre></div><ul><li>渲染时，我们需要首先注入一个 <code>TemplateEngine </code>对象，这个对象就是在 Thymeleaf 的自动化配置类中配置的（即当我们引入 Thymeleaf 的依赖之后，这个实例就有了）。</li><li>然后构造一个 Context 对象用来存放变量。</li><li>调用 process 方法进行渲染，该方法的返回值就是渲染后的 HTML 字符串，然后我们将这个字符串发送出去。</li></ul><p>这是 Spring Boot 整合 Thymeleaf 的几个关键点，关于 Thymeleaf 这个页面模板本身更多的用法，可以参考 Thymeleaf 的文档：[<a href="https://www.thymeleaf.org]">https://www.thymeleaf.org]</a>(</p><h3 id="1-3-Thymeleaf-细节"><a href="#1-3-Thymeleaf-细节" class="headerlink" title="1.3 Thymeleaf 细节"></a>1.3 Thymeleaf 细节</h3><h4 id="1-3-1-标准表达式语法"><a href="#1-3-1-标准表达式语法" class="headerlink" title="1.3.1 标准表达式语法"></a>1.3.1 标准表达式语法</h4><h5 id="简单表达式"><a href="#简单表达式" class="headerlink" title="简单表达式"></a>简单表达式</h5><p><strong>${…}</strong></p><p>直接使用 <code>th:xx = &quot;$&#123;&#125;&quot;</code> 获取对象属性。这个在前面的案例中已经演示过了，不再赘述。</p><p><strong>*{…}</strong></p><p>可以像 <code>$&#123;...&#125;</code> 一样使用，也可以通过 <code>th:object</code> 获取对象，然后使用 <code>th:xx = &quot;*&#123;&#125;&quot;</code> 获取对象属性，这种简写风格极为清爽，推荐大家在实际项目中使用。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$&#123;user&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><p><strong>#{…}</strong></p><p>通常的国际化属性：<code>#&#123;...&#125;</code> 用于获取国际化语言翻译值。</p><p>在 resources 目录下新建两个文件：messages.properties 和 messages_zh_CN.properties，内容如下：</p><p>messages.properties：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">message</span> = <span class="hljs-string">javaboy</span></code></pre></div><p>messages_zh_CN.properties：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">message</span> = <span class="hljs-string">江南一点雨</span></code></pre></div><p>然后在 thymeleaf 中引用 message，系统会根据浏览器的语言环境显示不同的值：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;message&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>@{…}</strong></p><ul><li><strong>引用绝对 URL：</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;http://localhost:8080/hello.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>等价于：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/hello.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li><strong>上下文相关的 URL：</strong></li></ul><p>首先在 application.properties 中配置 Spring Boot 的上下文，以便于测试：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/myapp</span></code></pre></div><p>引用路径：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/hello.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>等价于：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/myapp/hello.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li><strong>相对 URL：</strong></li></ul><p>这个相对是指相对于服务器的 URL，例如如下引用：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;~/hello.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>等价于：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/hello.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>应用程序的上下文 <strong>/myapp</strong> 将被忽略。</p><ul><li><strong>协议相对 URL：</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;//localhost:8080/hello.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>等价于：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//localhost:8080/hello.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li><strong>带参数的 URL：</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;//localhost:8080/hello.js(name=&#x27;javaboy&#x27;,age=99)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>等价于：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;//localhost:8080/hello.js?name=javaboy&amp;age=99&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p><strong>~{…}</strong></p><p>片段表达式是 Thymeleaf 的特色之一，细粒度可以达到标签级别，这是 JSP 无法做到的。片段表达式拥有三种语法：</p><ul><li><code>~&#123; viewName &#125;</code>：表示引入完整页面</li><li><code>~&#123; viewName ::selector&#125;</code>：表示在指定页面寻找片段，其中 selector 可为片段名、jquery选择器等</li><li><code>~&#123; ::selector&#125;</code>： 表示在当前页寻找</li></ul><p>举个简单例子。</p><p>在 resources/templates 目录下新建 my_fragment.html 文件，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;javaboy_link&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.javaboy.org&quot;</span>&gt;</span>www.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;itboyhub_link&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.itboyhub.com&quot;</span>&gt;</span>www.itboyhub.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>这里有两个 div，通过 th:fragment 来定义片段，两个 div 分别具有不同的名字。</p><p>然后在另外一个页面中引用该片段：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$&#123;user&#125;&quot;</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;aaa&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;my_fragment.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;~&#123;my_fragment.html::javaboy_link&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;~&#123;::aaa&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>通过 th:replace 来引用片段。第一个表示引用完整的 <code>my_fragment.html</code> 页面；第二个表示引用 <code>my_fragment.html</code> 中的名为 <code>javaboy_link</code> 的片段；第三个表示引用当前页面名为 aaa 的片段，也就是上面那个 table。</p><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>这些是一些可以直接写在表达式中的字符，主要有如下几种：</p><ul><li>文本字面量： ‘one text’, ‘Another one!’,…</li><li>数字字面量： 0, 34, 3.0, 12.3,…</li><li>布尔字面量： true, false</li><li>Null字面量： null</li><li>字面量标记：one, sometext, main,…</li></ul><p>案例：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;这是 文本字面量(有空格)&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;javaboy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;99&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>如果文本是英文，并且不包含空格、逗号等字符，可以不用加单引号。</p><h5 id="文本运算"><a href="#文本运算" class="headerlink" title="文本运算"></a>文本运算</h5><p>文本可以使用 <code>+</code> 进行拼接。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;hello &#x27;+&#x27;javaboy&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;hello &#x27;+$&#123;user.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>如果字符串中包含变量，也可以使用另一种简单的方式，叫做字面量置换，用 <code>|</code> 代替 <code>&#39;...&#39; + &#39;...&#39;</code>，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;|hello $&#123;user.username&#125;|&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;hello &#x27;+$&#123;user.username&#125;+&#x27; &#x27;+|Go $&#123;user.address&#125;|&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h5 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h5><p>算术运算有：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 和 <code>%</code>。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;age=(99*99/99+99-1)&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>th:with 定义了一个局部变量 age，在其所在的 div 中可以使用该局部变量</p><h5 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h5><ul><li>二元运算符：and, or</li><li>布尔非（一元运算符）：!, not</li></ul><p>案例：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;age=(99*99/99+99-1)&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;9 eq 9 or 8 ne 8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;!(9 eq 9 or 8 ne 8)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;not(9 eq 9 or 8 ne 8)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h5 id="比较和相等"><a href="#比较和相等" class="headerlink" title="比较和相等"></a>比较和相等</h5><p>表达式里的值可以使用 <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> 和 <code>&lt;=</code> 符号比较。<code>==</code> 和 <code>!=</code> 运算符用于检查相等（或者不相等）。注意 <code>XML</code>规定 <code>&lt;</code> 和 <code>&gt;</code> 标签不能用于属性值，所以应当把它们转义为 <code>&lt;</code> 和 <code>&gt;</code>。</p><p>如果不想转义，也可以使用别名：<code>gt (&gt;)；lt (&lt;)；ge (&gt;=)；le (&lt;=)；not (!)</code>还有<code> eq (==), neq/ne (!=)</code></p><p>举例：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;age=(99*99/99+99-1)&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; eq 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; ne 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; ge 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; gt 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; le 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; lt 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h5 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h5><p>类似于我们 Java 中的三目运算符。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;age=(99*99/99+99-1)&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;($&#123;age&#125; ne 197)?&#x27;yes&#x27;:&#x27;no&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>其中，: 后面的部分可以省略，如果省略了，又同时计算结果为 false 时，将返回 null。</p><h5 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h5><p>基本内置对象：</p><ul><li>#ctx：上下文对象。</li><li>#vars: 上下文变量。</li><li>#locale：上下文区域设置。</li><li>#request：（仅在 Web 上下文中）HttpServletRequest 对象。</li><li>#response：（仅在 Web 上下文中）HttpServletResponse 对象。</li><li>#session：（仅在 Web 上下文中）HttpSession 对象。</li><li>#servletContext：（仅在 Web 上下文中）ServletContext 对象。</li></ul><p>在页面可以访问到上面这些内置对象，举个简单例子：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&#x27;$&#123;#session.getAttribute(&quot;name&quot;)&#125;&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>实用内置对象：</p><ul><li>#execInfo：有关正在处理的模板的信息。</li><li>#messages：在变量表达式中获取外部化消息的方法，与使用＃{…}语法获得的方式相同。</li><li>#uris：转义URL / URI部分的方法</li><li>#conversions：执行配置的转换服务（如果有）的方法。</li><li>#dates：java.util.Date对象的方法：格式化，组件提取等</li><li>#calendars：类似于#dates但是java.util.Calendar对象。</li><li>#numbers：用于格式化数字对象的方法。</li><li>#strings：String对象的方法：contains，startsWith，prepending / appending等</li><li>#objects：一般对象的方法。</li><li>#bools：布尔评估的方法。</li><li>#arrays：数组方法。</li><li>#lists：列表的方法。</li><li>#sets：集合的方法。</li><li>#maps：地图方法。</li><li>#aggregates：在数组或集合上创建聚合的方法。</li><li>#ids：处理可能重复的id属性的方法（例如，作为迭代的结果）。</li></ul><p>这是一些内置对象以及工具方法，使用方式也都比较容易，如果使用的是 IntelliJ IDEA，都会自动提示对象中的方法，很方便。</p><p>举例：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#execInfo.getProcessedTemplateName()&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#arrays.length(#request.getAttribute(&#x27;names&#x27;))&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="1-3-2-设置属性值"><a href="#1-3-2-设置属性值" class="headerlink" title="1.3.2 设置属性值"></a>1.3.2 设置属性值</h4><p>这个是给 HTML 元素设置属性值。可以一次设置多个，多个之间用 <code>,</code> 分隔开。</p><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:attr</span>=<span class="hljs-string">&quot;src=@&#123;/1.png&#125;,title=$&#123;user.username&#125;,alt=$&#123;user.username&#125;&quot;</span>&gt;</span></code></pre></div><p>会被渲染成：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/myapp/1.png&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;javaboy&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;javaboy&quot;</span>&gt;</span></code></pre></div><p>当然这种设置方法不太美观，可读性也不好。Thymeleaf 还支持在每一个原生的 HTML 属性前加上 th: 前缀的方式来使用动态值，像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/1.png&#125;&quot;</span> <span class="hljs-attr">th:alt</span>=<span class="hljs-string">&quot;$&#123;user.username&#125;&quot;</span> <span class="hljs-attr">th:title</span>=<span class="hljs-string">&quot;$&#123;user.username&#125;&quot;</span>&gt;</span></code></pre></div><p>这种写法看起来更清晰一些，渲染效果和前面一致。</p><p>上面案例中的 alt 和 title 则是两个特殊的属性，可以一次性设置，像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/1.png&#125;&quot;</span> <span class="hljs-attr">th:alt-title</span>=<span class="hljs-string">&quot;$&#123;user.username&#125;&quot;</span>&gt;</span></code></pre></div><p>这个等价于前文的设置。</p><h4 id="1-3-3-遍历"><a href="#1-3-3-遍历" class="headerlink" title="1.3.3 遍历"></a>1.3.3 遍历</h4><p>数组/集合/Map/Enumeration/Iterator 等的遍历也算是一个非常常见的需求，Thymeleaf 中通过 th:each 来实现遍历，像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;u : $&#123;users&#125;&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><p>users 是要遍历的集合/数组，u 则是集合中的单个元素。</p><p>遍历的时候，我们可能需要获取遍历的状态，Thymeleaf 也对此提供了支持：</p><ul><li>index：当前的遍历索引，从0开始。</li><li>count：当前的遍历索引，从1开始。</li><li>size：被遍历变量里的元素数量。</li><li>current：每次遍历的遍历变量。</li><li>even/odd：当前的遍历是偶数次还是奇数次。</li><li>first：当前是否为首次遍历。</li><li>last：当前是否为最后一次遍历。</li></ul><p>u 后面的 state 表示遍历状态，通过遍历状态可以引用上面的属性。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;u,state : $&#123;users&#125;&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.index&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.count&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.size&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.current&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.even&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.first&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.last&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><h4 id="1-3-4-分支语句"><a href="#1-3-4-分支语句" class="headerlink" title="1.3.4 分支语句"></a>1.3.4 分支语句</h4><p>只显示奇数次的遍历，可以使用 th:if，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;u,state : $&#123;users&#125;&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.index&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.count&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.size&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.current&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.even&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.first&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.last&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><p>th:if 不仅仅只接受布尔值，也接受其他类型的值，例如如下值都会判定为 true：</p><ul><li>如果值是布尔值，并且为 true。</li><li>如果值是数字，并且不为 0。</li><li>如果值是字符，并且不为 0。</li><li>如果值是字符串，并且不为 “false”， “off” 或者 “no”。</li><li>如果值不是布尔值，数字，字符或者字符串。</li></ul><p>但是如果值为 null，th:if 会求值为 false。</p><p>th:unless 的判定条件则与 th:if 完全相反。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;u,state : $&#123;users&#125;&quot;</span> <span class="hljs-attr">th:unless</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.index&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.count&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.size&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.current&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.even&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.first&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.last&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><p>这个显示效果则与上面的完全相反。</p><p>当可能性比较多的时候，也可以使用 switch：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;u,state : $&#123;users&#125;&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.index&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.count&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.size&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.current&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.even&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.first&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.last&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>odd<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;*&quot;</span>&gt;</span>even<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><p><code>th:case=&quot;*&quot;</code> 则表示默认选项。</p><h4 id="1-3-5-本地变量"><a href="#1-3-5-本地变量" class="headerlink" title="1.3.5 本地变量"></a>1.3.5 本地变量</h4><p>这个我们前面已经涉及到了，使用 th:with 可以定义一个本地变量。</p><h4 id="1-3-6-内联"><a href="#1-3-6-内联" class="headerlink" title="1.3.6 内联"></a>1.3.6 内联</h4><p>我们可以使用属性将数据放入页面模版中，但是很多时候，内联的方式看起来更加直观一些，像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello [[$&#123;user.username&#125;]]<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>用内联的方式去做拼接也显得更加自然。</p><p><code>[[...]]</code> 对应于 th:text （结果会是转义的 HTML），<code>[(...)]</code>对应于 th:utext，它不会执行任何的 HTML 转义。</p><p>像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;str=&#x27;hello &lt;strong&gt;javaboy&lt;/strong&gt;&#x27;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>[[$&#123;str&#125;]]<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>[($&#123;str&#125;)]<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>最终的显示效果如下：</p><p><a href="http://img.itboyhub.com/2020/20201215210604.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201215210604.png" alt="img"></a></p><p>不过内联方式有一个问题。我们使用 Thymeleaf 的一大优势在于不用动态渲染就可以直接在浏览器中看到显示效果，当我们使用属性配置的时候确实是这样，但是如果我们使用内联的方式，各种表达式就会直接展示在静态网页中。</p><p>也可以在 js 或者 css 中使用内联，以 js 为例，js 中需要通过 <code>th:inline=&quot;javascript&quot;</code> 开启内联</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">var</span> username=[[$&#123;user.username&#125;]]</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(username)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>大家在网上可能都看到过一些代码生成工具，很酷！MyBatis、Service、Controller、Model 全部都可以自动生成。</p><p>这些工具的实现其实非常 Easy，只要熟悉 JDBC API 和任意一种页面模版就可以实现。今天松哥就尝试使用 Freemarker 做一个简单的案例，带大家揭开代码生成工具的神秘面纱。</p><p>我们先来看看 Spring Boot 整合 Freemarker，然后再来看看如何实现自动生成代码。</p><h2 id="2-Freemarker"><a href="#2-Freemarker" class="headerlink" title="2. Freemarker"></a>2. Freemarker</h2><p>这是一个相当老牌的开源的免费的模版引擎，基于Apache许可证2.0版本发布。</p><p>通过 Freemarker 模版，我们可以将数据渲染成 HTML 网页、电子邮件、配置文件以及源代码等。Freemarker 不是面向最终用户的，而是一个 Java 类库，我们可以将之作为一个普通的组件嵌入到我们的产品中。</p><p>来看一张来自 Freemarker 官网的图片：</p><p><a href="http://img.itboyhub.com/2020/10-1.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/10-1-20210521175030210.png" alt="img"></a></p><p>可以看到，Freemarker 可以将模版和数据渲染成 HTML 。</p><p>Freemarker 模版后缀为 <code>.ftlh</code>(FreeMarker Template Language)。FTL 是一种简单的、专用的语言，它不是像 Java 那样成熟的编程语言。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。</p><h3 id="2-1-整合-Spring-Boot"><a href="#2-1-整合-Spring-Boot" class="headerlink" title="2.1  整合 Spring Boot"></a>2.1  整合 Spring Boot</h3><p>在 SSM 中整合 Freemarker ，所有的配置文件加起来，前前后后大约在 50 行左右，Spring Boot 中要几行配置呢？ 0 行！</p><h4 id="2-1-1-创建工程"><a href="#2-1-1-创建工程" class="headerlink" title="2.1.1 创建工程"></a>2.1.1 创建工程</h4><p>首先创建一个 Spring Boot 工程，引入 Freemarker 依赖，如下图：</p><p><a href="http://img.itboyhub.com/2020/20201217125112.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217125112.png" alt="img"></a></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>工程创建完成后，在 <code>org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration</code> 类中，可以看到关于 Freemarker 的自动化配置：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><span class="hljs-meta">@ConditionalOnClass(&#123; freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class &#125;)</span><span class="hljs-meta">@EnableConfigurationProperties(FreeMarkerProperties.class)</span><span class="hljs-meta">@Import(&#123; FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class,</span><span class="hljs-meta">FreeMarkerNonWebConfiguration.class &#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerAutoConfiguration</span> </span>&#123;&#125;</code></pre></div><p>从这里可以看出，当 <code>classpath</code> 下存在 <code>freemarker.template.Configuration</code> 以及 <code>FreeMarkerConfigurationFactory</code> 时，配置才会生效，也就是说当我们引入了 <code>Freemarker</code> 之后，配置就会生效。但是这里的自动化配置只做了模板位置检查，其他配置则是在导入的 <code>FreeMarkerServletWebConfiguration</code> 配置中完成的。那么我们再来看看 <code>FreeMarkerServletWebConfiguration</code> 类，部分源码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><span class="hljs-meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, FreeMarkerConfigurer.class &#125;)</span><span class="hljs-meta">@AutoConfigureAfter(WebMvcAutoConfiguration.class)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerServletWebConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFreeMarkerConfiguration</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">FreeMarkerServletWebConfiguration</span><span class="hljs-params">(FreeMarkerProperties properties)</span> </span>&#123;<span class="hljs-keyword">super</span>(properties);&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean(FreeMarkerConfig.class)</span><span class="hljs-function">FreeMarkerConfigurer <span class="hljs-title">freeMarkerConfigurer</span><span class="hljs-params">()</span> </span>&#123;FreeMarkerConfigurer configurer = <span class="hljs-keyword">new</span> FreeMarkerConfigurer();applyProperties(configurer);<span class="hljs-keyword">return</span> configurer;&#125;<span class="hljs-meta">@Bean</span>freemarker.template.<span class="hljs-function">Configuration <span class="hljs-title">freeMarkerConfiguration</span><span class="hljs-params">(FreeMarkerConfig configurer)</span> </span>&#123;<span class="hljs-keyword">return</span> configurer.getConfiguration();&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;freeMarkerViewResolver&quot;)</span><span class="hljs-meta">@ConditionalOnProperty(name = &quot;spring.freemarker.enabled&quot;, matchIfMissing = true)</span><span class="hljs-function">FreeMarkerViewResolver <span class="hljs-title">freeMarkerViewResolver</span><span class="hljs-params">()</span> </span>&#123;FreeMarkerViewResolver resolver = <span class="hljs-keyword">new</span> FreeMarkerViewResolver();getProperties().applyToMvcViewResolver(resolver);<span class="hljs-keyword">return</span> resolver;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnEnabledResourceChain</span><span class="hljs-meta">@ConditionalOnMissingFilterBean(ResourceUrlEncodingFilter.class)</span><span class="hljs-function">FilterRegistrationBean&lt;ResourceUrlEncodingFilter&gt; <span class="hljs-title">resourceUrlEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;FilterRegistrationBean&lt;ResourceUrlEncodingFilter&gt; registration = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;(<span class="hljs-keyword">new</span> ResourceUrlEncodingFilter());registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ERROR);<span class="hljs-keyword">return</span> registration;&#125;&#125;</code></pre></div><p>我们来简单看下这段源码：</p><ul><li>@ConditionalOnWebApplication 表示当前配置在 web 环境下才会生效。</li><li>ConditionalOnClass 表示当前配置在存在 Servlet 和 FreeMarkerConfigurer 时才会生效。</li><li>@AutoConfigureAfter 表示当前自动化配置在 WebMvcAutoConfiguration 之后完成。</li><li>代码中，主要提供了 FreeMarkerConfigurer 和 FreeMarkerViewResolver。</li><li>FreeMarkerConfigurer 是 Freemarker 的一些基本配置，例如 templateLoaderPath、defaultEncoding 等</li><li>FreeMarkerViewResolver 则是视图解析器的基本配置，包含了viewClass、suffix、allowRequestOverride、allowSessionOverride 等属性。</li></ul><p>另外还有一点，在这个类的构造方法中，注入了 FreeMarkerProperties：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.freemarker&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">&quot;.ftlh&quot;</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Well-known FreeMarker keys which are passed to FreeMarker&#x27;s Configuration.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();&#125;</code></pre></div><p>FreeMarkerProperties 中则配置了 Freemarker 的基本信息，例如模板位置在 <code>classpath:/templates/</code> ，再例如模板后缀为 <code>.ftlh</code>，那么这些配置我们以后都可以在 application.properties 中进行修改。</p><p>如果我们在 SSM 的 XML 文件中自己配置 Freemarker ，也不过就是配置这些东西。现在，这些配置由 FreeMarkerServletWebConfiguration 帮我们完成了。</p><h4 id="2-1-2-创建类"><a href="#2-1-2-创建类" class="headerlink" title="2.1.2 创建类"></a>2.1.2 创建类</h4><p>首先我们来创建一个 User 类，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String address;    <span class="hljs-comment">//省略 getter/setter</span>&#125;</code></pre></div><p>再来创建 <code>UserController</code>：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/index&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            User user = <span class="hljs-keyword">new</span> User();            user.setId((<span class="hljs-keyword">long</span>) i);            user.setUsername(<span class="hljs-string">&quot;javaboy&gt;&gt;&gt;&gt;&quot;</span> + i);            user.setAddress(<span class="hljs-string">&quot;www.javaboy.org&gt;&gt;&gt;&gt;&quot;</span> + i);            users.add(user);        &#125;        model.addAttribute(<span class="hljs-string">&quot;users&quot;</span>, users);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;    &#125;&#125;</code></pre></div><p>最后在 freemarker 中渲染数据，创建<code>index.ftlh</code></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户编号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    &lt;#list users as user&gt;        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    &lt;/#list&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>运行效果如下：</p><p><a href="http://img.itboyhub.com/2020/10-3.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/10-3.png" alt="img"></a></p><h4 id="2-1-3-其他配置"><a href="#2-1-3-其他配置" class="headerlink" title="2.1.3 其他配置"></a>2.1.3 其他配置</h4><p>如果我们要修改模版文件位置等，可以在 application.properties 中进行配置：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.freemarker.allow-request-override</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.freemarker.allow-session-override</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.freemarker.cache</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.freemarker.charset</span>=<span class="hljs-string">UTF-8</span><span class="hljs-meta">spring.freemarker.check-template-location</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.freemarker.content-type</span>=<span class="hljs-string">text/html</span><span class="hljs-meta">spring.freemarker.expose-request-attributes</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.freemarker.expose-session-attributes</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.freemarker.suffix</span>=<span class="hljs-string">.ftl</span><span class="hljs-meta">spring.freemarker.template-loader-path</span>=<span class="hljs-string">classpath:/templates/</span></code></pre></div><p>配置文件按照顺序依次解释如下：</p><ul><li>HttpServletRequest的属性是否可以覆盖controller中model的同名项</li><li>HttpSession的属性是否可以覆盖controller中model的同名项</li><li>是否开启缓存</li><li>模板文件编码</li><li>是否检查模板位置</li><li>Content-Type的值</li><li>是否将HttpServletRequest中的属性添加到Model中</li><li>是否将HttpSession中的属性添加到Model中</li><li>模板文件后缀</li><li>模板文件位置</li></ul><p>好了，整合完成之后，Freemarker 的更多用法，就和在 SSM 中使用 Freemarker 一样了</p><h3 id="2-2-Freemarker-使用细节"><a href="#2-2-Freemarker-使用细节" class="headerlink" title="2.2 Freemarker 使用细节"></a>2.2 Freemarker 使用细节</h3><h4 id="2-2-1-插值与表达式"><a href="#2-2-1-插值与表达式" class="headerlink" title="2.2.1 插值与表达式"></a>2.2.1 插值与表达式</h4><h5 id="直接输出值"><a href="#直接输出值" class="headerlink" title="直接输出值"></a>直接输出值</h5><p><strong>字符串</strong></p><p>可以直接输出一个字符串：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;hello，我是直接输出的字符串&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;我的文件保存在C:\\盘&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>\ 需要进行转义。</p><p>如果感觉转义太麻烦，可以在目标字符串的引号前增加 r 标记,在 r 标记后的文本内容将会直接输出，像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;r&quot;我的文件保存在C:\盘&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>数字</strong></p><p>在 FreeMarker 中使用数值需要注意以下几点:</p><ol><li>数值不能省略小数点前面的0，所以”.5”是错误的写法。</li><li>数值 8 , +8 , 8.00 都是相同的。</li></ol><p>数字还有一些其他的玩法：</p><ul><li>将数字以钱的形式展示：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#assign num=99&gt;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;num?string.currency&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><code>&lt;#assign num=99&gt;</code> 表示定义了一个变量 num，值为 99。最终的展示形式是在数字前面出现了一个人民币符号：</p><p><a href="http://img.itboyhub.com/2020/20201217155655.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217155655.png" alt="img"></a></p><ul><li>将数字以百分数的形式展示：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;num?string.percent&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>展示效果如下：</p><p><a href="http://img.itboyhub.com/2020/20201217160444.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217160444.png" alt="img"></a></p><p><strong>布尔</strong></p><p>布尔类型可以直接定义，不需要引号，像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#assign flag=true&gt;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;flag?string(&quot;a&quot;,&quot;b&quot;)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>首先使用 <code>&lt;#assign flag=true&gt;</code> 定义了一个 Boolean 类型的变量，然后在 div 中展示，如果 flag 为 true，则输出 a，否则输出 b。</p><p><strong>集合</strong></p><p>集合也可以现场定义现场输出，例如如下方式定义一个 List 集合并显示出来：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;    $&#123;x&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>&lt;/#list&gt;</code></pre></div><p>x 代表集合中的每一个元素，最终显示效果如下：</p><p><a href="http://img.itboyhub.com/2020/20201217161426.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217161426.png" alt="img"></a></p><p>集合中的元素也可以是一个表达式：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#list [2+2,&quot;javaboy&quot;] as x&gt;    $&#123;x&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>&lt;/#list&gt;</code></pre></div><p>集合中的第一个元素就是 2+2 的结果，即 4。</p><p>也可以用 <code>1..5</code> 表示 1 到 5，<code>5..1</code> 表示 5 到 1，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#list 5..1 as x&gt;    $&#123;x&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>&lt;/#list&gt;&lt;#list 1..5 as x&gt;    $&#123;x&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>&lt;/#list&gt;</code></pre></div><p>也可以定义 Map 集合，Map 集合用一个 <code>&#123;&#125;</code> 来描述：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#list &#123;&quot;name&quot;:&quot;javaboy&quot;,&quot;address&quot;:&quot;www.javaboy.org&quot;&#125;?keys as x&gt;$&#123;x&#125;&lt;/#list&gt;&lt;#list &#123;&quot;name&quot;:&quot;javaboy&quot;,&quot;address&quot;:&quot;www.javaboy.org&quot;&#125;?values as x&gt;$&#123;x&#125;&lt;/#list&gt;</code></pre></div><p>上面两个循环分别表示遍历 Map 中的 key 和 values。</p><h5 id="输出变量"><a href="#输出变量" class="headerlink" title="输出变量"></a>输出变量</h5><p>创建一个 HelloController，然后添加如下方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            User u = <span class="hljs-keyword">new</span> User();            u.setUsername(<span class="hljs-string">&quot;javaboy:&quot;</span> + i);            u.setAddress(<span class="hljs-string">&quot;www.javaboy.org:&quot;</span> + i);            users.add(u);        &#125;        Map&lt;String, Object&gt; info = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        info.put(<span class="hljs-string">&quot;site&quot;</span>, <span class="hljs-string">&quot;http://www.itboyhub.com&quot;</span>);        info.put(<span class="hljs-string">&quot;wechat&quot;</span>, <span class="hljs-string">&quot;a_java_boy&quot;</span>);        info.put(<span class="hljs-string">&quot;github&quot;</span>, <span class="hljs-string">&quot;https://github.com/lenve&quot;</span>);        model.addAttribute(<span class="hljs-string">&quot;users&quot;</span>, users);        model.addAttribute(<span class="hljs-string">&quot;info&quot;</span>, info);        model.addAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;江南一点雨&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;&#125;</code></pre></div><p>接下来我们在模版文件中对这里的普通变量、List 集合以及 Map 分别进行展示。</p><p><strong>普通变量</strong></p><p>普通变量的展示很容易，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>集合</strong></p><p>集合的展示就有很多不同的玩法了。</p><p>直接遍历：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>        &lt;#list users as u&gt;            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        &lt;/#list&gt;    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>输出集合中第三个元素：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    $&#123;users[3].username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>输出集合中第 4-6 个元素，即子集合：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>        &lt;#list users[3..5] as u&gt;            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        &lt;/#list&gt;    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>遍历时，可以通过 <code>变量_index</code> 获取遍历的下标：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>        &lt;#list users[3..5] as u&gt;            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u_index&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        &lt;/#list&gt;    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>Map</strong></p><p>直接获取 Map 中的值有不同的写法，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;info.wechat&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;info[&#x27;site&#x27;]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>获取 Map 中的所有 key，并根据 key 获取 value：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    &lt;#list info?keys as key&gt;        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;key&#125;--$&#123;info[key]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    &lt;/#list&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>获取 Map 中的所有 value：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    &lt;#list info?values as value&gt;        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    &lt;/#list&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><p>字符串的拼接有两种方式：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;hello $&#123;name&#125;&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;hello &quot;+ name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>也可以从字符串中截取子串：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;name[0]&#125;$&#123;name[1]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;name[0..2]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>最终显示效果如下：</p><p><a href="http://img.itboyhub.com/2020/20201217200637.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217200637.png" alt="img"></a></p><h5 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h5><p>集合或者 Map 都可以相加。</p><p>集合相加：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    &lt;#list [&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;] + [&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;] as x&gt;        $&#123;x&#125;    &lt;/#list&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>Map 相加：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    &lt;#list (info+&#123;&quot;gitee&quot;:&quot;https://gitee.com/lenve&quot;&#125;)?keys as key&gt;        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;key&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    &lt;/#list&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p><code>+</code>、<code>—</code>、<code>*</code>、<code>/</code>、<code>%</code> 运算都是支持的。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    &lt;#assign age=99&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;age*99/99+99-1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h5 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h5><p>比较运算和 Thymeleaf 比较类似:</p><ul><li>= 或者 == 判断两个值是否相等。</li><li>!= 判断两个值是否不等。</li><li><code>&gt;</code> 或者 gt 判断左边值是否大于右边值。</li><li><code>&gt;=</code> 或者 gte 判断左边值是否大于等于右边值。</li><li><code>&lt;</code> 或者 lt 判断左边值是否小于右边值。</li><li><code>&lt;=</code> 或者 lte 判断左边值是否小于等于右边值。</li></ul><p>可以看到，带 <code>&lt;</code> 或者 <code>&gt;</code> 的符号，也都有别名，建议使用别名。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    &lt;#assign age=99&gt;    &lt;#if age=99&gt;age=99&lt;/#if&gt;    &lt;#if age gt 99&gt;age gt 99&lt;/#if&gt;    &lt;#if age gte 99&gt;age gte 99&lt;/#if&gt;    &lt;#if age lt 99&gt;age lt 99&lt;/#if&gt;    &lt;#if age lte 99&gt;age lte 99&lt;/#if&gt;    &lt;#if age!=99&gt;age!=99&lt;/#if&gt;    &lt;#if age==99&gt;age==99&lt;/#if&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>逻辑运算符有三个:</p><ul><li>逻辑与 <code>&amp;&amp;</code></li><li>逻辑或 <code>||</code></li><li>逻辑非 <code>!</code></li></ul><p>逻辑运算符只能作用于布尔值,否则将产生错误。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    &lt;#assign age=99&gt;    &lt;#if age=99 &amp;&amp; 1==1&gt;age=99 &amp;&amp; 1==1&lt;/#if&gt;    &lt;#if age=99 || 1==0&gt;age=99 || 1==0&lt;/#if&gt;    &lt;#if !(age gt 99)&gt;!(age gt 99)&lt;/#if&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h5 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h5><p>为了处理缺失变量,Freemarker 提供了两个运算符:</p><ol><li><code>!</code>：指定缺失变量的默认值</li><li><code>??</code>：判断某个变量是否存在</li></ol><p>如果某个变量不存在，则设置其为 javaboy，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!&quot;javaboy&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>如果某个变量不存在，则设置其为空字符串，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>即，<code>!</code> 后面的东西如果省略了，默认就是空字符串。</p><p>判断某个变量是否存在：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!&quot;javaboy&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  &lt;#if aaa??&gt;    aaa    &lt;/#if&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="2-2-2-内建函数"><a href="#2-2-2-内建函数" class="headerlink" title="2.2.2 内建函数"></a>2.2.2 内建函数</h4><p>内建函数涉及到的东西比较多，可以参考官方文档:<a href="http://freemarker.foofun.cn/ref_builtins.html%E3%80%82">http://freemarker.foofun.cn/ref_builtins.html。</a></p><p>这里仅说一些比较常用的内建函数。</p><p><strong>cap_first</strong></p><p>使字符串第一个字母大写：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;hello&quot;?cap_first&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>lower_case</strong></p><p>将字符串转换成小写：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;HELLO&quot;?lower_case&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>upper_case</strong></p><p>将字符串转换成大写：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;hello&quot;?upper_case&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>trim</strong></p><p>去掉字符串前后的空白字符：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot; hello&quot;?trim&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>size</strong></p><p>获取序列中元素的个数：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;users?size&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>int</strong></p><p>取得数字的整数部分,结果带符号：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;3.14?int&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>日期格式化</strong></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;birthday?string(&quot;yyyy-MM-dd&quot;)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="2-2-3-常用指令"><a href="#2-2-3-常用指令" class="headerlink" title="2.2.3 常用指令"></a>2.2.3 常用指令</h4><h5 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h5><p>分支控制指令，作用类似于 Java 语言中的 if：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    &lt;#assign age=23&gt;    &lt;#if (age&gt;60)&gt;老年人    &lt;#elseif (age&gt;40)&gt;中年人    &lt;#elseif (age&gt;20)&gt;青年人    &lt;#else&gt; 少年人    &lt;/#if&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>比较符号中用了 <code>()</code>，因此不用转义。</p><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><p>分支指令，类似于 Java 中的 switch：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    &lt;#assign age=99&gt;    &lt;#switch age&gt;        &lt;#case 23&gt;23&lt;#break&gt;        &lt;#case 24&gt;24&lt;#break&gt;        &lt;#default&gt;9999    &lt;/#switch&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><code>&lt;#break&gt;</code> 是提前退出，也可以用在 <code>&lt;#list&gt;</code> 中。</p><h5 id="include"><a href="#include" class="headerlink" title="include"></a>include</h5><p>include 可以包含一个外部页面进来。</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#include &quot;./javaboy.ftlh&quot;&gt;</code></pre></div><h5 id="macro"><a href="#macro" class="headerlink" title="macro"></a>macro</h5><p>macro 用来定义一个宏。</p><p>我们可以自定义一个名为 book 的宏，并引用它：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#macro book&gt;    三国演义&lt;/#macro&gt;&lt;@book/&gt;</code></pre></div><p>最终页面中会输出宏中所定义的内容。</p><p>在定义宏的时候，也可以传入参数，那么引用时，也需要传入参数：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#macro book bs&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>        &lt;#list bs as b&gt;            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;b&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        &lt;/#list&gt;    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>&lt;/#macro&gt;&lt;@book [&quot;三国演义&quot;,&quot;水浒传&quot;]/&gt;</code></pre></div><p>bs 就是需要传入的参数。可以通过传入多个参数，多个参数跟在 bs 后面即可，中间用空格隔开。</p><p>还可以使用 <code>&lt;#nested&gt;</code> 引入用户自定义指令的标签体，像下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#macro book bs&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>        &lt;#list bs as b&gt;            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;b&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        &lt;/#list&gt;    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>    &lt;#nested&gt;&lt;/#macro&gt;&lt;@book [&quot;三国演义&quot;,&quot;水浒传&quot;]&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello javaboy!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>&lt;/@book&gt;</code></pre></div><p>在宏定义的时候，<code>&lt;#nested&gt;</code> 相当于是一个占位符，在调用的时候，<code>&lt;@book&gt;</code> 标签中的内容会出现在 <code>&lt;#nested&gt;</code> 位置。</p><p>前面的案例中，宏都是定义在当前页面中，宏也可以定义在一个专门的页面中。新建<code>myjavaboy.ftlh</code>页面，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#macro book bs&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>        &lt;#list bs as b&gt;            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;b&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        &lt;/#list&gt;    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>    &lt;#nested&gt;&lt;/#macro&gt;</code></pre></div><p>此时，需要先通过 <code>&lt;#import&gt;</code> 标签导入宏，然后才能调用，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#import &quot;./myjavaboy.ftlh&quot; as com&gt;&lt;@com.book bs=[&quot;三国演义&quot;,&quot;水浒传&quot;]&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello javaboy!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>&lt;/@com.book&gt;</code></pre></div><h5 id="noparse"><a href="#noparse" class="headerlink" title="noparse"></a>noparse</h5><p>如果想在页面展示一些 Freemarker 语法而不被渲染，则可以使用 noparse 标签，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#noparse&gt;&lt;#import &quot;./myjavaboy.ftlh&quot; as com&gt;&lt;@com.book bs=[&quot;三国演义&quot;,&quot;水浒传&quot;]&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello javaboy!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>&lt;/@com.book&gt;&lt;/#noparse&gt;</code></pre></div><p>显示效果如下：</p><p><a href="http://img.itboyhub.com/2020/20201217214402.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217214402.png" alt="img"></a></p><p><strong>如果要同时使用Thymeleaf，要把Freemarker的pom依赖放在前面</strong></p><h1 id="SpringBoot整合Web"><a href="#SpringBoot整合Web" class="headerlink" title="SpringBoot整合Web"></a>SpringBoot整合Web</h1><h2 id="1-SpringBoot中的JSON"><a href="#1-SpringBoot中的JSON" class="headerlink" title="1. SpringBoot中的JSON"></a>1. SpringBoot中的JSON</h2><p>具体的JSON用法可以[参考SringMVC](#11. JSON)中的介绍，这里补充几点</p><h3 id="1-1-Jackson"><a href="#1-1-Jackson" class="headerlink" title="1.1 Jackson"></a>1.1 Jackson</h3><p>SpringBoot默认就有，不需要额外引入<code>pom.xml</code>的依赖</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//批量忽略字段</span><span class="hljs-meta">@JsonIgnoreProperties(&#123;&quot;birthday&quot;,&quot;address&quot;&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-comment">//指定属性序列化/反序列化时的名称，默认名称就是属性名</span>    <span class="hljs-meta">@JsonProperty(value = &quot;aaaage&quot;,index = 99)</span>    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-meta">@JsonProperty(index = 98)</span>    <span class="hljs-keyword">private</span> String username;<span class="hljs-meta">@JsonProperty(index = 97)</span>    <span class="hljs-comment">//日期格式化，注意时区问题</span><span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;Asia/Shanghai&quot;)</span>    <span class="hljs-comment">//类似于 @JsonProperty 中的 index</span>    <span class="hljs-meta">@JsonPropertyOrder</span>    <span class="hljs-keyword">private</span> Date birthday;    <span class="hljs-comment">//序列化/反序列化时忽略某一个字段</span><span class="hljs-meta">@JsonIgnore</span>    <span class="hljs-keyword">private</span> String address;</code></pre></div><p>自己提供一个<code>ObjectMapper</code>实例，就不用每个实体类上添加</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">ObjectMapper <span class="hljs-title">objectMapper</span><span class="hljs-params">()</span> </span>&#123;        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();        om.setDateFormat(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));        <span class="hljs-keyword">return</span> om;    &#125;&#125;</code></pre></div><h3 id="1-2-Gson"><a href="#1-2-Gson" class="headerlink" title="1.2 Gson"></a>1.2 Gson</h3><p>在<code>pom.xml</code>里排除默认的依赖再引入</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><code>application.properties</code>里的配置</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.gson.date-format</span>=<span class="hljs-string">yyyy-MM-dd HH:mm:ss</span><span class="hljs-comment">## 是否禁用 HTML 的转义字符</span><span class="hljs-meta">spring.gson.disable-html-escaping</span>=<span class="hljs-string">true</span><span class="hljs-comment">## 序列化时是否排除内部类</span><span class="hljs-meta">spring.gson.disable-inner-class-serialization</span>=<span class="hljs-string">false</span><span class="hljs-comment">## 序列化时是否弃用复杂映射键</span><span class="hljs-meta">spring.gson.enable-complex-map-key-serialization</span>=<span class="hljs-string"></span><span class="hljs-comment">## 是否排除没有 @Expose 注解的字段</span><span class="hljs-meta">spring.gson.exclude-fields-without-expose-annotation</span>=<span class="hljs-string"></span><span class="hljs-comment">## 序列化时字段名的命名策略</span><span class="hljs-meta">spring.gson.field-naming-policy</span>=<span class="hljs-string"></span><span class="hljs-comment">## 在输出之前添加一些特殊的文本来生成一个不可执行的 JSON</span><span class="hljs-meta">spring.gson.generate-non-executable-json</span>=<span class="hljs-string"></span><span class="hljs-comment">## 是否序列化空字段</span><span class="hljs-meta">spring.gson.serialize-nulls</span>=<span class="hljs-string"></span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/user&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setUsername(<span class="hljs-string">&quot;javaboy&quot;</span>);        user.setBirthday(<span class="hljs-keyword">new</span> Date());        <span class="hljs-keyword">return</span> user;    &#125;&#125;<span class="hljs-comment">//同理于jackson的ObjectMapper</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">GsonBuilder <span class="hljs-title">gsonBuilder</span><span class="hljs-params">()</span> </span>&#123;        GsonBuilder gsonBuilder = <span class="hljs-keyword">new</span> GsonBuilder();        gsonBuilder.setDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);        <span class="hljs-keyword">return</span> gsonBuilder;    &#125;  <span class="hljs-comment">//或者</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">GsonHttpMessageConverter <span class="hljs-title">gsonHttpMessageConverter</span><span class="hljs-params">()</span> </span>&#123;        GsonBuilder gsonBuilder = <span class="hljs-keyword">new</span> GsonBuilder();        gsonBuilder.setDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);        GsonHttpMessageConverter converter = <span class="hljs-keyword">new</span> GsonHttpMessageConverter();        converter.setGson(gsonBuilder.create());        <span class="hljs-keyword">return</span> converter;    &#125;&#125;</code></pre></div><h3 id="1-3-fastjson"><a href="#1-3-fastjson" class="headerlink" title="1.3 fastjson"></a>1.3 fastjson</h3><p>在<code>pom.xml</code>里排除默认的依赖再引入</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.75<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>Spring没有给它提供<code>FastJsonHttpMessageConverter</code>，必须要自己提供</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">FastJsonHttpMessageConverter <span class="hljs-title">fastJsonHttpMessageConverter</span><span class="hljs-params">()</span> </span>&#123;        FastJsonHttpMessageConverter converter = <span class="hljs-keyword">new</span> FastJsonHttpMessageConverter();        FastJsonConfig fastJsonConfig = <span class="hljs-keyword">new</span> FastJsonConfig();        fastJsonConfig.setCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));        fastJsonConfig.setDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        converter.setFastJsonConfig(fastJsonConfig);        converter.setDefaultCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));        <span class="hljs-keyword">return</span> converter;    &#125;&#125;<span class="hljs-comment">//或者</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;        FastJsonHttpMessageConverter converter = <span class="hljs-keyword">new</span> FastJsonHttpMessageConverter();        FastJsonConfig fastJsonConfig = <span class="hljs-keyword">new</span> FastJsonConfig();        fastJsonConfig.setCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));        fastJsonConfig.setDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        converter.setFastJsonConfig(fastJsonConfig);        converter.setDefaultCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));        converters.add(converter);    &#125;&#125;</code></pre></div><h2 id="2-静态资源配置"><a href="#2-静态资源配置" class="headerlink" title="2. 静态资源配置"></a>2. 静态资源配置</h2><h3 id="2-1-SSM-中的配置"><a href="#2-1-SSM-中的配置" class="headerlink" title="2.1 SSM 中的配置"></a>2.1 SSM 中的配置</h3><p>要讲 Spring Boot 中的问题，我们得先回到 SSM 环境搭建中，一般来说，我们可以通过 <code>&lt;mvc:resources /&gt;</code> 节点来配置不拦截静态资源，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/js/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/js/&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/css/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/css/&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/html/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/html/&quot;</span>/&gt;</span></code></pre></div><p>由于这是一种Ant风格的路径匹配符，<code>/**</code> 表示可以匹配任意层级的路径，因此上面的代码也可以像下面这样简写：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/&quot;</span>/&gt;</span></code></pre></div><p>这种配置是在 XML 中的配置，大家知道，SpringMVC 的配置除了在XML中配置，也可以在 Java 代码中配置，如果在Java代码中配置的话，我们只需要自定义一个类，继承自WebMvcConfigurationSupport即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.sang.javassm&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;        registry.addResourceHandler(<span class="hljs-string">&quot;/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;/&quot;</span>);    &#125;&#125;</code></pre></div><p>重写 WebMvcConfigurationSupport 类中的addResourceHandlers方法，在该方法中配置静态资源位置即可，这里的含义和上面 xml 配置的含义一致，因此无需多说。<br>这是我们传统的解决方案，在Spring Boot 中，其实配置方式和这个一脉相承，只是有一些自动化的配置了。</p><h3 id="2-2-Spring-Boot-中的配置"><a href="#2-2-Spring-Boot-中的配置" class="headerlink" title="2.2 Spring Boot 中的配置"></a>2.2 Spring Boot 中的配置</h3><p>在 Spring Boot 中，如果我们是从 <code>https://start.spring.io</code> 这个网站上创建的项目，或者使用 IntelliJ IDEA 中的 Spring Boot 初始化工具创建的项目，默认都会存在<code>resources/static</code>目录，很多小伙伴也知道静态资源只要放到这个目录下，就可以直接访问，除了这里还有没有其他可以放静态资源的位置呢？为什么放在这里就能直接访问了呢？这就是本文要讨论的问题了。</p><h4 id="2-2-1-整体规划"><a href="#2-2-1-整体规划" class="headerlink" title="2.2.1 整体规划"></a>2.2.1 整体规划</h4><p>首先，在 Spring Boot 中，默认情况下，一共有5个位置可以放静态资源，五个路径分别是如下5个：</p><ul><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public/</li><li>/</li></ul><p>前四个目录好理解，分别对应了resources目录下不同的目录，第5个 <code>/</code> 是啥意思呢？我们知道，在 Spring Boot 项目中，默认是没有 webapp 这个目录的，当然我们也可以自己添加（例如在需要使用JSP的时候），这里第5个 <code>/</code>其实就是表示 webapp 目录中的静态资源也不被拦截。如果同一个文件分别出现在五个目录下，那么优先级也是按照上面列出的顺序。</p><p>不过，虽然有5个存储目录，除了第5个用的比较少之外，其他四个，系统默认创建了 <code>classpath:/static/</code> ， 正常情况下，我们只需要将我们的静态资源放到这个目录下即可，也不需要额外去创建其他静态资源目录，例如我在 <code>classpath:/static/</code> 目录下放了一张名为1.png 的图片，那么我的访问路径是：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8080</span>/<span class="hljs-number">1</span>.png</code></pre></div><p>这里大家注意，请求地址中并不需要 <code>static</code>，如果加上了<code>static</code>反而多此一举会报404错误。很多人会觉得奇怪，为什么不需要添加<code> static</code>呢？资源明明放在 <code>static </code>目录下。其实这个效果很好实现，例如在SSM配置中，我们的静态资源拦截配置如果是下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/&quot;</span>/&gt;</span></code></pre></div><p>如果我们是这样配置的话，请求地址如果是 <code>http://localhost:8080/1.png</code> 实际上系统会去 <code>/static/1.png</code> 目录下查找相关的文件。</p><p>所以我们理所当然的猜测，在 Spring Boot 中可能也是类似的配置。</p><h4 id="2-2-2-源码解读"><a href="#2-2-2-源码解读" class="headerlink" title="2.2.2 源码解读"></a>2.2.2 源码解读</h4><p>胡适之先生说：“大胆猜想，小心求证”，我们这里就通过源码解读来看看 Spring Boot 中的静态资源到底是怎么配置的。</p><p>首先我们在 <code>WebMvcAutoConfiguration </code>类中看到了 SpringMVC 自动化配置的相关的内容，找到了静态资源拦截的配置，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/21-1-20210525153453678.png" alt="img"></p><p>可以看到这里静态资源的定义和我们前面提到的Java配置SSM中的配置非常相似，其中，<code>this.mvcProperties.getStaticPathPattern() </code>方法对应的值是 <code>“/**”</code>，<code>this.resourceProperties.getStaticLocations()</code>方法返回了四个位置，分别是：”<code>classpath:/META-INF/resources/”, “classpath:/resources/”,”classpath:/static/”, “classpath:/public/”</code>，然后在<code>getResourceLocations</code>方法中，又添加了<code>“/”</code>，因此这里返回值一共有5个。其中，<code>/</code>表示<code>webapp</code>目录，即webapp中的静态文件也可以直接访问。静态资源的匹配路径按照定义路径优先级依次降低。因此这里的配置和我们前面提到的如出一辙。这样大伙就知道了为什么Spring Boot 中支持5个静态资源位置，同时也明白了为什么静态资源请求路径中不需要<code>/static</code>，因为在路径映射中已经自动的添加上了<code>/static</code>了。</p><h4 id="2-2-3-自定义配置"><a href="#2-2-3-自定义配置" class="headerlink" title="2.2.3 自定义配置"></a>2.2.3 自定义配置</h4><p>当然，这个是系统默认配置，如果我们并不想将资源放在系统默认的这五个位置上，也可以自定义静态资源位置和映射，自定义的方式也有两种，可以通过 application.properties 来定义，也可以在 Java 代码中来定义，下面分别来看。</p><ul><li>application.properties</li></ul><p>在配置文件中定义的方式比较简单，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.resources.static-locations</span>=<span class="hljs-string">classpath:/</span><span class="hljs-meta">spring.mvc.static-path-pattern</span>=<span class="hljs-string">/**</span></code></pre></div><p>第一行配置表示定义资源位置，第二行配置表示定义请求 URL 规则。以上文的配置为例，如果我们这样定义了，表示可以将静态资源放在 resources目录下的任意地方，我们访问的时候当然也需要写完整的路径，例如在resources/static目录下有一张名为1.png 的图片，那么访问路径就是 <code>http://localhost:8080/static/1.png</code> ,注意此时的static不能省略。</p><ul><li>Java 代码定义</li></ul><p>当然，在Spring Boot中我们也可以通过 Java代码来自定义，方式和 Java 配置的 SSM 比较类似，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMVCConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;        registry.addResourceHandler(<span class="hljs-string">&quot;/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/aaa/&quot;</span>);    &#125;&#125;</code></pre></div><p>这里需要提醒大家的是，有很多人用了 Thymeleaf 之后，<strong>会将静态资源也放在 resources/templates 目录下，注意，templates 目录并不是静态资源目录，它是一个放页面模板的位置（</strong>你看到的 Thymeleaf 模板虽然后缀为 .html，其实并不是静态资源）</p><h3 id="2-3-路径映射"><a href="#2-3-路径映射" class="headerlink" title="2.3 路径映射"></a>2.3 路径映射</h3><p>利用Controller跳转</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/01&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello01</span><span class="hljs-params">(Model model)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;01&quot;</span>;    &#125;&#125;</code></pre></div><p>利用配置类直接进行</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        registry.addViewController(<span class="hljs-string">&quot;/02&quot;</span>).setViewName(<span class="hljs-string">&quot;02&quot;</span>);    &#125;&#125;</code></pre></div><p>这样就可以在不创建controller的情况下，在url中直接输入02跳转到02.html页面了，但是此方法不支持跳转到动态渲染的页面上，具有一定的局限性</p><h3 id="2-4-自定义首页"><a href="#2-4-自定义首页" class="headerlink" title="2.4 自定义首页"></a>2.4 自定义首页</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        registry.addViewController(<span class="hljs-string">&quot;/index&quot;</span>).setViewName(<span class="hljs-string">&quot;index&quot;</span>);    &#125;&#125;</code></pre></div><p>默认访问的是<code>static</code>下的<code>index.html</code>，如果下面没有，去访问<code>templates</code>下的<code>index.html</code></p><p>如果要定义网站<code>favicon</code>，放置<code>favicon.ico</code>放在<code>static</code>下即可</p><h2 id="3-文件上传"><a href="#3-文件上传" class="headerlink" title="3. 文件上传"></a>3. 文件上传</h2><p>Spring自带的是<code>StandardServletMultipartResolver</code>，创建Controller</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController</span> </span>&#123;    <span class="hljs-comment">//分类处理</span>    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;/yyyy/MM/dd/&quot;</span>);    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span>    <span class="hljs-comment">//file要和html的name值对应</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;        <span class="hljs-comment">//临时目录</span>        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">&quot;/&quot;</span>);        String format = sdf.format(<span class="hljs-keyword">new</span> Date());        String path = realPath + format;        File folder = <span class="hljs-keyword">new</span> File(path);        <span class="hljs-comment">//判空处理</span>        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;            folder.mkdirs();        &#125;        <span class="hljs-comment">//名字后缀</span>        String oldName = file.getOriginalFilename();        <span class="hljs-comment">//前缀</span>        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//拼接</span>            file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));            <span class="hljs-comment">//动态获取</span>            String s = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + format + newName;            <span class="hljs-keyword">return</span> s;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--name属性必须写上,同时要和controller里的对应--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#设置上传文件大小</span><span class="hljs-meta">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">1KB</span></code></pre></div><p><strong>如果要上传多文件</strong>，配置如下</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController2</span> </span>&#123;    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;/yyyy/MM/dd/&quot;</span>);    <span class="hljs-meta">@PostMapping(&quot;/upload2&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile[] files, HttpServletRequest req)</span> </span>&#123;        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">&quot;/&quot;</span>);        String format = sdf.format(<span class="hljs-keyword">new</span> Date());        String path = realPath + format;        File folder = <span class="hljs-keyword">new</span> File(path);        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;            folder.mkdirs();        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (MultipartFile file : files) &#123;                String oldName = file.getOriginalFilename();                String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));                file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));                String s = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + format + newName;                System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload2&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;files&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p><strong>ajax的文件上传</strong></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://code.jquery.com/jquery-3.5.1.js&quot;</span> <span class="hljs-attr">integrity</span>=<span class="hljs-string">&quot;sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc=&quot;</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;uploadFile()&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadFile</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        <span class="hljs-comment">//拿到文件对象</span></span><span class="javascript">        <span class="hljs-keyword">var</span> file = $(<span class="hljs-string">&quot;#file&quot;</span>)[<span class="hljs-number">0</span>].files[<span class="hljs-number">0</span>];</span><span class="javascript">        <span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> FormData();</span><span class="javascript">        formData.append(<span class="hljs-string">&quot;file&quot;</span>, file);</span><span class="javascript">        formData.append(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);</span><span class="javascript">        $.ajax(&#123;</span><span class="javascript">            type:<span class="hljs-string">&#x27;post&#x27;</span>,</span><span class="javascript">            url:<span class="hljs-string">&#x27;/upload&#x27;</span>,</span><span class="javascript">            processData:<span class="hljs-literal">false</span>,</span><span class="javascript">            contentType:<span class="hljs-literal">false</span>,</span>            data:formData,<span class="javascript">            success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span><span class="javascript">                $(<span class="hljs-string">&quot;#result&quot;</span>).html(msg);</span>            &#125;        &#125;)    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h2><p>在 Spring Boot 项目中 ，异常统一处理，可以使用 Spring 中 @ControllerAdvice 来统一处理，也可以自己来定义异常处理方案。Spring Boot 中，对异常的处理有一些默认的策略，我们分别来看。</p><p>默认情况下，Spring Boot 中的异常页面 是这样的：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-1-20210525153453655.png" alt="img"></p><p>我们从这个异常提示中，也能看出来，之所以用户看到这个页面，是因为开发者没有明确提供一个 /error 路径，如果开发者提供了 /error 路径 ，这个页面就不会展示出来，不过在 Spring Boot 中，提供 /error 路径实际上是下下策，Spring Boot 本身在处理异常时，也是当所有条件都不满足时，才会去找 /error 路径。那么我们就先来看看，在 Spring Boot 中，如何自定义 error 页面，整体上来说，可以分为两种，一种是静态页面，另一种是动态页面。</p><h3 id="4-1-静态异常页面"><a href="#4-1-静态异常页面" class="headerlink" title="4.1 静态异常页面"></a>4.1 静态异常页面</h3><p>自定义静态异常页面，又分为两种，第一种 是使用 HTTP 响应码来命名页面，例如<code> 404.html、405.html、500.html ….</code>，另一种就是直接定义一个 <code>4xx.html</code>，表示400-499 的状态都显示这个异常页面，5xx.html 表示 500-599 的状态显示这个异常页面。</p><p>默认是在 <code>classpath:/static/error/</code> 路径下定义相关页面：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-2-20210525153453642.png" alt="img"></p><p>此时，启动项目，如果项目抛出 500 请求错误，就会自动展示 500.html 这个页面，发生 404 就会展示 404.html 页面。如果异常展示页面既存在 5xx.html，也存在 500.html ，此时，发生500异常时，优先展示 500.html 页面</p><h3 id="4-2-动态异常页面"><a href="#4-2-动态异常页面" class="headerlink" title="4.2 动态异常页面"></a>4.2 动态异常页面</h3><p>动态的异常页面定义方式和静态的基本 一致，可以采用的页面模板有 jsp、freemarker、thymeleaf。动态异常页面，也支持 404.html 或者 4xx.html ，但是一般来说，由于动态异常页面可以直接展示异常详细信息，所以就没有必要挨个枚举错误了 ，直接定义 4xx.html（这里使用thymeleaf模板）或者 5xx.html 即可。</p><p><strong>注意，动态页面模板，不需要开发者自己去定义控制器，直接定义异常页面即可 ，Spring Boot 中自带的异常处理器会自动查找到异常页面。</strong></p><p>页面定义如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-3-20210525153453651.png" alt="img"></p><p>页面内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>5xx<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>path<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;path&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;error&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>message<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>timestamp<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;timestamp&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>status<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;status&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>默认情况下，完整的异常信息就是这5条，展示 效果如下 ：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-4-20210525153453654.png" alt="img"></p><p>如果动态页面和静态页面同时定义了异常处理页面，例如 <code>classpath:/static/error/404.html</code> 和 <code>classpath:/templates/error/404.html</code> 同时存在时，默认使用动态页面。即完整的错误页面查找方式应该是这样：</p><p><strong>发生了500错误–&gt;查找动态 500.html 页面–&gt;查找静态 500.html –&gt; 查找动态 5xx.html–&gt;查找静态 5xx.html</strong></p><h3 id="4-3-自定义异常数据"><a href="#4-3-自定义异常数据" class="headerlink" title="4.3 自定义异常数据"></a>4.3 自定义异常数据</h3><p>默认情况下，在Spring Boot 中，所有的异常数据其实就是上文所展示出来的5条数据，这5条数据定义在 <code>org.springframework.boot.web.reactive.error.DefaultErrorAttributes</code> 类中，具体定义在 <code>getErrorAttributes</code> 方法中 ：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getErrorAttributes</span><span class="hljs-params">(ServerRequest request,</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">boolean</span> includeStackTrace)</span> </span>&#123;        Map&lt;String, Object&gt; errorAttributes = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        errorAttributes.put(<span class="hljs-string">&quot;timestamp&quot;</span>, <span class="hljs-keyword">new</span> Date());        errorAttributes.put(<span class="hljs-string">&quot;path&quot;</span>, request.path());        Throwable error = getError(request);        HttpStatus errorStatus = determineHttpStatus(error);        errorAttributes.put(<span class="hljs-string">&quot;status&quot;</span>, errorStatus.value());        errorAttributes.put(<span class="hljs-string">&quot;error&quot;</span>, errorStatus.getReasonPhrase());        errorAttributes.put(<span class="hljs-string">&quot;message&quot;</span>, determineMessage(error));        handleException(errorAttributes, determineException(error), includeStackTrace);        <span class="hljs-keyword">return</span> errorAttributes;&#125;</code></pre></div><p><code>DefaultErrorAttributes </code>类本身则是在<code>org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration </code>异常自动配置类中定义的，如果开发者没有自己提供一个 <code>ErrorAttributes</code> 的实例的话，那么 Spring Boot 将自动提供一个<code>ErrorAttributes</code> 的实例，也就是 <code>DefaultErrorAttributes </code></p><p>基于此 ，开发者自定义 <code>ErrorAttributes </code>有两种方式 ：</p><ul><li>直接实现 <code>ErrorAttributes </code>接口</li><li>继承 <code>DefaultErrorAttributes</code>（推荐），因为<code>DefaultErrorAttributes</code>中对异常数据的处理已经完成，开发者可以直接使用。</li></ul><p>具体定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyErrorAttributes</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultErrorAttributes</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getErrorAttributes</span><span class="hljs-params">(WebRequest webRequest, <span class="hljs-keyword">boolean</span> includeStackTrace)</span> </span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">super</span>.getErrorAttributes(webRequest, includeStackTrace);        <span class="hljs-keyword">if</span> ((Integer)map.get(<span class="hljs-string">&quot;status&quot;</span>) == <span class="hljs-number">500</span>) &#123;            map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;服务器内部错误!&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> map;    &#125;&#125;</code></pre></div><p>定义好的<code>ErrorAttributes</code>一定要注册成一个 Bean ，这样，Spring Boot 就不会使用默认的 <code>DefaultErrorAttributes </code>了，运行效果如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-5-20210525153453655.png" alt="img"></p><h3 id="4-4-自定义异常视图"><a href="#4-4-自定义异常视图" class="headerlink" title="4.4 自定义异常视图"></a>4.4 自定义异常视图</h3><p>异常视图默认就是前面所说的静态或者动态页面，这个也是可以自定义的，首先 ，默认的异常视图加载逻辑在 <code>org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController </code>类的 <code>errorHtml </code>方法中，这个方法用来返回异常页面+数据，还有另外一个 error 方法，这个方法用来返回异常数据（如果是 ajax 请求，则该方法会被触发）。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">errorHtml</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">                HttpServletResponse response)</span> </span>&#123;        HttpStatus status = getStatus(request);        Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(                        request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));        response.setStatus(status.value());        ModelAndView modelAndView = resolveErrorView(request, response, status, model);        <span class="hljs-keyword">return</span> (modelAndView != <span class="hljs-keyword">null</span>) ? modelAndView : <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>, model);&#125;</code></pre></div><p>在该方法中 ，首先会通过 <code>getErrorAttributes</code> 方法去获取异常数据（实际上会调用到 <code>ErrorAttributes </code>的实例 的 <code>getErrorAttributes </code>方法），然后调用<code> resolveErrorView</code> 去创建一个<code> ModelAndView</code> ，如果这里创建失败，那么用户将会看到默认的错误提示页面。</p><p>正常情况下，<code>resolveErrorView</code>方法会来到 <code>DefaultErrorViewResolver </code>类的 <code>resolveErrorView</code> 方法中：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveErrorView</span><span class="hljs-params">(HttpServletRequest request, HttpStatus status,</span></span><span class="hljs-function"><span class="hljs-params">                Map&lt;String, Object&gt; model)</span> </span>&#123;        ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);        <span class="hljs-keyword">if</span> (modelAndView == <span class="hljs-keyword">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;                modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);        &#125;        <span class="hljs-keyword">return</span> modelAndView;&#125;</code></pre></div><p>在这里，首先以异常响应码作为视图名分别去查找动态页面和静态页面，如果没有查找到，则再以 4xx 或者 5xx 作为视图名再去分别查找动态或者静态页面。</p><p>要自定义异常视图解析，也很容易 ，由于<code>DefaultErrorViewResolver</code>是在<code> ErrorMvcAutoConfiguration</code> 类中提供的实例，即开发者没有提供相关实例时，会使用默认的 <code>DefaultErrorViewResolver </code>，开发者提供了自己的<code> ErrorViewResolver</code> 实例后，默认的配置就会失效，因此，自定义异常视图，只需要提供 一个 <code>ErrorViewResolver </code>的实例即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyErrorViewResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultErrorViewResolver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyErrorViewResolver</span><span class="hljs-params">(ApplicationContext applicationContext, ResourceProperties resourceProperties)</span> </span>&#123;        <span class="hljs-keyword">super</span>(applicationContext, resourceProperties);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveErrorView</span><span class="hljs-params">(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;/aaa/123&quot;</span>, model);    &#125;&#125;</code></pre></div><p>实际上，开发者也可以在这里定义异常数据（直接在<code> resolveErrorView</code> 方法重新定义一个 model ，将参数中的model 数据拷贝过去并修改，注意参数中的 model 类型为 <code>UnmodifiableMap</code>，即不可以直接修改），而不需要自定义<code>MyErrorAttributes</code>。定义完成后，提供一个名为123的视图，如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-6-20210525153453660.png" alt="img"></p><p>如此之后，错误试图就算定义成功了。</p><h2 id="5-CORS解决跨域"><a href="#5-CORS解决跨域" class="headerlink" title="5. CORS解决跨域"></a>5. CORS解决跨域</h2><blockquote><p>域：协议+域名/IP/端口</p></blockquote><h3 id="5-1-同源策略"><a href="#5-1-同源策略" class="headerlink" title="5.1 同源策略"></a>5.1 同源策略</h3><p>很多人对跨域有一种误解，以为这是前端的事，和后端没关系，其实不是这样的，说到跨域，就不得不说说浏览器的同源策略。<br>同源策略是由Netscape提出的一个著名的安全策略，它是浏览器最核心也最基本的安全功能，现在所有支持JavaScript的浏览器都会使用这个策略。所谓同源是指协议、域名以及端口要相同。同源策略是基于安全方面的考虑提出来的，这个策略本身没问题，但是我们在实际开发中，由于各种原因又经常有跨域的需求，传统的跨域方案是JSONP，JSONP虽然能解决跨域但是有一个很大的局限性，那就是只支持GET请求，不支持其他类型的请求，而今天我们说的<strong>CORS（跨域源资源共享）（CORS，Cross-origin resource sharing）</strong>是一个W3C标准，它是一份浏览器技术的规范，提供了Web服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，这是JSONP模式的现代版。<br>在Spring框架中，对于CORS也提供了相应的解决方案，今天我们就来看看SpringBoot中如何实现CORS。</p><h3 id="5-2-实践"><a href="#5-2-实践" class="headerlink" title="5.2 实践"></a>5.2 实践</h3><p>首先创建两个普通的SpringBoot项目，第一个命名为<code>provider</code>提供服务，第二个命名为<code>consumer</code>消费服务，第一个配置端口为8080，第二个配置配置为8081，然后在provider上提供两个hello接口，一个get，一个post，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;    <span class="hljs-meta">@PostMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;post hello&quot;</span>;    &#125;&#125;</code></pre></div><p>在<code>consumer</code>的<code>resources/static</code>目录下创建一个html文件，发送一个简单的ajax请求，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;btnClick()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;get_button&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;btnClick2()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;post_button&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">btnClick</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        $.get(<span class="hljs-string">&#x27;http://localhost:8080/hello&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span><span class="javascript">            $(<span class="hljs-string">&quot;#app&quot;</span>).html(msg);</span>        &#125;);    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">btnClick2</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        $.post(<span class="hljs-string">&#x27;http://localhost:8080/hello&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span><span class="javascript">            $(<span class="hljs-string">&quot;#app&quot;</span>).html(msg);</span>        &#125;);    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>然后分别启动两个项目，发送请求按钮，观察浏览器控制台如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Access to XMLHttpRequest at <span class="hljs-string">&#x27;http://localhost:8080/hello&#x27;</span> from origin <span class="hljs-string">&#x27;http://localhost:8081&#x27;</span> has been blocked by CORS policy: No <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.</code></pre></div><p>可以看到，由于同源策略的限制，请求无法发送成功。</p><p>使用CORS可以在前端代码不做任何修改的情况下，实现跨域，那么接下来看看在provider中如何配置。首先可以通过<code>@CrossOrigin</code>注解配置某一个方法接受某一个域的请求，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;    <span class="hljs-meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span>    <span class="hljs-meta">@PostMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;post hello&quot;</span>;    &#125;&#125;</code></pre></div><p>这个注解表示这两个接口接受来自<a href="http://localhost:8081地址的请求，配置完成后，重启provider，再次发送请求，浏览器控制台就不会报错了，consumer也能拿到数据了">http://localhost:8081地址的请求，配置完成后，重启provider，再次发送请求，浏览器控制台就不会报错了，consumer也能拿到数据了</a></p><p>此时观察浏览器请求网络控制台，可以看到响应头中多了如下信息：<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/w1-1-20210525153453702.png" alt="img"></p><p>这个表示服务端愿意接收来自<a href="http://localhost:8081的请求，拿到这个信息后，浏览器就不会再去限制本次请求的跨域了。">http://localhost:8081的请求，拿到这个信息后，浏览器就不会再去限制本次请求的跨域了。</a></p><p>provider上，每一个方法上都去加注解未免太麻烦了，在Spring Boot中，还可以通过全局配置一次性解决这个问题，全局配置只需要在配置类中重写<code>addCorsMappings</code>方法即可，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)        .allowedOrigins(<span class="hljs-string">&quot;http://localhost:8081&quot;</span>)        .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)        .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>);    &#125;  <span class="hljs-comment">//或者</span>      <span class="hljs-meta">@Bean</span>    <span class="hljs-function">CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;        UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();        CorsConfiguration cfg = <span class="hljs-keyword">new</span> CorsConfiguration();        cfg.addAllowedOrigin(<span class="hljs-string">&quot;http://localhost:8081&quot;</span>);      <span class="hljs-comment">//允许options探测请求</span>        cfg.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>,cfg);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(source);    &#125;&#125;</code></pre></div><p><code>/**</code>表示本应用的所有方法都会去处理跨域请求，<code>allowedMethods</code>表示允许通过的请求数，<code>allowedHeaders</code>则表示允许的请求头。经过这样的配置之后，就不必在每个方法上单独配置跨域了。</p><h3 id="5-3-存在的问题"><a href="#5-3-存在的问题" class="headerlink" title="5.3 存在的问题"></a>5.3 存在的问题</h3><p>了解了整个CORS的工作过程之后，我们通过Ajax发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是CSRF（Cross-site request forgery）跨站请求伪造。跨站请求伪造也被称为one-click attack 或者 session riding，通常缩写为CSRF或者XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法，举个例子：</p><blockquote><p>假如一家银行用以运行转账操作的URL地址如下：<code>http://icbc.com/aa?bb=cc</code>，那么，一个恶意攻击者可以在另一个网站上放置如下代码：<code>&lt;img src=&quot;http://icbc.com/aa?bb=cc&quot;&gt;</code>，如果用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会遭受损失。</p></blockquote><p>基于此，浏览器在实际操作中，会对请求进行分类，分为简单请求，预先请求，带凭证的请求等，预先请求会首先发送一个options探测请求，和浏览器进行协商是否接受请求。默认情况下跨域请求是不需要凭证的，但是服务端可以配置要求客户端提供凭证，这样就可以有效避免csrf攻击。</p><h2 id="6-拦截器"><a href="#6-拦截器" class="headerlink" title="6. 拦截器"></a>6. 拦截器</h2><p>和SpringMVC的用法相同</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-comment">//该方法返回 false，请求将不再继续往下走</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;preHandle&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//Controller 执行之后被调用</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;postHandle&quot;</span>);    &#125;    <span class="hljs-comment">//preHandle 方法返回 true，afterCompletion 才会执行。</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;afterCompletion&quot;</span>);    &#125;&#125;</code></pre></div><p>不再用xml配置，使用基于注解的配置</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        registry.addInterceptor(<span class="hljs-keyword">new</span> MyInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).excludePathPatterns(<span class="hljs-string">&quot;/hello&quot;</span>);    &#125;&#125;</code></pre></div><p>就可以对Conroller进行拦截</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;    <span class="hljs-meta">@GetMapping(&quot;/hello2&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello2&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello2&quot;</span>;    &#125;&#125;</code></pre></div><h2 id="7-定义系统启动任务"><a href="#7-定义系统启动任务" class="headerlink" title="7. 定义系统启动任务"></a>7. 定义系统启动任务</h2><p>在 Servlet/Jsp 项目中，如果涉及到系统任务，例如在项目启动阶段要做一些数据初始化操作，这些操作有一个共同的特点，只在项目启动时进行，以后都不再执行，这里，容易想到web基础中的三大组件（ Servlet、Filter、Listener ）之一 Listener ，这种情况下，一般定义一个 ServletContextListener，然后就可以监听到项目启动和销毁，进而做出相应的数据初始化和销毁操作，例如下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;        <span class="hljs-comment">//在这里做数据初始化操作</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;        <span class="hljs-comment">//在这里做数据备份操作</span>    &#125;&#125;</code></pre></div><p>当然，这是基础 web 项目的解决方案，如果使用了 Spring Boot，那么我们可以使用更为简便的方式。Spring Boot 中针对系统启动任务提供了两种解决方案，分别是 CommandLineRunner 和 ApplicationRunner，分别来看。</p><h3 id="7-1-CommandLineRunner"><a href="#7-1-CommandLineRunner" class="headerlink" title="7.1 CommandLineRunner"></a>7.1 CommandLineRunner</h3><p>使用 CommandLineRunner 时，首先自定义 MyCommandLineRunner1 并且实现 CommandLineRunner 接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Order(100)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCommandLineRunner1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    &#125;&#125;</code></pre></div><p>关于这段代码，我做如下解释：</p><ul><li>首先通过 <code>@Compoent </code>注解将 <code>MyCommandLineRunner1 </code>注册为Spring容器中的一个 Bean。</li><li>添加 <code>@Order</code>注解，表示这个启动任务的执行优先级，因为在一个项目中，启动任务可能有多个，所以需要有一个排序。<code>@Order</code> 注解中，数字越小，优先级越大，默认情况下，优先级的值为<code> Integer.MAX_VALUE</code>，表示优先级最低。</li><li>在 run 方法中，写启动任务的核心逻辑，当项目启动时，run方法会被自动执行。</li><li>run 方法的参数，来自于项目的启动参数，即项目入口类中，main方法的参数会被传到这里。</li></ul><p>此时启动项目，run方法就会被执行，至于参数，可以通过两种方式来传递，如果是在 IDEA 中，可以通过如下方式来配置参数：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-1-20210523104130918-20210525153453711.png" alt="img"></p><p>另一种方式，则是将项目打包，在命令行中启动项目，然后启动时在命令行传入参数，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">java -jar devtools-0.0.1-SNAPSHOT.jar 三国演义 西游记</code></pre></div><p>注意，这里参数传递时没有key，直接写value即可，执行结果如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-2-20210525153453688.png" alt="img"></p><h3 id="7-2-ApplicationRunner"><a href="#7-2-ApplicationRunner" class="headerlink" title="7.2 ApplicationRunner"></a>7.2 ApplicationRunner</h3><p>ApplicationRunner 和 CommandLineRunner 功能一致，用法也基本一致，唯一的区别主要体现在对参数的处理上，ApplicationRunner 可以接收更多类型的参数（ApplicationRunner 除了可以接收 CommandLineRunner 的参数之外，还可以接收 key/value形式的参数）。</p><p>使用 ApplicationRunner ，自定义类实现 ApplicationRunner 接口即可，组件注册以及组件优先级的配置都和 CommandLineRunner 一致，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Order(98)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationRunner1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();        System.out.println(<span class="hljs-string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+nonOptionArgs);        Set&lt;String&gt; optionNames = args.getOptionNames();        <span class="hljs-keyword">for</span> (String key : optionNames) &#123;            System.out.println(<span class="hljs-string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+key + <span class="hljs-string">&quot;:&quot;</span> + args.getOptionValues(key));        &#125;        String[] sourceArgs = args.getSourceArgs();        System.out.println(<span class="hljs-string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+Arrays.toString(sourceArgs));    &#125;&#125;</code></pre></div><p>当项目启动时，这里的 run 方法就会被自动执行，关于 run 方法的参数 ApplicationArguments ，我说如下几点：</p><ul><li><code>args.getNonOptionArgs()</code>;可以用来获取命令行中的无key参数（和CommandLineRunner一样）。</li><li><code>args.getOptionNames()</code>;可以用来获取所有key/value形式的参数的key。</li><li><code>args.getOptionValues(key))</code>;可以根据key获取key/value 形式的参数的value。</li><li><code>args.getSourceArgs()</code>; 则表示获取命令行中的所有参数。</li></ul><p>ApplicationRunner 定义完成后，传启动参数也是两种方式，参数类型也有两种，第一种和 CommandLineRunner 一致，第二种则是 –key=value 的形式，在 IDEA 中定义方式如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-3-20210525153453687.png" alt="img"></p><p>或者使用 如下启动命令：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">java -jar devtools-0.0.1-SNAPSHOT.jar 三国演义 西游记 --age=99</code></pre></div><p>运行结果如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-4-20210525153453678.png" alt="img"></p><h2 id="8-定时任务"><a href="#8-定时任务" class="headerlink" title="8. 定时任务"></a>8. 定时任务</h2><p>在 Spring + SpringMVC 环境中，一般来说，要实现定时任务，我们有两中方案，一种是使用 Spring 自带的定时任务处理器 @Scheduled 注解，另一种就是使用第三方框架 Quartz ，Spring Boot 源自 Spring+SpringMVC ，因此天然具备这两个 Spring 中的定时任务实现策略，当然也支持 Quartz，本文我们就来看下 Spring Boot 中两种定时任务的实现方式。</p><h4 id="8-1-Scheduled"><a href="#8-1-Scheduled" class="headerlink" title="8.1 @Scheduled"></a>8.1 @Scheduled</h4><p>使用 @Scheduled 非常容易，直接创建一个 Spring Boot 项目，并且添加 web 依赖 <code>spring-boot-starter-web</code>，项目创建成功后，添加 <code>@EnableScheduling</code> 注解，开启定时任务：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableScheduling</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ScheduledApplication.class, args);    &#125;&#125;</code></pre></div><p>接下来配置定时任务：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(fixedRate = 2000)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fixedRate</span><span class="hljs-params">()</span> </span>&#123;  System.out.println(<span class="hljs-string">&quot;fixedRate&gt;&gt;&gt;&quot;</span>+<span class="hljs-keyword">new</span> Date());    &#125;<span class="hljs-meta">@Scheduled(fixedDelay = 2000)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fixedDelay</span><span class="hljs-params">()</span> </span>&#123;  System.out.println(<span class="hljs-string">&quot;fixedDelay&gt;&gt;&gt;&quot;</span>+<span class="hljs-keyword">new</span> Date());&#125;<span class="hljs-meta">@Scheduled(initialDelay = 2000,fixedDelay = 2000)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialDelay</span><span class="hljs-params">()</span> </span>&#123;  System.out.println(<span class="hljs-string">&quot;initialDelay&gt;&gt;&gt;&quot;</span>+<span class="hljs-keyword">new</span> Date());&#125;</code></pre></div><ul><li>首先使用 @Scheduled 注解开启一个定时任务。</li><li>fixedRate 表示任务执行之间的时间间隔，具体是指两次任务的开始时间间隔，即第二次任务开始时，第一次任务可能还没结束。</li><li>fixedDelay 表示任务执行之间的时间间隔，具体是指本次任务结束到下次任务开始之间的时间间隔。</li><li>initialDelay 表示首次任务启动的延迟时间。</li><li>所有时间的单位都是毫秒。</li></ul><p>上面这是一个基本用法，除了这几个基本属性之外，@Scheduled 注解也支持 cron 表达式，使用 cron 表达式，可以非常丰富的描述定时任务的时间。cron 表达式格式如下：</p><blockquote><p>[秒] [分] [小时] [日] [月] [周] [年]</p></blockquote><p>具体取值如下：</p><table><thead><tr><th align="left">序号</th><th align="left">说明</th><th align="left">是否必填</th><th align="left">允许填写的值</th><th align="left">允许的通配符</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">秒</td><td align="left">是</td><td align="left">0-59</td><td align="left">- * /</td></tr><tr><td align="left">2</td><td align="left">分</td><td align="left">是</td><td align="left">0-59</td><td align="left">- * /</td></tr><tr><td align="left">3</td><td align="left">时</td><td align="left">是</td><td align="left">0-23</td><td align="left">- * /</td></tr><tr><td align="left">4</td><td align="left">日</td><td align="left">是</td><td align="left">1-31</td><td align="left">- * ? / L W</td></tr><tr><td align="left">5</td><td align="left">月</td><td align="left">是</td><td align="left">1-12 or JAN-DEC</td><td align="left">- * /</td></tr><tr><td align="left">6</td><td align="left">周</td><td align="left">是</td><td align="left">1-7 or SUN-SAT</td><td align="left">- * ? / L #</td></tr><tr><td align="left">7</td><td align="left">年</td><td align="left">否</td><td align="left">1970-2099</td><td align="left">- * /</td></tr></tbody></table><p><strong>这一块需要大家注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 <code>?</code></strong></p><p><strong>通配符含义：</strong></p><ul><li><code>?</code> 表示不指定值，即不关心某个字段的取值时使用。需要注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 <code>?</code></li><li><code>*</code> 表示所有值，例如:在秒的字段上设置 <code>*</code>,表示每一秒都会触发</li><li><code>,</code> 用来分开多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</li><li><code>-</code> 表示区间，例如在秒上设置 “10-12”,表示 10,11,12秒都会触发</li><li><code>/</code> 用于递增触发，如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)</li><li><code>#</code> 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六，(用 在母亲节和父亲节再合适不过了)</li><li>周字段的设置，若使用英文字母是不区分大小写的 ，即 MON 与mon相同</li><li><code>L</code> 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会自动判断是否是润年), 在周字段上表示星期六，相当于”7”或”SAT”（注意周日算是第一天）。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示”本月最后一个星期五”</li><li><code>W</code> 表示离指定日期的最近工作日(周一至周五)，例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)</li><li><code>L</code> 和 <code>W</code> 可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发(一般指发工资 )</li></ul><p>例如，在 @Scheduled 注解中来一个简单的 cron 表达式，每隔5秒触发一次，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(cron = &quot;0/5 * * * * *&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cron</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-keyword">new</span> Date());&#125;</code></pre></div><p>上面介绍的是使用 @Scheduled 注解的方式来实现定时任务，接下来我们再来看看如何使用 Quartz 实现定时任务。</p><h4 id="8-2-Quartz"><a href="#8-2-Quartz" class="headerlink" title="8.2 Quartz"></a>8.2 Quartz</h4><p>一般在项目中，除非定时任务涉及到的业务实在是太简单，使用 @Scheduled 注解来解决定时任务，否则大部分情况可能都是使用 Quartz 来做定时任务。在 Spring Boot 中使用 Quartz ，只需要在创建项目时，添加 Quartz 依赖即可：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/6-1.png" alt="img"></p><p>项目创建完成后，也需要添加开启定时任务的注解：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableScheduling</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuartzApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(QuartzApplication.class, args);    &#125;&#125;</code></pre></div><p>Quartz 在使用过程中，有两个关键概念，一个是JobDetail（要做的事情），另一个是触发器（什么时候做），要定义 JobDetail，需要先定义 Job，Job 的定义有两种方式：</p><p>第一种方式，直接定义一个Bean：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJob1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyJob1&gt;&gt;&gt;&quot;</span>+<span class="hljs-keyword">new</span> Date());    &#125;&#125;</code></pre></div><p>关于这种定义方式说两点：</p><ol><li>首先将这个 Job 注册到 Spring 容器中。</li><li>这种定义方式有一个缺陷，就是无法传参。</li></ol><p>第二种定义方式，则是继承 QuartzJobBean 并实现默认的方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJob2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">QuartzJobBean</span> </span>&#123;    HelloService helloService;    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">getHelloService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> helloService;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHelloService</span><span class="hljs-params">(HelloService helloService)</span> </span>&#123;        <span class="hljs-keyword">this</span>.helloService = helloService;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeInternal</span><span class="hljs-params">(JobExecutionContext jobExecutionContext)</span> <span class="hljs-keyword">throws</span> JobExecutionException </span>&#123;        helloService.sayHello();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello service &gt;&gt;&gt;&quot;</span>+<span class="hljs-keyword">new</span> Date());    &#125;&#125;</code></pre></div><p>和第1种方式相比，这种方式支持传参，任务启动时，executeInternal 方法将会被执行。</p><p>Job 有了之后，接下来创建类，配置 JobDetail 和 Trigger 触发器，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuartzConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">MethodInvokingJobDetailFactoryBean <span class="hljs-title">methodInvokingJobDetailFactoryBean</span><span class="hljs-params">()</span> </span>&#123;        MethodInvokingJobDetailFactoryBean bean = <span class="hljs-keyword">new</span> MethodInvokingJobDetailFactoryBean();        bean.setTargetBeanName(<span class="hljs-string">&quot;myJob1&quot;</span>);        bean.setTargetMethod(<span class="hljs-string">&quot;sayHello&quot;</span>);        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">JobDetailFactoryBean <span class="hljs-title">jobDetailFactoryBean</span><span class="hljs-params">()</span> </span>&#123;        JobDetailFactoryBean bean = <span class="hljs-keyword">new</span> JobDetailFactoryBean();        bean.setJobClass(MyJob2.class);        JobDataMap map = <span class="hljs-keyword">new</span> JobDataMap();        map.put(<span class="hljs-string">&quot;helloService&quot;</span>, helloService());        bean.setJobDataMap(map);        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">SimpleTriggerFactoryBean <span class="hljs-title">simpleTriggerFactoryBean</span><span class="hljs-params">()</span> </span>&#123;        SimpleTriggerFactoryBean bean = <span class="hljs-keyword">new</span> SimpleTriggerFactoryBean();        bean.setStartTime(<span class="hljs-keyword">new</span> Date());        bean.setRepeatCount(<span class="hljs-number">5</span>);        bean.setJobDetail(methodInvokingJobDetailFactoryBean().getObject());        bean.setRepeatInterval(<span class="hljs-number">3000</span>);        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">CronTriggerFactoryBean <span class="hljs-title">cronTrigger</span><span class="hljs-params">()</span> </span>&#123;        CronTriggerFactoryBean bean = <span class="hljs-keyword">new</span> CronTriggerFactoryBean();        bean.setCronExpression(<span class="hljs-string">&quot;0/10 * * * * ?&quot;</span>);        bean.setJobDetail(jobDetailFactoryBean().getObject());        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">SchedulerFactoryBean <span class="hljs-title">schedulerFactoryBean</span><span class="hljs-params">()</span> </span>&#123;        SchedulerFactoryBean bean = <span class="hljs-keyword">new</span> SchedulerFactoryBean();        bean.setTriggers(cronTrigger().getObject(), simpleTriggerFactoryBean().getObject());        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">HelloService <span class="hljs-title">helloService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloService();    &#125;&#125;</code></pre></div><p>关于这个配置说如下几点：</p><ul><li>JobDetail 的配置有两种方式：MethodInvokingJobDetailFactoryBean 和 JobDetailFactoryBean 。</li><li>使用 MethodInvokingJobDetailFactoryBean 可以配置目标 Bean 的名字和目标方法的名字，这种方式不支持传参。</li><li>使用 JobDetailFactoryBean 可以配置 JobDetail ，任务类继承自 QuartzJobBean ，这种方式支持传参，将参数封装在 JobDataMap 中进行传递。</li><li>Trigger 是指触发器，Quartz 中定义了多个触发器，这里向大家展示其中两种的用法，SimpleTrigger 和 CronTrigger 。</li><li>SimpleTrigger 有点类似于前面说的 @Scheduled 的基本用法。</li><li>CronTrigger 则有点类似于 @Scheduled 中 cron 表达式的用法。</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/6-2.png" alt="img"></p><h2 id="9-Web基础组件"><a href="#9-Web基础组件" class="headerlink" title="9. Web基础组件"></a>9. Web基础组件</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestContextListener</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestInitialized</span><span class="hljs-params">(ServletRequestEvent requestEvent)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;requestInitialized&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestDestroyed</span><span class="hljs-params">(ServletRequestEvent requestEvent)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;requestDestroyed&quot;</span>);    &#125;&#125;<span class="hljs-meta">@WebServlet(urlPatterns = &quot;/hello&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doPost(req,resp);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyServlet&quot;</span>);    &#125;&#125;<span class="hljs-comment">//启动类</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@ServletComponentScan(&quot;org.javaboy.webcomponent&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebcomponentApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(WebcomponentApplication.class, args);    &#125;&#125;</code></pre></div><p>关于过滤器，一般推荐使用拦截器，但这里还是对过滤器进行一定的说明</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//基础用法</span><span class="hljs-meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyFilter&quot;</span>);        chain.doFilter(request,response);    &#125;&#125;<span class="hljs-comment">//设置优先级需要用当基础组件处理</span><span class="hljs-meta">@Component</span><span class="hljs-comment">//数字越小优先级越高</span><span class="hljs-meta">@Order(101)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyFilter02&quot;</span>);        chain.doFilter(request, response);    &#125;&#125;<span class="hljs-comment">//上述过滤器2无法指定拦截url，需要更换配置</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyFilter04&quot;</span>);        chain.doFilter(request, response);    &#125;&#125;<span class="hljs-comment">//针对03对应的配置类</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterConfiguration</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">FilterRegistrationBean&lt;MyFilter03&gt; <span class="hljs-title">filter03FilterRegistrationBean03</span><span class="hljs-params">()</span> </span>&#123;        FilterRegistrationBean&lt;MyFilter03&gt; bean = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();        bean.setOrder(<span class="hljs-number">90</span>);        bean.setFilter(<span class="hljs-keyword">new</span> MyFilter03());        bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">&quot;/*&quot;</span>));        <span class="hljs-keyword">return</span> bean;    &#125;&#125;</code></pre></div><h2 id="10-AOP"><a href="#10-AOP" class="headerlink" title="10.  AOP"></a>10.  AOP</h2><p>Spring中已经对[AOP注解编程](#6. 基于注解的AOP编程)进行了讲解，这里做一定的补充</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//UserService</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserById</span><span class="hljs-params">(Integer id)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;getUserById&quot;</span>);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user&quot;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;delete id:&quot;</span> + id);    &#125;&#125;<span class="hljs-comment">//LogAspect</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;    <span class="hljs-meta">@Pointcut(&quot;execution(* org.javaboy.aop.service.*.*(..))&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc1</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-meta">@Before(&quot;pc1()&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(JoinPoint jp)</span> </span>&#123;        String name = jp.getSignature().getName();        System.out.println(name + <span class="hljs-string">&quot; 方法开始执行了...&quot;</span>);    &#125;    <span class="hljs-meta">@After(&quot;pc1()&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">(JoinPoint jp)</span> </span>&#123;        String name = jp.getSignature().getName();        System.out.println(name + <span class="hljs-string">&quot; 方法执行结束了...&quot;</span>);    &#125;    <span class="hljs-meta">@AfterReturning(value = &quot;pc1()&quot;, returning = &quot;s&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(JoinPoint jp, String s)</span> </span>&#123;        String name = jp.getSignature().getName();        System.out.println(name + <span class="hljs-string">&quot; 方法的返回值是 &quot;</span> + s);    &#125;    <span class="hljs-meta">@AfterThrowing(value = &quot;pc1()&quot;, throwing = &quot;e&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(JoinPoint jp, Exception e)</span> </span>&#123;        String name = jp.getSignature().getName();        System.out.println(name + <span class="hljs-string">&quot; 方法抛出了异常 &quot;</span> + e.getMessage());    &#125;    <span class="hljs-meta">@Around(&quot;pc1()&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//类似于反射中的 invoke 方法</span>            Object proceed = pjp.proceed();            <span class="hljs-keyword">return</span> proceed;        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;            throwable.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><h2 id="11-整合Swagger"><a href="#11-整合Swagger" class="headerlink" title="11. 整合Swagger"></a>11. 整合Swagger</h2><h3 id="11-1-引言"><a href="#11-1-引言" class="headerlink" title="11.1 引言"></a>11.1 引言</h3><blockquote><p>相信无论是前端还是后端开发，都或多或少地被接口文档折磨过。前端经常抱怨后端给的接口文档和实际情况不一致。后端又觉得编写及维护接口文档会耗费不少精力，经常来不及更新。其实无论是前端调用后端，还是后端调用前端，都期望有一个好的接口文档。但是这个接口文档对于程序员来说，就跟注释一样，经常还会抱怨别人写的代码没有写注释，然而自己写起代码来，最讨厌的也是写注释。所以仅仅只听过强制了来规范大家是不够的，随着时间推移，版本迭代，接口文档往往很容易就跟不上代码了</p></blockquote><h3 id="11-2-什么是Swagger"><a href="#11-2-什么是Swagger" class="headerlink" title="11.2  什么是Swagger"></a>11.2  什么是Swagger</h3><blockquote><p>发现了痛点就要去找解决方案。解决方案用的人多了，就成了标准的规范，这就是 Swagger 的由来。通过这套规范，你只需要按照它的规范去定义接口及接口相关信息。再通过 Swagger 衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，生成多做语言的客户端和服务端的代码，以及在线接口调试页面等等。这样，如果按照新的开发木事，在开发新版本或者迭代版本的时候，只需要更新 Swagger 描述文件，就可以自动生成接口文档和客户端代码，做到调用端代码、服务端代码以及接口文档的一致性。 但即便如此，对于许多开发来说，编写这个 yml 或 json 格式的描述文件，本身也是有一定负担的工作，特别是在后面持续迭代开发的时候，往往会忽略更新这个描述文件，直接更改代码。久而久之，这个描述文件也和实际项目渐行渐远，基于该描述文件生成的接口文档也失去了参考意义。<code>所以作为 Java 界服务端的大一统框架 Spring，迅速将 Swagger 规范纳入自身的标准，建立了 Spring-swagger 项目，后面改成了现在的 Springfox。通过在项目中引入 Springfox，可以扫描相关的代码，生成该描述文件，进而生成与代码一致的接口文档和客户端代码。</code>这种通过代码生成接口文档的形式，在后面需求持续迭代的项目中，显得尤为重要和高效</p></blockquote><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519160517871.png" alt="image-20210519160517871"></p><p><strong>总结：Swagger 就是一个用来定义接口标准，接口规范，同时能根据你的代码自动生成接口说明文档的一个工具</strong></p><h3 id="11-3-官方提供的工具"><a href="#11-3-官方提供的工具" class="headerlink" title="11.3 官方提供的工具"></a>11.3 官方提供的工具</h3><p><strong>Swagger Codegen</strong>：通过Codegen 可以将描述文件生成 html 格式和 cwiki 形式的接口文档，同时也能生成多种语言的服务端和客户端代码。支持通过 jar 包、docker、node 等方式在本地化执行生成。也可以在后面的 Swagger Editor 中在线生成。 </p><p><strong>Swagger UI</strong>：提供了一个可视化的 UI 页面展示描述文件。接口的调用方、测试、项目经理等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求。该项目支持在线导入描述文件和本地部署 UI 项目。 </p><p><strong>Swagger Editor</strong>：类似于 Markdown 编辑器的编辑 Swagger 描述文件的编辑器，该编辑器支持实时预览描述文件的更新效果，也提供了在线编辑器和本地部署器俩种方式。         </p><p><strong>Swagger Inspector</strong>：感觉和 Postman 差不多，是一个可以对接口进行测试的在线版的 postman。比如在 Swagger UI 里面做接口请求，会返回更多的信息，也会保存你请求的实际请求参数等数据。         </p><p><strong>Swagger Hub</strong>：集成了上面所有项目的各个功能，你可以以项目和版本为单位，将你的描述文件上传到 Swagger Hub 中。在 Swagger Hub 中可以完成上面项目的所有工作，需要注册账号，分免费版和收费版。         </p><p><strong>Springfox Swagger</strong>：Spring 基于 Swagger 规范，可以将基于 SpringMVC 和 Spring Boot 项目的项目代码，自动生成 JSON 格式的描述文件。本身不是属于 Swagger 官网提供的，在这里列出来做个说明，方便后面作一个使用的展开。</p><h3 id="11-4-构建-Swagger-与-Spring-Boot-环境"><a href="#11-4-构建-Swagger-与-Spring-Boot-环境" class="headerlink" title="11.4 构建 Swagger 与 Spring Boot 环境"></a>11.4 构建 Swagger 与 Spring Boot 环境</h3><h4 id="11-4-1-引入依赖"><a href="#11-4-1-引入依赖" class="headerlink" title="11.4.1 引入依赖"></a>11.4.1 引入依赖</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="11-4-2-编写-Swagger-配置类"><a href="#11-4-2-编写-Swagger-配置类" class="headerlink" title="11.4.2 编写 Swagger 配置类"></a>11.4.2 编写 Swagger 配置类</h4><blockquote><p>这个配置类基本都是不变的</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;<span class="hljs-keyword">import</span> springfox.documentation.builders.PathSelectors;<span class="hljs-keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;<span class="hljs-keyword">import</span> springfox.documentation.service.Contact;<span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger2</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .pathMapping(<span class="hljs-string">&quot;/&quot;</span>)                .select()                <span class="hljs-comment">// 扫描哪个接口的包</span>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.example.controller&quot;</span>))                .paths(PathSelectors.any())                .build().apiInfo(<span class="hljs-keyword">new</span> ApiInfoBuilder()                        .title(<span class="hljs-string">&quot;标题: SpringBoot 整合 Swagger 使用&quot;</span>)                        .description(<span class="hljs-string">&quot;详细信息: SpringBoot 整合 Swagger,详细信息......&quot;</span>)                        <span class="hljs-comment">// 版本信息</span>                        .version(<span class="hljs-string">&quot;1.1&quot;</span>)                        <span class="hljs-comment">// 开发文档的联系人</span>                    .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;lucifer&quot;</span>, <span class="hljs-string">&quot;https://lucifer2u.github.io&quot;</span>,<span class="hljs-string">&quot;xiaoweliangx@gmail.com&quot;</span>))                        .license(<span class="hljs-string">&quot;This Baidu License&quot;</span>)                        .licenseUrl(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)                        .build());    &#125;&#125;</code></pre></div><h4 id="11-4-3-启动-SpringBoot-项目"><a href="#11-4-3-启动-SpringBoot-项目" class="headerlink" title="11.4.3 启动 SpringBoot 项目"></a>11.4.3 启动 SpringBoot 项目</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519162040084.png" alt="image-20210519162040084"></p><h4 id="11-4-4-访问-Swagger-的-UI-界面"><a href="#11-4-4-访问-Swagger-的-UI-界面" class="headerlink" title="11.4.4 访问 Swagger 的 UI 界面"></a>11.4.4 访问 Swagger 的 UI 界面</h4><p>访问 Swagger 提供的 UI 界面：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519162204984.png" alt="image-20210519162204984"></p><h3 id="11-5-使用-Swagger-构建"><a href="#11-5-使用-Swagger-构建" class="headerlink" title="11.5 使用 Swagger 构建"></a>11.5 使用 Swagger 构建</h3><h4 id="11-5-1-开发-Controller-接口"><a href="#11-5-1-开发-Controller-接口" class="headerlink" title="11.5.1 开发 Controller 接口"></a>11.5.1 开发 Controller 接口</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/findAll&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;查询所有数据成功&quot;</span>);        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> map;    &#125;&#125;</code></pre></div><h4 id="11-5-2-重启项目访问接口界面"><a href="#11-5-2-重启项目访问接口界面" class="headerlink" title="11.5.2 重启项目访问接口界面"></a>11.5.2 重启项目访问接口界面</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519162452762.png" alt="image-20210519162452762"></p><h3 id="11-6-Swagger-注解"><a href="#11-6-Swagger-注解" class="headerlink" title="11.6 Swagger 注解"></a>11.6 Swagger 注解</h3><h4 id="11-6-1-Api"><a href="#11-6-1-Api" class="headerlink" title="11.6.1 @Api"></a>11.6.1 @Api</h4><blockquote><p>作用：用来指定接口的描述文字<br>修饰范围：用在类上</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><span class="hljs-meta">@Api(tags = &quot;用户服务相关接口描叙&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;....&#125;</code></pre></div><h4 id="11-6-2-ApiOperation"><a href="#11-6-2-ApiOperation" class="headerlink" title="11.6.2 @ApiOperation"></a>11.6.2 @ApiOperation</h4><blockquote><p>作用：用来对接口中具体方法做描叙<br>修饰范围：用在方法上</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/findAll&quot;)</span><span class="hljs-meta">@ApiOperation(value = &quot;查询所有用户接口&quot;,</span><span class="hljs-meta">        notes = &quot;&lt;span style=&#x27;color:red;&#x27;&gt;描叙:&lt;/span&gt;&amp;nbsp;&amp;nbsp;用来查询所有用户信息的接口&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>&#123;    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;查询所有数据成功&quot;</span>);    map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-keyword">true</span>);    <span class="hljs-keyword">return</span> map;&#125;</code></pre></div><h4 id="11-6-3-ApiImplicitParams"><a href="#11-6-3-ApiImplicitParams" class="headerlink" title="11.6.3 @ApiImplicitParams"></a>11.6.3 @ApiImplicitParams</h4><blockquote><p>作用：用来接口中参数进行说明<br>修饰范围：用在方法上</p></blockquote><h5 id="普通参数使用"><a href="#普通参数使用" class="headerlink" title="普通参数使用"></a>普通参数使用</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;save&quot;)</span><span class="hljs-meta">@ApiOperation(value = &quot;保存用户信息接口&quot;,</span><span class="hljs-meta">        notes = &quot;&lt;span style=&#x27;color:red;&#x27;&gt;描叙:&lt;/span&gt;&amp;nbsp;&amp;nbsp;用来保存用户信息的接口&quot;)</span><span class="hljs-meta">@ApiImplicitParams(&#123;</span><span class="hljs-meta">        @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户 id&quot;, dataType = &quot;String&quot;, defaultValue = &quot;21&quot;),</span><span class="hljs-meta">        @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户姓名&quot;, dataType = &quot;String&quot;, defaultValue = &quot;lucifer&quot;)</span><span class="hljs-meta">&#125;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">save</span><span class="hljs-params">(String id, String name)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&quot;id&quot;</span>, id);    map.put(<span class="hljs-string">&quot;name&quot;</span>, name);    <span class="hljs-keyword">return</span> map;&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519163323183.png" alt="image-20210519163323183"></p><h5 id="RestFul-风格使用"><a href="#RestFul-风格使用" class="headerlink" title="RestFul 风格使用"></a>RestFul 风格使用</h5><blockquote><p>如果使用的是 RestFul 风格进行传参，必须再添加一个 paramType=”path”</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;save/&#123;id&#125;/&#123;name&#125;&quot;)</span><span class="hljs-meta">@ApiOperation(value = &quot;保存用户信息接口&quot;,</span><span class="hljs-meta">        notes = &quot;&lt;span style=&#x27;color:red;&#x27;&gt;描叙:&lt;/span&gt;&amp;nbsp;&amp;nbsp;用来保存用户信息的接口&quot;)</span><span class="hljs-meta">@ApiImplicitParams(&#123;</span><span class="hljs-meta">        @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户 id&quot;, dataType = &quot;String&quot;, defaultValue = &quot;21&quot;, paramType = &quot;path&quot;),</span><span class="hljs-meta">        @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户姓名&quot;, dataType = &quot;String&quot;, defaultValue = &quot;lucifer&quot;, paramType = &quot;path&quot;)</span><span class="hljs-meta">&#125;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">save</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id,<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&quot;id&quot;</span>, id);    map.put(<span class="hljs-string">&quot;name&quot;</span>, name);    <span class="hljs-keyword">return</span> map;&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519163641192.png" alt="image-20210519163641192"></p><h5 id="JSON-格式使用"><a href="#JSON-格式使用" class="headerlink" title="JSON 格式使用"></a>JSON 格式使用</h5><p>如果是 <code>RequestBody</code> 的方式，需要定义一个对象进行接收</p><p><strong>定义一个 User 对象</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String name;&#125;</code></pre></div><p><strong>编写 Controller</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;save2&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">save2</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + user.getId());    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + user.getName());    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&quot;id&quot;</span>, user.getId());    map.put(<span class="hljs-string">&quot;name&quot;</span>, user.getName());    <span class="hljs-keyword">return</span> map;&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519163919745.png" alt="image-20210519163919745"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519164215434.png" alt="image-20210519164215434"></p><h4 id="11-6-4-ApiResponses"><a href="#11-6-4-ApiResponses" class="headerlink" title="11.6.4 @ApiResponses"></a>11.6.4 @ApiResponses</h4><blockquote><p>作用：用在请求的方法上，表示一组响应<br>修饰范围：用在方法上</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;save2&quot;)</span><span class="hljs-meta">@ApiResponses(&#123;</span><span class="hljs-meta">        @ApiResponse(code = 404, message = &quot;请求路径不对&quot;),</span><span class="hljs-meta">        @ApiResponse(code = 400, message = &quot;程序不对&quot;)</span><span class="hljs-meta">&#125;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">save2</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + user.getId());    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + user.getName());    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&quot;id&quot;</span>, user.getId());    map.put(<span class="hljs-string">&quot;name&quot;</span>, user.getName());    <span class="hljs-keyword">return</span> map;&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="11-6-5-ApiModel"><a href="#11-6-5-ApiModel" class="headerlink" title="11.6.5 @ApiModel"></a>11.6.5 @ApiModel</h4><p>如果参数是一个对象（例如上文的更新接口），对于参数的描述也可以放在实体类中。例如下面一段代码： </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ApiModel(value = &quot;用户实体类&quot;， description= &quot;定义了用户所有属性&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@ApiModelProperty(value = &quot;用户id&quot;)</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@ApiModelProperty(value = &quot;用户名&quot;)</span>    <span class="hljs-keyword">private</span> String username;    <span class="hljs-meta">@ApiModelProperty(value = &quot;用户地址&quot;)</span>    <span class="hljs-keyword">private</span> String address;    <span class="hljs-comment">//getter/setter</span>&#125;</code></pre></div><h3 id="11-7-在Security中的配置"><a href="#11-7-在Security中的配置" class="headerlink" title="11.7 在Security中的配置"></a>11.7 在Security中的配置</h3><p>如果我们的Spring Boot项目中集成了Spring Security，那么如果不做额外配置，Swagger2文档可能会被拦截，此时只需要在Spring Security的配置类中重写configure方法，添加如下过滤即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    web.ignoring()            .antMatchers(<span class="hljs-string">&quot;/swagger-ui.html&quot;</span>)            .antMatchers(<span class="hljs-string">&quot;/v2/**&quot;</span>)            .antMatchers(<span class="hljs-string">&quot;/swagger-resources/**&quot;</span>);&#125;</code></pre></div><h3 id="11-8-Swagger-3-0"><a href="#11-8-Swagger-3-0" class="headerlink" title="11.8 Swagger 3.0"></a>11.8 Swagger 3.0</h3><p>在 3.0 版本中，我们不需要这么麻烦了，一个 starter 就可以搞定：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>和 Spring Boot 中的其他 starter 一样，springfox-boot-starter 依赖可以实现零配置以及自动配置支持。也就是说，如果你没有其他特殊需求，加一个这个依赖就行了，接口文档就自动生成了。</p><p><strong>接口地址</strong></p><p>3.0 中的接口地址也和之前有所不同，以前在 2.9.2 中我们主要访问两个地址：</p><ul><li>文档接口地址：<a href="http://localhost:8080/v2/api-docs">http://localhost:8080/v2/api-docs</a></li><li>文档页面地址：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></li></ul><p>现在在 3.0 中，这两个地址也发生了变化：</p><ul><li>文档接口地址：<a href="http://localhost:8080/v3/api-docs">http://localhost:8080/v3/api-docs</a></li><li>文档页面地址：<a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a></li></ul><p>特别是文档页面地址，如果用了 3.0，而去访问之前的页面，会报 404</p><p><strong>注解</strong></p><p>旧的注解还可以继续使用，不过在 3.0 中还提供了一些其他注解。</p><p>例如我们可以使用 @EnableOpenApi 代替以前旧版本中的 @EnableSwagger2。</p><p>话是这么说，不过松哥在实际体验中，感觉 @EnableOpenApi 注解的功能不明显，加不加都行。翻了下源码，@EnableOpenApi 注解主要功能是为了导入 OpenApiDocumentationConfiguration 配置类，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Target(value = &#123;java.lang.annotation.ElementType.TYPE&#125;)</span><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Import(OpenApiDocumentationConfiguration.class)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableOpenApi &#123;&#125;</code></pre></div><p>然后我又看了下自动化配置类 OpenApiAutoConfiguration，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties(SpringfoxConfigurationProperties.class)</span><span class="hljs-meta">@ConditionalOnProperty(value = &quot;springfox.documentation.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span><span class="hljs-meta">@Import(&#123;</span><span class="hljs-meta">    OpenApiDocumentationConfiguration.class,</span><span class="hljs-meta">    SpringDataRestConfiguration.class,</span><span class="hljs-meta">    BeanValidatorPluginsConfiguration.class,</span><span class="hljs-meta">    Swagger2DocumentationConfiguration.class,</span><span class="hljs-meta">    SwaggerUiWebFluxConfiguration.class,</span><span class="hljs-meta">    SwaggerUiWebMvcConfiguration.class</span><span class="hljs-meta">&#125;)</span><span class="hljs-meta">@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, JacksonAutoConfiguration.class,</span><span class="hljs-meta">    HttpMessageConvertersAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class &#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenApiAutoConfiguration</span> </span>&#123;&#125;</code></pre></div><p>可以看到，自动化配置类里边也导入了 OpenApiDocumentationConfiguration。</p><p>所以在正常情况下，实际上不需要添加 @EnableOpenApi 注解。</p><p>根据 OpenApiAutoConfiguration 上的 @ConditionalOnProperty 条件注解中的定义，我们发现，如果在 application.properties 中设置 <code>springfox.documentation.enabled=false</code>，即关闭了 swagger 功能，此时自动化配置类就不执行了，这个时候可以通过 @EnableOpenApi 注解导入 OpenApiDocumentationConfiguration 配置类。技术上来说逻辑是这样，不过应用中暂未发现这样的需求（即在 application.properties 中关闭 swagger，再通过 @EnableOpenApi 注解开启）。</p><p>另外，以前我们用的 @ApiResponses/@ApiResponse 注解，在 3.0 中名字没变，但是所在的包变了，小伙伴们使用时注意导包问题哦。</p><p>另外，我们之前用的 @ApiOperation 注解在 3.0 中可以使用 @Operation 代替。</p><p>另外还有一些新注解如 @Parameter、@Parameters、@Schema 等，感觉不太好用，不如旧的用的舒服，这些新注解小伙伴们可以自行尝试下。</p><h2 id="12-数据校验"><a href="#12-数据校验" class="headerlink" title="12. 数据校验"></a>12. 数据校验</h2><p><strong>依赖引入</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>配置文件 ValidationMessages.properties</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">user.name.size</span>=<span class="hljs-string">name xxx</span><span class="hljs-meta">user.address.notnull</span>=<span class="hljs-string">address xxx</span><span class="hljs-meta">user.age.min</span>=<span class="hljs-string">age xxx</span><span class="hljs-meta">user.age.max</span>=<span class="hljs-string">age xxx</span><span class="hljs-meta">user.email.notnull</span>=<span class="hljs-string">email xxx</span><span class="hljs-meta">user.email.pattern</span>=<span class="hljs-string">email xxx</span></code></pre></div><p>分组校验，首先需要定义校验组，所谓的校验组，其实就是<strong>空接口</strong>：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidationGroup1</span> </span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidationGroup2</span> </span>&#123;&#125;</code></pre></div><p><strong>实体类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@Size(min = 5,max = 8,message = &quot;&#123;user.name.size&#125;&quot;,groups = ValidationGroup1.class)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@NotNull(message = &quot;&#123;user.address.notnull&#125;&quot;,groups = ValidationGroup2.class)</span>    <span class="hljs-keyword">private</span> String address;    <span class="hljs-meta">@DecimalMin(value = &quot;1&quot;,message = &quot;&#123;user.age.min&#125;&quot;,groups = &#123;ValidationGroup1.class,ValidationGroup2.class&#125;)</span>    <span class="hljs-meta">@DecimalMax(value = &quot;200&quot;,message = &quot;&#123;user.age.max&#125;&quot;)</span>    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-meta">@NotNull(message = &quot;&#123;user.email.notnull&#125;&quot;)</span>    <span class="hljs-meta">@Email(message = &quot;&#123;user.email.pattern&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String email;&#125;</code></pre></div><p>校验注解，主要有如下几种：</p><ul><li>@Null 被注解的元素必须为 null</li><li>@NotNull 被注解的元素必须不为 null</li><li>@AssertTrue 被注解的元素必须为 true</li><li>@AssertFalse 被注解的元素必须为 false</li><li>@Min(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@Max(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@DecimalMin(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@DecimalMax(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@Size(max=, min=) 被注解的元素的大小必须在指定的范围内</li><li>@Digits (integer, fraction) 被注解的元素必须是一个数字，其值必须在可接受的范围内</li><li>@Past 被注解的元素必须是一个过去的日期</li><li>@Future 被注解的元素必须是一个将来的日期</li><li>@Pattern(regex=,flag=) 被注解的元素必须符合指定的正则表达式</li><li>@NotBlank(message =) 验证字符串非 null，且长度必须大于0</li><li>@Email 被注解的元素必须是电子邮箱地址</li><li>@Length(min=,max=) 被注解的字符串的大小必须在指定的范围内</li><li>@NotEmpty 被注解的字符串的必须非空</li><li>@Range(min=,max=,message=) 被注解的元素必须在合适的范围内</li></ul><p><strong>Controller</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@PostMapping(&quot;/user&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">(<span class="hljs-meta">@Validated(ValidationGroup1.class)</span> User user, BindingResult result)</span> </span>&#123;        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span> &amp;&amp; result.hasErrors()) &#123;            List&lt;ObjectError&gt; allErrors = result.getAllErrors();            <span class="hljs-keyword">for</span> (ObjectError error : allErrors) &#123;                System.out.println(error.getObjectName() + error.getDefaultMessage());            &#125;        &#125;    &#125;&#125;</code></pre></div><h1 id="SpringBoot整合持久层"><a href="#SpringBoot整合持久层" class="headerlink" title="SpringBoot整合持久层"></a>SpringBoot整合持久层</h1><h2 id="1-整合JDBCTemplate"><a href="#1-整合JDBCTemplate" class="headerlink" title="1. 整合JDBCTemplate"></a>1. 整合JDBCTemplate</h2><p>在Java领域，数据持久化有几个常见的方案，有Spring自带的JdbcTemplate、有MyBatis，还有JPA，在这些方案中，最简单的就是Spring自带的JdbcTemplate了，这个东西虽然没有MyBatis那么方便，但是比起最开始的Jdbc已经强了很多了，它没有MyBatis功能那么强大，当然也意味着它的使用比较简单，事实上，JdbcTemplate算是最简单的数据持久化方案</p><h3 id="1-1-基本配置"><a href="#1-1-基本配置" class="headerlink" title="1.1 基本配置"></a>1.1 基本配置</h3><p>JdbcTemplate基本用法实际上很简单，开发者在创建一个SpringBoot项目时，除了选择基本的Web依赖，再记得选上Jdbc依赖，以及数据库驱动依赖即可，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/1-1-20210525153228731.png" alt="img"></p><p>项目创建成功之后，记得添加Druid数据库连接池依赖（注意这里可以添加专门为Spring Boot打造的druid-spring-boot-starter，而不是我们一般在SSM中添加的Druid），所有添加的依赖如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>项目创建完后，接下来只需要在application.properties中提供数据的基本配置即可，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8</span></code></pre></div><p>如此之后，所有的配置就算完成了，<strong>接下来就可以直接使用JdbcTemplate，其实这就是SpringBoot的自动化配置带来的好处</strong></p><h3 id="1-2-基本用法"><a href="#1-2-基本用法" class="headerlink" title="1.2 基本用法"></a>1.2 基本用法</h3><p>首先我们来创建一个User Bean，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String address;    <span class="hljs-comment">//省略getter/setter</span>&#125;</code></pre></div><p>然后来创建一个UserService类，在UserService类中注入JdbcTemplate，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    JdbcTemplate jdbcTemplate;&#125;</code></pre></div><p>好了，如此之后，准备工作就算完成了。</p><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>JdbcTemplate中，除了查询有几个API之外，增删改统一都使用update来操作，自己来传入SQL即可。例如添加数据，方法如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span> </span>&#123;    <span class="hljs-keyword">return</span> jdbcTemplate.update(<span class="hljs-string">&quot;insert into user (username,address) values (?,?);&quot;</span>, user.getUsername(), user.getAddress());&#125;</code></pre></div><p>update方法的返回值就是SQL执行受影响的行数。</p><p>这里只需要传入SQL即可，如果你的需求比较复杂，例如在数据插入的过程中希望实现主键回填，那么可以使用PreparedStatementCreator，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addUser2</span><span class="hljs-params">(User user)</span> </span>&#123;      KeyHolder keyHolder = <span class="hljs-keyword">new</span> GeneratedKeyHolder();    <span class="hljs-keyword">int</span> update = jdbcTemplate.update(<span class="hljs-keyword">new</span> PreparedStatementCreator() &#123;              <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title">createPreparedStatement</span><span class="hljs-params">(Connection connection)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;            PreparedStatement ps = connection.prepareStatement(<span class="hljs-string">&quot;insert into user (username,address) values (?,?);&quot;</span>, Statement.RETURN_GENERATED_KEYS);            ps.setString(<span class="hljs-number">1</span>, user.getUsername());            ps.setString(<span class="hljs-number">2</span>, user.getAddress());            <span class="hljs-keyword">return</span> ps;        &#125;    &#125;, keyHolder);    user.setId(keyHolder.getKey().longValue());    System.out.println(user);    <span class="hljs-keyword">return</span> update;&#125;</code></pre></div><p>实际上这里就相当于完全使用了JDBC中的解决方案了，首先在构建PreparedStatement时传入Statement.RETURN_GENERATED_KEYS，然后传入KeyHolder，最终从KeyHolder中获取刚刚插入数据的id保存到user对象的id属性中去。</p><p>你能想到的JDBC的用法，在这里都能实现，Spring提供的JdbcTemplate虽然不如MyBatis，但是比起Jdbc还是要方便很多的。</p><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>删除也是使用update API，传入你的SQL即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;    <span class="hljs-keyword">return</span> jdbcTemplate.update(<span class="hljs-string">&quot;delete from user where id=?&quot;</span>, id);&#125;</code></pre></div><p>当然你也可以使用PreparedStatementCreator</p><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateUserById</span><span class="hljs-params">(User user)</span> </span>&#123;    <span class="hljs-keyword">return</span> jdbcTemplate.update(<span class="hljs-string">&quot;update user set username=?,address=? where id=?&quot;</span>, user.getUsername(), user.getAddress(),user.getId());&#125;</code></pre></div><p>当然你也可以使用PreparedStatementCreator</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>查询的话，稍微有点变化，这里主要向大伙介绍query方法，例如查询所有用户：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getAllUsers</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> jdbcTemplate.query(<span class="hljs-string">&quot;select * from user&quot;</span>, <span class="hljs-keyword">new</span> RowMapper&lt;User&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;            String username = resultSet.getString(<span class="hljs-string">&quot;username&quot;</span>);            String address = resultSet.getString(<span class="hljs-string">&quot;address&quot;</span>);            <span class="hljs-keyword">long</span> id = resultSet.getLong(<span class="hljs-string">&quot;id&quot;</span>);            User user = <span class="hljs-keyword">new</span> User();            user.setAddress(address);            user.setUsername(username);            user.setId(id);            <span class="hljs-keyword">return</span> user;        &#125;    &#125;);&#125;</code></pre></div><p>查询的时候需要提供一个RowMapper，就是需要自己手动映射，将数据库中的字段和对象的属性一一对应起来，这样看起来有点麻烦，实际上，如果数据库中的字段和对象属性的名字一模一样的话，有另外一个简单的方案，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getAllUsers2</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> jdbcTemplate.query(<span class="hljs-string">&quot;select * from user&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class));&#125;</code></pre></div><p>至于查询时候传参也是使用占位符，这个和前文的一致，这里不再赘述。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>除了这些基本用法之外，JdbcTemplate也支持其他用法，例如调用存储过程等，这些都比较容易，而且和Jdbc本身都比较相似，这里也就不做介绍了，有兴趣可以留言讨论。</p><h3 id="1-3-原理分析"><a href="#1-3-原理分析" class="headerlink" title="1.3 原理分析"></a>1.3 原理分析</h3><p>那么在SpringBoot中，配置完数据库基本信息之后，就有了一个JdbcTemplate了，这个东西是从哪里来的呢？源码在<code>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration</code>类中，该类源码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass(&#123; DataSource.class, JdbcTemplate.class &#125;)</span><span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span><span class="hljs-meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span><span class="hljs-meta">@EnableConfigurationProperties(JdbcProperties.class)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateAutoConfiguration</span> </span>&#123;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateConfiguration</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DataSource dataSource;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JdbcProperties properties;JdbcTemplateConfiguration(DataSource dataSource, JdbcProperties properties) &#123;<span class="hljs-keyword">this</span>.dataSource = dataSource;<span class="hljs-keyword">this</span>.properties = properties;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@Primary</span><span class="hljs-meta">@ConditionalOnMissingBean(JdbcOperations.class)</span><span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">()</span> </span>&#123;JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(<span class="hljs-keyword">this</span>.dataSource);JdbcProperties.Template template = <span class="hljs-keyword">this</span>.properties.getTemplate();jdbcTemplate.setFetchSize(template.getFetchSize());jdbcTemplate.setMaxRows(template.getMaxRows());<span class="hljs-keyword">if</span> (template.getQueryTimeout() != <span class="hljs-keyword">null</span>) &#123;jdbcTemplate.setQueryTimeout((<span class="hljs-keyword">int</span>) template.getQueryTimeout().getSeconds());&#125;<span class="hljs-keyword">return</span> jdbcTemplate;&#125;&#125;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import(JdbcTemplateConfiguration.class)</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NamedParameterJdbcTemplateConfiguration</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@Primary</span><span class="hljs-meta">@ConditionalOnSingleCandidate(JdbcTemplate.class)</span><span class="hljs-meta">@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)</span><span class="hljs-function"><span class="hljs-keyword">public</span> NamedParameterJdbcTemplate <span class="hljs-title">namedParameterJdbcTemplate</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">JdbcTemplate jdbcTemplate)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NamedParameterJdbcTemplate(jdbcTemplate);&#125;&#125;&#125;</code></pre></div><p>从这个类中，大致可以看出，当当前类路径下存在DataSource和JdbcTemplate时，该类就会被自动配置，jdbcTemplate方法则表示，如果开发者没有自己提供一个JdbcOperations的实例的话，系统就自动配置一个JdbcTemplate Bean（JdbcTemplate是JdbcOperations接口的一个实现）</p><h3 id="1-4-多数据源配置"><a href="#1-4-多数据源配置" class="headerlink" title="1.4 多数据源配置"></a>1.4 多数据源配置</h3><p>多数据源配置也算是一个常见的开发需求，Spring和SpringBoot中，对此都有相应的解决方案，不过一般来说，如果有多数据源的需求，我还是建议首选分布式数据库中间件<code>MyCat</code>去解决相关问题，之前有小伙伴在我的知识星球上提问，他的数据根据条件的不同，可能保存在四十多个不同的数据库中，怎么办？这种场景下使用多数据源其实就有些费事了，我给的建议是使用MyCat，然后分表策略使用sharding-by-intfile。当然如果一些简单的需求，还是可以使用多数据源的，Spring Boot中，JdbcTemplate、MyBatis以及Jpa都可以配置多数据源，本文就先和大伙聊一聊JdbcTemplate中多数据源的配置</p><h4 id="1-4-1-创建工程"><a href="#1-4-1-创建工程" class="headerlink" title="1.4.1 创建工程"></a>1.4.1 创建工程</h4><p>首先是创建工程，和前文一样，创建工程时，也是选择Web、Jdbc以及MySQL驱动，如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/1-1-20210523152539479-20210525153228676.png" alt="img"></p><p>创建成功之后，一定接下来手动添加Druid依赖，由于这里一会需要开发者自己配置DataSoruce，所以这里必须要使用<code>druid-spring-boot-starter</code>依赖，而不是传统的那个druid依赖，因为<code>druid-spring-boot-starter</code>依赖提供了DruidDataSourceBuilder类，这个可以用来构建一个DataSource实例，而传统的Druid则没有该类。完整的依赖如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="1-4-2-配置数据源"><a href="#1-4-2-配置数据源" class="headerlink" title="1.4.2 配置数据源"></a>1.4.2 配置数据源</h4><p>接下来，在application.properties中配置数据源，不同于上文，这里的数据源需要配置两个，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.one.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=utf-8</span><span class="hljs-meta">spring.datasource.one.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.one.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.one.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-meta">spring.datasource.two.url</span>=<span class="hljs-string">jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=utf-8</span><span class="hljs-meta">spring.datasource.two.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.two.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.two.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span></code></pre></div><p>这里通过one和two对数据源进行了区分，但是加了one和two之后，这里的配置就没法被SpringBoot自动加载了（因为前面的key变了），需要我们自己去加载DataSource了，此时，需要自己配置一个DataSourceConfig，用来提供两个DataSource Bean，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</span>    <span class="hljs-function">DataSource <span class="hljs-title">dsOne</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)</span>    <span class="hljs-function">DataSource <span class="hljs-title">dsTwo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();    &#125;&#125;</code></pre></div><p>这里提供了两个Bean，其中@ConfigurationProperties是Spring Boot提供的类型安全的属性绑定，以第一个Bean为例，<code>@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</code>表示使用<code>spring.datasource.one</code>前缀的数据库配置去创建一个DataSource，这样配置之后，我们就有了两个不同的DataSource，接下来再用这两个不同的DataSource去创建两个不同的JdbcTemplate</p><h4 id="1-4-3-配置JdbcTemplate实例"><a href="#1-4-3-配置JdbcTemplate实例" class="headerlink" title="1.4.3 配置JdbcTemplate实例"></a>1.4.3 配置JdbcTemplate实例</h4><p>创建JdbcTemplateConfig类，用来提供两个不同的JdbcTemplate实例，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">JdbcTemplate <span class="hljs-title">jdbcTemplateOne</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;dsOne&quot;)</span> DataSource dsOne)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dsOne);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">JdbcTemplate <span class="hljs-title">jdbcTemplateTwo</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;dsTwo&quot;)</span> DataSource dsTwo)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dsTwo);    &#125;&#125;</code></pre></div><p>每一个JdbcTemplate的创建都需要一个DataSource，由于Spring容器中现在存在两个DataSource，默认使用类型查找，会报错，因此加上@Qualifier注解，表示按照名称查找。这里创建了两个JdbcTemplate实例，分别对应了两个DataSource，接下来直接去使用这个JdbcTemplate就可以了</p><h4 id="1-4-4-测试使用"><a href="#1-4-4-测试使用" class="headerlink" title="1.4.4 测试使用"></a>1.4.4 测试使用</h4><p>关于JdbcTemplate的详细用法大伙可以参考我的上篇文章，这里我主要演示数据源的差异，在Controller中注入两个不同的JdbcTemplate，这两个JdbcTemplate分别对应了不同的数据源，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier(&quot;jdbcTemplateOne&quot;)</span>    JdbcTemplate jdbcTemplateOne;    <span class="hljs-meta">@Resource(name = &quot;jdbcTemplateTwo&quot;)</span>    JdbcTemplate jdbcTemplateTwo;    <span class="hljs-meta">@GetMapping(&quot;/user&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span> </span>&#123;        List&lt;User&gt; list = jdbcTemplateOne.query(<span class="hljs-string">&quot;select * from t_user&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class));        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-meta">@GetMapping(&quot;/user2&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getAllUser2</span><span class="hljs-params">()</span> </span>&#123;        List&lt;User&gt; list = jdbcTemplateTwo.query(<span class="hljs-string">&quot;select * from t_user&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class));        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre></div><p>和DataSource一样，Spring容器中的JdbcTemplate也是有两个，因此不能通过byType的方式注入进来，这里给大伙提供了两种注入思路，一种是使用@Resource注解，直接通过byName的方式注入进来，另外一种就是<code>@Autowired</code>注解加上<code>@Qualifier</code>注解，两者联合起来，实际上也是byName。将JdbcTemplate注入进来之后，jdbcTemplateOne和jdbcTemplateTwo此时就代表操作不同的数据源，使用不同的JdbcTemplate操作不同的数据源，实现了多数据源配置。</p><h2 id="2-整合MyBatis"><a href="#2-整合MyBatis" class="headerlink" title="2. 整合MyBatis"></a>2. 整合MyBatis</h2><p>JdbcTemplate虽然简单，但是用的并不多，因为它没有MyBatis方便，在Spring+SpringMVC中整合MyBatis步骤还是有点复杂的，要配置多个Bean，Spring Boot中对此做了进一步的简化，使MyBatis基本上可以做到开箱即用，本文就来看看在Spring Boot中MyBatis要如何使用</p><h3 id="2-1-工程创建"><a href="#2-1-工程创建" class="headerlink" title="2.1 工程创建"></a>2.1 工程创建</h3><p>首先创建一个基本的Spring Boot工程，添加Web依赖，MyBatis依赖以及MySQL驱动依赖，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-1-20210523153350314-20210525153228568.png" alt="img"></p><p>创建成功后，添加Druid依赖，并且锁定MySQL驱动版本，完整的依赖如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>如此，工程就算是创建成功了。读者注意，MyBatis和Druid依赖的命名和其他库的命名不太一样，是属于xxx-spring-boot-stater模式的，这表示该starter是由第三方提供的。</p><h3 id="2-2-基本用法"><a href="#2-2-基本用法" class="headerlink" title="2.2 基本用法"></a>2.2 基本用法</h3><p>MyBatis的使用和JdbcTemplate基本一致，首先也是在application.properties中配置数据库的基本信息：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=utf-8</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span></code></pre></div><p>配置完成后，MyBatis就可以创建Mapper来使用了，例如我这里直接创建一个UserMapper2，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper2</span> </span>&#123;    <span class="hljs-meta">@Select(&quot;select * from user&quot;)</span>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUsers</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@Results(&#123;</span><span class="hljs-meta">            @Result(property = &quot;id&quot;, column = &quot;id&quot;),</span><span class="hljs-meta">            @Result(property = &quot;username&quot;, column = &quot;u&quot;),</span><span class="hljs-meta">            @Result(property = &quot;address&quot;, column = &quot;a&quot;)</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-meta">@Select(&quot;select username as u,address as a,id as id from user where id=#&#123;id&#125;&quot;)</span>    <span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span></span>;    <span class="hljs-meta">@Select(&quot;select * from user where username like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)&quot;)</span>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUsersByName</span><span class="hljs-params">(String name)</span></span>;    <span class="hljs-meta">@Insert(&#123;&quot;insert into user(username,address) values(#&#123;username&#125;,#&#123;address&#125;)&quot;&#125;)</span>    <span class="hljs-meta">@SelectKey(statement = &quot;select last_insert_id()&quot;, keyProperty = &quot;id&quot;, before = false, resultType = Integer.class)</span>    <span class="hljs-function">Integer <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-meta">@Update(&quot;update user set username=#&#123;username&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&quot;)</span>    <span class="hljs-function">Integer <span class="hljs-title">updateUserById</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-meta">@Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)</span>    <span class="hljs-function">Integer <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span></span>;&#125;</code></pre></div><p>这里是通过全注解的方式来写SQL，不写XML文件，@Select、@Insert、@Update以及@Delete四个注解分别对应XML中的select、insert、update以及delete标签，@Results注解类似于XML中的ResultMap映射文件（getUserById方法给查询结果的字段取别名主要是向小伙伴们演示下<code>@Results</code>注解的用法），另外使用@SelectKey注解可以实现主键回填的功能，即当数据插入成功后，插入成功的数据id会赋值到user对象的id属性上。</p><p>UserMapper2创建好之后，还要配置mapper扫描，有两种方式，一种是直接在UserMapper2上面添加<code>@Mapper</code>注解，这种方式有一个弊端就是所有的Mapper都要手动添加，要是落下一个就会报错，还有一个一劳永逸的办法就是直接在启动类上添加Mapper扫描，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@MapperScan(basePackages = &quot;org.sang.mybatis.mapper&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(MybatisApplication.class, args);    &#125;&#125;</code></pre></div><p>好了，做完这些工作就可以去测试Mapper的使用了。</p><h3 id="2-3-mapper映射"><a href="#2-3-mapper映射" class="headerlink" title="2.3 mapper映射"></a>2.3 mapper映射</h3><p>当然，开发者也可以在XML中写SQL，例如创建一个UserMapper，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Integer <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-function">Integer <span class="hljs-title">updateUserById</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-function">Integer <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span></span>;&#125;</code></pre></div><p>然后创建UserMapper.xml文件，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.sang.mybatis.mapper.UserMapper&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span>        select * from t_user;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span>        insert into user (username,address) values (#&#123;username&#125;,#&#123;address&#125;);    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span>        update user set username=#&#123;username&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUserById&quot;</span>&gt;</span>        delete from user where id=#&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span>    <span class="hljs-comment">&lt;!--或者定义resultMap去映射--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.javaboy.mybatis.model.User&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address1&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span>  select * from user where id=#&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUsers&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span>  select * from user ;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>将接口中方法对应的SQL直接写在XML文件中</p><p>那么这个UserMapper.xml到底放在哪里呢？有两个位置可以放，第一个是直接放在UserMapper所在的包下面：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-2-20210523153350459-20210525153228563.png" alt="img"></p><p>放在这里的UserMapper.xml会被自动扫描到，但是有另外一个Maven带来的问题，就是java目录下的xml资源在项目打包时会被忽略掉，所以，如果UserMapper.xml放在包下，需要在pom.xml文件中再添加如下配置，避免打包时java目录下的XML文件被自动忽略掉：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>当然，UserMapper.xml也可以直接放在resources目录下，这样就不用担心打包时被忽略了，但是放在resources目录下，又不能自动被扫描到，需要添加额外配置。例如我在resources目录下创建mapper目录用来放mapper文件，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-3-20210523153349662-20210525153228563.png" alt="img"></p><p>此时在application.properties中告诉mybatis去哪里扫描mapper：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*.xml</span></code></pre></div><p>如此配置之后，mapper就可以正常使用了。注意第二种方式不需要在pom.xml文件中配置文件过滤。</p><h3 id="2-4-原理分析"><a href="#2-4-原理分析" class="headerlink" title="2.4 原理分析"></a>2.4 原理分析</h3><p>在SSM整合中，开发者需要自己提供两个Bean，一个SqlSessionFactoryBean，还有一个是MapperScannerConfigurer，在Spring Boot中，这两个东西虽然不用开发者自己提供了，但是并不意味着这两个Bean不需要了，在<code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code>类中，我们可以看到Spring Boot提供了这两个Bean，部分源码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration<span class="hljs-meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span><span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span><span class="hljs-meta">@EnableConfigurationProperties(MybatisProperties.class)</span><span class="hljs-meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisAutoConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;  <span class="hljs-meta">@Bean</span>  <span class="hljs-meta">@ConditionalOnMissingBean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    SqlSessionFactoryBean factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();    factory.setDataSource(dataSource);    <span class="hljs-keyword">return</span> factory.getObject();  &#125;  <span class="hljs-meta">@Bean</span>  <span class="hljs-meta">@ConditionalOnMissingBean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionTemplate <span class="hljs-title">sqlSessionTemplate</span><span class="hljs-params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;    ExecutorType executorType = <span class="hljs-keyword">this</span>.properties.getExecutorType();    <span class="hljs-keyword">if</span> (executorType != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory);    &#125;  &#125;  <span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration  <span class="hljs-meta">@Import(&#123; AutoConfiguredMapperScannerRegistrar.class &#125;)</span>  <span class="hljs-meta">@ConditionalOnMissingBean(MapperFactoryBean.class)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperScannerRegistrarNotFoundConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;      logger.debug(<span class="hljs-string">&quot;No &#123;&#125; found.&quot;</span>, MapperFactoryBean.class.getName());    &#125;  &#125;&#125;</code></pre></div><p>从类上的注解可以看出，当前类路径下存在SqlSessionFactory、 SqlSessionFactoryBean以及DataSource时，这里的配置才会生效，SqlSessionFactory和SqlTemplate都被提供了。</p><h3 id="2-5-多数据源"><a href="#2-5-多数据源" class="headerlink" title="2.5 多数据源"></a>2.5 多数据源</h3><p>其实关于多数据源，我的态度还是和之前一样，复杂的就直接上分布式数据库中间件，简单的再考虑多数据源。这是项目中的建议，技术上的话，当然还是各种技术都要掌握的。</p><h4 id="2-5-1-工程创建"><a href="#2-5-1-工程创建" class="headerlink" title="2.5.1 工程创建"></a>2.5.1 工程创建</h4><p>首先需要创建MyBatis项目，项目创建和前文的一样，添加MyBatis、MySQL以及Web依赖：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-1-20210523173628435-20210525153228619.png" alt="img"></p><p>项目创建完成后，添加Druid依赖，和JdbcTemplate一样，这里添加Druid依赖也必须是专为Spring boot打造的Druid，不能使用传统的Druid。完整的依赖如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="2-5-2-多数据源配置"><a href="#2-5-2-多数据源配置" class="headerlink" title="2.5.2 多数据源配置"></a>2.5.2 多数据源配置</h4><p>接下来配置多数据源，这里基本上还是和JdbcTemplate多数据源的配置方式一致，首先在application.properties中配置数据库基本信息，然后提供两个DataSource即可，这里我再把代码贴出来，里边的道理条条框框的，大伙可以参考前面的文章，这里不再赘述。</p><p>application.properties中的配置：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.one.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=utf-8</span><span class="hljs-meta">spring.datasource.one.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.one.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.one.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-meta">spring.datasource.two.url</span>=<span class="hljs-string">jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=utf-8</span><span class="hljs-meta">spring.datasource.two.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.two.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.two.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span></code></pre></div><p>然后再提供两个DataSource，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</span>    <span class="hljs-function">DataSource <span class="hljs-title">dsOne</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)</span>    <span class="hljs-function">DataSource <span class="hljs-title">dsTwo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();    &#125;&#125;</code></pre></div><h4 id="2-5-3-MyBatis配置"><a href="#2-5-3-MyBatis配置" class="headerlink" title="2.5.3 MyBatis配置"></a>2.5.3 MyBatis配置</h4><p>接下来则是MyBatis的配置，不同于JdbcTemplate，MyBatis的配置要稍微麻烦一些，因为要提供两个Bean，因此这里两个数据源我将在两个类中分开来配置，首先来看第一个数据源的配置：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@MapperScan(basePackages = &quot;org.sang.mybatis.mapper1&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactory1&quot;,sqlSessionTemplateRef = &quot;sqlSessionTemplate1&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfigOne</span> </span>&#123;    <span class="hljs-meta">@Resource(name = &quot;dsOne&quot;)</span>    DataSource dsOne;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">SqlSessionFactory <span class="hljs-title">sqlSessionFactory1</span><span class="hljs-params">()</span> </span>&#123;        SqlSessionFactory sessionFactory = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            SqlSessionFactoryBean bean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();            bean.setDataSource(dsOne);            sessionFactory = bean.getObject();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> sessionFactory;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">SqlSessionTemplate <span class="hljs-title">sqlSessionTemplate1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory1());    &#125;&#125;</code></pre></div><p>创建MyBatisConfigOne类，首先指明该类是一个配置类，配置类中要扫描的包是org.sang.mybatis.mapper1，即该包下的Mapper接口将操作dsOne中的数据，对应的SqlSessionFactory和SqlSessionTemplate分别是sqlSessionFactory1和sqlSessionTemplate1，在MyBatisConfigOne内部，分别提供SqlSessionFactory和SqlSessionTemplate即可，SqlSessionFactory根据dsOne创建，然后再根据创建好的SqlSessionFactory创建一个SqlSessionTemplate。</p><p>这里配置完成后，依据这个配置，再来配置第二个数据源即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@MapperScan(basePackages = &quot;org.sang.mybatis.mapper2&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactory2&quot;,sqlSessionTemplateRef = &quot;sqlSessionTemplate2&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfigTwo</span> </span>&#123;    <span class="hljs-meta">@Resource(name = &quot;dsTwo&quot;)</span>    DataSource dsTwo;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">SqlSessionFactory <span class="hljs-title">sqlSessionFactory2</span><span class="hljs-params">()</span> </span>&#123;        SqlSessionFactory sessionFactory = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            SqlSessionFactoryBean bean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();            bean.setDataSource(dsTwo);            sessionFactory = bean.getObject();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> sessionFactory;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">SqlSessionTemplate <span class="hljs-title">sqlSessionTemplate2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory2());    &#125;&#125;</code></pre></div><p>好了，这样MyBatis多数据源基本上就配置好了，接下来只需要在org.sang.mybatis.mapper1和org.sang.mybatis.mapper2包中提供不同的Mapper，Service中注入不同的Mapper就可以操作不同的数据源。</p><h4 id="2-5-4-mapper创建"><a href="#2-5-4-mapper创建" class="headerlink" title="2.5.4 mapper创建"></a>2.5.4 mapper创建</h4><p>org.sang.mybatis.mapper1中的mapper：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapperOne</span> </span>&#123;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>对应的XML文件：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.sang.mybatis.mapper1.UserMapperOne&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span>        select * from t_user;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>org.sang.mybatis.mapper2中的mapper：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>对应的XML文件：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.sang.mybatis.mapper2.UserMapper&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span>        select * from t_user;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>接下来，在Service中注入两个不同的Mapper，不同的Mapper将操作不同的数据源。</p><h2 id="3-整合Jpa"><a href="#3-整合Jpa" class="headerlink" title="3. 整合Jpa"></a>3. 整合Jpa</h2><h3 id="3-1-JPA是什么"><a href="#3-1-JPA是什么" class="headerlink" title="3.1 JPA是什么"></a>3.1 JPA是什么</h3><ul><li><p>Java Persistence API：用于对象持久化的 API</p></li><li><p>Java EE 5.0 平台标准的 ORM 规范，使得应用程序以统一的方式访问持久层 </p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/19-1-20210525153228703.png" alt="img"></p></li></ul><h3 id="3-2-JPA和Hibernate的关系"><a href="#3-2-JPA和Hibernate的关系" class="headerlink" title="3.2 JPA和Hibernate的关系"></a>3.2 JPA和Hibernate的关系</h3><ul><li>JPA 是 Hibernate 的一个抽象（就像JDBC和JDBC驱动的关系）</li><li>JPA 是规范：JPA 本质上就是一种 ORM 规范，不是ORM 框架，这是因为 JPA 并未提供 ORM 实现，它只是制订了一些规范，提供了一些编程的 API 接口，但具体实现则由 ORM 厂商提供实现；</li><li>Hibernate 是实现：Hibernate 除了作为 ORM 框架之外，它也是一种 JPA 实现</li><li>从功能上来说， JPA 是 Hibernate 功能的一个子集</li></ul><h3 id="3-3-JPA的供应商"><a href="#3-3-JPA的供应商" class="headerlink" title="3.3 JPA的供应商"></a>3.3 JPA的供应商</h3><p>JPA 的目标之一是制定一个可以由很多供应商实现的 API，Hibernate 3.2+、TopLink 10.1+ 以及 OpenJPA 都提供了 JPA 的实现，Jpa 供应商有很多，常见的有如下四种：</p><ul><li>Hibernate<br>JPA 的始作俑者就是 Hibernate 的作者，Hibernate 从 3.2 开始兼容 JPA。</li><li>OpenJPA<br>OpenJPA 是 Apache 组织提供的开源项目。</li><li>TopLink<br>TopLink 以前需要收费，如今开源了。</li><li>EclipseLink</li></ul><h3 id="3-4-JPA的优势"><a href="#3-4-JPA的优势" class="headerlink" title="3.4 JPA的优势"></a>3.4 JPA的优势</h3><ul><li>标准化: 提供相同的 API，这保证了基于JPA 开发的企业应用能够经过少量的修改就能够在不同的 JPA 框架下运行。</li><li>简单易用，集成方便: JPA 的主要目标之一就是提供更加简单的编程模型，在 JPA 框架下创建实体和创建 Java 类一样简单，只需要使用 javax.persistence.Entity 进行注解；JPA 的框架和接口也都非常简单。</li><li>可媲美JDBC的查询能力: JPA的查询语言是面向对象的，JPA定义了独特的JPQL，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。</li><li>支持面向对象的高级特性: JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，最大限度的使用面向对象的模型</li></ul><h3 id="3-5-JPA包含的技术"><a href="#3-5-JPA包含的技术" class="headerlink" title="3.5 JPA包含的技术"></a>3.5 JPA包含的技术</h3><ul><li>ORM 映射元数据：JPA 支持 XML 和 JDK 5.0 注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。</li><li>JPA 的 API：用来操作实体对象，执行CRUD操作，框架在后台完成所有的事情，开发者从繁琐的 JDBC 和 SQL 代码中解脱出来。</li><li>查询语言（JPQL）：这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序和具体的 SQL 紧密耦合。</li></ul><h3 id="3-6-Spring-Data"><a href="#3-6-Spring-Data" class="headerlink" title="3.6 Spring Data"></a>3.6 Spring Data</h3><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><ul><li>SpringData 项目支持 NoSQL 存储：<br>MongoDB （文档数据库）<br>Neo4j（图形数据库）<br>Redis（键/值存储）<br>Hbase（列族数据库）</li><li>SpringData 项目所支持的关系数据存储技术：<br>JDBC<br>JPA</li><li>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！</li><li>框架怎么可能代替开发者实现业务逻辑呢？比如：当有一个 UserDao.findUserById() 这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象。Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</li></ul><h3 id="3-7-Jpa-的故事"><a href="#3-7-Jpa-的故事" class="headerlink" title="3.7 Jpa 的故事"></a>3.7 Jpa 的故事</h3><p>为了让大伙彻底把这两个东西学会，这里我就先来介绍单纯的Jpa使用，然后我们再结合 Spring Data 来看 Jpa如何使用。</p><p>整体步骤如下：</p><p>1.使用 IntelliJ IDEA 创建项目，创建时选择 JavaEE Persistence ，如下：<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/19-2-20210525153228734.png" alt="img"></p><p>2.创建成功后，添加依赖jar，由于 Jpa 只是一个规范，因此我们说用Jpa实际上必然是用Jpa的某一种实现，那么是哪一种实现呢？当然就是Hibernate了，所以添加的jar，实际上来自 Hibernate，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/19-3-20210525153228618.png" alt="img"></p><p>3.添加实体类</p><p>接下来在项目中添加实体类，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Entity(name = &quot;t_book&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String author;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-comment">// 省略其他getter/setter</span>&#125;</code></pre></div><p>首先@Entity注解表示这是一个实体类，那么在项目启动时会自动针对该类生成一张表，默认的表名为类名，@Entity注解的name属性表示自定义生成的表名。@Id注解表示这个字段是一个id，@GeneratedValue注解表示主键的自增长策略，对于类中的其他属性，默认都会根据属性名在表中生成相应的字段，字段名和属性名相同，如果开发者想要对字段进行定制，可以使用@Column注解，去配置字段的名称，长度，是否为空等等。</p><p>4.创建 persistence.xml 文件</p><p>JPA 规范要求在类路径的 META-INF 目录下放置persistence.xml，文件的名称是固定的</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">persistence</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/persistence&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">persistence-unit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;NewPersistenceUnit&quot;</span> <span class="hljs-attr">transaction-type</span>=<span class="hljs-string">&quot;RESOURCE_LOCAL&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">provider</span>&gt;</span>org.hibernate.jpa.HibernatePersistenceProvider<span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">class</span>&gt;</span>org.sang.Book<span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.connection.url&quot;</span></span><span class="hljs-tag">                      <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///jpa01?useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.connection.driver_class&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.connection.username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.connection.password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.archive.autodetection&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;class&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.show_sql&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.format_sql&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.hbm2ddl.auto&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;update&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">persistence-unit</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">persistence</span>&gt;</span></code></pre></div><p>注意：</p><ul><li>persistence-unit 的name 属性用于定义持久化单元的名字, 必填。</li><li>transaction-type：指定 JPA 的事务处理策略。RESOURCE_LOCAL：默认值，数据库级别的事务，只能针对一种数据库，不支持分布式事务。如果需要支持分布式事务，使用JTA：transaction-type=”JTA”</li><li>class节点表示显式的列出实体类</li><li>properties中的配置分为两部分：数据库连接信息以及Hibernate信息</li></ul><ol><li>执行持久化操作</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java">EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(<span class="hljs-string">&quot;NewPersistenceUnit&quot;</span>);EntityManager manager = entityManagerFactory.createEntityManager();EntityTransaction transaction = manager.getTransaction();transaction.begin();Book book = <span class="hljs-keyword">new</span> Book();book.setAuthor(<span class="hljs-string">&quot;罗贯中&quot;</span>);book.setName(<span class="hljs-string">&quot;三国演义&quot;</span>);manager.persist(book);transaction.commit();manager.close();entityManagerFactory.close();</code></pre></div><p>这里首先根据配置文件创建出来一个 EntityManagerFactory ，然后再根据 EntityManagerFactory 的实例创建出来一个 EntityManager ，然后再开启事务，调用 EntityManager 中的 persist 方法执行一次持久化操作，最后提交事务，执行完这些操作后，数据库中旧多出来一个 t_book 表，并且表中有一条数据。</p><h4 id="关于-JPQL"><a href="#关于-JPQL" class="headerlink" title="关于 JPQL"></a>关于 JPQL</h4><ul><li><p>JPQL语言，即 Java Persistence Query Language 的简称。JPQL 是一种和 SQL 非常类似的中间性和对象化查询语言，它最终会被编译成针对不同底层数据库的 SQL 查询，从而屏蔽不同数据库的差异。JPQL语言的语句可以是 select 语句、update 语句或delete语句，它们都通过 Query 接口封装执行。</p></li><li><p>Query接口封装了执行数据库查询的相关方法。调用 EntityManager 的 createQuery、create NamedQuery 及 createNativeQuery 方法可以获得查询对象，进而可调用 Query 接口的相关方法来执行查询操作。</p></li><li><p>Query接口的主要方法如下：</p><ul><li><table><thead><tr><th><strong>int executeUpdate();</strong></th><th>用于执行update或delete语句。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>List getResultList();</strong></th><th>用于执行select语句并返回结果集实体列表。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>Object getSingleResult();</strong></th><th>用于执行只返回单个结果实体的select语句。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>Query setFirstResult(int startPosition);</strong></th><th>用于设置从哪个实体记录开始返回查询结果。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>Query setMaxResults(int maxResult);</strong></th><th>用于设置返回结果实体的最大数。与setFirstResult结合使用可实现分页查询。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>Query setFlushMode(FlushModeType flushMode);</strong></th><th>设置查询对象的Flush模式。参数可以取2个枚举值：FlushModeType.AUTO 为自动更新数据库记录，FlushMode Type.COMMIT 为直到提交事务时才更新数据库记录。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>setHint(String hintName, Object value);</strong></th><th>设置与查询对象相关的特定供应商参数或提示信息。参数名及其取值需要参考特定 JPA 实现库提供商的文档。如果第二个参数无效将抛出IllegalArgumentException异常。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>setParameter(int position, Object value);</strong></th><th>为查询语句的指定位置参数赋值。Position 指定参数序号，value 为赋给参数的值。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>setParameter(int position, Date d, TemporalType type);</strong></th><th>为查询语句的指定位置参数赋 Date 值。Position 指定参数序号，value 为赋给参数的值，temporalType 取 TemporalType 的枚举常量，包括 DATE、TIME 及 TIMESTAMP 三个，，用于将 Java 的 Date 型值临时转换为数据库支持的日期时间类型（java.sql.Date、java.sql.Time及java.sql.Timestamp）。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>setParameter(int position, Calendar c, TemporalType type);</strong></th><th>为查询语句的指定位置参数赋 Calenda r值。position 指定参数序号，value 为赋给参数的值，temporalType 的含义及取舍同前。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>setParameter(String name, Object value);</strong></th><th>为查询语句的指定名称参数赋值。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><table><thead><tr><th><strong>setParameter(String name, Date d, TemporalType type);</strong></th><th>为查询语句的指定名称参数赋 Date 值,用法同前。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>setParameter(String name, Calendar c, TemporalType type);</strong></th><th>为查询语句的指定名称参数设置Calendar值。name为参数名，其它同前。该方法调用时如果参数位置或参数名不正确，或者所赋的参数值类型不匹配，将抛出 IllegalArgumentException 异常。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li></ul></li></ul><h4 id="JPQL-举例"><a href="#JPQL-举例" class="headerlink" title="JPQL 举例"></a>JPQL 举例</h4><p>和在 SQL 中一样，JPQL 中的 select 语句用于执行查询。其语法可表示为：<br><code>select_clause form_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause]</code></p><p>其中：</p><ol><li>from 子句是查询语句的必选子句。</li><li>select 用来指定查询返回的结果实体或实体的某些属性。</li><li>from 子句声明查询源实体类，并指定标识符变量（相当于SQL表的别名）。</li><li>如果不希望返回重复实体，可使用关键字 distinct 修饰。select、from 都是 JPQL 的关键字，通常全大写或全小写，建议不要大小写混用。</li></ol><p>在 JPQL 中，查询所有实体的 JPQL 查询语句很简单，如下：<br><code>select o from Order o 或 select o from Order as o</code><br>这里关键字 as 可以省去，标识符变量的命名规范与 Java 标识符相同，且区分大小写,调用 EntityManager 的 createQuery() 方法可创建查询对象，接着调用 Query 接口的 getResultList() 方法就可获得查询结果集，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Query query = entityManager.createQuery( <span class="hljs-string">&quot;select o from Order o&quot;</span>); List orders = query.getResultList();Iterator iterator = orders.iterator();<span class="hljs-keyword">while</span>(iterator.hasNext() ) &#123;  <span class="hljs-comment">// 处理Order</span>&#125;</code></pre></div><p>其他方法的与此类似，这里不再赘述。</p><h3 id="3-8-Spring-Data-的故事"><a href="#3-8-Spring-Data-的故事" class="headerlink" title="3.8 Spring Data 的故事"></a>3.8 Spring Data 的故事</h3><p>在 Spring Boot 中，Spring Data Jpa 官方封装了太多东西了，导致很多人用的时候不知道底层到底是怎么配置的，本文就和大伙来看看在手工的Spring环境下，Spring Data Jpa要怎么配置，配置完成后，用法和 Spring Boot 中的用法是一致的。</p><h4 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h4><p>首先创建一个普通的Maven工程，并添加如下依赖：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-oxm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.12.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-jpamodelgen<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.12.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.11.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><p>这里除了 Jpa 的依赖之外，就是Spring Data Jpa 的依赖了。</p><p>接下来创建一个 User 实体类，创建方式参考 Jpa中实体类的创建方式，这里不再赘述。</p><p>接下来在resources目录下创建一个applicationContext.xml文件，并配置Spring和Jpa，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.sang&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.driver&#125;&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.url&#125;&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.username&#125;&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.password&#125;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jpaVendorAdapter&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;packagesToScan&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.sang.model&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jpaProperties&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL57Dialect<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- 配置jpa --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">jpa:repositories</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.sang.dao&quot;</span></span><span class="hljs-tag">                  <span class="hljs-attr">entity-manager-factory-ref</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span>/&gt;</span></code></pre></div><p>这里和 Jpa 相关的配置主要是三个，一个是entityManagerFactory，一个是Jpa的事务，还有一个是配置dao的位置，配置完成后，就可以在 org.sang.dao 包下创建相应的 Repository 了，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">User</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;    <span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span></span>;&#125;</code></pre></div><p>getUserById表示根据id去查询User对象，只要我们的方法名称符合类似的规范，就不需要写SQL，具体的规范一会来说。好了，接下来，创建 Service 和 Controller 来调用这个方法，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    UserDao userDao;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">return</span> userDao.getUserById(id);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);    UserService userService = ctx.getBean(UserService.class);    User user = userService.getUserById(<span class="hljs-number">1L</span>);    System.out.println(user);&#125;</code></pre></div><p>这样，就可以查询到id为1的用户了。</p><h4 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h4><p>上文我们自定义的 UserDao 实现了 Repository 接口，这个 Repository 接口是什么来头呢？</p><p>首先来看 Repository 的一个继承关系图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/19-4-20210525152813140.png" alt="img"></p><p>可以看到，实现类不少。那么到底如何理解 Repository 呢？</p><ol><li>Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法 <code>public interface Repository&lt;T, ID extends Serializable&gt; &#123; &#125;</code></li><li>若我们定义的接口继承了 Repository, 则该接口会被 IOC 容器识别为一个 Repository Bean，进而纳入到 IOC 容器中，进而可以在该接口中定义满足一定规范的方法。</li><li>Spring Data可以让我们只定义接口，只要遵循 Spring Data 的规范，就无需写实现类。</li><li>与继承 Repository 等价的一种方式，就是在持久层接口上使用 @RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性。像下面这样：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RepositoryDefinition(domainClass = User.class, idClass = Long.class)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(Long id)</span></span>;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>基础的 Repository 提供了最基本的数据访问功能，其几个子接口则扩展了一些功能，它的几个常用的实现类如下：</p><ul><li>CrudRepository： 继承 Repository，实现了一组 CRUD 相关的方法</li><li>PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法</li><li>JpaRepository： 继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法</li><li>自定义的 XxxxRepository 需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力。</li><li>JpaSpecificationExecutor： 不属于Repository体系，实现一组 JPA Criteria 查询相关的方法</li></ul><h4 id="方法定义规范"><a href="#方法定义规范" class="headerlink" title="方法定义规范"></a>方法定义规范</h4><h5 id="简单条件查询"><a href="#简单条件查询" class="headerlink" title="简单条件查询"></a>简单条件查询</h5><ul><li>按照 Spring Data 的规范，查询方法以 find  read  get 开头</li><li>涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写</li></ul><p>例如：定义一个 Entity 实体类：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>｛ </span><span class="hljs-class">   <span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">firstName</span></span>;    <span class="hljs-keyword">private</span> String lastName; ｝</code></pre></div><p>使用And条件连接时，条件的属性名称与个数要与参数的位置与个数一一对应，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java">findByLastNameAndFirstName(String lastName,String firstName);</code></pre></div><ul><li>支持属性的级联查询. 若当前类有符合条件的属性, 则优先使用, 而不使用级联属性. 若需要使用级联属性, 则属性之间使用 _ 进行连接.</li></ul><p>查询举例：<br>1.按照id查询</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span></span>;<span class="hljs-function">User <span class="hljs-title">getById</span><span class="hljs-params">(Long id)</span></span>;</code></pre></div><p>2.查询所有年龄小于90岁的人</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByAgeLessThan</span><span class="hljs-params">(Long age)</span></span>;</code></pre></div><p>3.查询所有姓赵的人</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByUsernameStartingWith</span><span class="hljs-params">(String u)</span></span>;</code></pre></div><p>4.查询所有姓赵的、并且id大于50的人</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByUsernameStartingWithAndIdGreaterThan</span><span class="hljs-params">(String name, Long id)</span></span>;</code></pre></div><p>5.查询所有姓名中包含”上”字的人</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByUsernameContaining</span><span class="hljs-params">(String name)</span></span>;</code></pre></div><p>6.查询所有姓赵的或者年龄大于90岁的</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByUsernameStartingWithOrAgeGreaterThan</span><span class="hljs-params">(String name, Long age)</span></span>;</code></pre></div><p>7.查询所有角色为1的用户</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByRole_Id</span><span class="hljs-params">(Long id)</span></span>;</code></pre></div><h5 id="支持的关键字"><a href="#支持的关键字" class="headerlink" title="支持的关键字"></a>支持的关键字</h5><p>支持的查询关键字如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/19-5-20210525152813173.png" alt="img"></p><h5 id="查询方法流程解析"><a href="#查询方法流程解析" class="headerlink" title="查询方法流程解析"></a>查询方法流程解析</h5><p>为什么写上方法名，JPA就知道你想干嘛了呢？假如创建如下的查询：<code>findByUserDepUuid()</code>，框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析，假设查询实体为Doc：</p><ol><li>先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步；</li><li>从右往左截取第一个大写字母开头的字符串(此处为Uuid)，然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设 user 为查询实体的一个属性；</li><li>接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 “ Doc.user.depUuid” 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 “Doc.user.dep.uuid” 的值进行查询。</li><li>可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 “_” 以显式表达意图，比如 “findByUser_DepUuid()” 或者 “findByUserDep_uuid()”</li><li>还有一些特殊的参数：例如分页或排序的参数：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Page&lt;UserModel&gt; <span class="hljs-title">findByName</span><span class="hljs-params">(String name, Pageable pageable)</span></span>;  <span class="hljs-function">List&lt;UserModel&gt; <span class="hljs-title">findByName</span><span class="hljs-params">(String name, Sort sort)</span></span>;</code></pre></div><h4 id="Query注解"><a href="#Query注解" class="headerlink" title="@Query注解"></a>@Query注解</h4><p>有的时候，这里提供的查询关键字并不能满足我们的查询需求，这个时候就可以使用 @Query 关键字，来自定义查询 SQL，例如查询Id最大的User：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Query(&quot;select u from t_user u where id=(select max(id) from t_user)&quot;)</span><span class="hljs-function">User <span class="hljs-title">getMaxIdUser</span><span class="hljs-params">()</span></span>;</code></pre></div><p>如果查询有参数的话，参数有两种不同的传递方式:</p><p>1.利用下标索引传参，索引参数如下所示，索引值从1开始，查询中 ”?X” 个数需要与方法定义的参数个数相一致，并且顺序也要一致：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Query(&quot;select u from t_user u where id&gt;?1 and username like ?2&quot;)</span><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">selectUserByParam</span><span class="hljs-params">(Long id, String name)</span></span>;</code></pre></div><p>2.命名参数（推荐）：这种方式可以定义好参数名，赋值时采用@Param(“参数名”)，而不用管顺序：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Query(&quot;select u from t_user u where id&gt;:id and username like :name&quot;)</span><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">selectUserByParam2</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name, <span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</code></pre></div><p>查询时候，也可以是使用原生的SQL查询，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Query(value = &quot;select * from t_user&quot;,nativeQuery = true)</span><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">selectAll</span><span class="hljs-params">()</span></span>;</code></pre></div><h4 id="Modifying注解"><a href="#Modifying注解" class="headerlink" title="@Modifying注解"></a>@Modifying注解</h4><p>涉及到数据修改操作，可以使用 @Modifying 注解，@Query 与 @Modifying 这两个 annotation一起声明，可定义个性化更新操作，例如涉及某些字段更新时最为常用，示例如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Modifying</span><span class="hljs-meta">@Query(&quot;update t_user set age=:age where id&gt;:id&quot;)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;age&quot;)</span> Long age, <span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</code></pre></div><p>注意：</p><ol><li>可以通过自定义的 JPQL 完成 UPDATE 和 DELETE 操作. 注意: JPQL 不支持使用 INSERT</li><li>方法的返回值应该是 int，表示更新语句所影响的行数</li><li>在调用的地方必须加事务，没有事务不能正常执行</li><li>默认情况下, Spring Data 的每个方法上有事务, 但都是一个只读事务. 他们不能完成修改操作</li></ol><p>说到这里，再来顺便说说Spring Data 中的事务问题：</p><ol><li>Spring Data 提供了默认的事务处理方式，即所有的查询均声明为只读事务。</li><li>对于自定义的方法，如需改变 Spring Data 提供的事务默认方式，可以在方法上添加 @Transactional 注解。</li><li>进行多个 Repository 操作时，也应该使它们在同一个事务中处理，按照分层架构的思想，这部分属于业务逻辑层，因此，需要在Service 层实现对多个 Repository 的调用，并在相应的方法上声明事务。</li></ol><p>Spring Boot中的数据持久化方案前面给大伙介绍了两种了，一个是JdbcTemplate，还有一个MyBatis，JdbcTemplate配置简单，使用也简单，但是功能也非常有限，MyBatis则比较灵活，功能也很强大，据我所知，公司采用MyBatis做数据持久化的相当多，但是MyBatis并不是唯一的解决方案，除了MyBatis之外，还有另外一个东西，那就是Jpa，松哥也有一些朋友在公司里使用Jpa来做数据持久化，本文就和大伙来说说Jpa如何实现数据持久化。</p><h3 id="3-9-整合Jpa"><a href="#3-9-整合Jpa" class="headerlink" title="3.9 整合Jpa"></a>3.9 整合Jpa</h3><p>首先需要向大伙介绍一下Jpa，Jpa（Java Persistence API）Java持久化API，它是一套ORM规范，而不是具体的实现，Jpa的江湖地位类似于JDBC，只提供规范，所有的数据库厂商提供实现（即具体的数据库驱动），Java领域，小伙伴们熟知的ORM框架可能主要是Hibernate，实际上，除了Hibernate之外，还有很多其他的ORM框架，例如：</p><ul><li>Batoo JPA</li><li>DataNucleus (formerly JPOX)</li><li>EclipseLink (formerly Oracle TopLink)</li><li>IBM, for WebSphere Application Server</li><li>JBoss with Hibernate</li><li>Kundera</li><li>ObjectDB</li><li>OpenJPA</li><li>OrientDB from Orient Technologies</li><li>Versant Corporation JPA (not relational, object database)</li></ul><p>Hibernate只是ORM框架的一种，上面列出来的ORM框架都是支持JPA2.0规范的ORM框架。既然它是一个规范，不是具体的实现，那么必然就不能直接使用（类似于JDBC不能直接使用，必须要加了驱动才能用），我们使用的是具体的实现，在这里我们采用的实现实际上还是Hibernate。</p><p>Spring Boot中使用的Jpa实际上是Spring Data Jpa，Spring Data是Spring家族的一个子项目，用于简化SQL和NoSQL的访问，在Spring Data中，只要你的方法名称符合规范，它就知道你想干嘛，不需要自己再去写SQL。</p><h4 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h4><p>创建Spring Boot工程，添加Web、Jpa以及MySQL驱动依赖，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5-1-20210523202517154-20210525152813172.png" alt="img"></p><p>工程创建好之后，添加Druid依赖，完整的依赖如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>如此，工程就算创建成功了。</p><h4 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h4><p>工程创建完成后，只需要在application.properties中进行数据库基本信息配置以及Jpa基本配置，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 数据库的基本配置</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8</span><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-comment"># JPA配置</span><span class="hljs-meta">spring.jpa.database</span>=<span class="hljs-string">mysql</span><span class="hljs-comment"># 在控制台打印SQL</span><span class="hljs-meta">spring.jpa.show-sql</span>=<span class="hljs-string">true</span><span class="hljs-comment"># 数据库平台</span><span class="hljs-meta">spring.jpa.database-platform</span>=<span class="hljs-string">mysql</span><span class="hljs-comment"># 每次启动项目时，数据库初始化策略</span><span class="hljs-meta">spring.jpa.hibernate.ddl-auto</span>=<span class="hljs-string">update</span><span class="hljs-comment"># 指定默认的存储引擎为InnoDB</span><span class="hljs-meta">spring.jpa.properties.hibernate.dialect</span>=<span class="hljs-string">org.hibernate.dialect.MySQL57Dialect</span></code></pre></div><p>注意这里和JdbcTemplate以及MyBatis比起来，多了Jpa配置，Jpa配置含义我都注释在代码中了，这里不再赘述，需要强调的是，最后一行配置，默认情况下，自动创建表的时候会使用MyISAM做表的引擎，如果配置了数据库方言为MySQL57Dialect，则使用InnoDB做表的引擎</p><p>好了，配置完成后，我们的Jpa差不多就可以开始用了</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ORM(Object Relational Mapping)框架表示对象关系映射，使用ORM框架我们不必再去创建表，框架会自动根据当前项目中的实体类创建相应的数据表。因此，我这里首先创建一个User对象，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Entity(name = &quot;t_user&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span>    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String address;    <span class="hljs-comment">//省略getter/setter</span>&#125;</code></pre></div><p>首先@Entity注解表示这是一个实体类，那么在项目启动时会自动针对该类生成一张表，默认的表名为类名，@Entity注解的name属性表示自定义生成的表名。@Id注解表示这个字段是一个id，@GeneratedValue注解表示主键的自增长策略，对于类中的其他属性，默认都会根据属性名在表中生成相应的字段，字段名和属性名相同，如果开发者想要对字段进行定制，可以使用@Column注解，去配置字段的名称，长度，是否为空等等。</p><p>做完这一切之后，启动Spring Boot项目，就会发现数据库中多了一个名为t_user的表了。</p><p>针对该表的操作，则需要我们提供一个Repository，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByAddressEqualsAndIdLessThanEqual</span><span class="hljs-params">(String address, Integer id)</span></span>;    <span class="hljs-meta">@Query(value = &quot;select * from t_user where id=(select max(id) from t_user)&quot;,nativeQuery = true)</span>    <span class="hljs-function">User <span class="hljs-title">maxIdUser</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>这里，自定义UserDao接口继承自JpaRepository，JpaRepository提供了一些基本的数据操作方法，例如保存，更新，删除，分页查询等，开发者也可以在接口中自己声明相关的方法，只需要方法名称符合规范即可，在Spring Data中，只要按照既定的规范命名方法，Spring Data Jpa就知道你想干嘛，这样就不用写SQL了，那么规范是什么呢？参考下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5-2-20210525152813241.jpeg" alt="img"></p><p>当然，这种方法命名主要是针对查询，但是一些特殊需求，可能并不能通过这种方式解决，例如想要查询id最大的用户，这时就需要开发者自定义查询SQL了，如上代码所示，自定义查询SQL，使用@Query注解，在注解中写自己的SQL，默认使用的查询语言不是SQL，而是JPQL，这是一种数据库平台无关的面向对象的查询语言，有点定位类似于Hibernate中的HQL，在@Query注解中设置nativeQuery属性为true则表示使用原生查询，即大伙所熟悉的SQL。上面代码中的只是一个很简单的例子，还有其他一些点，例如如果这个方法中的SQL涉及到数据操作，则需要使用@Modifying注解。</p><p>好了，定义完Dao之后，接下来就可以将UserDao注入到Controller中进行测试了(这里为了省事，就没有提供Service了，直接将UserDao注入到Controller中)。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserDao userDao;    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">()</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(<span class="hljs-number">1</span>);        user.setUsername(<span class="hljs-string">&quot;张三&quot;</span>);        user.setAddress(<span class="hljs-string">&quot;深圳&quot;</span>);        userDao.save(user);    &#125;    <span class="hljs-meta">@DeleteMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">()</span> </span>&#123;        userDao.deleteById(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@PutMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">()</span> </span>&#123;        User user = userDao.getOne(<span class="hljs-number">1</span>);        user.setUsername(<span class="hljs-string">&quot;李四&quot;</span>);        userDao.flush();    &#125;    <span class="hljs-meta">@GetMapping(&quot;/test1&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        List&lt;User&gt; all = userDao.findAll();        System.out.println(all);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/test2&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;        List&lt;User&gt; list = userDao.getUserByAddressEqualsAndIdLessThanEqual(<span class="hljs-string">&quot;广州&quot;</span>, <span class="hljs-number">2</span>);        System.out.println(list);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/test3&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;        User user = userDao.maxIdUser();        System.out.println(user);    &#125;&#125;</code></pre></div><p>如此之后，即可查询到需要的数据。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在和Spring框架整合时，如果用到ORM框架，大部分人可能都是首选Hibernate，实际上，在和Spring+SpringMVC整合时，也可以选择Spring Data Jpa做数据持久化方案，用法和本文所述基本是一样的，Spring Boot只是将Spring Data Jpa的配置简化了，因此，很多初学者对Spring Data Jpa觉得很神奇，但是又觉得无从下手，其实，此时可以回到Spring框架，先去学习Jpa，再去学习Spring Data Jpa，这是给初学者的一点建议。</p><h3 id="3-10-整合多数据源"><a href="#3-10-整合多数据源" class="headerlink" title="3.10 整合多数据源"></a>3.10 整合多数据源</h3><p>本文是Spring Boot整合数据持久化方案的最后一篇，主要和大伙来聊聊Spring Boot整合Jpa多数据源问题。在Spring Boot整合JbdcTemplate多数据源、Spring Boot整合MyBatis多数据源以及Spring Boot整合Jpa多数据源这三个知识点中，整合Jpa多数据源算是最复杂的一种，也是很多人在配置时最容易出错的一种。</p><h4 id="3-10-1-工程创建"><a href="#3-10-1-工程创建" class="headerlink" title="3.10.1 工程创建"></a>3.10.1 工程创建</h4><p>首先是创建一个Spring Boot工程，创建时添加基本的Web、Jpa以及MySQL依赖，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5-1-20210523212051594-20210525152813172.png" alt="img"></p><p>创建完成后，添加Druid依赖，这里和前文的要求一样，要使用专为Spring Boot打造的Druid，大伙可能发现了，如果整合多数据源一定要使用这个依赖，因为这个依赖中才有DruidDataSourceBuilder，最后还要记得锁定数据库依赖的版本，因为可能大部分人用的还是5.x的MySQL而不是8.x。完整依赖如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>如此之后，工程就创建成功了。</p><h4 id="3-10-2-基本配置"><a href="#3-10-2-基本配置" class="headerlink" title="3.10.2 基本配置"></a>3.10.2 基本配置</h4><p>在基本配置中，我们首先来配置多数据源基本信息以及DataSource，首先在application.properties中添加如下配置信息：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#  数据源一</span><span class="hljs-meta">spring.datasource.one.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.one.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.one.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8</span><span class="hljs-meta">spring.datasource.one.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-comment">#  数据源二</span><span class="hljs-meta">spring.datasource.two.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.two.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.two.url</span>=<span class="hljs-string">jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=UTF-8</span><span class="hljs-meta">spring.datasource.two.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-comment"># Jpa配置</span><span class="hljs-meta">spring.jpa.properties.database</span>=<span class="hljs-string">mysql</span><span class="hljs-meta">spring.jpa.properties.show-sql</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.jpa.properties.database-platform</span>=<span class="hljs-string">mysql</span><span class="hljs-meta">spring.jpa.properties.hibernate.ddl-auto</span>=<span class="hljs-string">update</span><span class="hljs-meta">spring.jpa.properties.hibernate.dialect</span>=<span class="hljs-string">org.hibernate.dialect.MySQL57Dialect</span></code></pre></div><p>这里Jpa的配置和上文相比key中多了properties，多数据源的配置和前文一致，然后接下来配置两个DataSource，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</span>    <span class="hljs-meta">@Primary</span>    <span class="hljs-function">DataSource <span class="hljs-title">dsOne</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)</span>    <span class="hljs-function">DataSource <span class="hljs-title">dsTwo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();    &#125;&#125;</code></pre></div><p>这里的配置和前文的多数据源配置基本一致，但是注意多了一个在Spring中使用较少的注解@Primary，这个注解一定不能少，否则在项目启动时会出错，@Primary表示当某一个类存在多个实例时，优先使用哪个实例。</p><h4 id="3-10-3-多数据源配置"><a href="#3-10-3-多数据源配置" class="headerlink" title="3.10.3 多数据源配置"></a>3.10.3 多数据源配置</h4><p>接下来配置Jpa的基本信息，这里两个数据源，我分别在两个类中来配置，先来看第一个配置：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableJpaRepositories(basePackages = &quot;org.sang.jpa.dao&quot;,entityManagerFactoryRef = &quot;localContainerEntityManagerFactoryBeanOne&quot;,transactionManagerRef = &quot;platformTransactionManagerOne&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaConfigOne</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier(value = &quot;dsOne&quot;)</span>    DataSource dsOne;    <span class="hljs-meta">@Autowired</span>    JpaProperties jpaProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Primary</span>    <span class="hljs-function">LocalContainerEntityManagerFactoryBean <span class="hljs-title">localContainerEntityManagerFactoryBeanOne</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;        <span class="hljs-keyword">return</span> builder.dataSource(dsOne)                .packages(<span class="hljs-string">&quot;org.sang.jpa.model&quot;</span>)                .properties(jpaProperties.getProperties())                .persistenceUnit(<span class="hljs-string">&quot;pu1&quot;</span>)                .build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PlatformTransactionManager <span class="hljs-title">platformTransactionManagerOne</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;        LocalContainerEntityManagerFactoryBean factoryBeanOne = localContainerEntityManagerFactoryBeanOne(builder);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JpaTransactionManager(factoryBeanOne.getObject());    &#125;&#125;</code></pre></div><p>首先这里注入dsOne，再注入JpaProperties，JpaProperties是系统提供的一个实例，里边的数据就是我们在application.properties中配置的jpa相关的配置。然后我们提供两个Bean，分别是LocalContainerEntityManagerFactoryBean和PlatformTransactionManager事务管理器，不同于MyBatis和JdbcTemplate，在Jpa中，事务一定要配置。在提供LocalContainerEntityManagerFactoryBean的时候，需要指定packages，这里的packages指定的包就是这个数据源对应的实体类所在的位置，另外在这里配置类上通过@EnableJpaRepositories注解指定dao所在的位置，以及LocalContainerEntityManagerFactoryBean和PlatformTransactionManager分别对应的引用的名字。</p><p>好了，这样第一个就配置好了，第二个基本和这个类似，主要有几个不同点：</p><ul><li>dao的位置不同</li><li>persistenceUnit不同</li><li>相关bean的名称不同</li></ul><p>注意实体类可以共用。</p><p>代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableJpaRepositories(basePackages = &quot;org.sang.jpa.dao2&quot;,entityManagerFactoryRef = &quot;localContainerEntityManagerFactoryBeanTwo&quot;,transactionManagerRef = &quot;platformTransactionManagerTwo&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaConfigTwo</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier(value = &quot;dsTwo&quot;)</span>    DataSource dsTwo;    <span class="hljs-meta">@Autowired</span>    JpaProperties jpaProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">LocalContainerEntityManagerFactoryBean <span class="hljs-title">localContainerEntityManagerFactoryBeanTwo</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;        <span class="hljs-keyword">return</span> builder.dataSource(dsTwo)                .packages(<span class="hljs-string">&quot;org.sang.jpa.model&quot;</span>)                .properties(jpaProperties.getProperties())                .persistenceUnit(<span class="hljs-string">&quot;pu2&quot;</span>)                .build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PlatformTransactionManager <span class="hljs-title">platformTransactionManagerTwo</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;        LocalContainerEntityManagerFactoryBean factoryBeanTwo = localContainerEntityManagerFactoryBeanTwo(builder);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JpaTransactionManager(factoryBeanTwo.getObject());    &#125;&#125;</code></pre></div><p>接下来，在对应位置分别提供相关的实体类和dao即可，数据源一的dao如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.sang.jpa.dao;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByAddressEqualsAndIdLessThanEqual</span><span class="hljs-params">(String address, Integer id)</span></span>;    <span class="hljs-meta">@Query(value = &quot;select * from t_user where id=(select max(id) from t_user)&quot;,nativeQuery = true)</span>    <span class="hljs-function">User <span class="hljs-title">maxIdUser</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>数据源二的dao如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.sang.jpa.dao2;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByAddressEqualsAndIdLessThanEqual</span><span class="hljs-params">(String address, Integer id)</span></span>;    <span class="hljs-meta">@Query(value = &quot;select * from t_user where id=(select max(id) from t_user)&quot;,nativeQuery = true)</span>    <span class="hljs-function">User <span class="hljs-title">maxIdUser</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>共同的实体类如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.sang.jpa.model;<span class="hljs-meta">@Entity(name = &quot;t_user&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String address;    <span class="hljs-comment">//省略getter/setter</span>&#125;</code></pre></div><p>到此，所有的配置就算完成了，接下来就可以在Service中注入不同的UserDao，不同的UserDao操作不同的数据源。</p><h1 id="SpringBoot整合NoSQL"><a href="#SpringBoot整合NoSQL" class="headerlink" title="SpringBoot整合NoSQL"></a>SpringBoot整合NoSQL</h1><h2 id="1-整合Redis"><a href="#1-整合Redis" class="headerlink" title="1. 整合Redis"></a>1. 整合Redis</h2><h3 id="1-1-创建工程"><a href="#1-1-创建工程" class="headerlink" title="1.1 创建工程"></a>1.1 创建工程</h3><p>创建工程，引入 Redis 依赖：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13-2-20210525152434590.png" alt="img"></p><p>创建成功后，还需要手动引入 commos-pool2 的依赖，因此最终完整的 pom.xml 依赖如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>这里主要就是引入了 Spring Data Redis + 连接池。</p><h3 id="1-2-配置-Redis-信息"><a href="#1-2-配置-Redis-信息" class="headerlink" title="1.2 配置 Redis 信息"></a>1.2 配置 Redis 信息</h3><p>接下来配置 Redis 的信息，信息包含两方面，一方面是 Redis 的基本信息，另一方面则是连接池信息:</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span><span class="hljs-comment">#没有就空着</span><span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string">123</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.66.128</span><span class="hljs-meta">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">5</span><span class="hljs-meta">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">10</span><span class="hljs-meta">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">8</span><span class="hljs-meta">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">1ms</span><span class="hljs-meta">spring.redis.lettuce.shutdown-timeout</span>=<span class="hljs-string">100ms</span></code></pre></div><h3 id="1-3-自动配置"><a href="#1-3-自动配置" class="headerlink" title="1.3 自动配置"></a>1.3 自动配置</h3><p>当开发者在项目中引入了 Spring Data Redis ，并且配置了 Redis 的基本信息，此时，自动化配置就会生效。</p><p>我们从 Spring Boot 中 Redis 的自动化配置类中就可以看出端倪：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass(RedisOperations.class)</span><span class="hljs-meta">@EnableConfigurationProperties(RedisProperties.class)</span><span class="hljs-meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;        <span class="hljs-meta">@Bean</span>        <span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                        RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;                RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();                template.setConnectionFactory(redisConnectionFactory);                <span class="hljs-keyword">return</span> template;        &#125;          <span class="hljs-meta">@Bean</span>        <span class="hljs-meta">@ConditionalOnMissingBean</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                        RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;                StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();                template.setConnectionFactory(redisConnectionFactory);                <span class="hljs-keyword">return</span> template;        &#125;&#125;</code></pre></div><p>这个自动化配置类很好理解：</p><ul><li>首先标记这个是一个配置类，同时该配置在 RedisOperations 存在的情况下才会生效(即项目中引入了 Spring Data Redis)</li><li>然后导入在 application.properties 中配置的属性</li><li>然后再导入连接池信息（如果存在的话）</li><li>最后，提供了两个 Bean ，RedisTemplate 和 StringRedisTemplate ，其中 StringRedisTemplate 是 RedisTemplate 的子类，两个的方法基本一致，不同之处主要体现在操作的数据类型不同，RedisTemplate 中的两个泛型都是 Object ，意味者存储的 key 和 value 都可以是一个对象，而 StringRedisTemplate 的 两个泛型都是 String ，意味者 StringRedisTemplate 的 key 和 value 都只能是字符串。如果开发者没有提供相关的 Bean ，这两个配置就会生效，否则不会生效。</li></ul><h3 id="1-4-使用"><a href="#1-4-使用" class="headerlink" title="1.4 使用"></a>1.4 使用</h3><p>接下来，可以直接在 Service 中注入 StringRedisTemplate 或者 RedisTemplate 来使用：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RedisTemplate redisTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        ValueOperations ops = redisTemplate.opsForValue();        ops.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);        Object k1 = ops.get(<span class="hljs-string">&quot;k1&quot;</span>);        System.out.println(k1);    &#125;&#125;</code></pre></div><p>Redis 中的数据操作，大体上来说，可以分为两种：</p><ul><li>针对 key 的操作，相关的方法就在 RedisTemplate 中</li><li>针对具体数据类型的操作，相关的方法需要首先获取对应的数据类型，获取相应数据类型的操作方法是 opsForXXX</li></ul><p>调用该方法就可以将数据存储到 Redis 中去了，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13-3-20210525152434572.png" alt="img"></p><p>k1 前面的字符是由于使用了 RedisTemplate 导致的，RedisTemplate 对 key 进行序列化之后的结果。</p><p>RedisTemplate 中，key 默认的序列化方案是 JdkSerializationRedisSerializer 。</p><p>而在 StringRedisTemplate 中，key 默认的序列化方案是 StringRedisSerializer ，因此，如果使用 StringRedisTemplate ，默认情况下 key 前面不会有前缀。</p><p>不过开发者也可以自行修改 RedisTemplate 中的序列化方案，如下:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RedisTemplate redisTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());        ValueOperations ops = redisTemplate.opsForValue();        ops.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);        Object k1 = ops.get(<span class="hljs-string">&quot;k1&quot;</span>);        System.out.println(k1);    &#125;&#125;</code></pre></div><p>当然也可以直接使用 StringRedisTemplate：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    StringRedisTemplate stringRedisTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;        ValueOperations ops = stringRedisTemplate.opsForValue();        ops.set(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);        Object k1 = ops.get(<span class="hljs-string">&quot;k2&quot;</span>);        System.out.println(k1);    &#125;&#125;</code></pre></div><p>另外需要注意 ，Spring Boot 的自动化配置，只能配置单机的 Redis ，如果是 Redis 集群，则所有的东西都需要自己手动配置</p><h3 id="1-5-解决接口幂等性"><a href="#1-5-解决接口幂等性" class="headerlink" title="1.5 解决接口幂等性"></a>1.5 解决接口幂等性</h3><p>利用Service操作Redis</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    StringRedisTemplate stringRedisTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setEx</span><span class="hljs-params">(String key, String value, Long expireTime)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();            ops.set(key,value);            stringRedisTemplate.expire(key, expireTime, TimeUnit.SECONDS);            result = <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> stringRedisTemplate.hasKey(key);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (exists(key)) &#123;            <span class="hljs-keyword">return</span> stringRedisTemplate.delete(key);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RedisService redisService;    <span class="hljs-comment">//创建</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createToken</span><span class="hljs-params">()</span> </span>&#123;        String uuid = UUID.randomUUID().toString();        redisService.setEx(uuid, uuid, <span class="hljs-number">10000L</span>);        <span class="hljs-keyword">return</span> uuid;    &#125;    <span class="hljs-comment">//检查</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkToken</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> IdempotentException </span>&#123;        String token = request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(token)) &#123;            token = request.getParameter(<span class="hljs-string">&quot;token&quot;</span>);            <span class="hljs-keyword">if</span> (StringUtils.isEmpty(token)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IdempotentException(<span class="hljs-string">&quot;token 不存在&quot;</span>);            &#125;        &#125;        <span class="hljs-keyword">if</span> (!redisService.exists(token)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IdempotentException(<span class="hljs-string">&quot;重复操作！&quot;</span>);        &#125;        <span class="hljs-keyword">boolean</span> remove = redisService.remove(token);        <span class="hljs-keyword">if</span> (!remove) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IdempotentException(<span class="hljs-string">&quot;重复操作！&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><p><strong>自定义注解</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//有此方法代表需要处理幂等性问题</span><span class="hljs-meta">@Target(ElementType.METHOD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoIdempotent &#123;&#125;</code></pre></div><p><strong>自定义异常</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdempotentException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IdempotentException</span><span class="hljs-params">(String message)</span> </span>&#123;        <span class="hljs-keyword">super</span>(message);    &#125;&#125;<span class="hljs-comment">//全局异常处理器</span><span class="hljs-meta">@RestControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalException</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler(IdempotentException.class)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">idempotentException</span><span class="hljs-params">(IdempotentException e)</span> </span>&#123;        <span class="hljs-keyword">return</span> e.getMessage();    &#125;&#125;</code></pre></div><h4 id="利用拦截器的解决方案"><a href="#利用拦截器的解决方案" class="headerlink" title="利用拦截器的解决方案"></a><strong>利用拦截器的解决方案</strong></h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdempotentInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    TokenService tokenService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//不是直接放行</span>        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        Method method = ((HandlerMethod) handler).getMethod();        AutoIdempotent idempotent = method.getAnnotation(AutoIdempotent.class);        <span class="hljs-comment">//自定义的注解不为空，说明加了注解，要进行幂等性处理</span>        <span class="hljs-keyword">if</span> (idempotent != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">return</span> tokenService.checkToken(request);            &#125; <span class="hljs-keyword">catch</span> (IdempotentException e) &#123;                <span class="hljs-keyword">throw</span> e;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><p>配置类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    IdempotentInterceptor idempotentInterceptor;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        registry.addInterceptor(idempotentInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);    &#125;&#125;</code></pre></div><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    TokenService tokenService;    <span class="hljs-meta">@GetMapping(&quot;/gettoken&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getToken</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> tokenService.createToken();    &#125;    <span class="hljs-meta">@PostMapping(&quot;/hello&quot;)</span>    <span class="hljs-meta">@AutoIdempotent</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;    <span class="hljs-meta">@PostMapping(&quot;/hello2&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello2&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="利用AOP的解决方案"><a href="#利用AOP的解决方案" class="headerlink" title="利用AOP的解决方案"></a>利用AOP的解决方案</h4><p>因为要使用AOP，把IdempotentInterceptor上的@Component注解掉，让其失效，同时让WebMvcConfig也失效，然后创建即可</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdempotentAspect</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    TokenService tokenService;    <span class="hljs-comment">//加了自定义注解的</span>    <span class="hljs-meta">@Pointcut(&quot;@annotation(org.javaboy.idempontent.anno.AutoIdempotent)&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc1</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">//前置通知</span>    <span class="hljs-meta">@Before(&quot;pc1()&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IdempotentException </span>&#123;        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();        <span class="hljs-keyword">try</span> &#123;            tokenService.checkToken(request);        &#125; <span class="hljs-keyword">catch</span> (IdempotentException e) &#123;            <span class="hljs-keyword">throw</span> e;        &#125;    &#125;&#125;</code></pre></div><h2 id="2-session共享"><a href="#2-session共享" class="headerlink" title="2. session共享"></a>2. session共享</h2><p>在传统的单服务架构中，一般来说，只有一个服务器，那么不存在 Session 共享问题，但是在分布式/集群项目中，Session 共享则是一个必须面对的问题，先看一个简单的架构图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-1-20210525152434632.png" alt="img"></p><p>在这样的架构中，会出现一些单服务中不存在的问题，例如客户端发起一个请求，这个请求到达 Nginx 上之后，被 Nginx 转发到 Tomcat A 上，然后在 Tomcat A 上往 session 中保存了一份数据，下次又来一个请求，这个请求被转发到 Tomcat B 上，此时再去 Session 中获取数据，发现没有之前的数据。对于这一类问题的解决，思路很简单，就是将各个服务之间需要共享的数据，保存到一个公共的地方（主流方案就是 Redis）：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-2-20210525152434653.png" alt="img"></p><p>当所有 Tomcat 需要往 Session 中写数据时，都往 Redis 中写，当所有 Tomcat 需要读数据时，都从 Redis 中读。这样，不同的服务就可以使用相同的 Session 数据了。</p><p>这样的方案，可以由开发者手动实现，即手动往 Redis 中存储数据，手动从 Redis 中读取数据，相当于使用一些 Redis 客户端工具来实现这样的功能，毫无疑问，手动实现工作量还是蛮大的。</p><p>一个简化的方案就是使用 Spring Session 来实现这一功能，Spring Session 就是使用 Spring 中的代理过滤器，将所有的 Session 操作拦截下来，自动的将数据 同步到 Redis 中，或者自动的从 Redis 中读取数据。</p><p>对于开发者来说，所有关于 Session 同步的操作都是透明的，开发者使用 Spring Session，一旦配置完成后，具体的用法就像使用一个普通的 Session 一样。</p><h3 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1 创建工程"></a>2.1 创建工程</h3><p>首先 创建一个 Spring Boot 工程，引入 Web、Spring Session 以及 Redis:</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-3-20210525152434702.png" alt="img"></p><p>创建成功之后，pom.xml 文件如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><p><strong>注意：</strong></p><p>这里我使用的 Spring Boot 版本是 2.1.4 ，如果使用当前最新版 Spring Boot2.1.5 的话，除了上面这些依赖之外，需要额外添加 Spring Security 依赖（其他操作不受影响，仅仅只是多了一个依赖，当然也多了 Spring Security 的一些默认认证流程）。</p><h3 id="2-2-配置-Redis"><a href="#2-2-配置-Redis" class="headerlink" title="2.2 配置 Redis"></a>2.2 配置 Redis</h3><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.66.128</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-comment">#spring.redis.password=123</span><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span></code></pre></div><p>这里的 Redis ，我虽然配置了四行，但是考虑到端口默认就是 6379 ，database 默认就是 0，所以真正要配置的，其实就是两行。</p><h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><p>配置完成后 ，就可以使用 Spring Session 了，其实就是使用普通的 HttpSession ，其他的 Session 同步到 Redis 等操作，框架已经自动帮你完成了：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>    Integer port;    <span class="hljs-meta">@GetMapping(&quot;/set&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;        session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);        <span class="hljs-keyword">return</span> String.valueOf(port);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;        <span class="hljs-keyword">return</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>) + <span class="hljs-string">&quot;:&quot;</span> + port;    &#125;&#125;</code></pre></div><p>考虑到一会 Spring Boot 将以集群的方式启动 ，为了获取每一个请求到底是哪一个 Spring Boot 提供的服务，需要在每次请求时返回当前服务的端口号，因此这里我注入了 server.port </p><p>接下来 ，项目打包：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-4-20210525152434653.png" alt="img"></p><p>打包之后，启动项目的两个实例：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8080java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8081</code></pre></div><p>然后先访问 <code>localhost:8080/set</code> 向 <code>8080</code> 这个服务的 <code>Session</code> 中保存一个变量，访问完成后，数据就已经自动同步到 <code>Redis</code> 中 了 ：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-5-20210525152434610.png" alt="img"></p><p>然后，再调用 <code>localhost:8081/get</code> 接口，就可以获取到 <code>8080</code> 服务的 <code>session</code> 中的数据：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-6-20210525152434632.png" alt="img"></p><p>此时关于 session 共享的配置就已经全部完成了，session 共享的效果我们已经看到了，但是每次访问都是我自己手动切换服务实例，因此，接下来我们来引入 Nginx ，实现服务实例自动切换。</p><h3 id="2-4-引入-Nginx"><a href="#2-4-引入-Nginx" class="headerlink" title="2.4 引入 Nginx"></a>2.4 引入 Nginx</h3><p>很简单，进入 Nginx 的安装目录的 conf 目录下（默认是在 <code>/usr/local/nginx/conf</code>），编辑 nginx.conf 文件:</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-7-20210525152434641.png" alt="img"></p><p>在这段配置中：</p><ul><li>upstream 表示配置上游服务器</li><li>javaboy.org 表示服务器集群的名字，这个可以随意取名字</li><li>upstream 里边配置的是一个个的单独服务</li><li>weight 表示服务的权重，意味者将有多少比例的请求从 Nginx 上转发到该服务上</li><li>location 中的 proxy_pass 表示请求转发的地址，<code>/</code> 表示拦截到所有的请求，转发转发到刚刚配置好的服务集群中</li><li>proxy_redirect 表示设置当发生重定向请求时，nginx 自动修正响应头数据（默认是 Tomcat 返回重定向，此时重定向的地址是 Tomcat 的地址，我们需要将之修改使之成为 Nginx 的地址）</li></ul><p>配置完成后，将本地的 Spring Boot 打包好的 jar 上传到 Linux ，然后在 Linux 上分别启动两个 Spring Boot 实例：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8080 &amp;nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8081 &amp;</code></pre></div><p>其中</p><ul><li>nohup 表示当终端关闭时，Spring Boot 不要停止运行</li><li>&amp; 表示让 Spring Boot 在后台启动</li></ul><p>配置完成后，重启 Nginx：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">/usr/local/nginx/sbin/nginx -s reload</code></pre></div><p>Nginx 启动成功后，我们首先手动清除 Redis 上的数据，然后访问 <code>192.168.66.128/set</code> 表示向 <code>session</code> 中保存数据，这个请求首先会到达 <code>Nginx</code> 上，再由 <code>Nginx</code> 转发给某一个 <code>Spring Boot</code> 实例：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-8-20210525152434681.png" alt="img"></p><p>如上，表示端口为 <code>8081</code> 的 <code>Spring Boot</code> 处理了这个 <code>/set</code> 请求，再访问 <code>/get</code> 请求：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-9-20210525152434677.png" alt="img"></p><p>可以看到，<code>/get</code> 请求是被端口为 8080 的服务所处理的。</p><h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p>本文主要向大家介绍了 Spring Session 的使用，另外也涉及到一些 Nginx 的使用 ，虽然本文较长，但是实际上 Spring Session 的配置没啥。</p><p>我们写了一些代码，也做了一些配置，但是全都和 Spring Session 无关，配置是配置 Redis，代码就是普通的 HttpSession，和 Spring Session 没有任何关系！</p><p>唯一和 Spring Session 相关的，可能就是我在一开始引入了 Spring Session 的依赖吧！</p><p>如果大家没有在 SSM 架构中用过 Spring Session ，可能不太好理解我们在 Spring Boot 中使用 Spring Session 有多么方便，因为在 SSM 架构中，Spring Session 的使用要配置三个地方 ，一个是 web.xml 配置代理过滤器，然后在 Spring 容器中配置 Redis，最后再配置 Spring Session，步骤还是有些繁琐的，而 Spring Boot 中直接帮我们省去了这些繁琐的步骤！不用再去配置 Spring Session。</p><h1 id="SpringBoot构建RESTful"><a href="#SpringBoot构建RESTful" class="headerlink" title="SpringBoot构建RESTful"></a>SpringBoot构建RESTful</h1><p>RESTful ，到现在相信已经没人不知道这个东西了吧！关于 RESTful 的概念，我这里就不做过多介绍了，传统的 Struts 对 RESTful 支持不够友好 ，但是 SpringMVC 对于 RESTful 提供了很好的支持，常见的相关注解有：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@GetMapping</span><span class="hljs-meta">@PutMapping</span><span class="hljs-meta">@PostMapping</span><span class="hljs-meta">@DeleteMapping</span><span class="hljs-meta">@ResponseBody</span>...</code></pre></div><p>这些注解都是和 RESTful 相关的，在移动互联网中，RESTful 得到了非常广泛的使用。RESTful 这个概念提出来很早，但是以前没有移动互联网时，我们做的大部分应用都是前后端不分的，在这种架构的应用中，数据基本上都是在后端渲染好返回给前端展示的，此时 RESTful 在 Web 应用中基本就没用武之地，移动互联网的兴起，让我们一套后台对应多个前端项目，因此前后端分离，RESTful 顺利走上前台。</p><p>Spring Boot 继承自 Spring + SpringMVC， SpringMVC 中对于 RESTful 支持的特性在 Spring Boot 中全盘接收，同时，结合 Jpa 和 自动化配置，对于 RESTful 还提供了更多的支持，使得开发者几乎不需要写代码（很少几行），就能快速实现一个 RESTful 风格的增删改查</p><h2 id="1-Spring-Data-JPA构建"><a href="#1-Spring-Data-JPA构建" class="headerlink" title="1. Spring Data JPA构建"></a>1. Spring Data JPA构建</h2><h3 id="1-1-创建工程-1"><a href="#1-1-创建工程-1" class="headerlink" title="1.1 创建工程"></a>1.1 创建工程</h3><p>首先创建一个 Spring Boot 工程，引入 <code>Web</code> 、 <code>Jpa</code> 、 <code>MySQL</code> 、<code>Rest Repositories</code> 依赖：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-1-20210525152434677.png" alt="img"></p><p>创建完成后，还需要锁定 MySQL 驱动的版本以及加入 Druid 数据库连接池，完整依赖如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-rest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h3 id="1-2-配置数据库"><a href="#1-2-配置数据库" class="headerlink" title="1.2 配置数据库"></a>1.2 配置数据库</h3><p>主要配置两个，一个是数据库，另一个是 Jpa：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///test01</span><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-meta">spring.jpa.properties.hibernate.dialect</span>=<span class="hljs-string">org.hibernate.dialect.MySQL57Dialect</span><span class="hljs-meta">spring.jpa.show-sql</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.jpa.hibernate.ddl-auto</span>=<span class="hljs-string">update</span><span class="hljs-meta">spring.jpa.database-platform</span>=<span class="hljs-string">mysql</span><span class="hljs-meta">spring.jpa.database</span>=<span class="hljs-string">mysql</span></code></pre></div><p>这里的配置，和 Jpa 中的基本一致。</p><p>前面五行配置了数据库的基本信息，包括数据库连接池、数据库用户名、数据库密码、数据库连接地址以及数据库驱动名称。</p><p>接下来的五行配置了 JPA 的基本信息，分别表示生成 SQL 的方言、打印出生成的 SQL 、每次启动项目时根据实际情况选择是否更新表、数据库平台是 MySQL。</p><h3 id="1-3-构建实体类"><a href="#1-3-构建实体类" class="headerlink" title="1.3 构建实体类"></a>1.3 构建实体类</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Entity(name = &quot;t_book&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@Column(name = &quot;book_name&quot;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String author;    <span class="hljs-comment">//省略 getter/setter</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;&#125;</code></pre></div><p>这里一个是配置了一个实体类 Book，另一个则是配置了一个 BookRepository ，项目启动成功后，框架会根据 Book 类的定义，在数据库中自动创建相应的表，BookRepository 接口则是继承自 JpaRepository ，JpaRepository 中自带了一些基本的增删改查方法。</p><p>一个 RESTful 风格的增删改查应用就有了，这就是 Spring Boot 的魅力</p><h3 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h3><p>此时，我们就可以启动项目进行测试了，使用 <code>POSTMAN </code>来测试（大家也可以自行选择趁手的 HTTP 请求工具）</p><p>此时我们的项目已经默认具备了一些接口，我们分别来看：</p><h4 id="根据-id-查询接口"><a href="#根据-id-查询接口" class="headerlink" title="根据 id 查询接口"></a>根据 id 查询接口</h4><ul><li><a href="http://127.0.0.1:8080/books/%7Bid%7D">http://127.0.0.1:8080/books/{id}</a></li></ul><p>这个接口表示根据 id 查询某一本书：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-2-20210525152434684.png" alt="img"></p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul><li><a href="http://127.0.0.1:8080/books">http://127.0.0.1:8080/books</a></li></ul><p>这是一个批量查询接口，默认请求路径是类名首字母小写，并且再加一个 s 后缀。这个接口实际上是一个分页查询接口，没有传参数，表示查询第一页，每页 20 条数据。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-3-20210525152434693.png" alt="img"></p><p>查询结果中，除了该有的数据之外，也包含了分页数据：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-4-20210525152434757.png" alt="img"></p><p>分页数据中：</p><ol><li>size 表示每页查询记录数</li><li>totalElements 表示总记录数</li><li>totalPages 表示总页数</li><li>number 表示当前页数，从0开始计</li></ol><p>如果要分页或者排序查询，可以使用 _links 中的链接。<code>http://127.0.0.1:8080/books?page=1&amp;size=3&amp;sort=id,desc</code> </p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-5-20210525152434720.png" alt="img"></p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>也可以添加数据，添加是 POST 请求，数据通过 JSON 的形式传递，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-6-20210525152434720.png" alt="img"></p><p>添加成功之后，默认会返回添加成功的数据。</p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>修改接口默认也是存在的，数据修改请求是一个 PUT 请求，修改的参数也是通过 JSON 的形式传递：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-7-20210525152434752.png" alt="img"></p><p>默认情况下，修改成功后，会返回修改成功的数据。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>当然也可以通过 DELETE 请求根据 id 删除数据：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-8-20210525152434730.png" alt="img"></p><p>删除成功后，是没有返回值的。</p><p>不需要几行代码，一个基本的增删改查就有了。</p><p>这些都是默认的配置，这些默认的配置实际上都是在 JpaRepository 的基础上实现的，实际项目中，我们还可以对这些功能进行定制。</p><h3 id="1-5-查询定制"><a href="#1-5-查询定制" class="headerlink" title="1.5 查询定制"></a>1.5 查询定制</h3><p>最广泛的定制，就是查询，因为增删改操作的变化不像查询这么丰富。对于查询的定制，非常容易，只需要提供相关的方法即可。例如根据作者查询书籍：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;    <span class="hljs-function">List&lt;Book&gt; <span class="hljs-title">findBookByAuthorContaining</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;author&quot;)</span> String author)</span></span>;&#125;</code></pre></div><p>注意，方法的定义，参数要有 @Param 注解。</p><p>定制完成后，重启项目，此时就多了一个查询接口，开发者可以通过 <a href="http://localhost:8080/books/search">http://localhost:8080/books/search</a> 来查看和 book 相关的自定义接口都有哪些：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-9-20210525152434766.png" alt="img"></p><p>查询结果表示，只有一个自定义接口，接口名就是方法名，而且查询结果还给出了接口调用的示例。我们来尝试调用一下自己定义的查询接口：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-10-20210525152434772.png" alt="img"></p><p>开发者可以根据实际情况，在 BookRepository 中定义任意多个查询方法，查询方法的定义规则和 Jpa 中一模一样，但是，这样有一个缺陷，就是 Jpa 中方法名太长，因此，如果不想使用方法名作为接口名，则可以自定义接口名</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;    <span class="hljs-meta">@RestResource(rel = &quot;byauthor&quot;,path = &quot;byauthor&quot;)</span>    <span class="hljs-function">List&lt;Book&gt; <span class="hljs-title">findBookByAuthorContaining</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;author&quot;)</span> String author)</span></span>;&#125;</code></pre></div><p>@RestResource 注解中，两个参数的含义：</p><ul><li>rel 表示接口查询中，这个方法的 key</li><li>path 表示请求路径</li></ul><p>这样定义完成后，表示接口名为 byauthor ，重启项目，继续查询接口：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-11-20210525152434803.png" alt="img"></p><p>除了 <code>rel</code> 和 <code>path</code> 两个属性之外，<code>@RestResource</code> 中还有一个属性，<code>exported</code> 表示是否暴露接口，默认为 <code>true</code>，表示暴露接口，即方法可以在前端调用，如果仅仅只是想定义一个方法，不需要在前端调用这个方法，可以设置 <code>exported</code> 属性为 <code>false</code> 。</p><p>如果不想暴露官方定义好的方法，例如根据 <code>id</code> 删除数据，只需要在自定义接口中重写该方法，然后在该方法上加 <code>@RestResource</code> 注解并且配置相关属性即可。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;    <span class="hljs-meta">@RestResource(rel = &quot;byauthor&quot;,path = &quot;byauthor&quot;)</span>    <span class="hljs-function">List&lt;Book&gt; <span class="hljs-title">findBookByAuthorContaining</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;author&quot;)</span> String author)</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@RestResource(exported = false)</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Long aLong)</span></span>;&#125;</code></pre></div><p>另外生成的 JSON 字符串中的集合名和单个 <code>item</code> 的名字都是可以自定义的：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RepositoryRestResource(collectionResourceRel = &quot;bs&quot;,itemResourceRel = &quot;b&quot;,path = &quot;bs&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;    <span class="hljs-meta">@RestResource(rel = &quot;byauthor&quot;,path = &quot;byauthor&quot;)</span>    <span class="hljs-function">List&lt;Book&gt; <span class="hljs-title">findBookByAuthorContaining</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;author&quot;)</span> String author)</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@RestResource(exported = false)</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Long aLong)</span></span>;&#125;</code></pre></div><p><code>path</code> 属性表示请求路径，请求路径默认是类名首字母小写+s，可以在这里自己重新定义。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-12-20210525152434760.png" alt="img"></p><h3 id="1-6-其他配置"><a href="#1-6-其他配置" class="headerlink" title="1.6 其他配置"></a>1.6 其他配置</h3><p>最后，也可以在 application.properties 中配置 REST 基本参数：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.data.rest.base-path</span>=<span class="hljs-string">/api</span><span class="hljs-meta">spring.data.rest.sort-param-name</span>=<span class="hljs-string">sort</span><span class="hljs-meta">spring.data.rest.page-param-name</span>=<span class="hljs-string">page</span><span class="hljs-meta">spring.data.rest.limit-param-name</span>=<span class="hljs-string">size</span><span class="hljs-meta">spring.data.rest.max-page-size</span>=<span class="hljs-string">20</span><span class="hljs-meta">spring.data.rest.default-page-size</span>=<span class="hljs-string">0</span><span class="hljs-meta">spring.data.rest.return-body-on-update</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.data.rest.return-body-on-create</span>=<span class="hljs-string">true</span></code></pre></div><p>配置含义，从上往下，依次是：</p><ul><li>给所有的接口添加统一的前缀</li><li>配置排序参数的 key ，默认是 sort</li><li>配置分页查询时页码的 key，默认是 page</li><li>配置分页查询时每页查询页数的 key，默认是size</li><li>配置每页最大查询记录数，默认是 20 条</li><li>分页查询时默认的页码</li><li>更新成功时是否返回更新记录</li><li>添加成功时是否返回添加记录</li></ul><h1 id="SpringBoot开发者工具"><a href="#SpringBoot开发者工具" class="headerlink" title="SpringBoot开发者工具"></a>SpringBoot开发者工具</h1><h2 id="1-Devtools"><a href="#1-Devtools" class="headerlink" title="1. Devtools"></a>1. Devtools</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524151205975.png" alt="image-20210524151205975"></p><p>Spring Boot 中的热部署相信大家都用过吧，只需要添加 <code>spring-boot-devtools</code> 依赖就可以轻松实现热部署。Spring Boot 中热部署最最关键的原理就是两个不同的 classloader：</p><ul><li>base classloader</li><li>restart classloader</li></ul><p>其中 base classloader 用来加载那些不会变化的类，例如各种第三方依赖，而 restart classloader 则用来加载那些会发生变化的类，例如你自己写的代码。Spring Boot 中热部署的原理就是当代码发生变化时，base classloader 不变，而 restart classloader 则会被废弃，被另一个新的 restart classloader 代替。在整个过程中，因为只重新加载了变化的类，所以启动速度要被重启快</p><p><strong>引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>在IDEA中开启</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524154546455.png" alt="image-20210524154546455"></p><p>找到</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524154656023.png" alt="image-20210524154656023"></p><p>在<code>Registry</code>中</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524154820641.png" alt="image-20210524154820641"></p><p>即可开启自动重启</p><p><strong>配置文件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#关闭自动重启</span><span class="hljs-meta">spring.devtools.restart.enabled</span>=<span class="hljs-string">false</span><span class="hljs-comment">#触发重启的文件，放置在resources目录下</span><span class="hljs-meta">spring.devtools.restart.trigger-file</span>=<span class="hljs-string">.reloadtrigger</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524153804327.png" alt="image-20210524153804327"></p><p>添加后这个文件下，每次去修改<code>.reloadtrigger</code>文件然后去刷新才会重启，这里的重启还是不全部重启的刷新</p><p>如果有个多模块的项目，在当前目录下创建<code>spring-boot-devtools.properties</code>文件</p><p>这里面的配置都让所有使用Devtools模块的项目都生效</p><p>但是有另外一个问题，就是静态资源文件！使用 devtools ，默认情况下当静态资源发生变化时，并不会触发项目重启。虽然我们可以通过配置解决这一问题，但是没有必要！因为静态资源文件发生变化后不需要编译，按理说保存后刷新下就可以访问到了，所以静态资源不会被Devtools监视到，静态资源不需要重启也能直接同步到target目录下</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524151746545.png" alt="image-20210524151746545"></p><h3 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h3><p>devtools 中默认嵌入了 LiveReload 服务器，利用 LiveReload 可以实现静态文件的热部署，LiveReload 可以在资源发生变化时自动触发浏览器更新，LiveReload 支持 Chrome、Firefox 以及 Safari 。以 Chrome 为例，在 Chrome 应用商店搜索 LiveReload ，结果如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/27-1-20210525152240919.png" alt="img"></p><p>将第一个搜索结果添加到 Chrome 中，添加成功后，在 Chrome 右上角有一个 LiveReload 图标</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/27-2-20210525152240870.png" alt="img"></p><p>在浏览器中打开项目的页面，然后点击浏览器右上角的 LiveReload 按钮，打开 LiveReload 连接。</p><p><strong>注意：</strong></p><p>LiveReload 是和浏览器选项卡绑定在一起的，在哪个选项卡中打开了 LiveReload，就在哪个选项卡中访问页面，这样才有效果</p><p>此时随便在 resources/static 目录下添加一个静态 html 页面，然后启动 Spring Boot 项目，在<strong>打开了 LiveReload 的选项卡中访问 html 页面</strong>。</p><p>访问成功后，我们再去手动修改 html 页面代码，修改成功后，回到浏览器，不用做任何操作，就会发现浏览器自动刷新了，页面已经更新了。</p><p>整个过程中，我的 Spring Boot 项目并没有重启。</p><p>如果开发者安装并且启动了 LiveReload 插件，同时也添加了 devtools 依赖，但是却并不想当静态页面发生变化时浏览器自动刷新，那么可以在 application.properties 中添加如下代码进行配置：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.devtools.livereload.enabled</span>=<span class="hljs-string">false</span></code></pre></div><p>建议开发者使用 LiveReload 策略而不是项目重启策略来实现静态资源的动态加载，因为项目重启所耗费时间一般来说要超过使用LiveReload 所耗费的时间</p><h2 id="2-Mock单元测试"><a href="#2-Mock单元测试" class="headerlink" title="2. Mock单元测试"></a>2. Mock单元测试</h2><p>针对Controller的接口简单测试，这里不使用Postman，使用Java代码来完成</p><p><strong>实体类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username;    &#125;&#125;</code></pre></div><p><strong>Controller</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(id);        user.setUsername(<span class="hljs-string">&quot;javaboy&quot;</span>);        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre></div><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * webEnvironment：指定 web 应用环境：</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * - MOCK</span><span class="hljs-comment"> * - RANDOM_PORT (对事务不回滚)</span><span class="hljs-comment"> * - DEFINED_PORT (对事务不回滚)</span><span class="hljs-comment"> * - NONE</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * classes：指定应用启动类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@SpringBootTest()</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    WebApplicationContext webApplicationContext;    MockMvc mockMvc;    <span class="hljs-meta">@BeforeEach</span> <span class="hljs-comment">//相当于Before</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>&#123;        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();   <span class="hljs-comment">//或者，但不推荐  mockMvc = MockMvcBuilders.standaloneSetup(new UserController()).build();</span>    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//GET请求</span>  mockMvc  .perform(MockMvcRequestBuilders.get(<span class="hljs-string">&quot;/user/99&quot;</span>).accept(MediaType.APPLICATION_JSON_UTF8))                .andExpect(MockMvcResultMatchers.status().isOk())                .andExpect(MockMvcResultMatchers.content().string(<span class="hljs-string">&quot;&#123;\&quot;id\&quot;:99,\&quot;username\&quot;:\&quot;javaboy\&quot;&#125;&quot;</span>))                .andDo(MockMvcResultHandlers.print());    &#125;    &#125;</code></pre></div><p><strong>对Service的测试</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserDao userDao;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">return</span> userDao.getUserById(id);    &#125;&#125;</code></pre></div><p><strong>DAO</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(id);        user.setUsername(<span class="hljs-string">&quot;111&quot;</span>);        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre></div><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest()</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestApplicationTests</span> </span>&#123;    <span class="hljs-comment">//不涉及数据库的注入，如果用AutoWired会改变数据库</span>    <span class="hljs-meta">@MockBean</span>    UserDao userDao;    <span class="hljs-meta">@Autowired</span>    UserService userService;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//仅供测试的数据</span>        User user = <span class="hljs-keyword">new</span> User();        user.setId(<span class="hljs-number">99L</span>);        user.setUsername(<span class="hljs-string">&quot;javaboy&quot;</span>);        Mockito.when(userDao.getUserById(<span class="hljs-number">99L</span>)).thenReturn(user);        User u = userService.getUserById(<span class="hljs-number">99L</span>);        Assertions.assertEquals(<span class="hljs-number">99L</span>,u.getId());        Assertions.assertEquals(<span class="hljs-string">&quot;javaboy&quot;</span>, u.getUsername());    &#125;&#125;</code></pre></div><h1 id="SpringBoot整合缓存"><a href="#SpringBoot整合缓存" class="headerlink" title="SpringBoot整合缓存"></a>SpringBoot整合缓存</h1><h2 id="1-Spring-Cache-Redis"><a href="#1-Spring-Cache-Redis" class="headerlink" title="1. Spring Cache + Redis"></a>1. Spring Cache + Redis</h2><p>经过Spring Boot的整合封装与自动化配置，在Spring Boot中整合Redis已经变得非常容易了，开发者只需要引入Spring Data Redis依赖，然后简单配下redis的基本信息，系统就会提供一个RedisTemplate供开发者使用。Spring3.1中开始引入了令人激动的Cache，在Spring Boot中，可以非常方便的使用Redis来作为Cache的实现，进而实现数据的缓存。</p><h3 id="1-1-工程创建"><a href="#1-1-工程创建" class="headerlink" title="1.1 工程创建"></a>1.1 工程创建</h3><p>首先创建一个Spring Boot工程，注意创建的时候需要引入三个依赖，web、cache以及redis，如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13-1-20210525152240902.png" alt="img"></p><p>对应的依赖内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="1-2-基本配置"><a href="#1-2-基本配置" class="headerlink" title="1.2 基本配置"></a>1.2 基本配置</h3><p>工程创建好之后，首先需要简单配置一下Redis，Redis的基本信息，另外，这里要用到Cache，因此还需要稍微配置一下Cache，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6380</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.66.128</span><span class="hljs-meta">spring.cache.cache-names</span>=<span class="hljs-string">c1</span></code></pre></div><p>简单起见，这里我只是配置了Redis的端口和地址，然后给缓存取了一个名字，这个名字在后文会用到。</p><p>另外，还需要在配置类上添加如下代码，表示开启缓存：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableCaching</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RediscacheApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(RediscacheApplication.class, args);    &#125;&#125;</code></pre></div><p>完成了这些配置之后，Spring Boot就会自动帮我们在后台配置一个RedisCacheManager，相关的配置是在org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration类中完成的。部分源码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass(RedisConnectionFactory.class)</span><span class="hljs-meta">@AutoConfigureAfter(RedisAutoConfiguration.class)</span><span class="hljs-meta">@ConditionalOnBean(RedisConnectionFactory.class)</span><span class="hljs-meta">@ConditionalOnMissingBean(CacheManager.class)</span><span class="hljs-meta">@Conditional(CacheCondition.class)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCacheConfiguration</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RedisCacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory,</span></span><span class="hljs-function"><span class="hljs-params">ResourceLoader resourceLoader)</span> </span>&#123;RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(determineConfiguration(resourceLoader.getClassLoader()));List&lt;String&gt; cacheNames = <span class="hljs-keyword">this</span>.cacheProperties.getCacheNames();<span class="hljs-keyword">if</span> (!cacheNames.isEmpty()) &#123;builder.initialCacheNames(<span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(cacheNames));&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.customizerInvoker.customize(builder.build());&#125;&#125;</code></pre></div><p>看类上的注解，发现在万事俱备的情况下，系统会自动提供一个RedisCacheManager的Bean，这个RedisCacheManager间接实现了Spring中的Cache接口，有了这个Bean，我们就可以直接使用Spring中的缓存注解和接口了，而缓存数据则会被自动存储到Redis上。在单机的Redis中，这个Bean系统会自动提供，如果是Redis集群，这个Bean需要开发者来提供。</p><h3 id="1-3-缓存使用"><a href="#1-3-缓存使用" class="headerlink" title="1.3 缓存使用"></a>1.3 缓存使用</h3><p>这里主要向小伙伴们介绍缓存中几个核心的注解使用。</p><h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><p>这个注解在类上使用，用来描述该类中所有方法使用的缓存名称，当然也可以不使用该注解，直接在具体的缓存注解上配置名称，示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@CacheConfig(cacheNames = &quot;c1&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;&#125;</code></pre></div><h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>这个注解一般加在查询方法上，表示将一个方法的返回值缓存起来，默认情况下，缓存的key就是方法的参数，缓存的value就是方法的返回值。示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(key = &quot;#id&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Integer id,String username)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;getUserById&quot;</span>);    <span class="hljs-keyword">return</span> getUserFromDBById(id);&#125;</code></pre></div><p>当有多个参数时，默认就使用多个参数来做key，如果只需要其中某一个参数做key，则可以在@Cacheable注解中，通过key属性来指定key，如上代码就表示只使用id作为缓存的key，如果对key有复杂的要求，可以自定义keyGenerator。当然，Spring Cache中提供了root对象，即<code>#root.</code>可以在不定义keyGenerator的情况下实现一些复杂的效果：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13-2-20210524162051323-20210525152240881.png" alt="img"></p><p>也可以自定义缓存的格式</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyKeyGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">KeyGenerator</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">generate</span><span class="hljs-params">(Object target, Method method, Object... params)</span> </span>&#123;        String s = target.toString() + <span class="hljs-string">&quot;:&quot;</span> + method.getName() + <span class="hljs-string">&quot;:&quot;</span> + Arrays.toString(params);        <span class="hljs-keyword">return</span> s;    &#125;&#125;<span class="hljs-meta">@Service</span><span class="hljs-meta">@CacheConfig(cacheNames = &quot;c1&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123; <span class="hljs-meta">@Cacheable(keyGenerator = &quot;myKeyGenerator&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById2</span><span class="hljs-params">(Long id,String username)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;getUserById2:&quot;</span> + id);        User user = <span class="hljs-keyword">new</span> User();        user.setId(id);        user.setUsername(username);        <span class="hljs-keyword">return</span> user;    &#125;  &#125;</code></pre></div><h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>这个注解一般加在更新方法上，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的key上，示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//如果缓存不存在，则进行缓存，否则进行更新</span><span class="hljs-meta">@CachePut(key = &quot;#user.id&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">updateUserById</span><span class="hljs-params">(User user)</span> </span>&#123;    <span class="hljs-keyword">return</span> user;&#125;</code></pre></div><h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>这个注解一般加在删除方法上，当数据库中的数据删除后，相关的缓存数据也要自动清除，该注解在使用的时候也可以配置按照某种条件删除（condition属性）或者或者配置清除所有缓存（allEntries属性），示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict()</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span> </span>&#123;    <span class="hljs-comment">//在这里执行删除操作， 删除是去数据库中删除</span>&#125;</code></pre></div><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>在Spring Boot中，使用Redis缓存，既可以使用RedisTemplate自己来实现，也可以使用使用这种方式，这种方式是Spring Cache提供的统一接口，实现既可以是Redis，也可以是Ehcache或者其他支持这种规范的缓存框架。从这个角度来说，Spring Cache和Redis、Ehcache的关系就像JDBC与各种数据库驱动的关系。</p><h2 id="2-Spring-Cache-Ehcache"><a href="#2-Spring-Cache-Ehcache" class="headerlink" title="2. Spring Cache + Ehcache"></a>2. Spring Cache + Ehcache</h2><p>用惯了 Redis ，很多人已经忘记了还有另一个缓存方案 Ehcache ，是的，在 Redis 一统江湖的时代，Ehcache 渐渐有点没落了，不过，我们还是有必要了解下 Ehcache ，在有的场景下，我们还是会用到 Ehcache。</p><p>Ehcache 也是 Java 领域比较优秀的缓存方案之一，Ehcache 这个缓存的名字很有意思，正着念反着念，都是 Ehcache，Spring Boot 中对此也提供了很好的支持，这个支持主要是通过 Spring Cache 来实现的。</p><p>Spring Cache 可以整合 Redis，当然也可以整合 Ehcache，两种缓存方案的整合还是比较相似，主要是配置的差异，具体的用法是一模一样的，就类似于 JDBC 和 数据库驱动的关系一样。前面配置完成后，后面具体使用的 API 都是一样的。</p><p>和 Spring Cache + Redis 相比，Spring Cache + Ehcache 主要是配置有所差异，具体的用法是一模一样的。我们来看下使用步骤。</p><h3 id="2-1-项目创建"><a href="#2-1-项目创建" class="headerlink" title="2.1 项目创建"></a>2.1 项目创建</h3><p>首先，来创建一个 Spring Boot 项目，引入 Cache 依赖：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/17-1-20210525152240867.png" alt="img"></p><p>工程创建完成后，引入 Ehcache 的依赖，Ehcache 目前有两个版本：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/17-2-20210525152240892.png" alt="img"></p><p>这里采用第二个，在 pom.xml 文件中，引入 Ehcache 依赖：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h3 id="2-2-添加-Ehcache-配置"><a href="#2-2-添加-Ehcache-配置" class="headerlink" title="2.2 添加 Ehcache 配置"></a>2.2 添加 Ehcache 配置</h3><p>在 resources 目录下，添加 ehcache 的配置文件 ehcache.xml ，文件内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;java.io.tmpdir/shiro-spring-sample&quot;</span>/&gt;</span>    &lt;defaultCache            maxElementsInMemory=&quot;10000&quot;            eternal=&quot;false&quot;            timeToIdleSeconds=&quot;120&quot;            timeToLiveSeconds=&quot;120&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            diskExpiryThreadIntervalSeconds=&quot;120&quot;    /&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;10000&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">&quot;600&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span></code></pre></div><p>配置含义：</p><ul><li>name:缓存名称。</li><li>maxElementsInMemory：缓存最大个数。</li><li>eternal:对象是否永久有效，一但设置了，timeout将不起作用。</li><li>timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</li><li>timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</li><li>overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。</li><li>diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</li><li>maxElementsOnDisk：硬盘最大缓存个数。</li><li>diskPersistent：是否缓存虚拟机重启期数据。</li><li>diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</li><li>memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</li><li>clearOnFlush：内存数量最大时是否清除。</li><li>diskStore 则表示临时缓存的硬盘目录。</li></ul><p><strong>注意</strong></p><p>默认情况下，这个文件名是固定的，必须叫 ehcache.xml ，如果一定要换一个名字，那么需要在 application.properties 中明确指定配置文件名，配置方式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.cache.ehcache.config</span>=<span class="hljs-string">classpath:aaa.xml</span></code></pre></div><h3 id="2-3-开启缓存"><a href="#2-3-开启缓存" class="headerlink" title="2.3 开启缓存"></a>2.3 开启缓存</h3><p>开启缓存的方式，也和 Redis 中一样，如下添加 <code>@EnableCaching</code> 依赖即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableCaching</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EhcacheApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(EhcacheApplication.class, args);    &#125;&#125;</code></pre></div><p>其实到这一步，Ehcache 就算配置完成了，接下来的用法，和Redis的就一样了</p><h3 id="2-4-使用缓存"><a href="#2-4-使用缓存" class="headerlink" title="2.4 使用缓存"></a>2.4 使用缓存</h3><p>这里主要向小伙伴们介绍缓存中几个核心的注解使用。</p><h4 id="CacheConfig-1"><a href="#CacheConfig-1" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><p>这个注解在类上使用，用来描述该类中所有方法使用的缓存名称，当然也可以不使用该注解，直接在具体的缓存注解上配置名称，示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@CacheConfig(cacheNames = &quot;user&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;&#125;</code></pre></div><h4 id="Cacheable-1"><a href="#Cacheable-1" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>这个注解一般加在查询方法上，表示将一个方法的返回值缓存起来，默认情况下，缓存的 key 就是方法的参数，缓存的 value 就是方法的返回值。示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(key = &quot;#id&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Integer id,String username)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;getUserById&quot;</span>);    <span class="hljs-keyword">return</span> getUserFromDBById(id);&#125;</code></pre></div><p>当有多个参数时，默认就使用多个参数来做 key ，如果只需要其中某一个参数做 key ，则可以在 @Cacheable 注解中，通过 key 属性来指定 key ，如上代码就表示只使用 id 作为缓存的 key ，如果对 key 有复杂的要求，可以自定义 keyGenerator 。当然，Spring Cache 中提供了root对象，可以在不定义 keyGenerator 的情况下实现一些复杂的效果，root 对象有如下属性：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13-2-20210524162503768-20210525152240961.png" alt="img"></p><p>也可以通过 keyGenerator 自定义 key ，方式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyKeyGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">KeyGenerator</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">generate</span><span class="hljs-params">(Object target, Method method, Object... params)</span> </span>&#123;        <span class="hljs-keyword">return</span> method.getName()+Arrays.toString(params);    &#125;&#125;</code></pre></div><p>然后在方法上使用该 keyGenerator ：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(keyGenerator = &quot;myKeyGenerator&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User();    user.setId(id);    user.setUsername(<span class="hljs-string">&quot;lisi&quot;</span>);    System.out.println(user);    <span class="hljs-keyword">return</span> user;&#125;</code></pre></div><h4 id="CachePut-1"><a href="#CachePut-1" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>这个注解一般加在更新方法上，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的 key 上，示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CachePut(key = &quot;#user.id&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">updateUserById</span><span class="hljs-params">(User user)</span> </span>&#123;    <span class="hljs-keyword">return</span> user;&#125;</code></pre></div><h4 id="CacheEvict-1"><a href="#CacheEvict-1" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>这个注解一般加在删除方法上，当数据库中的数据删除后，相关的缓存数据也要自动清除，该注解在使用的时候也可以配置按照某种条件删除（ condition 属性）或者或者配置清除所有缓存（ allEntries 属性），示例代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict()</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span> </span>&#123;    <span class="hljs-comment">//在这里执行删除操作， 删除是去数据库中删除</span>&#125;</code></pre></div><h1 id="SpringBoot安全管理"><a href="#SpringBoot安全管理" class="headerlink" title="SpringBoot安全管理"></a>SpringBoot安全管理</h1><h2 id="1-Spring-Security"><a href="#1-Spring-Security" class="headerlink" title="1. Spring Security"></a>1. Spring Security</h2><p>Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。</p><p>相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。</p><p>自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。</p><p>因此，一般来说，常见的安全管理技术栈的组合是这样的：</p><ul><li>SSM + Shiro</li><li>Spring Boot/Spring Cloud + Spring Security</li></ul><blockquote><p>注意，这只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的。</p></blockquote><h3 id="1-1-项目创建"><a href="#1-1-项目创建" class="headerlink" title="1.1 项目创建"></a>1.1 项目创建</h3><p>在 Spring Boot 中使用 Spring Security 非常容易，引入依赖即可：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/25-1-20210525152241244.png" alt="img"></p><p>pom.xml 中的 Spring Security 依赖：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>只要加入依赖，项目的所有接口都会被自动保护起来。</p><h3 id="1-2-初次体验"><a href="#1-2-初次体验" class="headerlink" title="1.2 初次体验"></a>1.2 初次体验</h3><p>我们创建一个 HelloController:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;&#125;</code></pre></div><p>访问 <code>/hello</code> ，需要登录之后才能访问。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/25-2-20210525152240990.png" alt="img"></p><p>当用户从浏览器发送请求访问 <code>/hello</code> 接口时，服务端会返回 <code>302</code> 响应码，让客户端重定向到 <code>/login</code> 页面，用户在 <code>/login</code> 页面登录，登陆成功之后，就会自动跳转到 <code>/hello</code> 接口</p><p>另外，也可以使用 <code>POSTMAN</code> 来发送请求，使用 <code>POSTMAN</code> 发送请求时，可以将用户信息放在请求头中（这样可以避免重定向到登录页面）：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/25-3-20210525152241103.png" alt="img"></p><p>通过以上两种不同的登录方式，可以看出，Spring Security 支持两种不同的认证方式：</p><ul><li>可以通过 form 表单来认证</li><li>可以通过 HttpBasic 来认证</li></ul><h3 id="1-3-用户名配置"><a href="#1-3-用户名配置" class="headerlink" title="1.3 用户名配置"></a>1.3 用户名配置</h3><p>默认情况下，登录的用户名是 <code>user</code> ，密码则是项目启动时随机生成的字符串，可以从启动的控制台日志中看到默认密码：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/25-4-20210525152241074.png" alt="img"></p><p>这个随机生成的密码，每次启动时都会变。对登录的用户名/密码进行配置，有三种不同的方式：</p><ul><li>在 application.properties 中进行配置</li><li>通过 Java 代码配置在内存中</li><li>通过 Java 从数据库中加载</li></ul><p>前两种比较简单，第三种代码量略大，本文就先来看看前两种，第三种后面再单独写文章介绍，也可以参考<a href="http://springboot.javaboy.org/2019/0725/springboot-springsecurity">微人事项目</a></p><h4 id="配置文件配置用户名-密码"><a href="#配置文件配置用户名-密码" class="headerlink" title="配置文件配置用户名/密码"></a>配置文件配置用户名/密码</h4><p>可以直接在 application.properties 文件中配置用户的基本信息：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.security.user.name</span>=<span class="hljs-string">javaboy</span><span class="hljs-meta">spring.security.user.password</span>=<span class="hljs-string">123</span></code></pre></div><p>配置完成后，重启项目，就可以使用这里配置的用户名/密码登录了</p><h4 id="Java-配置用户名-密码"><a href="#Java-配置用户名-密码" class="headerlink" title="Java 配置用户名/密码"></a>Java 配置用户名/密码</h4><p>也可以在 Java 代码中配置用户名密码，首先需要我们创建一个 Spring Security 的配置类，集成自 WebSecurityConfigurerAdapter 类，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//下面这两行配置表示在内存中配置了两个用户</span>        auth.inMemoryAuthentication()                .withUser(<span class="hljs-string">&quot;javaboy&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$OR3VSksVAmCzc.7WeaRPR.t0wyCsIj24k0Bne8iKWV1o.V9wsP8Xe&quot;</span>)                .and()          .withUser(<span class="hljs-string">&quot;lisi&quot;</span>).roles(<span class="hljs-string">&quot;user&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$p1H8iWa8I4.CA.7Z8bwLjes91ZpY.rYREGHQEInNtAp4NzL6PLKxi&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;&#125;</code></pre></div><p>这里我们在 configure 方法中配置了两个用户，用户的密码都是加密之后的字符串(明文是 123)，<strong>从 Spring5 开始，强制要求密码要加密</strong>，如果非不想加密，可以使用一个过期的 PasswordEncoder 的实例 NoOpPasswordEncoder，但是不建议这么做，毕竟不安全。</p><h3 id="1-4-加密方案"><a href="#1-4-加密方案" class="headerlink" title="1.4 加密方案"></a>1.4 加密方案</h3><p>密码加密我们一般会用到散列函数，又称散列算法、哈希函数，这是一种从任何数据中创建数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来，然后将数据打乱混合，重新创建一个散列值。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。我们常用的散列函数有 MD5 消息摘要算法、安全散列算法（Secure Hash Algorithm）。</p><p>但是仅仅使用散列函数还不够，为了增加密码的安全性，一般在密码加密过程中还需要加盐，所谓的盐可以是一个随机数也可以是用户名，加盐之后，即使密码明文相同的用户生成的密码密文也不相同，这可以极大的提高密码的安全性。但是传统的加盐方式需要在数据库中有专门的字段来记录盐值，这个字段可能是用户名字段（因为用户名唯一），也可能是一个专门记录盐值的字段，这样的配置比较繁琐。 </p><p>Spring Security 提供了多种密码加密方案，官方推荐使用 BCryptPasswordEncoder，BCryptPasswordEncoder 使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。</p><p>Spring Security 中提供了 BCryptPasswordEncoder 密码编码工具，可以非常方便的实现密码的加密加盐，相同明文加密出来的结果总是不同，这样就不需要用户去额外保存<strong>盐</strong>的字段了，这一点比 Shiro 要方便很多，而 BCryptPasswordEncoder 就是 PasswordEncoder 接口的实现类，只需要提供 BCryptPasswordEncoder 这个 Bean 的实例即可，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder(<span class="hljs-number">10</span>);&#125;</code></pre></div><p>创建 BCryptPasswordEncoder 时传入的参数 10 就是 strength，即密钥的迭代次数（也可以不配置，默认为 10）。同时，配置的内存用户的密码也不再是 123 了，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java">auth.inMemoryAuthentication().withUser(<span class="hljs-string">&quot;admin&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&quot;</span>).roles(<span class="hljs-string">&quot;ADMIN&quot;</span>, <span class="hljs-string">&quot;USER&quot;</span>).and().withUser(<span class="hljs-string">&quot;sang&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$eUHbAOMq4bpxTvOVz33LIehLe3fu6NwqC9tdOcxJXEhyZ4simqXTC&quot;</span>).roles(<span class="hljs-string">&quot;USER&quot;</span>);</code></pre></div><p>这里的密码就是使用 BCryptPasswordEncoder 加密后的密码，虽然 admin 和 sang 加密后的密码不一样，但是明文都是 123。配置完成后，使用 admin/123 或者 sang/123 就可以实现登录。</p><p>本案例使用了配置在内存中的用户，一般情况下，用户信息是存储在数据库中的，因此需要在用户注册时对密码进行加密处理，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reg</span><span class="hljs-params">(String username, String password)</span> </span>&#123;        BCryptPasswordEncoder encoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder(<span class="hljs-number">10</span>);        String encodePasswod = encoder.encode(password);        <span class="hljs-keyword">return</span> saveToDb(username, encodePasswod);    &#125;&#125;</code></pre></div><p>用户将密码从前端传来之后，通过调用 BCryptPasswordEncoder 实例中的 encode 方法对密码进行加密处理，加密完成后将密文存入数据库。</p><h3 id="1-5-登录配置"><a href="#1-5-登录配置" class="headerlink" title="1.5 登录配置"></a>1.5 登录配置</h3><p>对于登录接口，登录成功后的响应，登录失败后的响应，我们都可以在 WebSecurityConfigurerAdapter 的实现类中进行配置。例如下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;      <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-meta">@Autowired</span>    VerifyCodeFilter verifyCodeFilter;    <span class="hljs-comment">//http配置</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);        http        .authorizeRequests()<span class="hljs-comment">//开启登录配置</span>        .antMatchers(<span class="hljs-string">&quot;/hello&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)<span class="hljs-comment">//表示访问 /hello 这个接口，需要具备 admin 这个角色</span>        .anyRequest().authenticated()<span class="hljs-comment">//表示剩余的其他接口，登录之后就能访问</span>        .and()        .formLogin()        <span class="hljs-comment">//定义登录页面，未登录时，访问一个需要登录之后才能访问的接口，会自动跳转到该页面</span>        .loginPage(<span class="hljs-string">&quot;/login_p&quot;</span>)        <span class="hljs-comment">//登录处理接口</span>        .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)        <span class="hljs-comment">//定义登录时，用户名的 key，默认为 username</span>        .usernameParameter(<span class="hljs-string">&quot;uname&quot;</span>)        <span class="hljs-comment">//定义登录时，用户密码的 key，默认为 password</span>        .passwordParameter(<span class="hljs-string">&quot;passwd&quot;</span>)                  <span class="hljs-comment">//登录成功的处理器</span>                .successHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = resp.getWriter();                        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">200</span>);                        map.put(<span class="hljs-string">&quot;msg&quot;</span>, authentication.getPrincipal());                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map));                        out.flush();                        out.close();                    &#125;                &#125;)                    <span class="hljs-comment">//登录失败的处理器</span>               .failureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = resp.getWriter();                        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">401</span>);                        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException) &#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;账户被锁定，登录失败!&quot;</span>);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;用户名或密码输入错误，登录失败!&quot;</span>);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> DisabledException) &#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;账户被禁用，登录失败!&quot;</span>);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;账户过期，登录失败!&quot;</span>);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;密码过期，登录失败!&quot;</span>);                        &#125; <span class="hljs-keyword">else</span> &#123;                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;登录失败!&quot;</span>);                        &#125;                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map));                        out.flush();                        out.close();                    &#125;                &#125;)            .permitAll()<span class="hljs-comment">//和表单登录相关的接口统统都直接通过</span>            .and()            .logout()            .logoutUrl(<span class="hljs-string">&quot;/logout&quot;</span>)          <span class="hljs-comment">//注销成功的处理器</span>                .logoutSuccessHandler(<span class="hljs-keyword">new</span> LogoutSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = resp.getWriter();                        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">200</span>);                        map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;注销登录成功!&quot;</span>);                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map));                        out.flush();                        out.close();                    &#125;                &#125;)            .permitAll()            .and()            .httpBasic()            .and()            .csrf().disable();    &#125;&#125;</code></pre></div><p>我们可以在 successHandler 方法中，配置登录成功的回调，如果是前后端分离开发的话，登录成功后返回 JSON 即可，同理，failureHandler 方法中配置登录失败的回调，logoutSuccessHandler 中则配置注销成功的回调。</p><h4 id="多个Http的配置"><a href="#多个Http的配置" class="headerlink" title="多个Http的配置"></a><strong>多个Http的配置</strong></h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-comment">//不需要继承</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiHttpSecurityConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;  <span class="hljs-comment">//公用</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.inMemoryAuthentication()                .withUser(<span class="hljs-string">&quot;javaboy&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$G3kVAJHvmRrr6sOj.j4xpO2Dsxl5EG8rHycPHFWyi9UMIhtdSH15u&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>)                .and()                .withUser(<span class="hljs-string">&quot;江南一点雨&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$kWjG2GxWhm/2tN2ZBpi7bexXjUneIKFxIAaMYJzY7WcziZLCD4PZS&quot;</span>).roles(<span class="hljs-string">&quot;user&quot;</span>);    &#125;    <span class="hljs-meta">@Configuration</span>    <span class="hljs-meta">@Order(1)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            http.antMatcher(<span class="hljs-string">&quot;/admin/**&quot;</span>).authorizeRequests().anyRequest().hasAnyRole(<span class="hljs-string">&quot;admin&quot;</span>);        &#125;    &#125;    <span class="hljs-meta">@Configuration</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            http.authorizeRequests().anyRequest().authenticated()                    .and()                    .formLogin()                    .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)                    .permitAll()                    .and()                    .csrf().disable();        &#125;    &#125;&#125;</code></pre></div><h4 id="表达式控制方法权限"><a href="#表达式控制方法权限" class="headerlink" title="表达式控制方法权限"></a>表达式控制方法权限</h4><p>方法的安全默认是没有开启的，如果在Config类上加上注解<code>@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)</code>就可以开启方法的安全</p><p>这个配置开启了三个注解，分别是：</p><ul><li>@PreAuthorize：方法执行前进行权限检查</li><li>@PostAuthorize：方法执行后进行权限检查</li><li>@Secured：类似于 @PreAuthorize</li></ul><p>这三个结合 SpEL 之后，用法非常灵活，这里和大家稍微分享几个 Demo。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-meta">@PreAuthorize(&quot;principal.username.equals(&#x27;javaboy&#x27;)&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;    <span class="hljs-meta">@PreAuthorize(&quot;hasRole(&#x27;admin&#x27;)&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;admin&quot;</span>;    &#125;    <span class="hljs-meta">@Secured(&#123;&quot;ROLE_user&quot;&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user&quot;</span>;    &#125;    <span class="hljs-meta">@PreAuthorize(&quot;#age&gt;98&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">return</span> String.valueOf(age);    &#125;&#125;</code></pre></div><ul><li>第一个 hello 方法，注解的约束是，只有当前登录用户名为 javaboy 的用户才可以访问该方法。</li><li>第二个 admin 方法，表示访问该方法的用户必须具备 admin 角色。</li><li>第三个 user 方法，表示方法该方法的用户必须具备 user 角色，但是注意 user 角色需要加上 <code>ROLE_</code> 前缀。</li><li>第四个 getAge 方法，表示访问该方法的 age 参数必须大于 98，否则请求不予通过。</li></ul><p>可以看到，这里的表达式还是非常丰富，如果想引用方法的参数，前面加上一个 <code>#</code> 即可，既可以引用基本类型的参数，也可以引用对象参数。</p><h4 id="过滤注解"><a href="#过滤注解" class="headerlink" title="过滤注解"></a>过滤注解</h4><p>Spring Security 中还有两个过滤函数 @PreFilter 和 @PostFilter，可以根据给出的条件，自动移除集合中的元素。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostFilter(&quot;filterObject.lastIndexOf(&#x27;2&#x27;)!=-1&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span> </span>&#123;    List&lt;String&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        users.add(<span class="hljs-string">&quot;javaboy:&quot;</span> + i);    &#125;    <span class="hljs-keyword">return</span> users;&#125;<span class="hljs-meta">@PreFilter(filterTarget = &quot;ages&quot;,value = &quot;filterObject%2==0&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAllAge</span><span class="hljs-params">(List&lt;Integer&gt; ages,List&lt;String&gt; users)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;ages = &quot;</span> + ages);    System.out.println(<span class="hljs-string">&quot;users = &quot;</span> + users);&#125;</code></pre></div><ul><li>在 getAllUser 方法中，对集合进行过滤，只返回后缀为 2 的元素，filterObject 表示要过滤的元素对象。</li><li>在 getAllAge 方法中，由于有两个集合，因此使用 filterTarget 指定过滤对象。</li></ul><h4 id="忽略拦截"><a href="#忽略拦截" class="headerlink" title="忽略拦截"></a>忽略拦截</h4><p>如果某一个请求地址不需要拦截的话，有两种方式实现：</p><ul><li>设置该地址匿名访问</li><li>直接过滤掉该地址，即该地址不走 Spring Security 过滤器链</li></ul><p>推荐使用第二种方案，配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        web.ignoring().antMatchers(<span class="hljs-string">&quot;/vercode&quot;</span>);    &#125;&#125;</code></pre></div><h3 id="1-7-自定义表单登录"><a href="#1-7-自定义表单登录" class="headerlink" title="1.7 自定义表单登录"></a>1.7 自定义表单登录</h3><p>继续完善前面的 SecurityConfig 类，继续重写它的 <code>configure(WebSecurity web)</code> 和 <code>configure(HttpSecurity http)</code> 方法，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    web.ignoring().antMatchers(<span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/css/**&quot;</span>,<span class="hljs-string">&quot;/images/**&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            .anyRequest().authenticated()            .and()            .formLogin()            .loginPage(<span class="hljs-string">&quot;/login.html&quot;</span>)            .permitAll()            .and()            .csrf().disable();&#125;</code></pre></div><ul><li>web.ignoring() 用来配置忽略掉的 URL 地址，一般对于静态文件，我们可以采用此操作。</li><li>如果我们使用 XML 来配置 Spring Security ，里边会有一个重要的标签 <code>&lt;http&gt;</code>，HttpSecurity 提供的配置方法 都对应了该标签。</li><li>authorizeRequests 对应了 <code>&lt;intercept-url&gt;</code>。</li><li>formLogin 对应了 <code>&lt;formlogin&gt;</code>。</li><li>and 方法表示结束当前标签，上下文回到HttpSecurity，开启新一轮的配置。</li><li>permitAll 表示登录相关的页面/接口不要被拦截。</li><li>最后记得关闭 csrf ，关于 csrf 问题我到后面专门和大家说</li></ul><p>当我们定义了登录页面为 /login.html 的时候，Spring Security 也会帮我们自动注册一个 /login.html 的接口，这个接口是 POST 请求，用来处理登录逻辑。</p><p>我们将登录页面的相关静态文件拷贝到 Spring Boot 项目的 resources/static 目录下：</p><p><a href="http://img.itboyhub.com//2020/03/spring-security-2-7.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/spring-security-2-7.png" alt="img"></a></p><p>前端页面比较长，这里我把核心部分列出来（完整代码我会上传到 GitHub：<a href="https://github.com/lenve/spring-security-samples%EF%BC%89%EF%BC%9A">https://github.com/lenve/spring-security-samples）：</a></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/login.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spin&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;pass&quot;</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pass&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spin&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button login&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-check&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p>form 表单中，注意 action 为 <code>/login.html</code> </p><p>实际上它还有一个隐藏的操作，就是登录接口地址也设置成 <code>/login.html</code> 了。换句话说，新的登录页面和登录接口地址都是 <code>/login.html</code>，现在存在如下两个请求：</p><ul><li>GET <a href="http://localhost:8080/login.html">http://localhost:8080/login.html</a></li><li>POST <a href="http://localhost:8080/login.html">http://localhost:8080/login.html</a></li></ul><p>前面的 GET 请求用来获取登录页面，后面的 POST 请求用来提交登录数据。</p><p>有的小伙伴会感到奇怪？为什么登录页面和登录接口不能分开配置呢？</p><p>其实是可以分开配置的！</p><p>在 SecurityConfig 中，我们可以通过 loginProcessingUrl 方法来指定登录接口地址，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java">.and().formLogin().loginPage(<span class="hljs-string">&quot;/login.html&quot;</span>).loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>).permitAll().and()</code></pre></div><p>这样配置之后，登录页面地址和登录接口地址就分开了，各是各的。</p><p>此时我们还需要修改登录页面里边的 action 属性，改为 <code>/doLogin</code>，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/doLogin&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--省略--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p>此时，启动项目重新进行登录，我们发现依然可以登录成功。</p><p>那么为什么默认情况下两个配置地址是一样的呢？</p><p>我们知道，form 表单的相关配置在 FormLoginConfigurer 中，该类继承自 AbstractAuthenticationFilterConfigurer ，所以当 FormLoginConfigurer 初始化的时候，AbstractAuthenticationFilterConfigurer 也会初始化，在 AbstractAuthenticationFilterConfigurer 的构造方法中，我们可以看到：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractAuthenticationFilterConfigurer</span><span class="hljs-params">()</span> </span>&#123;setLoginPage(<span class="hljs-string">&quot;/login&quot;</span>);&#125;</code></pre></div><p>这就是配置默认的 loginPage 为 <code>/login</code>。</p><p>另一方面，FormLoginConfigurer 的初始化方法 init 方法中也调用了父类的 init 方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(H http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-keyword">super</span>.init(http);initDefaultLoginFilter(http);&#125;</code></pre></div><p>而在父类的 init 方法中，又调用了 updateAuthenticationDefaults，我们来看下这个方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAuthenticationDefaults</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (loginProcessingUrl == <span class="hljs-keyword">null</span>) &#123;loginProcessingUrl(loginPage);&#125;<span class="hljs-comment">//省略</span>&#125;</code></pre></div><p>从这个方法的逻辑中我们就可以看到，如果用户没有给 loginProcessingUrl 设置值的话，默认就使用 loginPage 作为 loginProcessingUrl。</p><p>而如果用户配置了 loginPage，在配置完 loginPage 之后，updateAuthenticationDefaults 方法还是会被调用，此时如果没有配置 loginProcessingUrl，则使用新配置的 loginPage 作为 loginProcessingUrl。</p><h3 id="1-8-基于数据库的认证"><a href="#1-8-基于数据库的认证" class="headerlink" title="1.8 基于数据库的认证"></a>1.8 基于数据库的认证</h3><p><strong>创建库</strong></p><div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;*!40101 SET NAMES utf8 *&#x2F;;&#x2F;*!40101 SET SQL_MODE&#x3D;&#39;&#39;*&#x2F;;&#x2F;*!40014 SET @OLD_UNIQUE_CHECKS&#x3D;@@UNIQUE_CHECKS, UNIQUE_CHECKS&#x3D;0 *&#x2F;;&#x2F;*!40014 SET @OLD_FOREIGN_KEY_CHECKS&#x3D;@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS&#x3D;0 *&#x2F;;&#x2F;*!40101 SET @OLD_SQL_MODE&#x3D;@@SQL_MODE, SQL_MODE&#x3D;&#39;NO_AUTO_VALUE_ON_ZERO&#39; *&#x2F;;&#x2F;*!40111 SET @OLD_SQL_NOTES&#x3D;@@SQL_NOTES, SQL_NOTES&#x3D;0 *&#x2F;;CREATE DATABASE &#x2F;*!32312 IF NOT EXISTS*&#x2F;&#96;security&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F;;USE &#96;security&#96;;&#x2F;*Table structure for table &#96;role&#96; *&#x2F;DROP TABLE IF EXISTS &#96;role&#96;;CREATE TABLE &#96;role&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;name&#96; varchar(32) DEFAULT NULL,  &#96;nameZh&#96; varchar(32) DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;&#x2F;*Data for the table &#96;role&#96; *&#x2F;insert  into &#96;role&#96;(&#96;id&#96;,&#96;name&#96;,&#96;nameZh&#96;) values (1,&#39;ROLE_dba&#39;,&#39;数据库管理员&#39;),(2,&#39;ROLE_admin&#39;,&#39;系统管理员&#39;),(3,&#39;ROLE_user&#39;,&#39;用户&#39;);&#x2F;*Table structure for table &#96;user&#96; *&#x2F;DROP TABLE IF EXISTS &#96;user&#96;;CREATE TABLE &#96;user&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;username&#96; varchar(32) DEFAULT NULL,  &#96;password&#96; varchar(255) DEFAULT NULL,  &#96;enabled&#96; tinyint(1) DEFAULT NULL,  &#96;locked&#96; tinyint(1) DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;&#x2F;*Data for the table &#96;user&#96; *&#x2F;insert  into &#96;user&#96;(&#96;id&#96;,&#96;username&#96;,&#96;password&#96;,&#96;enabled&#96;,&#96;locked&#96;) values (1,&#39;root&#39;,&#39;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&#39;,1,0),(2,&#39;admin&#39;,&#39;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&#39;,1,0),(3,&#39;sang&#39;,&#39;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&#39;,1,0);&#x2F;*Table structure for table &#96;user_role&#96; *&#x2F;DROP TABLE IF EXISTS &#96;user_role&#96;;CREATE TABLE &#96;user_role&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;uid&#96; int(11) DEFAULT NULL,  &#96;rid&#96; int(11) DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;5 DEFAULT CHARSET&#x3D;utf8;&#x2F;*Data for the table &#96;user_role&#96; *&#x2F;insert  into &#96;user_role&#96;(&#96;id&#96;,&#96;uid&#96;,&#96;rid&#96;) values (1,1,1),(2,1,2),(3,2,2),(4,3,3);&#x2F;*!40101 SET SQL_MODE&#x3D;@OLD_SQL_MODE *&#x2F;;&#x2F;*!40014 SET FOREIGN_KEY_CHECKS&#x3D;@OLD_FOREIGN_KEY_CHECKS *&#x2F;;&#x2F;*!40014 SET UNIQUE_CHECKS&#x3D;@OLD_UNIQUE_CHECKS *&#x2F;;&#x2F;*!40111 SET SQL_NOTES&#x3D;@OLD_SQL_NOTES *&#x2F;;</code></pre></div><p>得到user表、user_role表、role表</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525102214396.png" alt="image-20210525102214396"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525102226106.png" alt="image-20210525102226106"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525102243104.png" alt="image-20210525102243104"></p><p><strong>引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p><strong>配置文件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://192.168.66.128:3306/security</span><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span></code></pre></div><p><strong>定义实体类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实现认证的接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> Boolean enabled;    <span class="hljs-keyword">private</span> Boolean locked;    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;   <span class="hljs-comment">//重写接口中的方法</span>   <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;<span class="hljs-comment">//账户是否未过期，对应user中的locked</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;<span class="hljs-comment">//是否没有被锁定</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> !locked;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> enabled;    &#125;<span class="hljs-comment">//返回用户的所有角色</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (Role role : roles) &#123;          <span class="hljs-comment">//数据库的role表中用户必须以&quot;ROLE_&quot;开头</span>            authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));        &#125;        <span class="hljs-keyword">return</span> authorities;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String nameZh;    ...&#125;</code></pre></div><p><strong>创建Service</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserMapper userMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;      <span class="hljs-comment">//方法一  </span>      User user = userMapper.loadUserByUsername(username);        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;用户不存在!&quot;</span>);        &#125;       <span class="hljs-comment">//方法二</span>        user.setRoles(userMapper.getUserRolesById(user.getId()));        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre></div><p><strong>Mapper的接口以及实现类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;    <span class="hljs-function">User <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span></span>;    <span class="hljs-function">List&lt;Role&gt; <span class="hljs-title">getUserRolesById</span><span class="hljs-params">(Integer id)</span></span>;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.javaboy.securitydb.mapper.UserMapper&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loadUserByUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.javaboy.securitydb.bean.User&quot;</span>&gt;</span>        select * from user where username=#&#123;username&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserRolesById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.javaboy.securitydb.bean.Role&quot;</span>&gt;</span>        select * from role where id in (select rid from user_role where uid=#&#123;id&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p><strong>Security配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserService userService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(userService);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .antMatchers(<span class="hljs-string">&quot;/dba/**&quot;</span>).hasRole(<span class="hljs-string">&quot;dba&quot;</span>)                .antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)                .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasRole(<span class="hljs-string">&quot;user&quot;</span>)                .anyRequest().authenticated()                .and()                .formLogin()                .permitAll()                .and()                .csrf().disable();    &#125;&#125;</code></pre></div><p><strong>测试接口Controller</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello security!&quot;</span>;    &#125;    <span class="hljs-meta">@GetMapping(&quot;/dba/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dba</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello dba!&quot;</span>;    &#125;    <span class="hljs-meta">@GetMapping(&quot;/admin/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello admin&quot;</span>;    &#125;    <span class="hljs-meta">@GetMapping(&quot;/user/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello user&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="角色继承"><a href="#角色继承" class="headerlink" title="角色继承"></a>角色继承</h4><p>角色继承实际上是一个很常见的需求，因为大部分公司治理可能都是金字塔形的，上司可能具备下属的部分甚至所有权限，这一现实场景，反映到我们的代码中，就是角色继承了。 Spring Security 中为开发者提供了相关的角色继承解决方案，但是这一解决方案在最近的 Spring Security 版本变迁中，使用方法有所变化</p><p>SpringSecurity 在角色继承上有两种不同的写法，在 Spring Boot2.0.8（对应 Spring Security 也是 5.0.11）上面是一种写法，从 Spring Boot2.1.0（对应 Spring Security5.1.1）又是另外一种写法</p><p><strong>以前的写法</strong></p><p>这里说的以前写法，就是指 SpringBoot2.0.8（含）之前的写法，在之前的写法中，角色继承只需要开发者提供一个 RoleHierarchy 接口的实例即可，例如下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function">RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;    RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();    String hierarchy = <span class="hljs-string">&quot;ROLE_dba &gt; ROLE_admin ROLE_admin &gt; ROLE_user&quot;</span>;    roleHierarchy.setHierarchy(hierarchy);    <span class="hljs-keyword">return</span> roleHierarchy;&#125;</code></pre></div><p>在这里我们提供了一个 RoleHierarchy 接口的实例，使用字符串来描述了角色之间的继承关系， <code>ROLE_dba</code> 具备 <code>ROLE_admin</code> 的所有权限，而 <code>ROLE_admin</code> 则具备 <code>ROLE_user</code> 的所有权限，继承与继承之间用一个空格隔开。提供了这个 Bean 之后，以后所有具备 <code>ROLE_user</code> 角色才能访问的资源， <code>ROLE_dba</code> 和 <code>ROLE_admin</code> 也都能访问，具备 <code>ROLE_amdin</code> 角色才能访问的资源， <code>ROLE_dba</code> 也能访问。</p><p><strong>现在的写法</strong></p><p>但是上面这种写法仅限于 Spring Boot2.0.8（含）之前的版本，在之后的版本中，这种写法则不被支持，新版的写法是下面这样：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function">RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;    RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();    String hierarchy = <span class="hljs-string">&quot;ROLE_dba &gt; ROLE_admin \n ROLE_admin &gt; ROLE_user&quot;</span>;    roleHierarchy.setHierarchy(hierarchy);    <span class="hljs-keyword">return</span> roleHierarchy;&#125;</code></pre></div><p>变化主要就是分隔符，将原来用空格隔开的地方，现在用换行符了。这里表达式的含义依然和上面一样，不再赘述。</p><p>上面两种不同写法都是配置角色的继承关系，配置完成后，接下来指定角色和资源的对应关系即可，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests().antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>)            .hasRole(<span class="hljs-string">&quot;admin&quot;</span>)            .antMatchers(<span class="hljs-string">&quot;/db/**&quot;</span>)            .hasRole(<span class="hljs-string">&quot;dba&quot;</span>)            .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>)            .hasRole(<span class="hljs-string">&quot;user&quot;</span>)            .and()            .formLogin()            .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)            .permitAll()            .and()            .csrf().disable();&#125;</code></pre></div><p>这个表示 <code>/db/**</code> 格式的路径需要具备 dba 角色才能访问， <code>/admin/**</code> 格式的路径则需要具备 admin 角色才能访问， <code>/user/**</code> 格式的路径，则需要具备 user 角色才能访问，此时提供相关接口，会发现，dba 除了访问 <code>/db/**</code>，也能访问 <code>/admin/**</code> 和 <code>/user/**</code> ，admin 角色除了访问 <code>/admin/**</code> ，也能访问 <code>/user/**</code> ，user 角色则只能访问 <code>/user/**</code> 。</p><h4 id="动态权限配置"><a href="#动态权限配置" class="headerlink" title="动态权限配置"></a><strong>动态权限配置</strong></h4><p>继续创建表</p><div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;*Table structure for table &#96;menu&#96; *&#x2F;DROP TABLE IF EXISTS &#96;menu&#96;;CREATE TABLE &#96;menu&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;pattern&#96; varchar(128) DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;&#x2F;*Data for the table &#96;menu&#96; *&#x2F;insert  into &#96;menu&#96;(&#96;id&#96;,&#96;pattern&#96;) values (1,&#39;&#x2F;db&#x2F;**&#39;),(2,&#39;&#x2F;admin&#x2F;**&#39;),(3,&#39;&#x2F;user&#x2F;**&#39;);&#x2F;*Table structure for table &#96;menu_role&#96; *&#x2F;DROP TABLE IF EXISTS &#96;menu_role&#96;;CREATE TABLE &#96;menu_role&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;mid&#96; int(11) DEFAULT NULL,  &#96;rid&#96; int(11) DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;&#x2F;*Data for the table &#96;menu_role&#96; *&#x2F;insert  into &#96;menu_role&#96;(&#96;id&#96;,&#96;mid&#96;,&#96;rid&#96;) values (1,1,1),(2,2,2),(3,3,3);</code></pre></div><p>menu表、menu_role表</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525105223533.png" alt="image-20210525105223533"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525105242464.png" alt="image-20210525105242464"></p><p><strong>最终的五张表</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525105211929.png" alt="image-20210525105211929"></p><p>上面的角色之间的权限是在Config类中写死的</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()            .antMatchers(<span class="hljs-string">&quot;/dba/**&quot;</span>).hasRole(<span class="hljs-string">&quot;dba&quot;</span>)            .antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)            .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasRole(<span class="hljs-string">&quot;user&quot;</span>)            .anyRequest().authenticated()            .and()            .formLogin()            .permitAll()            .and()            .csrf().disable();&#125;</code></pre></div><p>如今转换到数据库中动态加载，<strong>新增实体类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String pattern;    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Menu&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, pattern=&#x27;&quot;</span> + pattern + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, roles=&quot;</span> + roles +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">getRoles</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> roles;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoles</span><span class="hljs-params">(List&lt;Role&gt; roles)</span> </span>&#123;        <span class="hljs-keyword">this</span>.roles = roles;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPattern</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> pattern;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPattern</span><span class="hljs-params">(String pattern)</span> </span>&#123;        <span class="hljs-keyword">this</span>.pattern = pattern;    &#125;&#125;</code></pre></div><p><strong>Service及Mapper</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MenuMapper menuMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getAllMenus</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> menuMapper.getAllMenus();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MenuMapper</span> </span>&#123;    <span class="hljs-function">List&lt;Menu&gt; <span class="hljs-title">getAllMenus</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p><strong>查询一对多的关系</strong></p><div class="hljs code-wrapper"><pre><code class="hljs mysql">select m.*,r.&#96;id&#96; as rid,r.&#96;name&#96; as rname,r.&#96;nameZh&#96; as rnameZh from menu m left join menu_role mr on m.&#96;id&#96;&#x3D;mr.&#96;mid&#96; left join role r on mr.&#96;rid&#96;&#x3D;r.&#96;id&#96;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525111027555.png" alt="image-20210525111027555"></p><p><strong>对应的Menumapper.xml</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.javaboy.securitydy.mapper.MenuMapper&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.javaboy.securitydy.bean.Menu&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pattern&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roles&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;org.javaboy.securitydy.bean.Role&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rnameZh&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;nameZh&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 一对多，需要resultMap--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllMenus&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>        select m.*,r.`id` as rid,r.`name` as rname,r.`nameZh` as rnameZh from menu m left join menu_role mr on m.`id`=mr.`mid` left join role r on mr.`rid`=r.`id`    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>在更新配置类之前，先创建过滤器根据url匹配用户角色</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterInvocationSecurityMetadataSource</span> </span>&#123;    <span class="hljs-comment">//路径匹配</span>    AntPathMatcher pathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-meta">@Autowired</span>    MenuService menuService;    <span class="hljs-comment">//根据请求的地址分析需要那个角色</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAttributes</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;        String requestUrl = ((FilterInvocation) o).getRequestUrl();        List&lt;Menu&gt; allMenus = menuService.getAllMenus();        <span class="hljs-comment">//遍历从数据库取出的结果，开始匹配</span>        <span class="hljs-keyword">for</span> (Menu menu : allMenus) &#123;            <span class="hljs-keyword">if</span> (pathMatcher.match(menu.getPattern(), requestUrl)) &#123;                <span class="hljs-comment">//url对应得上库中的结果</span>                List&lt;Role&gt; roles = menu.getRoles();                String[] rolesStr = <span class="hljs-keyword">new</span> String[roles.size()];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; roles.size(); i++) &#123;                    rolesStr[i] = roles.get(i).getName();                &#125;                <span class="hljs-keyword">return</span> SecurityConfig.createList(rolesStr);            &#125;        &#125;        <span class="hljs-comment">//url无法匹配，特殊标记</span>        <span class="hljs-keyword">return</span> SecurityConfig.createList(<span class="hljs-string">&quot;ROLE_login&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAllConfigAttributes</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; aClass)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><p>根据过滤器Collection得到的返回值，再进行处理Collection</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAccessDecisionManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDecisionManager</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decide</span><span class="hljs-params">(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection)</span> <span class="hljs-keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;        <span class="hljs-keyword">for</span> (ConfigAttribute attribute : collection) &#123;            <span class="hljs-comment">//说明url没匹配上</span>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ROLE_login&quot;</span>.equals(attribute.getAttribute())) &#123;                <span class="hljs-comment">//如果是匿名用户，抛异常</span>                <span class="hljs-keyword">if</span> (authentication <span class="hljs-keyword">instanceof</span> AnonymousAuthenticationToken) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;非法请求!&quot;</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            <span class="hljs-comment">//匹配得上</span>            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();            <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;                <span class="hljs-keyword">if</span> (authority.getAuthority().equals(attribute.getAttribute())) &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;非法请求!&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute configAttribute)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; aClass)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><p><strong>更新配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserService userService;    <span class="hljs-comment">//注入过滤器</span>    <span class="hljs-meta">@Autowired</span>    MyFilter myFilter;    <span class="hljs-comment">//注入处理</span>    <span class="hljs-meta">@Autowired</span>    MyAccessDecisionManager myAccessDecisionManager;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(userService);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O o)</span> </span>&#123;                        <span class="hljs-comment">//使用过滤器和处理</span>                        o.setAccessDecisionManager(myAccessDecisionManager);                        o.setSecurityMetadataSource(myFilter);                        <span class="hljs-keyword">return</span> o;                    &#125;                &#125;)                .and()                .formLogin()                .permitAll()                .and()                .csrf().disable();    &#125;&#125;</code></pre></div><h3 id="1-9-使用JSON登录"><a href="#1-9-使用JSON登录" class="headerlink" title="1.9 使用JSON登录"></a>1.9 使用JSON登录</h3><h4 id="使用Key-Value登录"><a href="#使用Key-Value登录" class="headerlink" title="使用Key/Value登录"></a>使用Key/Value登录</h4><ul><li>创建 Spring Boot 工程</li></ul><p>首先创建 SpringBoot 工程，添加 SpringSecurity 依赖，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ul><li>添加 Security 配置</li></ul><p>创建 SecurityConfig，完成 SpringSecurity 的配置，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.inMemoryAuthentication().withUser(<span class="hljs-string">&quot;zhangsan&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$2O4EwLrrFPEboTfDOtC0F.RpUMk.3q3KvBHRx7XXKUMLBGjOOBs8q&quot;</span>).roles(<span class="hljs-string">&quot;user&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .anyRequest().authenticated()                .and()                .formLogin()                .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)                .successHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        RespBean ok = RespBean.ok(<span class="hljs-string">&quot;登录成功！&quot;</span>,authentication.getPrincipal());                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = resp.getWriter();                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok));                        out.flush();                        out.close();                    &#125;                &#125;)                .failureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        RespBean error = RespBean.error(<span class="hljs-string">&quot;登录失败&quot;</span>);                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = resp.getWriter();                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(error));                        out.flush();                        out.close();                    &#125;                &#125;)                .loginPage(<span class="hljs-string">&quot;/login&quot;</span>)                .permitAll()                .and()                .logout()                .logoutUrl(<span class="hljs-string">&quot;/logout&quot;</span>)                .logoutSuccessHandler(<span class="hljs-keyword">new</span> LogoutSuccessHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        RespBean ok = RespBean.ok(<span class="hljs-string">&quot;注销成功！&quot;</span>);                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = resp.getWriter();                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok));                        out.flush();                        out.close();                    &#125;                &#125;)                .permitAll()                .and()                .csrf()                .disable()                .exceptionHandling()                .accessDeniedHandler(<span class="hljs-keyword">new</span> AccessDeniedHandler() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AccessDeniedException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                        RespBean error = RespBean.error(<span class="hljs-string">&quot;权限不足，访问失败&quot;</span>);                        resp.setStatus(<span class="hljs-number">403</span>);                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);                        PrintWriter out = resp.getWriter();                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(error));                        out.flush();                        out.close();                    &#125;                &#125;);    &#125;&#125;</code></pre></div><p>这里的配置虽然有点长，但是很基础，配置含义也比较清晰，首先提供 BCryptPasswordEncoder 作为 PasswordEncoder ，可以实现对密码的自动加密加盐，非常方便，然后提供了一个名为 <code>zhangsan</code> 的用户，密码是 <code>123</code> ，角色是 <code>user</code> ，最后配置登录逻辑，所有的请求都需要登录后才能访问，登录接口是 <code>/doLogin</code> ，用户名的 key 是 username ，密码的 key 是 password ，同时配置登录成功、登录失败以及注销成功、权限不足时都给用户返回JSON提示，另外，这里虽然配置了登录页面为 <code>/login</code> ，实际上这不是一个页面，而是一段 JSON ，在 LoginController 中提供该接口，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;尚未登录，请登录&quot;</span>);    &#125;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;&#125;</code></pre></div><p>这里 <code>/login</code> 只是一个 JSON 提示，而不是页面， <code>/hello</code> 则是一个测试接口。</p><p>OK，做完上述步骤就可以开始测试了，运行SpringBoot项目，访问 <code>/hello</code> 接口，结果如下：</p><p><img src="http://www.javaboy.org/images/boot/p1-1.png" alt="img"></p><p>此时先调用登录接口进行登录，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/p1-2.png" alt="img"></p><p>登录成功后，再去访问 <code>/hello</code> 接口就可以成功访问了。</p><h4 id="使用JSON登录"><a href="#使用JSON登录" class="headerlink" title="使用JSON登录"></a>使用JSON登录</h4><p>上面演示的是一种原始的登录方案，如果想将用户名密码通过 JSON 的方式进行传递，则需要自定义相关过滤器，通过分析源码我们发现，默认的用户名密码提取在 UsernamePasswordAuthenticationFilter 过滤器中，部分源码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> <span class="hljs-keyword">extends</span></span><span class="hljs-class"><span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPRING_SECURITY_FORM_USERNAME_KEY = <span class="hljs-string">&quot;username&quot;</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPRING_SECURITY_FORM_PASSWORD_KEY = <span class="hljs-string">&quot;password&quot;</span>;<span class="hljs-keyword">private</span> String usernameParameter = SPRING_SECURITY_FORM_USERNAME_KEY;<span class="hljs-keyword">private</span> String passwordParameter = SPRING_SECURITY_FORM_PASSWORD_KEY;<span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> postOnly = <span class="hljs-keyword">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;    <span class="hljs-keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());&#125;String username = obtainUsername(request);String password = obtainPassword(request);<span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;username = <span class="hljs-string">&quot;&quot;</span>;&#125;<span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;password = <span class="hljs-string">&quot;&quot;</span>;&#125;username = username.trim();UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password);<span class="hljs-comment">// Allow subclasses to set the &quot;details&quot; property</span>setDetails(request, authRequest);<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainPassword</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">return</span> request.getParameter(passwordParameter);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainUsername</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">return</span> request.getParameter(usernameParameter);&#125;    <span class="hljs-comment">//...</span>    <span class="hljs-comment">//...</span>&#125;</code></pre></div><p>从这里可以看到，默认的用户名/密码提取就是通过 request 中的 getParameter 来提取的，如果想使用 JSON 传递用户名密码，只需要将这个过滤器替换掉即可，自定义过滤器如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;              <span class="hljs-keyword">if</span> (request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)                || request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) &#123;            ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();            UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span> (InputStream is = request.getInputStream()) &#123;                Map&lt;String,String&gt; authenticationBean = mapper.readValue(is, Map.class);                authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(                        authenticationBean.get(<span class="hljs-string">&quot;username&quot;</span>), authenticationBean.get(<span class="hljs-string">&quot;password&quot;</span>));            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();                authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(                        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);            &#125; <span class="hljs-keyword">finally</span> &#123;                setDetails(request, authRequest);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);            &#125;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.attemptAuthentication(request, response);        &#125;    &#125;&#125;</code></pre></div><p>这里只是将用户名/密码的获取方案重新修正下，改为了从 JSON 中获取用户名密码，然后在 SecurityConfig 中作出如下修改：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests().anyRequest().authenticated()            .and()            .formLogin()            .and().csrf().disable();    http.addFilterAt(customAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);&#125;<span class="hljs-meta">@Bean</span><span class="hljs-function">CustomAuthenticationFilter <span class="hljs-title">customAuthenticationFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    CustomAuthenticationFilter filter = <span class="hljs-keyword">new</span> CustomAuthenticationFilter();    filter.setAuthenticationSuccessHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);            PrintWriter out = resp.getWriter();            RespBean respBean = RespBean.ok(<span class="hljs-string">&quot;登录成功!&quot;</span>);            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));            out.flush();            out.close();        &#125;    &#125;);    filter.setAuthenticationFailureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);            PrintWriter out = resp.getWriter();            RespBean respBean = RespBean.error(<span class="hljs-string">&quot;登录失败!&quot;</span>);            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));            out.flush();            out.close();        &#125;    &#125;);    filter.setAuthenticationManager(authenticationManagerBean());    <span class="hljs-keyword">return</span> filter;&#125;</code></pre></div><p>将自定义的 CustomAuthenticationFilter 类加入进来即可，接下来就可以使用 JSON 进行登录了，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/p1-3.png" alt="img"></p><h2 id="2-Shiro"><a href="#2-Shiro" class="headerlink" title="2. Shiro"></a>2. Shiro</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>Apache Shiro是一个开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架具有直观、易用等特性，同时也能提供健壮的安全性，虽然它的功能不如SpringSecurity那么强大，但是在普通的项目中也够用了。</p><h4 id="2-1-1-由来"><a href="#2-1-1-由来" class="headerlink" title="2.1.1 由来"></a>2.1.1 由来</h4><p>Shiro的前身是JSecurity，2004年，Les Hazlewood和Jeremy Haile创办了Jsecurity。当时他们找不到适用于应用程序级别的合适Java安全框架，同时又对JAAS非常失望。2004年到2008年期间，JSecurity托管在SourceForge上，贡献者包括Peter Ledbrook、Alan Ditzel和Tim Veil。2008年，JSecurity项目贡献给了Apache软件基金会（ASF），并被接纳成为Apache Incubator项目，由导师管理，目标是成为一个顶级Apache项目。期间，Jsecurity曾短暂更名为Ki，随后因商标问题被社区更名为“Shiro”。随后项目持续在Apache Incubator中孵化，并增加了贡献者Kalle Korhonen。2010年7月，Shiro社区发布了1.0版，随后社区创建了其项目管理委员会，并选举Les Hazlewood为主席。2010年9月22日，Shrio成为Apache软件基金会的顶级项目（TLP）。</p><h4 id="3-1-2-有哪些功能"><a href="#3-1-2-有哪些功能" class="headerlink" title="3.1.2 有哪些功能"></a>3.1.2 有哪些功能</h4><p>Apache Shiro是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。Apache Shiro的首要目标是易于使用和理解。安全有时候是很复杂的，甚至是痛苦的，但它没有必要这样。框架应该尽可能掩盖复杂的地方，露出一个干净而直观的API，来简化开发人员在应用程序安全上所花费的时间。</p><p>以下是你可以用Apache Shiro 所做的事情：</p><ul><li>验证用户来核实他们的身份</li><li>对用户执行访问控制，如：判断用户是否被分配了一个确定的安全角色；判断用户是否被允许做某事</li><li>在任何环境下使用Session API，即使没有Web容器</li><li>在身份验证，访问控制期间或在会话的生命周期，对事件作出反应</li><li>聚集一个或多个用户安全数据的数据源，并作为一个单一的复合用户“视图”</li><li>单点登录（SSO）功能</li><li>为没有关联到登录的用户启用”Remember Me”服务</li></ul><p>Apache Shiro是一个拥有许多功能的综合性的程序安全框架。下面的图表展示了Shiro的重点：</p><p><a href="https://img-blog.csdnimg.cn/img_convert/a6a1cb5eb8a807afe4f4b2bd094a97ba.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/a6a1cb5eb8a807afe4f4b2bd094a97ba.png" alt="p306"></a></p><p>Shiro中有四大基石——身份验证，授权，会话管理和加密</p><ol><li>Authentication：有时也简称为“登录”，这是一个证明用户是谁的行为。</li><li>Authorization：访问控制的过程，也就是决定“谁”去访问“什么”。</li><li>Session Management：管理用户特定的会话，即使在非Web 或EJB 应用程序。</li><li>Cryptography：通过使用加密算法保持数据安全同时易于使用。</li></ol><p>除此之外，Shiro也提供了额外的功能来解决在不同环境下所面临的安全问题，尤其是以下这些：</p><ol><li>Web Support：Shiro的web支持的API能够轻松地帮助保护Web应用程序。</li><li>Caching：缓存是Apache Shiro中的第一层公民，来确保安全操作快速而又高效。</li><li>Concurrency：Apache Shiro利用它的并发特性来支持多线程应用程序。</li><li>Testing：测试支持的存在来帮助你编写单元测试和集成测试。</li><li>“Run As”：一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。</li><li>“Remember Me”：在会话中记住用户的身份，这样用户只需要在强制登录时候登录。</li></ol><h3 id="2-2-Realm"><a href="#2-2-Realm" class="headerlink" title="2.2 Realm"></a>2.2 Realm</h3><h4 id="2-2-1-登录流程是什么样的"><a href="#2-2-1-登录流程是什么样的" class="headerlink" title="2.2.1 登录流程是什么样的"></a>2.2.1 登录流程是什么样的</h4><p>首先我们来看shiro官方文档中这样一张登录流程图：</p><p><a href="https://img-blog.csdnimg.cn/img_convert/f8b6568be71a8cb15f49f862101dd661.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/f8b6568be71a8cb15f49f862101dd661.png" alt="p308"></a></p><p>参照此图，我们的登录一共要经过如下几个步骤：</p><ol><li>应用程序代码调用Subject.login方法，传递创建好的包含终端用户的Principals(身份)和Credentials(凭证)的AuthenticationToken实例(即上文例子中的UsernamePasswordToken)。</li><li>Subject实例，通常是DelegatingSubject（或子类）委托应用程序的SecurityManager通过调用securityManager.login(token)开始真正的验证工作(在DelegatingSubject类的login方法中打断点即可看到)。</li><li>SubjectManager作为一个基本的“保护伞”的组成部分，接收token以及简单地委托给内部的Authenticator实例通过调用authenticator.authenticate(token)。这通常是一个ModularRealmAuthenticator实例，支持在身份验证中协调一个或多个Realm实例。ModularRealmAuthenticator本质上为Apache Shiro 提供了PAM-style 范式（其中在PAM 术语中每个Realm 都是一个’module’）。</li><li>如果应用程序中配置了一个以上的Realm，ModularRealmAuthenticator实例将利用配置好的AuthenticationStrategy来启动Multi-Realm认证尝试。在Realms 被身份验证调用之前，期间和以后，AuthenticationStrategy被调用使其能够对每个Realm的结果作出反应。如果只有一个单一的Realm 被配置，它将被直接调用，因为没有必要为一个单一Realm的应用使用AuthenticationStrategy。</li><li>每个配置的Realm用来帮助看它是否支持提交的AuthenticationToken。如果支持，那么支持Realm的getAuthenticationInfo方法将会伴随着提交的token被调用。</li></ol><h4 id="2-2-2-什么是Realm"><a href="#2-2-2-什么是Realm" class="headerlink" title="2.2.2 什么是Realm"></a>2.2.2 什么是Realm</h4><p>根据Realm文档上的解释，Realms担当Shiro和你的应用程序的安全数据之间的“桥梁”或“连接器”。当它实际上与安全相关的数据如用来执行身份验证（登录）及授权（访问控制）的用户帐户交互时，Shiro从一个或多个为应用程序配置的Realm 中寻找许多这样的东西。在这个意义上说，<strong>Realm 本质上是一个特定安全的DAO</strong>：它封装了数据源的连接详细信息，使Shiro 所需的相关的数据可用。当配置Shiro 时，你必须指定至少一个Realm 用来进行身份验证和/或授权。SecurityManager可能配置多个Realms，但至少有一个是必须的。Shiro 提供了立即可用的Realms 来连接一些安全数据源（即目录），如LDAP，关系数据库（JDBC），文本配置源，像INI 及属性文件，以及更多。</p><h3 id="2-2-整合SpringBoot"><a href="#2-2-整合SpringBoot" class="headerlink" title="2.2 整合SpringBoot"></a>2.2 整合SpringBoot</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p><strong>引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>自定义Realm</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        String username = (String) token.getPrincipal();        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;javaboy&quot;</span>.equals(username)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username, <span class="hljs-string">&quot;123&quot;</span>, getName());        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p>在 Realm 中实现简单的认证操作即可，不做授权，授权的具体写法和 SSM 中的 Shiro 一样，不赘述。这里的认证表示用户名必须是 javaboy ，用户密码必须是 123 ，满足这样的条件，就能登录成功！</p><p><strong>配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">MyRealm <span class="hljs-title">myRealm</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyRealm();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">SecurityManager <span class="hljs-title">securityManager</span><span class="hljs-params">()</span> </span>&#123;        DefaultWebSecurityManager manager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();        manager.setRealm(myRealm());        <span class="hljs-keyword">return</span> manager;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">ShiroFilterFactoryBean <span class="hljs-title">shiroFilterFactoryBean</span><span class="hljs-params">()</span> </span>&#123;        ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();        bean.setSecurityManager(securityManager());        bean.setLoginUrl(<span class="hljs-string">&quot;/login&quot;</span>);        bean.setSuccessUrl(<span class="hljs-string">&quot;/index&quot;</span>);        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;/doLogin&quot;</span>, <span class="hljs-string">&quot;anon&quot;</span>);        map.put(<span class="hljs-string">&quot;/**&quot;</span>, <span class="hljs-string">&quot;authc&quot;</span>);        bean.setFilterChainDefinitionMap(map);        <span class="hljs-keyword">return</span> bean;    &#125;&#125;</code></pre></div><p>在这里进行 Shiro 的配置主要配置 3 个 Bean ：</p><ul><li>首先需要提供一个 Realm 的实例</li><li>需要配置一个 SecurityManager，在 SecurityManager 中配置 Realm</li><li>配置一个 ShiroFilterFactoryBean ，在 ShiroFilterFactoryBean 中指定路径拦截规则等</li><li>配置登录和测试接口</li><li>其中，ShiroFilterFactoryBean 的配置稍微多一些，配置含义如下：<ul><li>setSecurityManager 表示指定 SecurityManager</li><li>setLoginUrl 表示指定登录页面</li><li>setSuccessUrl 表示指定登录成功页面</li><li>接下来的 Map 中配置了路径拦截规则，注意，要有序</li></ul></li></ul><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loging</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;please login&quot;</span>;    &#125;    <span class="hljs-meta">@PostMapping(&quot;/doLogin&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doLogin</span><span class="hljs-params">(String username, String password)</span> </span>&#123;        Subject subject = SecurityUtils.getSubject();        <span class="hljs-keyword">try</span> &#123;            subject.login(<span class="hljs-keyword">new</span> UsernamePasswordToken(username, password));            System.out.println(<span class="hljs-string">&quot;success&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;            e.printStackTrace();            System.out.println(<span class="hljs-string">&quot;fail&gt;&gt;&quot;</span> + e.getMessage());        &#125;    &#125;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello shiro!&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>上面这种配置方式实际上相当于把 SSM 中的 XML 配置拿到 Spring Boot 中用 Java 代码重新写了一遍，除了这种方式之外，我们也可以直接使用 Shiro 官方提供的 Starter </p><p><strong>依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">shiro.sessionManager.sessionIdCookieEnabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">shiro.sessionManager.sessionIdUrlRewritingEnabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">shiro.unauthorizedUrl</span>=<span class="hljs-string">/unauthorizedurl</span><span class="hljs-meta">shiro.web.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">shiro.successUrl</span>=<span class="hljs-string">/success</span><span class="hljs-meta">shiro.loginUrl</span>=<span class="hljs-string">/login</span></code></pre></div><ul><li>第一行表示是否允许将sessionId 放到 cookie 中</li><li>第二行表示是否允许将 sessionId 放到 Url 地址拦中</li><li>第三行表示访问未获授权的页面时，默认的跳转路径 </li><li>第四行表示开启 shiro</li><li>第五行表示登录成功的跳转页面 </li><li>第六行表示登录页面</li></ul><p><strong>配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Realm <span class="hljs-title">realm</span><span class="hljs-params">()</span> </span>&#123;        TextConfigurationRealm realm = <span class="hljs-keyword">new</span> TextConfigurationRealm();        realm.setUserDefinitions(<span class="hljs-string">&quot;javaboy=123,user \n admin=123,admin&quot;</span>);        realm.setRoleDefinitions(<span class="hljs-string">&quot;admin=read,write \n user=read&quot;</span>);        <span class="hljs-keyword">return</span> realm;    &#125;  <span class="hljs-comment">//配置拦截规则</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">ShiroFilterChainDefinition <span class="hljs-title">shiroFilterChainDefinition</span><span class="hljs-params">()</span> </span>&#123;        DefaultShiroFilterChainDefinition definition = <span class="hljs-keyword">new</span> DefaultShiroFilterChainDefinition();        definition.addPathDefinition(<span class="hljs-string">&quot;/doLogin&quot;</span>, <span class="hljs-string">&quot;anon&quot;</span>);        definition.addPathDefinition(<span class="hljs-string">&quot;/**&quot;</span>, <span class="hljs-string">&quot;authc&quot;</span>);        <span class="hljs-keyword">return</span> definition;    &#125;&#125;</code></pre></div><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello shiro!&quot;</span>;    &#125;    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;please login&quot;</span>;    &#125;    <span class="hljs-meta">@PostMapping(&quot;/doLogin&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doLogin</span><span class="hljs-params">(String username, String password)</span> </span>&#123;        Subject subject = SecurityUtils.getSubject();        <span class="hljs-keyword">try</span> &#123;            subject.login(<span class="hljs-keyword">new</span> UsernamePasswordToken(username, password));            System.out.println(<span class="hljs-string">&quot;success&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;            e.printStackTrace();            System.out.println(<span class="hljs-string">&quot;fail&gt;&quot;</span> + e.getMessage());        &#125;    &#125;&#125;</code></pre></div><h2 id="3-OAuth2"><a href="#3-OAuth2" class="headerlink" title="3. OAuth2"></a>3. OAuth2</h2><h3 id="3-1-引入"><a href="#3-1-引入" class="headerlink" title="3.1 引入"></a>3.1 引入</h3><p>住在一个大型的居民小区，小区有门禁系统，进入的时候需要输入密码，我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区，如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限。</p><h4 id="授权机制的设计"><a href="#授权机制的设计" class="headerlink" title="授权机制的设计"></a>授权机制的设计</h4><p>于是，我设计了一套授权机制。</p><p>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。</p><p>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p><p>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</p><p>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</p><p>第四步，快递员向门禁系统输入令牌，进入小区。</p><p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p><h4 id="互联网场景"><a href="#互联网场景" class="headerlink" title="互联网场景"></a>互联网场景</h4><p>我们把上面的例子搬到互联网，就是 OAuth 的设计了。</p><p>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。</p><p>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。</p><p>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</p><p>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p><h4 id="令牌与密码"><a href="#令牌与密码" class="headerlink" title="令牌与密码"></a>令牌与密码</h4><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth2.0 的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。</p><p>OAuth2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。</p><h3 id="3-2-简介"><a href="#3-2-简介" class="headerlink" title="3.2 简介"></a>3.2 简介</h3><p>OAuth 是一个开放标准，该标准允许用户让第三方应用访问该用户在某一网站上存储的私密资源（如头像、照片、视频等），而在这个过程中无需将用户名和密码提供给第三方应用。实现这一功能是通过提供一个令牌（token），而不是用户名和密码来访问他们存放在特定服务提供者的数据。采用令牌（token）的方式可以让用户灵活的对第三方应用授权或者收回权限。</p><p>OAuth2 是 OAuth 协议的下一版本，但不向下兼容 OAuth 1.0。传统的 Web 开发登录认证一般都是基于 session 的，但是在前后端分离的架构中继续使用 session 就会有许多不便，因为移动端（Android、iOS、微信小程序等）要么不支持 cookie（微信小程序），要么使用非常不便，对于这些问题，使用 OAuth2 认证都能解决。</p><p>对于大家而言，我们在互联网应用中最常见的 OAuth2 应该就是各种第三方登录了，例如 QQ 授权登录、微信授权登录、微博授权登录、GitHub 授权登录等等。</p><h3 id="3-3-四种模式"><a href="#3-3-四种模式" class="headerlink" title="3.3 四种模式"></a>3.3 四种模式</h3><p>OAuth2 协议一共支持 4 种不同的授权模式：</p><ol><li>授权码模式：常见的第三方平台登录功能基本都是使用这种模式。</li><li>简化模式：简化模式是不需要客户端服务器参与，直接在浏览器中向授权服务器申请令牌（token），一般如果网站是纯静态页面则可以采用这种方式。</li><li>密码模式：密码模式是用户把用户名密码直接告诉客户端，客户端使用这些信息向授权服务器申请令牌（token）。这需要用户对客户端高度信任，例如客户端应用和服务提供商就是同一家公司，我们自己做前后端分离登录就可以采用这种模式。</li><li>客户端模式：客户端模式是指客户端使用自己的名义而不是用户的名义向服务提供者申请授权，严格来说，客户端模式并不能算作 OAuth 协议要解决的问题的一种解决方案，但是，对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是非常方便的。</li></ol><h4 id="3-2-1-授权码模式"><a href="#3-2-1-授权码模式" class="headerlink" title="3.2.1 授权码模式"></a>3.2.1 授权码模式</h4><p>授权码模式是最安全并且使用最广泛的一种模式。假如我要引入微信登录功能，那么我的流程可能是这样：</p><p><a href="http://img.itboyhub.com/2020/04/oauth-1-7.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/oauth-1-7.png" alt="图片源自网络"></a></p><p>在授权码模式中，我们分授权服务器和资源服务器，授权服务器用来派发 Token，拿着 Token 则可以去资源服务器获取资源，这两个服务器可以分开，也可以合并。</p><p>上面这张流程图的含义，具体是这样：</p><ul><li>首先，在网页上放一个超链接（我的网站相当于是第三方应用），用户 A （服务方的用户，例如微信用户）点击这个超链接就会去请求授权服务器（微信的授权服务器），用户点击的过程其实也就是我跟用户要授权的过程，这就是上图中的 1、2 步。</li><li>接下来的第三步，就是用户点击了超链接之后，像授权服务器发送请求，一般来说，我放在 <a href="http://www.javaboy.org/">www.javaboy.org</a> 网页上的超链接可能有如下参数：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//wx.qq.com/oauth/authorize?response_type=code&amp;client_id=javaboy&amp;redirect_uri=www.javaboy.org&amp;scope=all</span></code></pre></div><ol><li>response_type 表示授权类型，使用授权码模式的时候这里固定为 code，表示要求返回授权码（将来拿着这个授权码去获取 access_token）</li><li>client_id 表示客户端 id，也就是我应用的 id。有的小伙伴对这个不好理解，我说一下，如果我想让我的 <a href="http://www.javaboy.org/">www.javaboy.org</a> 接入微信登录功能，我肯定得去微信开放平台注册，去填入我自己应用的基本信息等等，弄完之后，微信会给我一个 APPID，也就是我这里的 client_id，所以，从这里可以看出，授权服务器在校验的时候，会做两件事：1.校验客户端的身份；2.校验用户身份。</li><li>redirect_uri 表示用户登录在成功/失败后，跳转的地址（成功登录微信后，跳转到 <a href="http://www.javaboy.org/">www.javaboy.org</a> 中的哪个页面），跳转的时候，还会携带上一个授权码参数。</li><li>scope 表示授权范围，即 <a href="http://www.javaboy.org/">www.javaboy.org</a> 这个网站拿着用户的 token 都能干啥（一般来说就是获取用户非敏感的基本信息）</li></ol><ul><li><p>接下来第四步，<a href="http://www.javaboy.org/">www.javaboy.org</a> 这个网站，拿着第三步获取到的 code 以及自己的 client_id 和 client_secret 以及其他一些信息去授权服务器请求令牌，微信的授权服务器在校验过这些数据之后，就会发送一个令牌回来。这个过程一般是在后端完成的，而不是利用 js 去完成。</p></li><li><p>接下来拿着这个 token，我们就可以去请求用户信息了。</p></li></ul><p>一般情况下我们认为授权码模式是四种模式中最安全的一种模式，因为这种模式我们的 access_token 不用经过浏览器或者移动端 App，是直接从我们的后台发送到授权服务器上，这样就很大程度减少了 access_token 泄漏的风险。</p><h4 id="3-3-2-简化模式"><a href="#3-3-2-简化模式" class="headerlink" title="3.3.2 简化模式"></a>3.3.2 简化模式</h4><p>技术栈搭建的博客/电子书都是典型的纯前端应用，就是只有页面，没有后端，对于这种情况，如果我想接入微信登录该怎么办呢？这就用到了我们说的简化模式。</p><p>我们来看下简化模式的流程图：</p><p><a href="http://img.itboyhub.com/2020/04/oauth-1-8.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/oauth-1-8.png" alt="图片源自网络"></a></p><p>这个流程是这样：</p><ol><li>在我 <a href="http://www.javaboy.org/">www.javaboy.org</a> 网站上有一个微信登录的超链接，这个超链接类似下面这样：</li></ol><div class="hljs code-wrapper"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>wx.qq.com<span class="hljs-regexp">/oauth/</span>authorize?response_type=token&amp;client_id=javaboy&amp;redirect_uri=www.javaboy.org&amp;scope=all</code></pre></div><p>这里的参数和前面授权码模式的基本相同，只有 response_type 的值不一样，这里是 token，表示要求授权服务器直接返回 access_token。</p><ol><li>用户点击我这个超链接之后，就会跳转到微信登录页面，然后用户进行登录。</li><li>用户登录成功后，微信会自动重定向到 redirect_uri 参数指定的跳转网址，同时携带上 access_token，这样用户在前端就获取到 access_token 了。</li></ol><p>简化模式的弊端很明显，因为没有后端，所以非常不安全，除非你对安全性要求不高，否则不建议使用。</p><h4 id="3-3-3-密码模式"><a href="#3-3-3-密码模式" class="headerlink" title="3.3.3 密码模式"></a>3.3.3 密码模式</h4><p>密码模式在 Spring Cloud 项目中有着非常广泛的应用</p><p>密码模式有一个前提就是你高度信任第三方应用，举个不恰当的例子：如果我要在 <a href="http://www.javaboy.org/">www.javaboy.org</a> 这个网站上接入微信登录，我使用了密码模式，那你就要在 <a href="http://www.javaboy.org/">www.javaboy.org</a> 这个网站去输入微信的用户名密码，这肯定是不靠谱的，所以密码模式需要你非常信任第三方应用。</p><p>微服务中有一个特殊的场景，就是服务之间的调用，用密码模式做鉴权是非常恰当不过的了。这个以后再细说。</p><p>我们来看下密码模式的流程：</p><p><a href="http://img.itboyhub.com/2020/04/oauth-1-9.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/oauth-1-9.png" alt="img"></a></p><p>密码式的流程比较简单：</p><ul><li>首先 <a href="http://www.javaboy.org/">www.javaboy.org</a> 会发送一个 post 请求，类似下面这样的：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>wx.qq.com<span class="hljs-regexp">/oauth/</span>authorize?response_type=password&amp;client_id=javaboy&amp;username=江南一点雨&amp;password=<span class="hljs-number">123</span></code></pre></div><p>这里的参数和前面授权码模式的略有差异，response_type 的值不一样，这里是 password，表示密码式，另外多了用户名/密码参数，没有重定向的 redirect_uri ，因为这里不需要重定向。</p><ul><li>微信校验过用户名/密码之后，直接在 HTTP 响应中把 access_token 返回给客户端。</li></ul><h4 id="3-3-4-客户端模式"><a href="#3-3-4-客户端模式" class="headerlink" title="3.3.4 客户端模式"></a>3.3.4 客户端模式</h4><p>有的应用可能没有前端页面，就是一个后台，比如</p><ul><li><a href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw">Spring Boot 开发微信公众号后台，看看松哥公众号后台是怎么实现的！</a></li><li><a href="https://mp.weixin.qq.com/s/1jTl9kBeFeibjbe5EbsCzg">Spring Boot 如何给微信公众号返回消息</a></li></ul><p>这种应用开发好了就没有后台。</p><p>我们来看一个客户端模式的流程图：</p><p><a href="http://img.itboyhub.com/2020/04/oauth-1-10.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/oauth-1-10.png" alt="img"></a></p><p>这个步骤也很简单，就两步：</p><ul><li>客户端发送一个请求到授权服务器，请求格式如下：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">GET</span> <span class="hljs-string">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;client_id=APPID&amp;client_secret=APPSECRET</span></code></pre></div><p>这里有三个参数，含义如下：</p><p>grant_type，获取access_token填写client_credential</p><p>client_id 和 client_secret 用来确认客户端的身份</p><ul><li>授权服务器通过验证后，会直接返回 access_token 给客户端。</li></ul><p>大家发现，在这个过程中好像没有用户什么事了！是的，客户端模式给出的令牌，就是针对第三方应用的，而不是针对用户的。</p><p>在接入微信公众号后台的时候，有一个获取 Access_token 的步骤，其实就是这种模式，我截了一张微信开发平台文档的图，大家看下：</p><p><a href="http://img.itboyhub.com/2020/04/oauth-1-11.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/oauth-1-11.png" alt="img"></a></p><h3 id="3-4-整合到SpringBoot"><a href="#3-4-整合到SpringBoot" class="headerlink" title="3.4 整合到SpringBoot"></a>3.4 整合到SpringBoot</h3><p><strong>引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security.oauth<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>配置文件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.66.128</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string">123</span><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span></code></pre></div><p><strong>授权服务器配置（密码模式）</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAuthorizationServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    AuthenticationManager authenticationManager;    <span class="hljs-meta">@Autowired</span>    RedisConnectionFactory redisConnectionFactory;    <span class="hljs-meta">@Autowired</span>    UserDetailsService userDetailsService;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-comment">//token的配置</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        clients.inMemory()                .withClient(<span class="hljs-string">&quot;password&quot;</span>)                .authorizedGrantTypes(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;refresh_token&quot;</span>)                .accessTokenValiditySeconds(<span class="hljs-number">1800</span>)                .resourceIds(<span class="hljs-string">&quot;rid&quot;</span>)                .scopes(<span class="hljs-string">&quot;all&quot;</span>)                .secret(<span class="hljs-string">&quot;$2a$10$kwLIAqAupvY87OM.O25.Yu1QKEXV1imAv7jWbDaQRFUFWSnSiDEwG&quot;</span>);    &#125;    <span class="hljs-comment">//token的存储</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        endpoints.tokenStore(<span class="hljs-keyword">new</span> RedisTokenStore(redisConnectionFactory))                .authenticationManager(authenticationManager)                .userDetailsService(userDetailsService);    &#125;    <span class="hljs-comment">//登录认证</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        security.allowFormAuthenticationForClients();    &#125;&#125;</code></pre></div><p><strong>配置资源服务器</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableResourceServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        resources.resourceId(<span class="hljs-string">&quot;rid&quot;</span>).stateless(<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests().antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)                .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasRole(<span class="hljs-string">&quot;user&quot;</span>)                .anyRequest().authenticated();    &#125;&#125;</code></pre></div><p><strong>Security配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationManager();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.userDetailsService();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.inMemoryAuthentication()                .withUser(<span class="hljs-string">&quot;javaboy&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$kwLIAqAupvY87OM.O25.Yu1QKEXV1imAv7jWbDaQRFUFWSnSiDEwG&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>)                .and()                .withUser(<span class="hljs-string">&quot;江南一点雨&quot;</span>)                .password(<span class="hljs-string">&quot;$2a$10$kwLIAqAupvY87OM.O25.Yu1QKEXV1imAv7jWbDaQRFUFWSnSiDEwG&quot;</span>)                .roles(<span class="hljs-string">&quot;user&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.antMatcher(<span class="hljs-string">&quot;/oauth/**&quot;</span>)                .authorizeRequests()                .antMatchers(<span class="hljs-string">&quot;/oauth/**&quot;</span>).permitAll()                .and().csrf().disable();    &#125;&#125;</code></pre></div><h2 id="4-JWT"><a href="#4-JWT" class="headerlink" title="4. JWT"></a>4. JWT</h2><p>在前后端分离的项目中，上面介绍了Oauth2的方式，不过 JWT 算是目前比较流行的一种解决方案了，本文就和大家来分享一下如何将 Spring Security 和 JWT 结合在一起使用，进而实现前后端分离时的登录解决方案。</p><h3 id="1-无状态登录"><a href="#1-无状态登录" class="headerlink" title="1 无状态登录"></a>1 无状态登录</h3><h4 id="1-1-什么是有状态？"><a href="#1-1-什么是有状态？" class="headerlink" title="1.1 什么是有状态？"></a>1.1 什么是有状态？</h4><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如Tomcat中的Session。例如登录：用户登录后，我们把用户的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session，然后下次请求，用户携带cookie值来（这一步有浏览器自动完成），我们就能识别到对应session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h4 id="1-2-什么是无状态"><a href="#1-2-什么是无状态" class="headerlink" title="1.2 什么是无状态"></a>1.2 什么是无状态</h4><p>微服务集群中的每个服务，对外提供的都使用RESTful风格的接口。而RESTful风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p><strong>那么这种无状态性有哪些好处呢？</strong></p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h4 id="1-3-如何实现无状态"><a href="#1-3-如何实现无状态" class="headerlink" title="1.3.如何实现无状态"></a>1.3.如何实现无状态</h4><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的token</li><li>服务端对客户端发送来的token进行解密，判断是否有效，并且获取用户登录信息</li></ul><h4 id="1-4-JWT"><a href="#1-4-JWT" class="headerlink" title="1.4 JWT"></a>1.4 JWT</h4><h5 id="1-4-1-简介"><a href="#1-4-1-简介" class="headerlink" title="1.4.1 简介"></a>1.4.1 简介</h5><p>JWT，全称是Json Web Token， 是一种JSON风格的轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权，JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的Java 实现是GitHub 上的开源项目 jjwt，地址如下：<code>https://github.com/jwtk/jjwt</code></p><h5 id="1-4-2-JWT数据格式"><a href="#1-4-2-JWT数据格式" class="headerlink" title="1.4.2 JWT数据格式"></a>1.4.2 JWT数据格式</h5><p>JWT包含三部分数据：</p><ul><li><p>Header：头部，通常头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>加密算法，自定义</li></ul><p>我们会对头部进行Base64Url编码（可解码），得到第一部分数据。</p></li><li><p>Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息：</p><ul><li>iss (issuer)：表示签发人</li><li>exp (expiration time)：表示token过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>这部分也会采用Base64Url编码，得到第二部分数据。</p></li><li><p>Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过Header中配置的加密算法生成。用于验证整个数据完整和可靠性。</p></li></ul><p>生成的数据格式如下图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-2.png" alt="img"></p><p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p><h5 id="1-4-3-JWT交互流程"><a href="#1-4-3-JWT交互流程" class="headerlink" title="1.4.3 JWT交互流程"></a>1.4.3 JWT交互流程</h5><p>流程图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-3.png" alt="img"></p><p>步骤翻译：</p><ol><li>应用程序或客户端向授权服务器请求授权</li><li>获取到授权后，授权服务器会向应用程序返回访问令牌</li><li>应用程序使用访问令牌来访问受保护资源（如API）</li></ol><p>因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了RESTful的无状态规范。</p><h4 id="1-5-JWT-存在的问题"><a href="#1-5-JWT-存在的问题" class="headerlink" title="1.5 JWT 存在的问题"></a>1.5 JWT 存在的问题</h4><p>说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：</p><ol><li>续签问题，这是被很多人诟病的问题之一，传统的cookie+session的方案天然的支持续签，但是jwt由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入redis，虽然可以解决问题，但是jwt也变得不伦不类了。</li><li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改secret来实现注销，服务端secret修改后，已经颁发的未过期的token就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li><li>密码重置，密码重置后，原本的token依然可以访问系统，这时候也需要强制修改secret。</li><li>基于第2点和第3点，一般建议不同用户取不同secret。</li></ol><h3 id="2-整合到SpringBoot"><a href="#2-整合到SpringBoot" class="headerlink" title="2 整合到SpringBoot"></a>2 整合到SpringBoot</h3><h4 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h4><p>首先我们来创建一个Spring Boot项目，创建时需要添加Spring Security依赖，创建完成后，添加 <code>jjwt</code> 依赖，完整的pom.xml文件如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>然后在项目中创建一个简单的 User 对象实现 UserDetails 接口，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> List&lt;GrantedAuthority&gt; authorities;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//省略getter/setter</span>&#125;</code></pre></div><p>这个就是我们的用户对象，先放着备用，再创建一个HelloController，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello jwt !&quot;</span>;    &#125;    <span class="hljs-meta">@GetMapping(&quot;/admin&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello admin !&quot;</span>;    &#125;&#125;</code></pre></div><p>HelloController 很简单，这里有两个接口，设计是 <code>/hello</code> 接口可以被具有 user 角色的用户访问，而 <code>/admin</code> 接口则可以被具有 admin 角色的用户访问。</p><h4 id="2-2-JWT-过滤器配置"><a href="#2-2-JWT-过滤器配置" class="headerlink" title="2.2 JWT 过滤器配置"></a>2.2 JWT 过滤器配置</h4><p>接下来提供两个和 JWT 相关的过滤器配置：</p><ol><li>一个是用户登录的过滤器，在用户的登录的过滤器中校验用户是否登录成功，如果登录成功，则生成一个token返回给客户端，登录失败则给前端一个登录失败的提示。</li><li>第二个过滤器则是当其他请求发送来，校验token的过滤器，如果校验成功，就让请求继续执行。</li></ol><p>这两个过滤器，我们分别来看，先看第一个：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtLoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">JwtLoginFilter</span><span class="hljs-params">(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager)</span> </span>&#123;            <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(defaultFilterProcessesUrl));        setAuthenticationManager(authenticationManager);    &#125;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;        User user = <span class="hljs-keyword">new</span> ObjectMapper().readValue(req.getInputStream(), User.class);        <span class="hljs-keyword">return</span> getAuthenticationManager().authenticate(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword()));    &#125;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, FilterChain chain, Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        Collection&lt;? extends GrantedAuthority&gt; authorities = authResult.getAuthorities();        StringBuffer as = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;            as.append(authority.getAuthority())                    .append(<span class="hljs-string">&quot;,&quot;</span>);        &#125;        String jwt = Jwts.builder()                .claim(<span class="hljs-string">&quot;authorities&quot;</span>, as)<span class="hljs-comment">//配置用户角色</span>                .setSubject(authResult.getName())                .setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">10</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>))                .signWith(SignatureAlgorithm.HS512,<span class="hljs-string">&quot;sang@123&quot;</span>)                .compact();        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);        PrintWriter out = resp.getWriter();        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(jwt));        out.flush();        out.close();    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException failed)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);        PrintWriter out = resp.getWriter();        out.write(<span class="hljs-string">&quot;登录失败!&quot;</span>);        out.flush();        out.close();    &#125;&#125;</code></pre></div><p>关于这个类，我说如下几点：</p><ol><li>自定义 JwtLoginFilter 继承自 AbstractAuthenticationProcessingFilter，并实现其中的三个默认方法。</li><li>attemptAuthentication方法中，我们从登录参数中提取出用户名密码，然后调用AuthenticationManager.authenticate()方法去进行自动校验。</li><li>第二步如果校验成功，就会来到successfulAuthentication回调中，在successfulAuthentication方法中，将用户角色遍历然后用一个 <code>,</code> 连接起来，然后再利用Jwts去生成token，按照代码的顺序，生成过程一共配置了四个参数，分别是用户角色、主题、过期时间以及加密算法和密钥，然后将生成的token写出到客户端。</li><li>第二步如果校验失败就会来到unsuccessfulAuthentication方法中，在这个方法中返回一个错误提示给客户端即可。</li></ol><p>再来看第二个token校验的过滤器：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        HttpServletRequest req = (HttpServletRequest) servletRequest;        String jwtToken = req.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);        System.out.println(jwtToken);        Claims claims = Jwts.parser().setSigningKey(<span class="hljs-string">&quot;sang@123&quot;</span>).parseClaimsJws(jwtToken.replace(<span class="hljs-string">&quot;Bearer&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))                .getBody();        String username = claims.getSubject();<span class="hljs-comment">//获取当前登录用户名</span>        List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(<span class="hljs-string">&quot;authorities&quot;</span>));        UsernamePasswordAuthenticationToken token = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, <span class="hljs-keyword">null</span>, authorities);        SecurityContextHolder.getContext().setAuthentication(token);        filterChain.doFilter(req,servletResponse);    &#125;&#125;</code></pre></div><p>关于这个过滤器，我说如下几点：</p><ol><li>首先从请求头中提取出 authorization 字段，这个字段对应的value就是用户的token。</li><li>将提取出来的token字符串转换为一个Claims对象，再从Claims对象中提取出当前用户名和用户角色，创建一个UsernamePasswordAuthenticationToken放到当前的Context中，然后执行过滤链使请求继续执行下去。</li></ol><p>如此之后，两个和JWT相关的过滤器就算配置好了。</p><h4 id="2-3-Spring-Security-配置"><a href="#2-3-Spring-Security-配置" class="headerlink" title="2.3 Spring Security 配置"></a>2.3 Spring Security 配置</h4><p>接下来我们来配置 Spring Security,如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.inMemoryAuthentication().withUser(<span class="hljs-string">&quot;admin&quot;</span>)                .password(<span class="hljs-string">&quot;123&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>)                .and()                .withUser(<span class="hljs-string">&quot;sang&quot;</span>)                .password(<span class="hljs-string">&quot;456&quot;</span>)                .roles(<span class="hljs-string">&quot;user&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .antMatchers(<span class="hljs-string">&quot;/hello&quot;</span>).hasRole(<span class="hljs-string">&quot;user&quot;</span>)                .antMatchers(<span class="hljs-string">&quot;/admin&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)                .antMatchers(HttpMethod.POST, <span class="hljs-string">&quot;/login&quot;</span>).permitAll()                .anyRequest().authenticated()                .and()                .addFilterBefore(<span class="hljs-keyword">new</span> JwtLoginFilter(<span class="hljs-string">&quot;/login&quot;</span>,authenticationManager()),UsernamePasswordAuthenticationFilter.class)                .addFilterBefore(<span class="hljs-keyword">new</span> JwtFilter(),UsernamePasswordAuthenticationFilter.class)                .csrf().disable();    &#125;&#125;</code></pre></div><ol><li>简单起见，这里我并未对密码进行加密，因此配置了NoOpPasswordEncoder的实例。</li><li>简单起见，这里并未连接数据库，我直接在内存中配置了两个用户，两个用户具备不同的角色。</li><li>配置路径规则时， <code>/hello</code> 接口必须要具备 user 角色才能访问， <code>/admin</code> 接口必须要具备 admin 角色才能访问，POST 请求并且是 <code>/login</code> 接口则可以直接通过，其他接口必须认证后才能访问。</li><li>最后配置上两个自定义的过滤器并且关闭掉csrf保护。</li></ol><h4 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h4><p>做完这些之后，我们的环境就算完全搭建起来了，接下来启动项目然后在 POSTMAN 中进行测试，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-4.png" alt="img"></p><p>登录成功后返回的字符串就是经过 base64url 转码的token，一共有三部分，通过一个 <code>.</code> 隔开，我们可以对第一个 <code>.</code> 之前的字符串进行解码，即Header，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-5.png" alt="img"></p><p>再对两个 <code>.</code> 之间的字符解码，即 payload：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-6.png" alt="img"></p><p>可以看到，我们设置信息，由于base64并不是加密方案，只是一种编码方案，因此，不建议将敏感的用户信息放到token中。</p><p>接下来再去访问 <code>/hello</code> 接口，注意认证方式选择 Bearer Token，Token值为刚刚获取到的值，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-7.png" alt="img"></p><h2 id="5-区别"><a href="#5-区别" class="headerlink" title="5. 区别"></a>5. 区别</h2><h3 id="JWT和OAuth2"><a href="#JWT和OAuth2" class="headerlink" title="JWT和OAuth2"></a>JWT和OAuth2</h3><ul><li> oauth2有client和scope的概念，jwt没有。如果只是拿来用于颁布token的话，二者没区别。常用的bearer算法oauth、jwt都可以用。应用场景不同而已  </li><li>Spring Cloud 的权限框架就是用的jwt实现的oauth2 。二者没有必然联系  </li><li>Token功能不一样，JWT的token是包含用户基本信息的，然后通过加密的方式生成的字符串，服务器端拿到这个token之后不需要再去查询用户基本信息，解析完token之后就能拿到。想想在微服务架构下，用户服务是一个单独的服务，但是其他服务大部分情况下也会需要用户信息，难道要每次用到都去取一次吗？ JWT非常适合微服务。  </li><li>OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)。OAuth2是一个相对复杂的协议, 有4种授权模式, 其中的access code模式在实现时可以使用jwt才生成code, 也可以不用. 它们之间没有必然的联系. </li><li>JWT是用在前后端分离, 需要简单的对后台API进行保护时使用.(前后端分离无session, 频繁传用户密码不安全)  </li><li>JWT是一种认证协议 。JWT提供了一种用于**发布接入令牌（Access Token),**并对发布的签名接入令牌进行验证的方法。 令牌（Token）本身包含了一系列声明，应用程序可以根据这些声明限制用户对资源的访问。  </li><li>OAuth2是一种授权框架。提供了一套详细的授权机制（指导）。用户或应用可以通过公开的或私有的设置，授权第三方应用访问特定资源。</li></ul><p>总而言之，Oauth2和jwt是完全不同的两种东西，一个是授权认证的框架，另一种则是认证验证的方式方法（轻量级概念）。OAuth2不像JWT一样是一个严格的标准协议，因此在实施过程中更容易出错。尽管有很多现有的库，但是每个库的成熟度也不尽相同，同样很容易引入各种错误。在常用的库中也很容易发现一些安全漏洞。</p><h3 id="OAuth2和Shiro"><a href="#OAuth2和Shiro" class="headerlink" title="OAuth2和Shiro"></a>OAuth2和Shiro</h3><p>一、性质不同</p><p>1、oauth2 ：是OAuth协议的延续版本，但不向前兼容OAuth 2.0(即完全废止了OAuth1.0)。</p><p>2、shiro：是一个强大且易用的Java安全框架。</p><p>二、语言不同</p><p>1、oauth2 ：PHP、JavaScript，Java</p><p>2、shiro：Java</p><p>三、用途不同</p><p>1、oauth2 ：允许第三方应用代表用户获得访问的权限。</p><p>2、shiro：执行身份验证、授权、密码和会话管理。</p><h1 id="SpringBoot与中间件"><a href="#SpringBoot与中间件" class="headerlink" title="SpringBoot与中间件"></a>SpringBoot与中间件</h1><h2 id="1-WebSocket"><a href="#1-WebSocket" class="headerlink" title="1. WebSocket"></a>1. WebSocket</h2><h3 id="1-1-引入"><a href="#1-1-引入" class="headerlink" title="1.1 引入"></a>1.1 引入</h3><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/bg2017051507.jpg" alt="img"></p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<a href="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">“轮询”</a>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/bg2017051502.png" alt="img"></p><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">ws</span>:<span class="hljs-string">//example.com:80/some/path</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/bg2017051503.jpg" alt="img"></p><h3 id="1-2-整合SpringBoot"><a href="#1-2-整合SpringBoot" class="headerlink" title="1.2 整合SpringBoot"></a>1.2 整合SpringBoot</h3><h4 id="实现群聊"><a href="#实现群聊" class="headerlink" title="实现群聊"></a>实现群聊</h4><p><strong>引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--前端库集成--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sockjs-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--兼容浏览器协议--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>stomp-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--js文件的定位器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>webjars-locator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>实体类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String content;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> content;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;        <span class="hljs-keyword">this</span>.content = content;    &#125;&#125;</code></pre></div><p><strong>配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSocketMessageBroker</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebSocketMessageBrokerConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageBroker</span><span class="hljs-params">(MessageBrokerRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//广播前缀</span>        registry.enableSimpleBroker(<span class="hljs-string">&quot;/topic&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerStompEndpoints</span><span class="hljs-params">(StompEndpointRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//注册端点，定义前缀为chat的endpoint并开启sockjs的支持</span>        registry.addEndpoint(<span class="hljs-string">&quot;/chat&quot;</span>).withSockJS();    &#125;&#125;</code></pre></div><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingController</span> </span>&#123;    <span class="hljs-meta">@MessageMapping(&quot;/hello&quot;)</span>    <span class="hljs-meta">@SendTo(&quot;/topic/greetings&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">greeting1</span><span class="hljs-params">(Message message)</span> </span>&#123;        <span class="hljs-keyword">return</span> message;    &#125;&#125;</code></pre></div><p><strong>前端页面</strong></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>群聊<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/jquery/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/sockjs-client/sockjs.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/stomp-websocket/stomp.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>请输入用户名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;connect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;连接&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;disconnect&quot;</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&quot;disabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;断开连接&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chat&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>请输入聊天内容<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;send&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;发送&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversation&quot;</span>&gt;</span>群聊进行中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        $(<span class="hljs-string">&quot;#connect&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>            connect();        &#125;)<span class="javascript">        $(<span class="hljs-string">&quot;#disconnect&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">if</span> (stompClient != <span class="hljs-literal">null</span>) &#123;</span>                stompClient.disconnect();            &#125;<span class="javascript">            setConnected(<span class="hljs-literal">false</span>);</span>        &#125;)<span class="javascript">        $(<span class="hljs-string">&quot;#send&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            stompClient.send(<span class="hljs-string">&#x27;/app/hello&#x27;</span>,&#123;&#125;,<span class="hljs-built_in">JSON</span>.stringify(&#123;<span class="hljs-string">&#x27;name&#x27;</span>:$(<span class="hljs-string">&quot;#name&quot;</span>).val(),<span class="hljs-string">&#x27;content&#x27;</span>:$(<span class="hljs-string">&quot;#content&quot;</span>).val()&#125;))</span>        &#125;)    &#125;)<span class="javascript">    <span class="hljs-keyword">var</span> stompClient = <span class="hljs-literal">null</span>;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">if</span> (!$(<span class="hljs-string">&quot;#name&quot;</span>).val()) &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span>;</span>        &#125;<span class="javascript">        <span class="hljs-keyword">var</span> socket = <span class="hljs-keyword">new</span> SockJS(<span class="hljs-string">&#x27;/chat&#x27;</span>);</span>        stompClient = Stomp.over(socket);<span class="javascript">        stompClient.connect(&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">success</span>) </span>&#123;</span><span class="javascript">            setConnected(<span class="hljs-literal">true</span>);</span><span class="javascript">            stompClient.subscribe(<span class="hljs-string">&#x27;/topic/greetings&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span><span class="javascript">                showGreeting(<span class="hljs-built_in">JSON</span>.parse(msg.body));</span>            &#125;);        &#125;)    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showGreeting</span>(<span class="hljs-params">msg</span>) </span>&#123;</span><span class="javascript">        $(<span class="hljs-string">&quot;#conversation&quot;</span>).append(<span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span> + msg.name + <span class="hljs-string">&#x27;:&#x27;</span> + msg.content + <span class="hljs-string">&#x27;&lt;/div&gt;&#x27;</span>);</span>    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setConnected</span>(<span class="hljs-params">flag</span>) </span>&#123;</span><span class="javascript">        $(<span class="hljs-string">&quot;#connect&quot;</span>).prop(<span class="hljs-string">&quot;disabled&quot;</span>, flag);</span><span class="javascript">        $(<span class="hljs-string">&quot;#disconnect&quot;</span>).prop(<span class="hljs-string">&quot;disabled&quot;</span>, !flag);</span>        if (flag) &#123;<span class="javascript">            $(<span class="hljs-string">&quot;#chat&quot;</span>).show();</span><span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="javascript">            $(<span class="hljs-string">&quot;#chat&quot;</span>).hide();</span>        &#125;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="实现单聊"><a href="#实现单聊" class="headerlink" title="实现单聊"></a>实现单聊</h4><p><strong>引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--前端库集成--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sockjs-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--兼容浏览器协议--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>stomp-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--js文件的定位器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>webjars-locator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>实体类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String content;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> content;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;        <span class="hljs-keyword">this</span>.content = content;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chat</span> </span>&#123;    <span class="hljs-keyword">private</span> String from;    <span class="hljs-keyword">private</span> String content;    <span class="hljs-keyword">private</span> String to;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFrom</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> from;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFrom</span><span class="hljs-params">(String from)</span> </span>&#123;        <span class="hljs-keyword">this</span>.from = from;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> content;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;        <span class="hljs-keyword">this</span>.content = content;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> to;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTo</span><span class="hljs-params">(String to)</span> </span>&#123;        <span class="hljs-keyword">this</span>.to = to;    &#125;&#125;</code></pre></div><p><strong>Security配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.inMemoryAuthentication()                .withUser(<span class="hljs-string">&quot;javaboy&quot;</span>)                .password(<span class="hljs-string">&quot;123&quot;</span>)                .roles(<span class="hljs-string">&quot;admin&quot;</span>)                .and()                .withUser(<span class="hljs-string">&quot;sang&quot;</span>)                .password(<span class="hljs-string">&quot;123&quot;</span>)                .roles(<span class="hljs-string">&quot;user&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .anyRequest().authenticated()                .and()                .formLogin().permitAll();    &#125;&#125;</code></pre></div><p><strong>socket配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSocketMessageBroker</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebSocketMessageBrokerConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageBroker</span><span class="hljs-params">(MessageBrokerRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//广播前缀</span>        registry.enableSimpleBroker(<span class="hljs-string">&quot;/topic&quot;</span>,<span class="hljs-string">&quot;/queue&quot;</span>);        registry.setApplicationDestinationPrefixes(<span class="hljs-string">&quot;/app&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerStompEndpoints</span><span class="hljs-params">(StompEndpointRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//新版SpringBoot要开启连接域</span>        registry.addEndpoint(<span class="hljs-string">&quot;/chat&quot;</span>).setAllowedOrigins(<span class="hljs-string">&quot;http://localhost:8080&quot;</span>).withSockJS();    &#125;&#125;</code></pre></div><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SimpMessagingTemplate simpMessagingTemplate;    <span class="hljs-meta">@MessageMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">greeting</span><span class="hljs-params">(Message message)</span> </span>&#123;        simpMessagingTemplate.convertAndSend(<span class="hljs-string">&quot;/topic/greetings&quot;</span>, message);    &#125;    <span class="hljs-meta">@MessageMapping(&quot;/chat&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">chat</span><span class="hljs-params">(Principal principal, Chat chat)</span> </span>&#123;        chat.setFrom(principal.getName());        simpMessagingTemplate.convertAndSendToUser(chat.getTo(), <span class="hljs-string">&quot;/queue/chat&quot;</span>, chat);    &#125;&#125;</code></pre></div><p><strong>前端页面</strong></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>群聊<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/jquery/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/sockjs-client/sockjs.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/stomp-websocket/stomp.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;connect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;连接&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;disconnect&quot;</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&quot;disabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;断开连接&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>消息内容：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>目标用户：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;to&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;发送&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;send&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversation&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        $(<span class="hljs-string">&quot;#connect&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>            connect();        &#125;)<span class="javascript">        $(<span class="hljs-string">&quot;#disconnect&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">if</span> (stompClient != <span class="hljs-literal">null</span>) &#123;</span>                stompClient.disconnect();            &#125;<span class="javascript">            setConnected(<span class="hljs-literal">false</span>);</span>        &#125;)<span class="javascript">        $(<span class="hljs-string">&quot;#send&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            stompClient.send(<span class="hljs-string">&#x27;/app/chat&#x27;</span>, &#123;&#125;, <span class="hljs-built_in">JSON</span>.stringify(&#123;</span><span class="javascript">                <span class="hljs-string">&#x27;to&#x27;</span>: $(<span class="hljs-string">&quot;#to&quot;</span>).val(),</span><span class="javascript">                <span class="hljs-string">&#x27;content&#x27;</span>: $(<span class="hljs-string">&quot;#content&quot;</span>).val()</span>            &#125;))        &#125;)    &#125;)<span class="javascript">    <span class="hljs-keyword">var</span> stompClient = <span class="hljs-literal">null</span>;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">var</span> socket = <span class="hljs-keyword">new</span> SockJS(<span class="hljs-string">&#x27;/chat&#x27;</span>);</span>        stompClient = Stomp.over(socket);<span class="javascript">        stompClient.connect(&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">success</span>) </span>&#123;</span><span class="javascript">            setConnected(<span class="hljs-literal">true</span>);</span><span class="javascript">            stompClient.subscribe(<span class="hljs-string">&#x27;/user/queue/chat&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span><span class="javascript">                showGreeting(<span class="hljs-built_in">JSON</span>.parse(msg.body));</span>            &#125;);        &#125;)    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showGreeting</span>(<span class="hljs-params">msg</span>) </span>&#123;</span><span class="javascript">        $(<span class="hljs-string">&quot;#conversation&quot;</span>).append(<span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span> + msg.from + <span class="hljs-string">&#x27;:&#x27;</span> + msg.content + <span class="hljs-string">&#x27;&lt;/div&gt;&#x27;</span>);</span>    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setConnected</span>(<span class="hljs-params">flag</span>) </span>&#123;</span><span class="javascript">        $(<span class="hljs-string">&quot;#connect&quot;</span>).prop(<span class="hljs-string">&quot;disabled&quot;</span>, flag);</span><span class="javascript">        $(<span class="hljs-string">&quot;#disconnect&quot;</span>).prop(<span class="hljs-string">&quot;disabled&quot;</span>, !flag);</span>        if (flag) &#123;<span class="javascript">            $(<span class="hljs-string">&quot;#chat&quot;</span>).show();</span><span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="javascript">            $(<span class="hljs-string">&quot;#chat&quot;</span>).hide();</span>        &#125;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h2><h3 id="2-1-为什么要用消息队列"><a href="#2-1-为什么要用消息队列" class="headerlink" title="2.1 为什么要用消息队列"></a>2.1 为什么要用消息队列</h3><p><strong>解耦、异步、削峰</strong></p><p>(1)解耦</p><p>传统模式:</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3436b97edc32fbfdecda61aa1543e4c11603446712357.jpeg" alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别1"></p><p>传统模式的缺点：</p><ul><li>系统间耦合性太强，如上图所示，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！</li></ul><p>中间件模式:</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/2c64f4b92100a42ad84a11bd5defbeb31603446712358.jpeg" alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别2"></p><p>中间件模式的的优点：</p><ul><li>将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改。</li></ul><p>(2)异步</p><p>传统模式:</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/8c151f9dbfdf279ae55f37c683bc52b31603446712358.jpeg" alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别3"></p><p>传统模式的缺点：</p><ul><li>一些非必要的业务逻辑以同步的方式运行，太耗费时间。</li></ul><p>中间件模式:</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/e13290419111dcb5c234f01693a376b81603446712358.jpeg" alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别4"></p><p>中间件模式的的优点：</p><ul><li>将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</li></ul><p>(3)削峰</p><p>传统模式</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/ace4c2a7886db87fd0ae0e6ed11a99511603446712360.jpeg" alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别5"></p><p>传统模式的缺点：</p><ul><li>并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</li></ul><p>中间件模式:</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/582691ee877b26dec97b30a3bf23ddf71603446712360.jpeg" alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别6"></p><p>中间件模式的的优点：</p><ul><li>系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。</li></ul><h3 id="2-2-消息队列的弊端"><a href="#2-2-消息队列的弊端" class="headerlink" title="2.2 消息队列的弊端"></a>2.2 消息队列的弊端</h3><ul><li>系统可用性降低:本来其他系统只要运行好好的，那系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统也会挂。因此，系统可用性降低</li><li>系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大</li></ul><h3 id="2-3-如何选用"><a href="#2-3-如何选用" class="headerlink" title="2.3 如何选用"></a>2.3 如何选用</h3><table><thead><tr><th align="center">特性</th><th align="center">ActiveMQ</th><th align="center">RabbitMQ</th><th align="center">RocketMQ</th><th align="center">kafka</th></tr></thead><tbody><tr><td align="center">开发语言</td><td align="center">java</td><td align="center">erlang</td><td align="center">java</td><td align="center">scala</td></tr><tr><td align="center">单机吞吐量</td><td align="center">万级</td><td align="center">万级</td><td align="center">10万级</td><td align="center">10万级</td></tr><tr><td align="center">时效性</td><td align="center">ms级</td><td align="center">us级</td><td align="center">ms级</td><td align="center">ms级以内</td></tr><tr><td align="center">可用性</td><td align="center">高(主从架构)</td><td align="center">高(主从架构)</td><td align="center">非常高(分布式架构)</td><td align="center">非常高(分布式架构)</td></tr><tr><td align="center">功能特性</td><td align="center">成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好</td><td align="center">基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富</td><td align="center">MQ功能比较完备，扩展性佳</td><td align="center">只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。</td></tr></tbody></table><p>(1)中小型软件公司，建议选RabbitMQ.一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。正所谓，成也萧何，败也萧何！他的弊端也在这里，虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢？所幸，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。</p><p>(2)大型软件公司，根据具体使用在rocketMq和kafka之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针对rocketMQ,大型软件公司也可以抽出人手对rocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。至于kafka，根据业务场景选择，如果有日志采集功能，肯定是首选kafka了。具体该选哪个，看使用场景。</p><h3 id="2-4-保证是高可用"><a href="#2-4-保证是高可用" class="headerlink" title="2.4 保证是高可用"></a>2.4 保证是高可用</h3><p>以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。多master多slave模式部署架构图<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/o_rocketcluster.png" alt="image"><br>类似于kafka，只是NameServer集群，在kafka中是用zookeeper代替，都是用来保存和发现master和slave用的。通信过程如下:<br>Producer 与 NameServer集群中的其中一个节点（随机选择)建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker 发送心跳。Producer 只能将消息发送到 Broker master，但是 Consumer 则不一样，它同时和提供 Topic 服务的 Master 和 Slave建立长连接，既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息。</p><h3 id="2-5-保证消息不被重复消费"><a href="#2-5-保证消息不被重复消费" class="headerlink" title="2.5 保证消息不被重复消费"></a>2.5 保证消息不被重复消费</h3><p>分析:这个问题其实换一种问法就是，如何保证消息队列的幂等性?这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。<br><strong>回答:先来说一下为什么会造成重复消费?</strong><br>其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下(如果还不懂，出门找一个kafka入门到精通教程),就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因?，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。<br> <strong>如何解决?这个问题针对业务场景来答分以下几点</strong><br>  (1)比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。<br>  (2)再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。<br>  (3)如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</p><h3 id="2-6-消费的可靠性传输"><a href="#2-6-消费的可靠性传输" class="headerlink" title="2.6 消费的可靠性传输"></a>2.6 消费的可靠性传输</h3><p>分析:我们在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。如果无法做到可靠性传输，可能给公司带来千万级别的财产损失。</p><p>回答:其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据</p><p><strong>以RabbitMQ为例</strong></p><p>(1)生产者丢数据<br>从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p><p>transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p><p>然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作</p><p>(2)消息队列丢数据</p><p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。<br>那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步</p><ul><li><p>将queue的持久化标识durable设置为true,则代表是一个持久的队列</p></li><li><p>发送消息的时候将deliveryMode=2</p><p>这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据</p></li></ul><p>(3)消费者丢数据</p><p>消费者丢数据一般是因为采用了自动确认消息模式。这种模式下，消费者会自动确认收到信息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。<br>至于解决方案，采用手动确认消息即可。</p><h3 id="2-7-保证消息顺序性"><a href="#2-7-保证消息顺序性" class="headerlink" title="2.7 保证消息顺序性"></a>2.7 保证消息顺序性</h3><p>回答:针对这个问题，通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。</p><p>有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？<br>这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。</p><p>总之，针对这个问题，我的观点是保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路。</p><h2 id="3-ActiveMQ"><a href="#3-ActiveMQ" class="headerlink" title="3. ActiveMQ"></a>3. ActiveMQ</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p>下载最新的压缩包</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210526113352279.png" alt="image-20210526113352279"></p><p>下载完成后在bin目录下执行<code>./activemq start</code>即可</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210526113812627.png" alt="image-20210526113812627"></p><p>账号密码都是admin</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210526113848366.png" alt="image-20210526113848366"></p><h3 id="3-2-整合到SpringBoot"><a href="#3-2-整合到SpringBoot" class="headerlink" title="3.2 整合到SpringBoot"></a>3.2 整合到SpringBoot</h3><p><strong>引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>配置文件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.activemq.broker-url</span>=<span class="hljs-string">tcp://127.0.0.1:61616</span><span class="hljs-meta">spring.activemq.packages.trust-all</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.activemq.user</span>=<span class="hljs-string">adminx</span><span class="hljs-meta">spring.activemq.password</span>=<span class="hljs-string">admin</span></code></pre></div><p><strong>启动类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivemqApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ActivemqApplication.class, args);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveMQQueue(<span class="hljs-string">&quot;hello.javaboy&quot;</span>);    &#125;&#125;</code></pre></div><p><strong>实体类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String content;    <span class="hljs-keyword">private</span> Date sendDate;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> content;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +                <span class="hljs-string">&quot;content=&#x27;&quot;</span> + content + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, sendDate=&quot;</span> + sendDate +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;        <span class="hljs-keyword">this</span>.content = content;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getSendDate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sendDate;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSendDate</span><span class="hljs-params">(Date sendDate)</span> </span>&#123;        <span class="hljs-keyword">this</span>.sendDate = sendDate;    &#125;&#125;</code></pre></div><p><strong>配置组件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JmsComponent</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    JmsMessagingTemplate jmsMessagingTemplate;    <span class="hljs-meta">@Autowired</span>    Queue queue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Message message)</span> </span>&#123;        jmsMessagingTemplate.convertAndSend(<span class="hljs-keyword">this</span>.queue, message);    &#125;    <span class="hljs-meta">@JmsListener(destination = &quot;hello.javaboy&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(Message msg)</span> </span>&#123;        System.out.println(msg);    &#125;&#125;</code></pre></div><h2 id="4-RabbitMQ"><a href="#4-RabbitMQ" class="headerlink" title="4. RabbitMQ"></a>4. RabbitMQ</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>安装参考Linux中的教程</p><h3 id="2-整合到SpringBoot-1"><a href="#2-整合到SpringBoot-1" class="headerlink" title="2.整合到SpringBoot"></a>2.整合到SpringBoot</h3><p><strong>引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>配置文件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">192.168.66.131</span><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">32771</span></code></pre></div><p>RabbitMQ 有四种交换机模式：</p><ul><li>Direct Pattern （此模式不需要配置交换机）</li><li>Fanout Pattern ( 类似于广播一样，将消息发送给和他绑定的队列 )</li><li>Topic Pattern ( 绑定交换机时可以做匹配。 #：表示零个或多个单词。*：表示一个单词 )</li><li>Header Pattern ( 带有参数的匹配规则 )</li></ul><h4 id="2-1-Direct模式"><a href="#2-1-Direct模式" class="headerlink" title="2.1 Direct模式"></a>2.1 Direct模式</h4><p>直连交换机是一种带路由功能的交换机，一个队列会和一个交换机绑定，除此之外再绑定一个<code>routing_key</code>，当消息被发送的时候，需要指定一个<code>binding_key</code>，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个<code>binding_key</code>也是支持应用到多个队列中的。这样当一个交换机绑定多个队列，就会被送到对应的队列去处理。</p><p><img src="https://upload-images.jianshu.io/upload_images/1479657-3f2eff8920707c97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p><p>适用场景：有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p><p><strong>配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitDirectConfig</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String DIRECTNAME = <span class="hljs-string">&quot;javaboy-direct&quot;</span>;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;hello.javaboy&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DIRECTNAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">binding</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue()).to(directExchange()).with(<span class="hljs-string">&quot;direct&quot;</span>);    &#125;&#125;</code></pre></div><p><strong>接收机</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectReceiver</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queues = &quot;hello.javaboy&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler1</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;handler1&gt;&gt;&gt;&quot;</span>+msg);    &#125;&#125;</code></pre></div><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RabbitTemplate rabbitTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hello.javaboy&quot;</span>, <span class="hljs-string">&quot;hello javaboy!hahaha&quot;</span>);    &#125;&#125;</code></pre></div><h4 id="2-2-Fanout模式"><a href="#2-2-Fanout模式" class="headerlink" title="2.2 Fanout模式"></a>2.2 Fanout模式</h4><p>扇形交换机是最基本的交换机类型，它所能做的事情非常简单———广播消息。扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/1200.png" alt="img"></p><p><strong>配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitFanoutConfig</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FANOUTNAME = <span class="hljs-string">&quot;javaboy-fanout&quot;</span>;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">queueOne</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue-one&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">queueTwo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue-two&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">FanoutExchange <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(FANOUTNAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingOne</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueOne()).to(fanoutExchange());    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingTwo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueTwo()).to(fanoutExchange());    &#125;&#125;</code></pre></div><p><strong>接收机</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutReceiver</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queues = &quot;queue-one&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler1</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;FanoutReceiver:handler1:&quot;</span> + msg);    &#125;    <span class="hljs-meta">@RabbitListener(queues = &quot;queue-two&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler2</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;FanoutReceiver:handler2:&quot;</span> + msg);    &#125;&#125;</code></pre></div><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    rabbitTemplate.convertAndSend(RabbitFanoutConfig.FANOUTNAME,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;hello fanout!&quot;</span>);&#125;</code></pre></div><h4 id="2-3-Topic模式"><a href="#2-3-Topic模式" class="headerlink" title="2.3 Topic模式"></a>2.3 Topic模式</h4><p>直连交换机的<code>routing_key</code>方案非常简单，如果我们希望一条消息发送给多个队列，那么这个交换机需要绑定上非常多的<code>routing_key</code>，假设每个交换机上都绑定一堆的<code>routing_key</code>连接到各个队列上。那么消息的管理就会异常地困难。</p><p>所以<code>RabbitMQ</code>提供了一种主题交换机，发送到主题交换机上的消息需要携带指定规则的<code>routing_key</code>，主题交换机会根据这个规则将数据发送到对应的(多个)队列上。</p><p>主题交换机的<code>routing_key</code>需要有一定的规则，交换机和队列的<code>binding_key</code>需要采用<code>*.#.*.....</code>的格式，每个部分用<code>.</code>分开，其中：</p><ul><li><code>*</code>表示一个单词</li><li><code>#</code>表示任意数量（零个或多个）单词。</li></ul><p>假设有一条消息的<code>routing_key</code>为<code>fast.rabbit.white</code>,那么带有这样<code>binding_key</code>的几个队列都会接收这条消息：</p><ul><li>fast.<em>.</em></li><li><em>.</em>.white</li><li>fast.#</li><li>……</li></ul><p>这个图是网上找的，感觉对主题交换机的描述比较到位：</p><p><img src="https://upload-images.jianshu.io/upload_images/1479657-48e5409a26f0c75b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/571" alt="img"></p><p>主题交换机</p><p>当一个队列的绑定键为<code>#</code>的时候，这个队列将会无视消息的路由键，接收所有的消息</p><p><strong>配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitTopicConfig</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPICNAME = <span class="hljs-string">&quot;javaboy-topic&quot;</span>;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">TopicExchange <span class="hljs-title">topicExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(TOPICNAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">xiaomi</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;xiaomi&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">huawei</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;huawei&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">phone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;phone&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">xiaomiBinding</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(xiaomi()).to(topicExchange()).with(<span class="hljs-string">&quot;xiaomi.#&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">huaweiBinding</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(huawei()).to(topicExchange()).with(<span class="hljs-string">&quot;huawei.#&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">phoneBinding</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(phone()).to(topicExchange()).with(<span class="hljs-string">&quot;#.phone.#&quot;</span>);    &#125;&#125;</code></pre></div><p><strong>接收机</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopicReceiver</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queues = &quot;xiaomi&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler1</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;TopicReceiver:handler1:&quot;</span> + msg);    &#125;    <span class="hljs-meta">@RabbitListener(queues = &quot;huawei&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler2</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;TopicReceiver:handler2:&quot;</span> + msg);    &#125;    <span class="hljs-meta">@RabbitListener(queues = &quot;phone&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler3</span><span class="hljs-params">(String msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;TopicReceiver:handler3:&quot;</span> + msg);    &#125;&#125;</code></pre></div><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, <span class="hljs-string">&quot;xiaomi.news&quot;</span>, <span class="hljs-string">&quot;小米新闻&quot;</span>);    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, <span class="hljs-string">&quot;vivo.phone&quot;</span>, <span class="hljs-string">&quot;vivo 手机&quot;</span>);    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, <span class="hljs-string">&quot;huawei.phone&quot;</span>, <span class="hljs-string">&quot;华为手机&quot;</span>);&#125;</code></pre></div><h4 id="2-4-Header模式"><a href="#2-4-Header模式" class="headerlink" title="2.4 Header模式"></a>2.4 Header模式</h4><p>首部交换机是忽略<code>routing_key</code>的一种路由方式。路由器和交换机路由的规则是通过<code>Headers</code>信息来交换的，这个有点像<code>HTTP</code>的<code>Headers</code>。将一个交换机声明成首部交换机，绑定一个队列的时候，定义一个<code>Hash</code>的数据结构，消息发送的时候，会携带一组hash数据结构的信息，当<code>Hash</code>的内容匹配上的时候，消息就会被写入队列。</p><p>绑定<code>交换机</code>和队列的时候，Hash结构中要求携带一个键<code>“x-match”</code>，这个键的<code>Value</code>可以是<code>any</code>或者<code>all</code>，这代表消息携带的<code>Hash</code>是需要<code>全部匹配(all)</code>，还是<code>仅匹配一个键</code>(any)就可以了。相比直连交换机，首部交换机的优势是匹配的规则<code>不被</code>限定为字符串(string)</p><p><strong>配置类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitHeaderConfig</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HEADERNAME = <span class="hljs-string">&quot;javaboy-header&quot;</span>;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">HeadersExchange <span class="hljs-title">headersExchange</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeadersExchange(HEADERNAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">queueName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;name-queue&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Queue <span class="hljs-title">queueAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;age-queue&quot;</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingName</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueName()).to(headersExchange()).whereAny(map).match();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function">Binding <span class="hljs-title">bindingAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueAge()).to(headersExchange()).where(<span class="hljs-string">&quot;age&quot;</span>).exists();    &#125;&#125;</code></pre></div><p><strong>接收机</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeaderReceiver</span> </span>&#123;    <span class="hljs-meta">@RabbitListener(queues = &quot;name-queue&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler1</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;HeaderReceiver:handler1:&quot;</span> + <span class="hljs-keyword">new</span> String(msg, <span class="hljs-number">0</span>, msg.length));    &#125;    <span class="hljs-meta">@RabbitListener(queues = &quot;age-queue&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler2</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] msg)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;HeaderReceiver:handler2:&quot;</span> + <span class="hljs-keyword">new</span> String(msg, <span class="hljs-number">0</span>, msg.length));    &#125;&#125;</code></pre></div><p><strong>测试类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;    Message nameMsg = MessageBuilder.withBody(<span class="hljs-string">&quot;hello javaboy !&quot;</span>.getBytes()).setHeader(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;江南一点雨&quot;</span>).build();    Message ageMsg = MessageBuilder.withBody(<span class="hljs-string">&quot;hello 99 !&quot;</span>.getBytes()).setHeader(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;99&quot;</span>).build();    rabbitTemplate.send(RabbitHeaderConfig.HEADERNAME, <span class="hljs-keyword">null</span>, ageMsg);    rabbitTemplate.send(RabbitHeaderConfig.HEADERNAME, <span class="hljs-keyword">null</span>, nameMsg);&#125;</code></pre></div><h1 id="SpringBoot企业级开发"><a href="#SpringBoot企业级开发" class="headerlink" title="SpringBoot企业级开发"></a>SpringBoot企业级开发</h1><h2 id="1-邮件"><a href="#1-邮件" class="headerlink" title="1. 邮件"></a>1. 邮件</h2><h3 id="1-1-邮件协议"><a href="#1-1-邮件协议" class="headerlink" title="1.1 邮件协议"></a>1.1 邮件协议</h3><p>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。 </p><p>SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。 </p><p>生活中我们投递一封邮件要经过如下几个步骤： </p><ol><li>深圳的小王先将邮件投递到深圳的邮局 </li><li>深圳的邮局将邮件运送到上海的邮局 </li><li>上海的小张来邮局取邮件 </li></ol><p>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:aaa@qq.com">aaa@qq.com</a> 发送邮件到 <a href="mailto:111@163.com">111@163.com</a> ： </p><ol><li><a href="mailto:aaa@qq.com">aaa@qq.com</a> 先将邮件投递到腾讯的邮件服务器 </li><li>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器 </li><li><a href="mailto:111@163.com">111@163.com</a> 登录网易的邮件服务器查看邮件 </li></ol><p>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。 </p><p>SMTP 协议全称为 <code>Simple Mail Transfer Protocol</code>，译作简单邮件传输协议，它定义了邮件客户端软件于 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p><p>也就是说 <a href="mailto:aaa@qq.com">aaa@qq.com</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p><p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:111@163.com">111@163.com</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p><h3 id="1-2-邮件发送"><a href="#1-2-邮件发送" class="headerlink" title="1.2 邮件发送"></a>1.2 邮件发送</h3><p><strong>项目创建</strong></p><p>接下来，我们就可以创建项目了，Spring Boot 中，对于邮件发送提供了自动配置类，开发者只需要加入相关依赖，然后配置一下邮箱的基本信息，就可以发送邮件了。</p><ul><li>首先创建一个 Spring Boot 项目，引入邮件发送依赖：</li></ul><p><a href="http://www.javaboy.org/images/boot2/43-4.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/43-4.png" alt="img"></a></p><p>创建完成后，项目依赖如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ul><li>配置邮箱基本信息</li></ul><p>项目创建成功后，接下来在 application.properties 中配置邮箱的基本信息：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.mail.host</span>=<span class="hljs-string">smtp.qq.com</span><span class="hljs-meta">spring.mail.port</span>=<span class="hljs-string">587</span><span class="hljs-meta">spring.mail.username</span>=<span class="hljs-string">xxxx@xxx.com</span><span class="hljs-meta">spring.mail.password</span>=<span class="hljs-string">xxxx</span><span class="hljs-meta">spring.mail.default-encoding</span>=<span class="hljs-string">UTF-8</span><span class="hljs-meta">spring.mail.properties.mail.smtp.socketFactoryClass</span>=<span class="hljs-string">javax.net.ssl.SSLSocketFactory</span><span class="hljs-meta">spring.mail.properties.mail.debug</span>=<span class="hljs-string">true</span></code></pre></div><p>配置含义分别如下：</p><ul><li>配置 SMTP 服务器地址</li><li>SMTP 服务器的端口</li><li>配置邮箱用户名</li><li>配置密码，注意，不是真正的密码，而是刚刚申请到的授权码</li><li>默认的邮件编码</li><li>配饰 SSL 加密工厂</li><li>表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</li></ul><p>如果不知道 smtp 服务器的端口或者地址的的话，可以参考 腾讯的邮箱文档</p><ul><li><a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371</a></li></ul><p>做完这些之后，Spring Boot 就会自动帮我们配置好邮件发送类，相关的配置在 <code>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration</code> 类中，部分源码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass(&#123; MimeMessage.class, MimeType.class, MailSender.class &#125;)</span><span class="hljs-meta">@ConditionalOnMissingBean(MailSender.class)</span><span class="hljs-meta">@Conditional(MailSenderCondition.class)</span><span class="hljs-meta">@EnableConfigurationProperties(MailProperties.class)</span><span class="hljs-meta">@Import(&#123; MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class &#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderAutoConfiguration</span> </span>&#123;&#125;</code></pre></div><p>从这段代码中，可以看到，导入了另外一个配置 <code>MailSenderPropertiesConfiguration</code> 类，这个类中，提供了邮件发送相关的工具类：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;spring.mail&quot;, name = &quot;host&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderPropertiesConfiguration</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MailProperties properties;        MailSenderPropertiesConfiguration(MailProperties properties) &#123;                <span class="hljs-keyword">this</span>.properties = properties;        &#125;        <span class="hljs-meta">@Bean</span>        <span class="hljs-meta">@ConditionalOnMissingBean</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> JavaMailSenderImpl <span class="hljs-title">mailSender</span><span class="hljs-params">()</span> </span>&#123;                JavaMailSenderImpl sender = <span class="hljs-keyword">new</span> JavaMailSenderImpl();                applyProperties(sender);                <span class="hljs-keyword">return</span> sender;        &#125;&#125;</code></pre></div><p>可以看到，这里创建了一个 <code>JavaMailSenderImpl</code> 的实例， <code>JavaMailSenderImpl</code> 是 <code>JavaMailSender</code> 的一个实现，我们将使用 <code>JavaMailSenderImpl</code> 来完成邮件的发送工作。</p><h4 id="简单邮件"><a href="#简单邮件" class="headerlink" title="简单邮件"></a>简单邮件</h4><p>简单邮件就是指邮件内容是一个普通的文本文档：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>JavaMailSender javaMailSender;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSimpleMail</span><span class="hljs-params">()</span> </span>&#123;    SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();    message.setSubject(<span class="hljs-string">&quot;这是一封测试邮件&quot;</span>);    message.setFrom(<span class="hljs-string">&quot;1510161612@qq.com&quot;</span>);    message.setTo(<span class="hljs-string">&quot;25xxxxx755@qq.com&quot;</span>);    message.setCc(<span class="hljs-string">&quot;37xxxxx37@qq.com&quot;</span>);    message.setBcc(<span class="hljs-string">&quot;14xxxxx098@qq.com&quot;</span>);    message.setSentDate(<span class="hljs-keyword">new</span> Date());    message.setText(<span class="hljs-string">&quot;这是测试邮件的正文&quot;</span>);    javaMailSender.send(message);&#125;</code></pre></div><p>从上往下，代码含义分别如下：</p><ul><li>构建一个邮件对象</li><li>设置邮件主题</li><li>设置邮件发送者</li><li>设置邮件接收者，可以有多个接收者</li><li>设置邮件抄送人，可以有多个抄送人</li><li>设置隐秘抄送人，可以有多个</li><li>设置邮件发送日期</li><li>设置邮件的正文</li><li>发送邮件</li></ul><h4 id="带附件的邮件"><a href="#带附件的邮件" class="headerlink" title="带附件的邮件"></a>带附件的邮件</h4><p>邮件的附件可以是图片，也可以是普通文件，都是支持的。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAttachFileMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;    MimeMessage mimeMessage = javaMailSender.createMimeMessage();    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage,<span class="hljs-keyword">true</span>);    helper.setSubject(<span class="hljs-string">&quot;这是一封测试邮件&quot;</span>);    helper.setFrom(<span class="hljs-string">&quot;1510161612@qq.com&quot;</span>);    helper.setTo(<span class="hljs-string">&quot;25xxxxx755@qq.com&quot;</span>);    helper.setCc(<span class="hljs-string">&quot;37xxxxx37@qq.com&quot;</span>);    helper.setBcc(<span class="hljs-string">&quot;14xxxxx098@qq.com&quot;</span>);    helper.setSentDate(<span class="hljs-keyword">new</span> Date());    helper.setText(<span class="hljs-string">&quot;这是测试邮件的正文&quot;</span>);    helper.addAttachment(<span class="hljs-string">&quot;javaboy.jpg&quot;</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\sang\\Downloads\\javaboy.png&quot;</span>));    javaMailSender.send(mimeMessage);&#125;</code></pre></div><p>注意这里在构建邮件对象上和前文有所差异，这里是通过 javaMailSender 来获取一个复杂邮件对象，然后再利用 MimeMessageHelper 对邮件进行配置，MimeMessageHelper 是一个邮件配置的辅助工具类，创建时候的 true 表示构建一个 multipart message 类型的邮件，有了 MimeMessageHelper 之后，我们针对邮件的配置都是由 MimeMessageHelper 来代劳。最后通过 addAttachment 方法来添加一个附件。</p><h4 id="图片资源的邮件"><a href="#图片资源的邮件" class="headerlink" title="图片资源的邮件"></a>图片资源的邮件</h4><p>图片资源和附件有什么区别呢？图片资源是放在邮件正文中的，即一打开邮件，就能看到图片。但是一般来说，不建议使用这种方式，一些公司会对邮件内容的大小有限制（因为这种方式是将图片一起发送的）。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendImgResMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;    MimeMessage mimeMessage = javaMailSender.createMimeMessage();    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);    helper.setSubject(<span class="hljs-string">&quot;这是一封测试邮件&quot;</span>);    helper.setFrom(<span class="hljs-string">&quot;1510161612@qq.com&quot;</span>);    helper.setTo(<span class="hljs-string">&quot;25xxxxx755@qq.com&quot;</span>);    helper.setCc(<span class="hljs-string">&quot;37xxxxx37@qq.com&quot;</span>);    helper.setBcc(<span class="hljs-string">&quot;14xxxxx098@qq.com&quot;</span>);    helper.setSentDate(<span class="hljs-keyword">new</span> Date());    helper.setText(<span class="hljs-string">&quot;&lt;p&gt;hello 大家好，这是一封测试邮件，这封邮件包含两种图片，分别如下&lt;/p&gt;&lt;p&gt;第一张图片：&lt;/p&gt;&lt;img src=&#x27;cid:p01&#x27;/&gt;&lt;p&gt;第二张图片：&lt;/p&gt;&lt;img src=&#x27;cid:p02&#x27;/&gt;&quot;</span>,<span class="hljs-keyword">true</span>);    helper.addInline(<span class="hljs-string">&quot;p01&quot;</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\sang\\Downloads\\javaboy.png&quot;</span>)));    helper.addInline(<span class="hljs-string">&quot;p02&quot;</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\sang\\Downloads\\javaboy2.png&quot;</span>)));    javaMailSender.send(mimeMessage);&#125;</code></pre></div><p>这里的邮件 text 是一个 HTML 文本，里边涉及到的图片资源先用一个占位符占着，setText 方法的第二个参数 true 表示第一个参数是一个 HTML 文本。setText 之后，再通过 addInline 方法来添加图片资源。</p><h3 id="1-3-Freemarker邮件"><a href="#1-3-Freemarker邮件" class="headerlink" title="1.3 Freemarker邮件"></a>1.3 Freemarker邮件</h3><p>首先需要引入 Freemarker 依赖：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>然后在 <code>resources/templates</code> 目录下创建一个 <code>mail.ftl</code> 作为邮件发送模板：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;salary&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: #ff1a0e&quot;</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>接下来，将邮件模板渲染成 HTML ，然后发送即可。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFreemarkerMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException, IOException, TemplateException </span>&#123;    MimeMessage mimeMessage = javaMailSender.createMimeMessage();    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);    helper.setSubject(<span class="hljs-string">&quot;这是一封测试邮件&quot;</span>);    helper.setFrom(<span class="hljs-string">&quot;1510161612@qq.com&quot;</span>);    helper.setTo(<span class="hljs-string">&quot;25xxxxx755@qq.com&quot;</span>);    helper.setCc(<span class="hljs-string">&quot;37xxxxx37@qq.com&quot;</span>);    helper.setBcc(<span class="hljs-string">&quot;14xxxxx098@qq.com&quot;</span>);    helper.setSentDate(<span class="hljs-keyword">new</span> Date());    <span class="hljs-comment">//构建 Freemarker 的基本配置</span>    Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_0);    <span class="hljs-comment">// 配置模板位置</span>    ClassLoader loader = MailApplication.class.getClassLoader();    configuration.setClassLoaderForTemplateLoading(loader, <span class="hljs-string">&quot;templates&quot;</span>);    <span class="hljs-comment">//加载模板</span>    Template template = configuration.getTemplate(<span class="hljs-string">&quot;mail.ftl&quot;</span>);    User user = <span class="hljs-keyword">new</span> User();    user.setUsername(<span class="hljs-string">&quot;javaboy&quot;</span>);    user.setNum(<span class="hljs-number">1</span>);    user.setSalary((<span class="hljs-keyword">double</span>) <span class="hljs-number">99999</span>);    StringWriter out = <span class="hljs-keyword">new</span> StringWriter();    <span class="hljs-comment">//模板渲染，渲染的结果将被保存到 out 中 ，将out 中的 html 字符串发送即可</span>    template.process(user, out);    helper.setText(out.toString(),<span class="hljs-keyword">true</span>);    javaMailSender.send(mimeMessage);&#125;</code></pre></div><p>需要注意的是，虽然引入了 <code>Freemarker</code> 的自动化配置，但是我们在这里是直接 <code>new Configuration</code> 来重新配置 <code>Freemarker</code> 的，所以 Freemarker 默认的配置这里不生效，因此，在填写模板位置时，值为 <code>templates</code> </p><h3 id="1-4-Thymeleaf邮件"><a href="#1-4-Thymeleaf邮件" class="headerlink" title="1.4 Thymeleaf邮件"></a>1.4 Thymeleaf邮件</h3><p>推荐在 Spring Boot 中使用 Thymeleaf 来构建邮件模板。因为 Thymeleaf 的自动化配置提供了一个 TemplateEngine，通过 TemplateEngine 可以方便的将 Thymeleaf 模板渲染为 HTML ，同时，Thymeleaf 的自动化配置在这里是继续有效的 。</p><p>首先，引入 Thymeleaf 依赖：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>然后，创建 <code>Thymeleaf</code> 邮件模板：</p><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;!DOCTYPE html&gt;&lt;html lang=<span class="hljs-string">&quot;en&quot;</span> xmlns:th=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;&lt;head&gt;    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;hello 欢迎加入 xxx 大家庭，您的入职信息如下：&lt;/p&gt;&lt;table border=<span class="hljs-string">&quot;1&quot;</span>&gt;    &lt;tr&gt;        &lt;td&gt;姓名&lt;/td&gt;        &lt;td th:text=&quot;$&#123;username&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;工号&lt;/td&gt;        &lt;td th:text=&quot;$&#123;num&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;薪水&lt;/td&gt;        &lt;td th:text=&quot;$&#123;salary&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;div style=&quot;color: #ff1a0e&quot;&gt;一起努力创造辉煌&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><p>接下来发送邮件：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>TemplateEngine templateEngine;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendThymeleafMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;    MimeMessage mimeMessage = javaMailSender.createMimeMessage();    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);    helper.setSubject(<span class="hljs-string">&quot;这是一封测试邮件&quot;</span>);    helper.setFrom(<span class="hljs-string">&quot;1510161612@qq.com&quot;</span>);    helper.setTo(<span class="hljs-string">&quot;25xxxxx755@qq.com&quot;</span>);    helper.setCc(<span class="hljs-string">&quot;37xxxxx37@qq.com&quot;</span>);    helper.setBcc(<span class="hljs-string">&quot;14xxxxx098@qq.com&quot;</span>);    helper.setSentDate(<span class="hljs-keyword">new</span> Date());    Context context = <span class="hljs-keyword">new</span> Context();    context.setVariable(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);    context.setVariable(<span class="hljs-string">&quot;num&quot;</span>,<span class="hljs-string">&quot;000001&quot;</span>);    context.setVariable(<span class="hljs-string">&quot;salary&quot;</span>, <span class="hljs-string">&quot;99999&quot;</span>);    String process = templateEngine.process(<span class="hljs-string">&quot;mail.html&quot;</span>, context);    helper.setText(process,<span class="hljs-keyword">true</span>);    javaMailSender.send(mimeMessage);&#125;</code></pre></div><h1 id="SpringBoot应用监控"><a href="#SpringBoot应用监控" class="headerlink" title="SpringBoot应用监控"></a>SpringBoot应用监控</h1><p>应用监控是我们在生产环境下一个非常重要的东西，运维人员不可能 24 小时盯着应用，应用挂了及时解决，这不现实。我们需要能够实时掌握应用的运行数据，以便提早发现问题，同时在应用挂掉的时候还能够自动报警，这样才能解放开发人员。</p><p>Spring Boot 中也提供了生产级的应用监控方案，对于单体应用、微服务应用都有相应的解决方案，今天松哥就想来和大家捋一捋 Spring Boot 中的应用监控方案都有哪些。</p><p>首先我们来捋一下应用监控都需要哪些东西？其实就两点：</p><ul><li>信息采集器</li><li>数据可视化 UI</li></ul><p>信息采集器会收集应用的健康、审计、指标、HTTP 请求等信息，并将之暴露出来，数据可视化 UI 则会通过仪表盘、图形等展示这些数据，并对数据进行分析、报警等处理。我们分别来看。</p><h2 id="1-Spring-Boot-Actuator"><a href="#1-Spring-Boot-Actuator" class="headerlink" title="1. Spring Boot Actuator"></a>1. Spring Boot Actuator</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>在 Spring Boot 项目中，我们使用的信息采集器主要就是 Spring Boot Actuator，这个模块由 Spring Boot 官方提供，它包含了许多生产级别的功能，例如健康检查、审计、指标收集、HTTP 请求追踪等，Spring Boot Actuator 将这些信息收集起来后，通过 HTTP 和 JMX 两种方式暴露给外部模块。例如 Spring Boot Actuator 通过 <code>/health</code> 端点（endpoints）提供了应用的健康信息，开发者只需要访问该端点就可以看到应用的健康信息，但是这些端点返回的数据是 JSON 格式的，不方便查看，也不方便分析，所以一般情况下，Spring Boot Actuator 都是和一些外部模块一起使用。</p><p>Spring Boot Actuator 支持的端点主要有如下一些：</p><p><a href="http://img.itboyhub.com/2021/02/20210201202406.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20210201202406.png" alt="img"></a></p><p>如果是 Web 应用，则再次基础上还支持如下端点：</p><p><a href="http://img.itboyhub.com/2021/02/20210201202855.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20210201202855.png" alt="img"></a></p><p>提到 Spring Boot Actuator，就还有一个东西需要和大家介绍，那就是 Micrometer，从 Spring Boot2.0 开始，Actuator 底层改为了 Micrometer。</p><p>当我们在一个 Spring Boot 项目中引入 Actuator 依赖之后，我们会发现它里边包含了 Micrometer：</p><p><a href="http://img.itboyhub.com/2021/01/spring-cloud/20210201162644.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20210201162644.png" alt="img"></a></p><p>Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标即可，而 Micrometer 则会负责完成与不同监控系统的适配工作，类似于一个 Adapter，有了这个 Adapter，切换监控系统就变得非常容易。同时 Micrometer 还支持推送数据到多个不同的监控系统。</p><p>而 Spring Boot Actuator 使用 Micrometer 与外部应用监视系统进行集成，这样一来，开发者只需要稍微配置一下就可以使其和外部应用监视系统进行整合了。Micrometer 支持的监控系统有：</p><ul><li>AppOptics</li><li>Atlas</li><li>Datadog</li><li>Dynatrace</li><li>Elastic</li><li>Ganglia</li><li>Graphite</li><li>Humio</li><li>Influx</li><li>JMX</li><li>KairosDB</li><li>New Relic</li><li>Prometheus</li><li>SignalFx</li><li>Simple (in-memory)</li><li>StatsD</li><li>Wavefront</li></ul><h3 id="1-2-整合到SpringBoot"><a href="#1-2-整合到SpringBoot" class="headerlink" title="1.2 整合到SpringBoot"></a>1.2 整合到SpringBoot</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p><strong>引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>启动后可以看到</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210527112349779.png" alt="image-20210527112349779"></p><p><strong>配置文件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span><span class="hljs-comment"># 开启优雅的关闭</span><span class="hljs-meta">management.endpoints.shutdown.enabled</span>=<span class="hljs-string">true</span><span class="hljs-comment">#SecurityConfig</span><span class="hljs-meta">spring.security.user.name</span>=<span class="hljs-string">javaboy</span><span class="hljs-meta">spring.security.user.password</span>=<span class="hljs-string">123</span><span class="hljs-meta">spring.security.user.roles</span>=<span class="hljs-string">ADMIN</span></code></pre></div><p><strong>Security配置</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.requestMatcher(EndpointRequest.toAnyEndpoint())                .authorizeRequests()                .anyRequest().hasRole(<span class="hljs-string">&quot;ADMIN&quot;</span>)                .and()                .httpBasic().and().csrf().disable();    &#125;&#125;</code></pre></div><h4 id="配置路径映射"><a href="#配置路径映射" class="headerlink" title="配置路径映射"></a>配置路径映射</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 以/开头</span><span class="hljs-meta">management.endpoints.web.base-path</span>=<span class="hljs-string">/</span><span class="hljs-comment"># bs代替beans</span><span class="hljs-meta">management.endpoints.web.path-mapping.beans</span>=<span class="hljs-string">bs</span></code></pre></div><h4 id="支持跨域"><a href="#支持跨域" class="headerlink" title="支持跨域"></a>支持跨域</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">management.endpoints.web.cors.allowed-origins</span>=<span class="hljs-string">http://localhost:8888</span><span class="hljs-meta">management.endpoints.web.cors.allowed-methods</span>=<span class="hljs-string">GET,POST</span></code></pre></div><h4 id="健康信息"><a href="#健康信息" class="headerlink" title="健康信息"></a>健康信息</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">management.endpoint.health.show-details</span>=<span class="hljs-string">when_authorized</span><span class="hljs-meta">management.endpoint.health.roles</span>=<span class="hljs-string">ADMIN</span><span class="hljs-meta">management.endpoint.health.status.order</span>=<span class="hljs-string">FATAL,DOWN,OUT_OF_SERVICE,UP,UNKNOWN</span><span class="hljs-meta">management.endpoint.health.status.http-mapping.FATAL</span>=<span class="hljs-string">503</span></code></pre></div><p>自定义健康</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaboyHealth</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HealthIndicator</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Health <span class="hljs-title">health</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//       return Health.status(&quot;FATAL&quot;).withDetail(&quot;msg&quot;,&quot;发现严重问题&quot;).build();</span>       <span class="hljs-keyword">return</span> Health.up().withDetail(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;一切正常...&quot;</span>).build();    &#125;&#125;</code></pre></div><h4 id="应用信息"><a href="#应用信息" class="headerlink" title="应用信息"></a>应用信息</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">info.app.encoding</span>=<span class="hljs-string">@project.build.sourceEncoding@</span><span class="hljs-meta">info.app.java.source</span>=<span class="hljs-string">@java.version@</span><span class="hljs-meta">info.app.java.target</span>=<span class="hljs-string">@java.version@</span><span class="hljs-meta">info.author.name</span>=<span class="hljs-string">lucifer</span><span class="hljs-meta">info.author.email</span>=<span class="hljs-string">xx@qq.com</span></code></pre></div><p>或者在配置类中定义</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InfoContributor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contribute</span><span class="hljs-params">(Info.Builder builder)</span> </span>&#123;        Map&lt;String, String&gt; link = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        link.put(<span class="hljs-string">&quot;site&quot;</span>, <span class="hljs-string">&quot;www.javaboy.org&quot;</span>);        link.put(<span class="hljs-string">&quot;site-2&quot;</span>, <span class="hljs-string">&quot;www.itboyhub.com&quot;</span>);        builder.withDetail(<span class="hljs-string">&quot;link&quot;</span>, link);    &#125;&#125;</code></pre></div><h4 id="git相关"><a href="#git相关" class="headerlink" title="git相关"></a>git相关</h4><p>引入依赖</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>pl.project13.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>git-commit-id-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210527115729859.png" alt="image-20210527115729859"></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">management.info.git.mode</span>=<span class="hljs-string">full</span></code></pre></div><h4 id="构建信息"><a href="#构建信息" class="headerlink" title="构建信息"></a>构建信息</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build-info<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210527115712060.png" alt="image-20210527115712060"></p><h3 id="1-3-Admin"><a href="#1-3-Admin" class="headerlink" title="1.3 Admin"></a>1.3 Admin</h3><p>这个算是 Spring Boot 中最最正宗的应用监控可视化工具了，看名字就知道有多正宗，当我们创建一个 Spring Boot 项目时，选择依赖时候就有这个选项：</p><p><a href="http://img.itboyhub.com/2021/02/20210201173448.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20210201173448.png" alt="img"></a></p><p>如果是<strong>单体应用</strong>很多人可能会选择 Spring Boot Admin 作为监控数据可视化工具，不过它也支持微服务应用的(可以通过 Eureka、Consul 等注册中心获取应用信息)，只不过在微服务中，我们可能会更多的选择 Grafana+Prometheus 组合。</p><p>Spring Boot Admin 主要包含如下功能：</p><ul><li>显示应用健康信息。</li><li>显示应用运行的详细信息，例如 JVM 和内存指标、数据源指标、缓存指标等等。</li><li>显示应用的构建信息。</li><li>查看 JVM 系统和环境属性</li><li>查看 Spring Boot 配置属性</li><li>支持 Spring Cloud 中的端点刷新功能 /refresh-endpoint</li><li>方便的日志级别管理功能</li><li>可以与 JMX-beans 进行交互</li><li>查看 Thread dump</li><li>查看 http 请求</li><li>查看计划任务</li><li>查看和删除活动会话</li><li>查看 Flyway/Liquibase 数据库迁移</li><li>下载 heapdump</li><li>状态更改通知</li><li>…</li></ul><p>可以看到，Spring Boot Admin 不仅仅是将 Actuator 接口中的数据进行可视化，还在此基础上提供了分析、报警等功能。</p><p>Spring Boot Admin 的显示界面如下：</p><p><a href="http://img.itboyhub.com/2021/02/20210201181913.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20210201181913.png" alt="img"></a></p><p><strong>原本客户端上引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>这里服务端引入依赖</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>启动类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableAdminServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(AdminApplication.class, args);    &#125;&#125;</code></pre></div><p><strong>服务器文件配置</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><span class="hljs-meta">spring.boot.admin.instance-auth.default-user-name</span>=<span class="hljs-string">javaboy</span><span class="hljs-meta">spring.boot.admin.instance-auth.default-password</span>=<span class="hljs-string">123</span></code></pre></div><p><strong>客户端文件配置</strong></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.boot.admin.client.url</span>=<span class="hljs-string">http://localhost:8081</span></code></pre></div><h3 id="1-4-邮件报警"><a href="#1-4-邮件报警" class="headerlink" title="1.4 邮件报警"></a>1.4 邮件报警</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.mail.host</span>=<span class="hljs-string">smtp.qq.com</span><span class="hljs-meta">spring.mail.port</span>=<span class="hljs-string">465</span><span class="hljs-meta">spring.mail.username</span>=<span class="hljs-string">1510161612@qq.com</span><span class="hljs-meta">spring.mail.password</span>=<span class="hljs-string">laikremaxeyqfgbj</span><span class="hljs-meta">spring.mail.default-encoding</span>=<span class="hljs-string">utf-8</span><span class="hljs-meta">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="hljs-string">javax.net.ssl.SSLSocketFactory</span><span class="hljs-meta">spring.mail.properties.mail.debug</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.boot.admin.notify.mail.from</span>=<span class="hljs-string">1510161612@qq.com</span><span class="hljs-meta">spring.boot.admin.notify.mail.to</span>=<span class="hljs-string">1470249098@qq.com</span><span class="hljs-comment">#状态发生变化就发</span><span class="hljs-meta">spring.boot.admin.notify.mail.ignore-changes</span>=<span class="hljs-string"></span></code></pre></div><h1 id="SpringBoot打包发布"><a href="#SpringBoot打包发布" class="headerlink" title="SpringBoot打包发布"></a>SpringBoot打包发布</h1><h2 id="1-可执行Jar"><a href="#1-可执行Jar" class="headerlink" title="1. 可执行Jar"></a>1. 可执行Jar</h2><p>Spring Boot 中默认打包成的 jar 叫做 可执行 jar，这种 jar 不同于普通的 jar，普通的 jar 不可以通过 <code>java -jar xxx.jar</code> 命令执行，普通的 <code>jar</code> 主要是被其他应用依赖，<code>Spring Boot</code> 打成的 <code>jar</code> 可以执行，但是不可以被其他的应用所依赖，即使强制依赖，也无法获取里边的类。但是可执行 jar 并不是 Spring Boot 独有的，Java 工程本身就可以打包成可执行 jar 。</p><p>有的小伙伴可能就有疑问了，既然同样是执行 <code>mvn package</code> 命令进行项目打包，为什么 Spring Boot 项目就打成了可执行 jar ，而普通项目则打包成了不可执行 jar 呢？</p><p>这我们就不得不提 Spring Boot 项目中一个默认的插件配置 <code>spring-boot-maven-plugin</code> ，这个打包插件存在 5 个方面的功能，从插件命令就可以看出：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-1.png" alt="img"></p><p>五个功能分别是：</p><ul><li>build-info：生成项目的构建信息文件 build-info.properties</li><li>repackage：这个是默认 goal，在 <code>mvn package</code> 执行之后，这个命令再次打包生成可执行的 jar，同时将 <code>mvn package</code> 生成的 jar 重命名为 <code>*.origin</code></li><li>run：这个可以用来运行 Spring Boot 应用</li><li>start：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li><li>stop：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li></ul><p>这里功能，默认情况下使用就是 repackage 功能，其他功能要使用，则需要开发者显式配置</p><h2 id="2-打包"><a href="#2-打包" class="headerlink" title="2. 打包"></a>2. 打包</h2><p>打包的依赖</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>repackage 功能的 作用，就是在打包的时候，多做一点额外的事情：</p><ol><li>首先 <code>mvn package</code> 命令 对项目进行打包，打成一个 <code>jar</code>，这个 <code>jar</code> 就是一个普通的 <code>jar</code>，可以被其他项目依赖，但是不可以被执行</li><li><code>repackage</code> 命令，对第一步 打包成的 <code>jar</code> 进行再次打包，将之打成一个 可执行 <code>jar</code> ，通过将第一步打成的 <code>jar</code> 重命名为 <code>*.original</code> 文件</li></ol><p>举个例子：</p><p>对任意一个 Spring Boot 项目进行打包，可以执行 <code>mvn package</code> 命令，也可以直接在 <code>IDEA</code> 中点击 <code>package</code> ，如下 ：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-2.png" alt="img"></p><p>打包成功之后， <code>target</code> 中的文件如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-3.png" alt="img"></p><p>这里有两个文件，第一个 <code>restful-0.0.1-SNAPSHOT.jar</code> 表示打包成的可执行 <code>jar</code> ，第二个 <code>restful-0.0.1-SNAPSHOT.jar.original</code> 则是在打包过程中 ，被重命名的 <code>jar</code>，这是一个不可执行 <code>jar</code>，但是可以被其他项目依赖的 <code>jar</code>。通过对这两个文件的解压，我们可以看出这两者之间的差异。</p><p>可执行 <code>jar</code> 解压之后，目录如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-4.png" alt="img"></p><p>可以看到，可执行 jar 中，我们自己的代码是存在 于 <code>BOOT-INF/classes/</code> 目录下，另外，还有一个 <code>META-INF</code> 的目录，该目录下有一个 <code>MANIFEST.MF</code> 文件，打开该文件，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">Manifest-Version: 1.0</span><span class="hljs-section">Implementation-Title: restful</span><span class="hljs-section">Implementation-Version: 0.0.1-SNAPSHOT</span><span class="hljs-section">Start-Class: org.javaboy.restful.RestfulApplication</span><span class="hljs-section">Spring-Boot-Classes: BOOT-INF/classes/</span><span class="hljs-section">Spring-Boot-Lib: BOOT-INF/lib/</span><span class="hljs-section">Build-Jdk-Spec: 1.8</span><span class="hljs-section">Spring-Boot-Version: 2.1.6.RELEASE</span><span class="hljs-section">Created-By: Maven Archiver 3.4.0</span><span class="hljs-section">Main-Class: org.springframework.boot.loader.JarLauncher</span></code></pre></div><p>可以看到，这里定义了一个 <code>Start-Class</code>，这就是可执行 <code>jar</code> 的入口类，<code>Spring-Boot-Classes</code> 表示我们自己代码编译后的位置，<code>Spring-Boot-Lib</code> 则表示项目依赖的 <code>jar</code> 的位置。</p><p>换句话说，如果自己要打一个可执行 <code>jar</code> 包的话，除了添加相关依赖之外，还需要配置 <code>META-INF/MANIFEST.MF</code> 文件。</p><p>这是可执行 jar 的结构，那么不可执行 jar 的结构呢？</p><p>我们首先将默认的后缀 <code>.original</code> 除去，然后给文件重命名，重命名完成，进行解压：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-5.png" alt="img"></p><p>解压后可以看到，不可执行 <code>jar</code> 根目录就相当于我们的 <code>classpath</code>，解压之后，直接就能看到我们的代码，它也有 <code>META-INF/MANIFEST.MF</code> 文件，但是文件中没有定义启动类等。</p><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">Manifest-Version: 1.0</span><span class="hljs-section">Implementation-Title: restful</span><span class="hljs-section">Implementation-Version: 0.0.1-SNAPSHOT</span><span class="hljs-section">Build-Jdk-Spec: 1.8</span><span class="hljs-section">Created-By: Maven Archiver 3.4.0</span></code></pre></div><p><strong>注意</strong></p><p>这个不可以执行 <code>jar</code> 也没有将项目的依赖打包进来。</p><p>从这里我们就可以看出，两个 <code>jar</code> ，虽然都是 <code>jar</code> 包，但是内部结构是完全不同的，因此一个可以直接执行，另一个则可以被其他项目依赖。</p><p><strong>自定义jar包后缀</strong></p><p>一般来说，Spring Boot 直接打包成可执行 <code>jar</code> 就可以了，不建议将 Spring Boot 作为普通的 <code>jar</code> 被其他的项目所依赖。如果有这种需求，建议将被依赖的部分，单独抽出来做一个普通的 <code>Maven</code> 项目，然后在 Spring Boot 中引用这个 <code>Maven</code> 项目。</p><p>如果非要将 Spring Boot 打包成一个普通 <code>jar</code> 被其他项目依赖，技术上来说，也是可以的，给 <code>spring-boot-maven-plugin</code> 插件添加如下配置：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>配置的 <code>classifier</code> 表示可执行 <code>jar</code> 的名字，配置了这个之后，在插件执行 <code>repackage</code> 命令时，就不会给 <code>mvn package</code> 所打成的 <code>jar</code> 重命名了，所以，打包后的 jar 如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-6.png" alt="img"></p><p>第一个 jar 表示可以被其他项目依赖的 jar ，第二个 jar 则表示一个可执行 jar。</p><p><strong>补充</strong></p><p>可执行 jar 的文件大小都很大，因为包含了打包项目所依赖的jar包，如果不需要打包的时候把这些包也加进来，可进行如下配置</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>org.javaboy.client.ClientApplication<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>ZIP<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>这样打包后的jar体积就很小了，如果要执行需要加上原先lib所在的目录</p><div class="hljs code-wrapper"><pre><code class="hljs shell">java -Dloader.path=./xx/BOOT-INF/lib/ -jar xxx-exec.jar</code></pre></div><p><strong>war包</strong></p><p>在创建工程的时候选择war，在依赖中会多一个tomcat的依赖</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>并多了一个初始化的类</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2021/08/01/Spring/"/>
    <url>/2021/08/01/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h1 id="第一章、Spring工厂"><a href="#第一章、Spring工厂" class="headerlink" title="第一章、Spring工厂"></a>第一章、Spring工厂</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><h3 id="1-1-EJB存在的问题"><a href="#1-1-EJB存在的问题" class="headerlink" title="1.1 EJB存在的问题"></a>1.1 EJB存在的问题</h3><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200411104428457.png" alt="image-20200411104428457"></p><h3 id="1-2-什么是Spring"><a href="#1-2-什么是Spring" class="headerlink" title="1.2 什么是Spring"></a>1.2 什么是Spring</h3><blockquote><p>Spring是一个轻量级的JavaEE解决方案，整合众多优秀的设计模式</p></blockquote><p><strong>轻量级</strong></p><ul><li>对于运行环境是没有额外要求的<ul><li>开源 tomcat resion jetty<br>收费 weblogic  websphere </li></ul></li><li>代码移植性高<ul><li>不需要实现额外接口</li></ul></li></ul><p><strong>JavaEE的解决方案</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200411111041836.png" alt="image-20200411111041836"></p><p><strong>整合设计模式</strong></p><ul><li>工厂</li><li>代理</li><li>模板</li><li>策略</li></ul><h3 id="1-3-设计模式"><a href="#1-3-设计模式" class="headerlink" title="1.3 设计模式"></a>1.3 设计模式</h3><p><strong>广义概念</strong></p><blockquote><p>面向对象设计中，解决特定问题的经典代码</p></blockquote><p><strong>狭义概念</strong></p><blockquote><p>GOF4人帮定义的23种设计模式：工厂、适配器、装饰器、门面、代理、模板…</p></blockquote><h3 id="1-4-工厂设计模式"><a href="#1-4-工厂设计模式" class="headerlink" title="1.4 工厂设计模式"></a>1.4 工厂设计模式</h3><h4 id="1-4-1-什么是工厂设计模式"><a href="#1-4-1-什么是工厂设计模式" class="headerlink" title="1.4.1 什么是工厂设计模式"></a>1.4.1 什么是工厂设计模式</h4><ul><li><p>概念：通过工厂类，创建对象</p>  <div class="hljs code-wrapper"><pre><code class="hljs java">User user = <span class="hljs-keyword">new</span> User();UserDAO userDAO = <span class="hljs-keyword">new</span> UserDAOImpl();</code></pre></div></li><li><p>好处：解耦合</p><ul><li><p>耦合：指定是代码间的强关联关系，一方的改变会影响到另一方</p></li><li><p>问题：不利于代码维护</p></li><li><p>简单：把接口的实现类，硬编码在程序中</p> <div class="hljs code-wrapper"><pre><code class="hljs java">UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();</code></pre></div></li></ul></li></ul><h4 id="1-4-2-简单工厂的设计"><a href="#1-4-2-简单工厂的设计" class="headerlink" title="1.4.2 简单工厂的设计"></a>1.4.2 简单工厂的设计</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<span class="hljs-comment">/* 对象的创建方式：</span><span class="hljs-comment">1. 直接调用构造方法 创建对象  UserService userService = new UserServiceImpl();</span><span class="hljs-comment">2. 通过反射的形式 创建对象 解耦合</span><span class="hljs-comment">//com.baizhiedu.basic.UserServiceImpl,类名改变也会改变</span><span class="hljs-comment"> Class clazz = Class.forName(&quot;com.baizhiedu.basic.UserServiceImpl&quot;);</span><span class="hljs-comment">    UserService userService = (UserService)clazz.newInstance();*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserService <span class="hljs-title">getUserService</span><span class="hljs-params">()</span> </span>&#123;    UserService userService = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;                                     <span class="hljs-comment">//com.baizhiedu.basic.UserServiceImpl,类名改变也会改变</span> Class clazz = Class.forName(<span class="hljs-string">&quot;com.baizhiedu.basic.UserServiceImpl&quot;</span>);    UserService userService = (UserService)clazz.newInstance();    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> userService;&#125;&#125;</code></pre></div><p>通过反射的形式创建对象来解耦合，但<code>com.baizhiedu.basic.UserServiceImpl</code>改变<code>Class.forName(&quot;com.baizhiedu.basic.UserServiceImpl&quot;)</code>也会改变，并没有完全解耦，可以利用Properties文件来进行管理，配置文件<code>applicationContext.properties</code></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># Properties 集合 存储 Properties文件的内容</span><span class="hljs-comment"># 特殊Map key=String value=String</span><span class="hljs-comment"># Properties [userService = com.baizhiedu.xxx.UserServiceImpl]</span><span class="hljs-comment"># Properties.getProperty(&quot;userService&quot;)</span><span class="hljs-attr">userService</span> = <span class="hljs-string">com.baizhiedu.basic.UserServiceImpl</span><span class="hljs-attr">userDAO</span> = <span class="hljs-string">com.baizhiedu.basic.UserDAOImpl</span></code></pre></div><p><strong>下面利用Properties来调用</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;    <span class="hljs-comment">//创建对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Properties env = <span class="hljs-keyword">new</span> Properties();    <span class="hljs-keyword">static</span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//第一步 获得IO输入流</span>            InputStream inputStream = BeanFactory.class.getResourceAsStream(<span class="hljs-string">&quot;/applicationContext.properties&quot;</span>);            <span class="hljs-comment">//第二步 文件内容 封装 Properties集合中 key = userService value = com.baizhixx.UserServiceImpl</span>            env.load(inputStream);          <span class="hljs-comment">//关闭流</span>            inputStream.close();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserService <span class="hljs-title">getUserService</span><span class="hljs-params">()</span> </span>&#123;    UserService userService = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//利用getProperty调用applicationContext.properties中的userService</span>        Class clazz = Class.forName(env.getProperty(<span class="hljs-string">&quot;userService&quot;</span>));        userService = (UserService) clazz.newInstance();    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> userService;&#125;&#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDAO <span class="hljs-title">getUserDAO</span><span class="hljs-params">()</span></span>&#123;        UserDAO userDAO = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-comment">//同理</span>            Class clazz = Class.forName(env.getProperty(<span class="hljs-string">&quot;userDAO&quot;</span>));            userDAO = (UserDAO) clazz.newInstance();        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> userDAO;    &#125;&#125;</code></pre></div><h4 id="1-4-3-通用工厂的设计"><a href="#1-4-3-通用工厂的设计" class="headerlink" title="1.4.3 通用工厂的设计"></a>1.4.3 通用工厂的设计</h4><ul><li>简单工厂会存在大量的代码冗余</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200411181701143.png" alt="image-20200411181701143"></p><ul><li><p>通用工厂的代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建一切想要的对象</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span></span>&#123;  <span class="hljs-comment">//传参</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String key)</span></span>&#123;         Object ret = <span class="hljs-keyword">null</span>;         <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//传入参数key，不再手写</span>             Class clazz = Class.forName(env.getProperty(key));             ret = clazz.newInstance();         &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();         &#125;         <span class="hljs-keyword">return</span> ret;     &#125;&#125;</code></pre></div></li></ul><h4 id="1-4-4-通用工厂的使用方式"><a href="#1-4-4-通用工厂的使用方式" class="headerlink" title="1.4.4 通用工厂的使用方式"></a>1.4.4 通用工厂的使用方式</h4><ul><li>定义类型 (类)</li><li>通过配置文件的配置告知工厂<code>applicationContext.properties</code><br> <code>key = value</code></li><li>通过工厂获得类的对象<br> <code>Object ret = BeanFactory.getBean(&quot;key&quot;)</code></li></ul><h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p><strong>Spring本质</strong></p><p>工厂 <code>ApplicationContext (applicationContext.xml)</code></p><h2 id="2-第一个Spring程序"><a href="#2-第一个Spring程序" class="headerlink" title="2. 第一个Spring程序"></a>2. 第一个Spring程序</h2><h3 id="2-1-软件版本"><a href="#2-1-软件版本" class="headerlink" title="2.1 软件版本"></a>2.1 软件版本</h3><ul><li><strong>JDK1.8+</strong></li><li><strong>Maven3.5+</strong></li><li><strong>IDEA2018+</strong></li><li><strong>SpringFramework 5.1.4</strong> </li></ul><h3 id="2-2-环境搭建"><a href="#2-2-环境搭建" class="headerlink" title="2.2 环境搭建"></a>2.2 环境搭建</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>Spring的配置文件</p><ul><li>配置文件的放置位置：任意位置</li><li>配置文件的命名 <ul><li>建议：<code>applicationContext.xml</code></li></ul></li></ul><p>日后应用Spring框架时，需要进行配置文件路径的设置</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200413114751707.png" alt="image-20200413114751707"></p><h3 id="2-3-Spring的核心API"><a href="#2-3-Spring的核心API" class="headerlink" title="2.3 Spring的核心API"></a>2.3 Spring的核心API</h3><p><code>ApplicationContext</code></p><ul><li>作用：Spring提供的ApplicationContext这个工厂，用于对象的创建</li><li>好处：解耦合</li></ul><p><strong>ApplicationContext接口类型</strong></p><ul><li>接口：屏蔽实现的差异</li><li>非web环境 ： <code>ClassPathXmlApplicationContext (main junit)</code></li><li>web环境  ： <code> XmlWebApplicationContext</code></li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200413142452724.png" alt="image-20200413142452724"></p><p><strong>重量级资源</strong></p><ul><li>ApplicationContext工厂的对象占用大量内存</li><li>不会频繁的创建对象 ： 一个应用只会创建一个工厂对象</li><li>ApplicationContext工厂：一定是线程安全的(多线程并发访问)</li></ul><h3 id="2-4-程序开发"><a href="#2-4-程序开发" class="headerlink" title="2.4 程序开发"></a>2.4 程序开发</h3><p>创建类型，配置文件的配置 <code>applicationContext.xml</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.basic.Person&quot;</span>/&gt;</span></code></pre></div><p> 通过工厂类，获得对象<code>ApplicationContext</code>与<code>ClassPathXmlApplicationContext</code></p><div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);Person person = (Person)ctx.getBean(<span class="hljs-string">&quot;person&quot;</span>);</code></pre></div><h3 id="2-5-细节分析"><a href="#2-5-细节分析" class="headerlink" title="2.5 细节分析"></a>2.5 细节分析</h3><p><strong>名词解释</strong></p><blockquote><p>Spring工厂创建的对象，叫做bean或者组件(componet)        </p></blockquote><p><strong>Spring工厂的相关的方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//通过这种方式获得对象，就不需要强制类型转换</span>Person person = ctx.getBean(<span class="hljs-string">&quot;person&quot;</span>, Person.class);System.out.println(<span class="hljs-string">&quot;person = &quot;</span> + person);        <span class="hljs-comment">//当前Spring的配置文件中 只能有一个&lt;bean class是Person类型</span>Person person = ctx.getBean(Person.class);System.out.println(<span class="hljs-string">&quot;person = &quot;</span> + person);        <span class="hljs-comment">//获取的是 Spring工厂配置文件中所有bean标签的id值  person person1</span>String[] beanDefinitionNames = ctx.getBeanDefinitionNames();<span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;  System.out.println(<span class="hljs-string">&quot;beanDefinitionName = &quot;</span> + beanDefinitionName);&#125;        <span class="hljs-comment">//根据类型获得Spring配置文件中对应的id值</span>String[] beanNamesForType = ctx.getBeanNamesForType(Person.class);<span class="hljs-keyword">for</span> (String id : beanNamesForType) &#123;  System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);&#125;        <span class="hljs-comment">//用于判断是否存在指定id值得bean</span><span class="hljs-keyword">if</span> (ctx.containsBeanDefinition(<span class="hljs-string">&quot;a&quot;</span>)) &#123;  System.out.println(<span class="hljs-string">&quot;true = &quot;</span> + <span class="hljs-keyword">true</span>);&#125;<span class="hljs-keyword">else</span>&#123;  System.out.println(<span class="hljs-string">&quot;false = &quot;</span> + <span class="hljs-keyword">false</span>);&#125;      <span class="hljs-comment">//用于判断是否存在指定id值得bean</span><span class="hljs-keyword">if</span> (ctx.containsBean(<span class="hljs-string">&quot;person&quot;</span>)) &#123;  System.out.println(<span class="hljs-string">&quot;true = &quot;</span> + <span class="hljs-keyword">true</span>);&#125;<span class="hljs-keyword">else</span>&#123;  System.out.println(<span class="hljs-string">&quot;false = &quot;</span> + <span class="hljs-keyword">false</span>);&#125;</code></pre></div><p><strong>配置文件中需要注意的细节</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 只配置class属性</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.basic.Person&quot;</span>/&gt;</span></span><span class="hljs-bullet">1.</span> 上述这种配置 有id值com.baizhiedu.basic.Person#0<span class="hljs-bullet">2.</span> 如果这个bean只需要使用一次，那么就可以省略id值<span class="hljs-code"> 如果这个bean会使用多次，或者被其他bean引用则需要设置id值</span><span class="hljs-code"></span><span class="hljs-code"># 2. name属性</span><span class="hljs-code">作用：用于在Spring的配置文件中，为bean对象定义别名(小名)</span><span class="hljs-code">相同：</span><span class="hljs-code">   1. ctx.getBean(&quot;id|name&quot;)--&gt;object</span><span class="hljs-code">   </span><span class="hljs-code">   2. &lt;bean id=&quot;&quot; class=&quot;&quot;</span><span class="hljs-code">      等效</span><span class="hljs-code">      &lt;bean name=&quot;&quot; class=&quot;&quot;</span><span class="hljs-code">区别：</span><span class="hljs-code">   1. 别名可以定义多个,但是id属性只能有一个值</span><span class="hljs-code">   </span><span class="hljs-code">   2. XML的id属性的值，以前命名要求：必须以字母开头，字母 数字 下划线 连字符 不能以特殊字符开头 如/person</span><span class="hljs-code">      name属性的值，命名没有要求 如/person</span><span class="hljs-code">      name属性会应用在特殊命名的场景下</span><span class="hljs-code">      XML发展到了今天：ID属性的限制，不存在 可以使用/person</span><span class="hljs-code">   </span><span class="hljs-code">   3. 代码</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">  <span class="hljs-comment">//用于判断是否存在指定id值得bean,不能判断name值    </span><span class="hljs-keyword">if</span> (ctx.containsBeanDefinition(<span class="hljs-string">&quot;person&quot;</span>)) &#123;          System.out.println(<span class="hljs-string">&quot;true = &quot;</span> + <span class="hljs-keyword">true</span>);      &#125;<span class="hljs-keyword">else</span>&#123;          System.out.println(<span class="hljs-string">&quot;false = &quot;</span> + <span class="hljs-keyword">false</span>);      &#125;  <span class="hljs-comment">//用于判断是否存在指定id值得bean,也可以判断name值</span>  <span class="hljs-keyword">if</span> (ctx.containsBean(<span class="hljs-string">&quot;p&quot;</span>)) &#123;      System.out.println(<span class="hljs-string">&quot;true = &quot;</span> + <span class="hljs-keyword">true</span>);  &#125;<span class="hljs-keyword">else</span>&#123;      System.out.println(<span class="hljs-string">&quot;false = &quot;</span> + <span class="hljs-keyword">false</span>);  &#125;</code></pre></div><h3 id="2-6-Spring工厂的底层实现原理-简易版"><a href="#2-6-Spring工厂的底层实现原理-简易版" class="headerlink" title="2.6 Spring工厂的底层实现原理(简易版)"></a>2.6 Spring工厂的底层实现原理(简易版)</h3><p>Spring工厂是可以<strong>调用对象私有的构造方法</strong>创建对象</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200415113032782.png" alt="image-20200415113032782"></p><h3 id="2-7-思考"><a href="#2-7-思考" class="headerlink" title="2.7 思考"></a>2.7 思考</h3><p>问题：未来在开发过程中，是不是所有的对象，都会交给Spring工厂来创建呢？<br>回答：理论上 是的，但是有特例 ：<strong>实体对象(entity)是不会交给Spring创建</strong>，它是由持久层框架进行创建</p><h2 id="3-Spring5-x与日志框架的整合"><a href="#3-Spring5-x与日志框架的整合" class="headerlink" title="3. Spring5.x与日志框架的整合"></a>3. Spring5.x与日志框架的整合</h2><blockquote><p>Spring与日志框架进行整合，日志框架就可以在控制台中，输出Spring框架运行过程中的一些重要的信息。<br>好处：便于了解Spring框架的运行过程，利于程序的调试</p></blockquote><p><strong>默认</strong></p><p>  Spring1.2.3早期都是于<code>commons-logging.jar</code><br>  Spring5.x默认整合的日志框架 <code>logback log4j2</code></p><p><strong>Spring5.x整合log4j</strong> </p><ul><li>引入<code>log4j jar</code>包</li><li>引入<code>log4.properties</code>配置文件</li></ul><p><code>pom</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><code>log4j.properties</code></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># resources文件夹根目录下</span><span class="hljs-comment">### 配置根</span><span class="hljs-meta">log4j.rootLogger</span> = <span class="hljs-string">debug,console</span><span class="hljs-comment">### 日志输出到控制台显示</span><span class="hljs-meta">log4j.appender.console</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-meta">log4j.appender.console.Target</span>=<span class="hljs-string">System.out</span><span class="hljs-meta">log4j.appender.console.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span></code></pre></div><h2 id="4-注入-Injection"><a href="#4-注入-Injection" class="headerlink" title="4. 注入(Injection)"></a>4. 注入(Injection)</h2><h3 id="4-1-什么是注入"><a href="#4-1-什么是注入" class="headerlink" title="4.1 什么是注入"></a>4.1 什么是注入</h3><blockquote><p>通过Spring工厂及配置文件，为所创建对象的成员变量赋值</p></blockquote><h4 id="4-1-1-为什么需要注入"><a href="#4-1-1-为什么需要注入" class="headerlink" title="4.1.1 为什么需要注入"></a>4.1.1 为什么需要注入</h4><p><strong>通过编码的方式，为成员变量进行赋值，存在耦合</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200415185212664.png" alt="image-20200415185212664"></p><h4 id="4-1-2-如何进行注入-开发步骤"><a href="#4-1-2-如何进行注入-开发步骤" class="headerlink" title="4.1.2 如何进行注入[开发步骤]"></a>4.1.2 如何进行注入[开发步骤]</h4><p>类的成员变量提供set get方法</p><p>配置spring的配置文件</p><div class="hljs code-wrapper"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.basic.Person&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>xiaojr<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>通过注入，达到<strong>解耦合</strong>的目的</p><h3 id="4-2-Spring注入的原理分析-简易版"><a href="#4-2-Spring注入的原理分析-简易版" class="headerlink" title="4.2 Spring注入的原理分析(简易版)"></a>4.2 Spring注入的原理分析(简易版)</h3><p><strong>Spring通过底层调用对象属性对应的set方法，完成成员变量的赋值，这种方式我们也称之为set注入</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200415191157364.png" alt="image-20200415191157364"></p><h2 id="5-Set注入详解"><a href="#5-Set注入详解" class="headerlink" title="5. Set注入详解"></a>5. Set注入详解</h2><p>针对于不同类型的成员变量，在<code>&lt;property&gt;</code>标签，需要嵌套其他标签</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>    xxxxx<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416090518713.png" alt="image-20200416090518713"></p><h3 id="5-1-JDK内置类型"><a href="#5-1-JDK内置类型" class="headerlink" title="5.1 JDK内置类型"></a>5.1 JDK内置类型</h3><p>在<code>&lt;property&gt;</code>标签里添加</p><h4 id="5-1-1-String-8种基本类型"><a href="#5-1-1-String-8种基本类型" class="headerlink" title="5.1.1 String+8种基本类型"></a>5.1.1 String+8种基本类型</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></code></pre></div><h4 id="5-1-2-数组"><a href="#5-1-2-数组" class="headerlink" title="5.1.2 数组"></a>5.1.2 数组</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns@zparkhr.com.cn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>liucy@zparkhr.com.cn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>chenyn@zparkhr.com.cn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span></code></pre></div><h4 id="5-1-3-Set集合"><a href="#5-1-3-Set集合" class="headerlink" title="5.1.3 Set集合"></a>5.1.3 Set集合</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>112222<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span># Set如果不加范性，可以存任何的标签<span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span></span>   &lt;set <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre></div><h4 id="5-1-4-List集合"><a href="#5-1-4-List集合" class="headerlink" title="5.1.4 List集合"></a>5.1.4 List集合</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span># 同理于set<span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span></span>   &lt;set <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span></code></pre></div><h4 id="5-1-5-Map集合"><a href="#5-1-5-Map集合" class="headerlink" title="5.1.5 Map集合"></a>5.1.5 Map集合</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">注意： map -- entry  -- key有特定的标签  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>                       值根据对应类型选择对应类型的标签<span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3434334343<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>chenyn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span></span>  &lt;/entry&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span></code></pre></div><h4 id="5-1-6-Properites"><a href="#5-1-6-Properites" class="headerlink" title="5.1.6 Properites"></a>5.1.6 Properites</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">Properties类型 特殊的Map key=String value=String <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;key1&quot;</span>&gt;</span>value1<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;key2&quot;</span>&gt;</span>value2<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span></code></pre></div><h4 id="5-1-7-复杂的JDK类型-Date"><a href="#5-1-7-复杂的JDK类型-Date" class="headerlink" title="5.1.7 复杂的JDK类型 (Date)"></a>5.1.7 复杂的JDK类型 (Date)</h4><p>需要程序员自定义类型转换器，处理</p><h3 id="5-2-用户自定义类型"><a href="#5-2-用户自定义类型" class="headerlink" title="5.2 用户自定义类型"></a>5.2 用户自定义类型</h3><h4 id="5-2-1-第一种方式"><a href="#5-2-1-第一种方式" class="headerlink" title="5.2.1 第一种方式"></a>5.2.1 第一种方式</h4><p>为成员变量提供<code>set get</code>方法</p><p>配置文件中进行注入(赋值)</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxxx.UserServiceImpl&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.UserDAOImpl&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="5-2-2-第二种方式"><a href="#5-2-2-第二种方式" class="headerlink" title="5.2.2 第二种方式"></a>5.2.2 第二种方式</h4><p>第一种赋值方式存在的问题</p><ul><li>配置文件代码冗余</li><li>被注入的对象<code>&lt;bean class=&quot;xxx.UserDAOImpl&quot;/&gt;</code>,多次创建，浪费内存资源</li></ul><p>为成员变量提供<code>set get</code>方法</p><p>配置文件中进行配置</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.UserDAOImpl&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.UserServiceImpl&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>#Spring4.x 废除了 <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">local</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span> 基本等效 <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span></code></pre></div><h3 id="5-3-Set注入的简化写法"><a href="#5-3-Set注入的简化写法" class="headerlink" title="5.3 Set注入的简化写法"></a>5.3 Set注入的简化写法</h3><h4 id="5-3-1-基于属性简化"><a href="#5-3-1-基于属性简化" class="headerlink" title="5.3.1 基于属性简化"></a>5.3.1 基于属性简化</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">JDK类型注入 <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>替换为<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;suns&quot;</span>/&gt;</span>注意：value属性 只能简化 8种基本类型+String 注入标签用户自定义类型<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>替换为<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span></code></pre></div><h4 id="5-3-2-基于p命名空间简化"><a href="#5-3-2-基于p命名空间简化" class="headerlink" title="5.3.2 基于p命名空间简化"></a>5.3.2 基于p命名空间简化</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">JDK类型注入 <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxxx.Person&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>替换为<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.Person&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;suns&quot;</span> <span class="hljs-attr">p:id</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span>注意：value属性 只能简化 8种基本类型+String 注入标签用户自定义类型<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xx.UserServiceImpl&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>替换为<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.UserServiceImpl&quot;</span> <span class="hljs-attr">p:userDAO-ref</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span></code></pre></div><h2 id="6-构造注入"><a href="#6-构造注入" class="headerlink" title="6 构造注入"></a>6 构造注入</h2><ul><li>注入：通过Spring的配置文件，为成员变量赋值</li><li>Set注入：Spring调用Set方法 通过配置文件 为成员变量赋值</li><li>构造注入：Spring调用构造方法 通过配置文件 为成员变量赋值</li></ul><h3 id="6-1-开发步骤"><a href="#6-1-开发步骤" class="headerlink" title="6.1 开发步骤"></a>6.1 开发步骤</h3><p>提供有参构造方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre></div><p>Spring的配置文件</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.basic.constructer.Customer&quot;</span>&gt;</span> 有两个参数，需要两个构造标签  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>102<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h3 id="6-2-构造方法重载"><a href="#6-2-构造方法重载" class="headerlink" title="6.2 构造方法重载"></a>6.2 构造方法重载</h3><h4 id="6-2-1-参数个数不同时"><a href="#6-2-1-参数个数不同时" class="headerlink" title="6.2.1 参数个数不同时"></a>6.2.1 参数个数不同时</h4><p>通过控制<code>&lt;constructor-arg&gt;</code>标签的数量进行区分 </p><h4 id="6-2-2-构造参数个数相同时"><a href="#6-2-2-构造参数个数相同时" class="headerlink" title="6.2.2 构造参数个数相同时"></a>6.2.2 构造参数个数相同时</h4><p>通过在标签引入 type属性 进行类型的区分<code> &lt;constructor-arg type=&quot;&quot;&gt;</code></p><h3 id="6-3-注入的总结"><a href="#6-3-注入的总结" class="headerlink" title="6.3 注入的总结"></a>6.3 注入的总结</h3><p>未来的实战中，应用set注入还是构造注入？</p><p>答案：<strong>set注入更多</strong><br>       1. 构造注入麻烦 (重载)<br>              2. Spring框架底层 大量应用了 set注入</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416155620897.png" alt="image-20200416155620897"></p><h2 id="7-反转控制与依赖注入"><a href="#7-反转控制与依赖注入" class="headerlink" title="7. 反转控制与依赖注入"></a>7. 反转控制与依赖注入</h2><h3 id="7-1-反转-转移-控制-IOC-Inverse-of-Control"><a href="#7-1-反转-转移-控制-IOC-Inverse-of-Control" class="headerlink" title="7.1 反转(转移)控制(IOC Inverse of Control)"></a>7.1 反转(转移)控制(IOC Inverse of Control)</h3><ul><li>控制：对于成员<strong>变量赋值</strong>的控制权</li><li>反转控制：把对于成员变量赋值的控制权，从代码中<strong>反转(转移)到Spring工厂和配置文件</strong>中完成<ul><li>好处：解耦合</li></ul></li><li>底层实现：工厂设计模式</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416161127972.png" alt="image-20200416161127972"></p><h3 id="7-2-依赖注入-Dependency-Injection-DI"><a href="#7-2-依赖注入-Dependency-Injection-DI" class="headerlink" title="7.2 依赖注入 (Dependency Injection  DI)"></a>7.2 依赖注入 (Dependency Injection  DI)</h3><ul><li><p>注入：通过Spring的工厂及配置文件，为对象（bean，组件）的成员变量赋值</p></li><li><p>依赖注入：当一个类需要另一个类时，就意味着依赖，一旦出现依赖，就可以把另一个类作为本类的成员变量，最终通过Spring配置文件进行注入(赋值)</p><ul><li> 好处：解耦合</li></ul></li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416162615816.png" alt="image-20200416162615816"></p><h2 id="8-Spring工厂创建复杂对象"><a href="#8-Spring工厂创建复杂对象" class="headerlink" title="8. Spring工厂创建复杂对象"></a>8. Spring工厂创建复杂对象</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416164044047.png" alt="image-20200416164044047"></p><h3 id="8-1-什么是复杂对象"><a href="#8-1-什么是复杂对象" class="headerlink" title="8.1 什么是复杂对象"></a>8.1 什么是复杂对象</h3><blockquote><p>复杂对象：指的就是不能直接通过new构造方法创建的对象</p></blockquote><ul><li>Connection</li><li>SqlSessionFactory</li></ul><h3 id="8-2-Spring工厂创建复杂对象的3种方式"><a href="#8-2-Spring工厂创建复杂对象的3种方式" class="headerlink" title="8.2 Spring工厂创建复杂对象的3种方式"></a>8.2 Spring工厂创建复杂对象的3种方式</h3><h4 id="8-2-1-FactoryBean接口"><a href="#8-2-1-FactoryBean接口" class="headerlink" title="8.2.1 FactoryBean接口"></a>8.2.1 FactoryBean接口</h4><p><strong>开发步骤</strong></p><ul><li><p>实现FactoryBean接口 <img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416204458451.png" alt="image-20200416204458451"></p></li><li><p>Spring配置文件的配置</p><p>如果Class中指定的类型是<code>FactoryBean</code>接口的实现类，那么通过id值获得的是这个类所创建的复杂对象  <code>Connection</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conn&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.factorybean.ConnectionFactoryBean&quot;</span>/&gt;</span></code></pre></div></li><li><p>细节</p><ul><li><p>如果就想获得<code>FactoryBean</code>类型的对象<code>ctx.getBean(&quot;&amp;conn&quot;)</code>获得就是<code>ConnectionFactoryBean</code>对象</p></li><li><p><code>isSingleton</code>方法 返回  true 只会创建一个复杂对象</p><ul><li>返回 false 每一次都会创建新的对象 问题：根据这个对象的特点 ，决定是返回<code>true (SqlSessionFactory) </code>还是<code> false  (Connection)</code></li><li>如果是连接对象<code>Connection</code>，需要返回false，因为会出现并发问题</li></ul></li><li><p>mysql高版本连接创建时，需要制定SSL证书，解决问题的方式</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">url</span> = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/suns?useSSL=false&quot;</span></code></pre></div></li><li><p>依赖注入的体会(DI)</p><p>把<code>ConnectionFactoryBean</code>中依赖的4个字符串信息 ，进行配置文件的注入<br>好处：解耦合</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conn&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.factorybean.ConnectionFactoryBean&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/suns?useSSL=false&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div></li></ul></li></ul><p><strong>FactoryBean的实现原理[简易版]</strong></p><p>接口回调</p><ul><li>为什么Spring规定<code>FactoryBean</code>接口 实现 并且<code> getObject()</code>?</li><li><code>ctx.getBean(&quot;conn&quot;) </code>获得是复杂对象 <code>Connection</code> 而没有获得 <code>ConnectionFactoryBean(&amp;)</code></li></ul><p>Spring内部运行流程</p><ul><li>通过conn获得 <code>ConnectionFactoryBean</code>类的对象 ，进而通过<code>instanceof </code>判断出是<code>FactoryBean</code>接口的实现类</li><li>Spring按照规定 <code>getObject() ---&gt; Connection</code></li><li>返回<code>Connection </code></li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200417114723005.png" alt="image-20200417114723005"></p><p><strong>FactoryBean总结</strong></p><p>Spring中用于创建复杂对象的一种方式，也是Spring原生提供的，后续讲解Spring整合其他框架，大量应用<code>FactoryBean</code></p><h4 id="8-2-2-实例工厂"><a href="#8-2-2-实例工厂" class="headerlink" title="8.2.2 实例工厂"></a>8.2.2 实例工厂</h4><ul><li>避免Spring框架的侵入，如果以后用其他框架，会被Spring框架所束缚</li><li>整合遗留系统 </li></ul><p><strong>开发步骤</strong></p><p>遗留的ConnectionFactory类</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;        Connection conn = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring?useSSL=false&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> conn;    &#125;&#125;</code></pre></div><p>直接用配置文件整合</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;connFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.factorybean.ConnectionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conn&quot;</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;connFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getConnection&quot;</span>/&gt;</span></code></pre></div><h4 id="8-2-3-静态工厂"><a href="#8-2-3-静态工厂" class="headerlink" title="8.2.3 静态工厂"></a>8.2.3 静态工厂</h4><p>原先是</p><div class="hljs code-wrapper"><pre><code class="hljs java">ConnectionFactory cf = <span class="hljs-keyword">new</span> ConnectionFactory();cf.getConnection();</code></pre></div><p>静态工厂是</p><div class="hljs code-wrapper"><pre><code class="hljs java">staticFactoryBean.getConnection();</code></pre></div><p><strong>开发步骤</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticFactoryBean</span> </span>&#123;<span class="hljs-comment">// 静态方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;        Connection conn = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring?useSSL=false&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> conn;    &#125;&#125;</code></pre></div><p>配置文件</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conn&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.factorybean.StaticConnectionFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getConnection&quot;</span>/&gt;</span></code></pre></div><h3 id="8-3-Spring工厂创建对象的总结"><a href="#8-3-Spring工厂创建对象的总结" class="headerlink" title="8.3 Spring工厂创建对象的总结"></a>8.3 Spring工厂创建对象的总结</h3><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200417152030222.png" alt="image-20200417152030222"></p><h2 id="9-控制Spring工厂创建对象的次数"><a href="#9-控制Spring工厂创建对象的次数" class="headerlink" title="9. 控制Spring工厂创建对象的次数"></a>9. 控制Spring工厂创建对象的次数</h2><h3 id="9-1-如何控制简单对象的创建次数"><a href="#9-1-如何控制简单对象的创建次数" class="headerlink" title="9.1 如何控制简单对象的创建次数"></a>9.1 如何控制简单对象的创建次数</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton|prototype&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxxx.Account&quot;</span>/&gt;</span>&lt;sigleton:只会创建一次简单对象默认值&gt;默认&lt;prototype:每一次都会创建新的对象&gt;</code></pre></div><h3 id="9-2-如何控制复杂对象的创建次数"><a href="#9-2-如何控制复杂对象的创建次数" class="headerlink" title="9.2 如何控制复杂对象的创建次数"></a>9.2 如何控制复杂对象的创建次数</h3><div class="hljs code-wrapper"><pre><code class="hljs java">FactoryBean&#123;   isSingleton()&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>  只会创建一次      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span> 每一次都会创建新的   &#125;&#125;</code></pre></div><p>如没有isSingleton方法 还是通过scope属性 进行对象创建次数的控制</p><h3 id="9-3-为什么要控制对象的创建次数？"><a href="#9-3-为什么要控制对象的创建次数？" class="headerlink" title="9.3 为什么要控制对象的创建次数？"></a>9.3 为什么要控制对象的创建次数？</h3><blockquote><p>好处：节省不别要的内存浪费 </p></blockquote><ul><li><p>什么样的对象只创建一次？</p><ul><li>SqlSessionFactory</li><li>DAO</li><li>Service</li></ul></li><li><p>什么样的对象 每一次都要创建新的？</p><ul><li>Connection</li><li>SqlSession | Session</li><li>Struts2 Action</li></ul></li></ul><h1 id="第二章、Spring工厂高级特性"><a href="#第二章、Spring工厂高级特性" class="headerlink" title="第二章、Spring工厂高级特性"></a>第二章、Spring工厂高级特性</h1><h2 id="1、对象的生命周期"><a href="#1、对象的生命周期" class="headerlink" title="1、对象的生命周期"></a>1、对象的生命周期</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200418155427918.png" alt="image-20200418155427918"></p><h3 id="1-1-什么是对象的生命周期"><a href="#1-1-什么是对象的生命周期" class="headerlink" title="1.1 什么是对象的生命周期"></a>1.1 什么是对象的生命周期</h3><blockquote><p>指的是一个对象创建、存活、消亡的一个完整过程</p></blockquote><h3 id="1-2-为什么要学习对象的生命周期"><a href="#1-2-为什么要学习对象的生命周期" class="headerlink" title="1.2 为什么要学习对象的生命周期"></a>1.2 为什么要学习对象的生命周期</h3><blockquote><p>由Spring负责对象的创建、存活、销毁，了解生命周期，有利于我们使用好Spring为我们创建的对象</p></blockquote><h3 id="1-3-生命周期的3个阶段"><a href="#1-3-生命周期的3个阶段" class="headerlink" title="1.3 生命周期的3个阶段"></a>1.3 生命周期的3个阶段</h3><h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><p>Spring工厂何时创建对象</p><ul><li><p>scope=”singleton”</p><ul><li>Spring工厂创建的同时，对象的创建</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">注意：设置scope=singleton 这种情况下 也需要在获取对象的同时，创建对象，加上标签 &lt;bean lazy-init=<span class="hljs-string">&quot;true&quot;</span>/&gt;</code></pre></div></li><li><p>scope=”prototype”</p><ul><li>Spring工厂会在获取对象的同时，创建对象</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">ctx.getBean(<span class="hljs-string">&quot;&quot;</span>)</code></pre></div></li></ul><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a><strong>初始化阶段</strong></h4><p>Spring工厂在创建完对象后，调用对象的初始化方法，完成对应的初始化操作</p><ol><li>初始化方法提供：程序员根据需求，提供初始化方法，最终完成初始化操作</li><li>初始化方法调用：Spring工厂进行调用</li></ol><ul><li><p>InitializingBean接口</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//程序员根据需求，实现的方法，完成初始化操作</span>implements InitializingBean  <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterProperitesSet</span><span class="hljs-params">()</span></span>&#123;  &#125;</code></pre></div></li><li><p>对象中提供一个普通的方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myInit</span><span class="hljs-params">()</span></span>&#123;  &#125;&lt;bean id=<span class="hljs-string">&quot;product&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;xxx.Product&quot;</span> init-method=<span class="hljs-string">&quot;myInit&quot;</span>/&gt;</code></pre></div></li><li><p>细节分析</p><ul><li><p>如果一个对象即实现InitializingBean 同时又提供的 普通的初始化方法  顺序</p><ul><li>InitializingBean </li><li>普通初始化方法</li></ul></li><li><p><strong>注入一定发生在初始化操作的前面</strong></p><ul><li><p>什么叫做初始化操作</p><blockquote><p>资源的初始化：数据库 IO 网络 …..</p></blockquote></li></ul></li></ul></li></ul><h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a><strong>销毁阶段</strong></h4><blockquote><p>Spring销毁对象前，会调用对象的销毁方法，完成销毁操作</p></blockquote><ol><li>Spring什么时候销毁所创建的对象？<br><code>ctx.close();</code></li><li>销毁方法：程序员根据自己的需求，定义销毁方法，完成销毁操作<br>   调用：Spring工厂完成调用</li></ol><ul><li><p>DisposableBean</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;  &#125;</code></pre></div></li><li><p>定义一个普通的销毁方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myDestroy</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;&#125;&lt;bean id=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;&quot;</span> init-method=<span class="hljs-string">&quot;&quot;</span> destroy-method=<span class="hljs-string">&quot;myDestroy&quot;</span>/&gt;</code></pre></div></li><li><p>细节分析</p><ul><li><p>销毁方法的操作只适用于<code> scope=&quot;singleton&quot;</code></p></li><li><p>什么叫做销毁操作</p><blockquote><p>主要指的就是 资源的释放操作  io.close()     connection.close();</p></blockquote></li></ul></li></ul><h2 id="2-配置文件参数化"><a href="#2-配置文件参数化" class="headerlink" title="2. 配置文件参数化"></a>2. 配置文件参数化</h2><blockquote><p>把Spring配置文件中需要经常修改的字符串信息，转移到一个更小的配置文件中</p></blockquote><ul><li>Spring的配置文件中存在需要经常修改的字符串？<br> 存在 以数据库连接相关的参数 代表</li><li>经常变化字符串，在Spring的配置文件中，直接修改<br> 不利于项目维护(修改)</li><li>转移到一个小的配置文件(.properties)<br> 利于维护(修改)</li></ul><p>配置文件参数化：利于Spring配置文件的维护(修改)</p><h3 id="配置文件参数的开发步骤"><a href="#配置文件参数的开发步骤" class="headerlink" title="配置文件参数的开发步骤"></a>配置文件参数的开发步骤</h3><p>提供一个小的配置文件<code>(.properities)</code></p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">名字：随便</span><span class="hljs-attr">放置位置：随便</span><span class="hljs-meta">jdbc.driverClassName</span> = <span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-meta">jdbc.url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/suns?useSSL=false</span><span class="hljs-meta">jdbc.username</span> = <span class="hljs-string">root</span><span class="hljs-meta">jdbc.password</span> = <span class="hljs-string">123456</span></code></pre></div><p>Spring的配置文件与小配置文件进行整合</p><p><code>applicationContext.xml</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:/db.properties&quot;</span>/&gt;</span></code></pre></div><p>在Spring配置文件中通过<code>$&#123;key&#125;</code>获取小配置文件中对应的值<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200418171133796.png" alt="image-20200418171133796"></p><h2 id="3-自定义类型转换器"><a href="#3-自定义类型转换器" class="headerlink" title="3. 自定义类型转换器"></a>3. 自定义类型转换器</h2><h3 id="3-1-类型转换器"><a href="#3-1-类型转换器" class="headerlink" title="3.1 类型转换器"></a>3.1 类型转换器</h3><blockquote><p>作用：Spring通过类型转换器把配置文件中字符串类型的数据，转换成了对象中成员变量对应类型的数据，进而完成了注入</p></blockquote><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200418201732220.png" alt="image-20200418201732220"></p><h3 id="3-2-自定义类型转换器"><a href="#3-2-自定义类型转换器" class="headerlink" title="3.2 自定义类型转换器"></a>3.2 自定义类型转换器</h3><blockquote><p>原因：当Spring内部没有提供特定类型转换器时，而程序员在应用的过程中还需要使用，那么就需要程序员自己定义类型转换器</p></blockquote><p><strong>类 implements Converter接口</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;   <span class="hljs-comment">/*</span><span class="hljs-comment">       convert方法作用：String ---&gt;  Date</span><span class="hljs-comment">                      SimpleDateFormat sdf = new SimpleDateFormat();</span><span class="hljs-comment">                      sdf.parset(String) ---&gt; Date</span><span class="hljs-comment">       param:source 代表的是配置文件中 日期字符串 &lt;value&gt;2020-10-11&lt;/value&gt;</span><span class="hljs-comment"></span><span class="hljs-comment">       return : 当把转换好的Date作为convert方法的返回值后，Spring自动的为birthday属性进行注入（赋值）</span><span class="hljs-comment"></span><span class="hljs-comment">     */</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String source)</span> </span>&#123;    Date date = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;      SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);      date = sdf.parse(source);    &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;      e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> date;  &#125;&#125;</code></pre></div><p><strong>在Spring的配置文件中进行配置</strong></p><ul><li>MyDateConverter对象创建出来</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDateConverter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxxx.MyDateConverter&quot;</span>/&gt;</span></code></pre></div><ul><li><p>类型转换器的注册</p><p>目的：告知Spring框架，我们所创建的MyDateConverter是一个类型转换器</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--用于注册类型转换器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversionService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;converters&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;myDateConverter&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h3 id="3-3-细节"><a href="#3-3-细节" class="headerlink" title="3.3 细节"></a>3.3 细节</h3><p>MyDateConverter中的日期的格式，通过依赖注入的方式，由配置文件完成赋值</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> String pattern;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPattern</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> pattern;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPattern</span><span class="hljs-params">(String pattern)</span> </span>&#123;        <span class="hljs-keyword">this</span>.pattern = pattern;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">       convert方法作用：String ---&gt;  Date</span><span class="hljs-comment">                      SimpleDateFormat sdf = new SimpleDateFormat();</span><span class="hljs-comment">                      sdf.parset(String) ---&gt; Date</span><span class="hljs-comment">       param:source 代表的是配置文件中 日期字符串 &lt;value&gt;2020-10-11&lt;/value&gt;</span><span class="hljs-comment"></span><span class="hljs-comment">       return : 当把转换好的Date作为convert方法的返回值后，Spring自动的为birthday属性进行注入（赋值）</span><span class="hljs-comment"></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String source)</span> </span>&#123;        Date date = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(pattern);            date = sdf.parse(source);        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> date;    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Spring创建MyDateConverter类型对象--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDateConverter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.converter.MyDateConverter&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p><code>ConversionSeviceFactoryBean </code><strong>定义 id属性 值必须</strong> <code>conversionService </code></p><p>Spring框架内置日期类型的转换器</p><div class="hljs code-wrapper"><pre><code class="hljs markdown">日期格式：2020/05/01 (不支持 ：2020-05-01)</code></pre></div><h2 id="4-后置处理Bean"><a href="#4-后置处理Bean" class="headerlink" title="4. 后置处理Bean"></a>4. 后置处理Bean</h2><blockquote><p>BeanPostProcessor作用：对Spring工厂所创建的对象，进行再加工</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs markdown">AOP底层实现：注意：BeanPostProcessor接口<span class="hljs-code">          xxxx()&#123;</span><span class="hljs-code">                 </span><span class="hljs-code">          &#125;</span></code></pre></div><p><strong>后置处理Bean的运行原理分析</strong><br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200420155053027.png" alt="image-20200420155053027"></p><p>程序员实现BeanPostProcessor规定接口中的方法：</p><ul><li><p><code>Object postProcessBeforeInitiallization(Object bean String beanName)</code><br>作用：Spring创建完对象，并进行注入后，可以运行Before方法进行加工<br>获得Spring创建好的对象 ：通过方法的参数<br>最终通过返回值交给Spring框架 </p></li><li><p><code>Object postProcessAfterInitiallization(Object bean String beanName)</code><br>作用：Spring执行完对象的初始化操作后，可以运行After方法进行加工<br>获得Spring创建好的对象 ：通过方法的参数<br>最终通过返回值交给Spring框架 </p></li></ul><p>实战中：</p><ul><li><strong>很少处理Spring的初始化操作</strong>：没有必要区分Before After。<strong>只需要实现其中的一个After方法</strong>即可<br>注意：<div class="hljs code-wrapper"><pre><code>`postProcessBeforeInitiallization``return bean`对象</code></pre></div></li></ul><p><strong>BeanPostProcessor的开发步骤</strong></p><ul><li>类 实现 BeanPostProcessor接口</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        Categroy categroy = (Categroy) bean;        categroy.setName(<span class="hljs-string">&quot;xiaowb&quot;</span>);        <span class="hljs-keyword">return</span> categroy;    &#125;&#125;</code></pre></div><ul><li>Spring的配置文件中进行配置</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBeanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.MyBeanPostProcessor&quot;</span>/&gt;</span></code></pre></div><ul><li>BeanPostProcessor细节</li></ul><p> BeanPostProcessor会对Spring工厂中所有创建的对象进行加工，如果工厂创建了多个不同的对象，要注意区别传入的对象：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span>  Category) &#123;        Category category = (Category) bean;        category.setName(<span class="hljs-string">&quot;xwb&quot;</span>);        <span class="hljs-keyword">return</span> category;    &#125;    <span class="hljs-keyword">return</span> bean;&#125;</code></pre></div><h1 id="第三章、Spring-AOP"><a href="#第三章、Spring-AOP" class="headerlink" title="第三章、Spring AOP"></a>第三章、Spring AOP</h1><h2 id="1-静态代理设计模式"><a href="#1-静态代理设计模式" class="headerlink" title="1. 静态代理设计模式"></a>1. 静态代理设计模式</h2><h3 id="1-1-为什么需要代理设计模式"><a href="#1-1-为什么需要代理设计模式" class="headerlink" title="1.1 为什么需要代理设计模式"></a>1.1 为什么需要代理设计模式</h3><p>在JavaEE分层开发开发中，那个层次对于我们来讲最重要?</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">DAO</span> <span class="hljs-string">---&gt; Service --&gt; Controller </span><span class="hljs-attr">JavaEE分层开发中，最为重要的是Service层</span></code></pre></div><p>Service 层中包含了哪些代码？</p><ul><li><strong>核心功能</strong>（代码量较多）：业务运算，DAO 调用</li><li><strong>额外功能</strong>（附加功能，不属于业务，可有可无，代码量小）：事务、日志、性能 …</li></ul><p>额外功能书写在 Service 层好不好?</p><ul><li>Service 层的调用者的角度（Controller)：需要在 Service 层书写额外功能</li><li>软件设计者：Service 层不需要额外功能</li></ul><p> 拿现实生活中的例子来做对比，解决方案是 <strong>引入一个代理</strong><br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200422110206172.png" alt="image-20200422110206172"></p><h3 id="1-2-代理设计模式"><a href="#1-2-代理设计模式" class="headerlink" title="1.2 代理设计模式"></a>1.2 代理设计模式</h3><h4 id="1-2-1-概念"><a href="#1-2-1-概念" class="headerlink" title="1.2.1 概念"></a>1.2.1 概念</h4><blockquote><p>通过代理类，为原始类（目标）增加额外的功能<br>好处：利于原始类(目标)的维护</p></blockquote><h4 id="1-2-2-名词解释"><a href="#1-2-2-名词解释" class="headerlink" title="1.2.2 名词解释"></a>1.2.2 名词解释</h4><p><strong>目标类 / 原始类</strong>：指的是 <strong>业务类</strong> (核心功能 –&gt; 业务运算、DAO调用)<br><strong>目标方法 / 原始方法</strong>：目标类（原始类）中的方法就是目标方法（原始方法）<br><strong>额外功能 / 附加功能</strong>：日志、事务、性能 …</p><h4 id="1-2-3-代理开发的核心要素"><a href="#1-2-3-代理开发的核心要素" class="headerlink" title="1.2.3 代理开发的核心要素"></a>1.2.3 代理开发的核心要素</h4><div class="hljs code-wrapper"><pre><code class="hljs java">代理类 = 目标类(原始类) + 额外功能 + 原始类(目标类)实现相同的接口房东 ---&gt; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span></span>&#123;               m1               m2          &#125;          UserServiceImpl implements UserService&#123;               m1 ---&gt; 业务运算 DAO调用               m2           &#125;中介 --- 代理类：要实现目标类相同的接口          UserServiceProxy implements UserService               m1               m2</code></pre></div><h4 id="1-2-4-编码"><a href="#1-2-4-编码" class="headerlink" title="1.2.4 编码"></a>1.2.4 编码</h4><p><strong>静态代理</strong>：为每一个原始类，手工编写一个代理类 (.java .class)</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span></span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.register 业务运算 + DAO&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.login 业务运算 + DAO&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><p><strong>代理类中必须有原始类</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200422114654195.png" alt="image-20200422114654195"></p><h4 id="1-2-5-静态代理存在的问题"><a href="#1-2-5-静态代理存在的问题" class="headerlink" title="1.2.5 静态代理存在的问题"></a>1.2.5 静态代理存在的问题</h4><ul><li><strong>静态类文件数量过多，不利于项目管理</strong><br><code>UserServiceImpl</code>、<code>UserServiceProxy</code><br><code>OrderServiceImpl</code>、<code>OrderServiceProxy</code><br>…</li><li><strong>额外功能维护性差</strong>：在代理类中修改额外功能较为麻烦</li></ul><h2 id="2-Spring的动态代理开发"><a href="#2-Spring的动态代理开发" class="headerlink" title="2. Spring的动态代理开发"></a>2. Spring的动态代理开发</h2><h3 id="2-1-Spring动态代理的概念"><a href="#2-1-Spring动态代理的概念" class="headerlink" title="2.1 Spring动态代理的概念"></a>2.1 Spring动态代理的概念</h3><blockquote><p>概念：通过代理类为原始类(目标类)增加额外功能<br>好处：利于原始类(目标类)的维护</p></blockquote><h3 id="2-2-搭建开发环境"><a href="#2-2-搭建开发环境" class="headerlink" title="2.2 搭建开发环境"></a>2.2 搭建开发环境</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjrt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="2-3-Spring动态代理的开发步骤"><a href="#2-3-Spring动态代理的开发步骤" class="headerlink" title="2.3 Spring动态代理的开发步骤"></a>2.3 Spring动态代理的开发步骤</h3><ul><li>创建原始对象(目标对象)</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span></span>;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.register 业务运算 + DAO&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.login 业务运算 + DAO&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.proxy.UserServiceImpl&quot;</span>/&gt;</span></code></pre></div><ul><li>额外功能<br>MethodBeforeAdvice接口</li></ul><p>额外的功能书写在接口的实现中，运行在原始方法执行之前运行额外功能</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Before</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 作用: 把需要运行在原始方法执行之前运行的额外功能, 书写在 before 方法中</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;---method before advice log---&quot;</span>);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.dynamic.Before&quot;</span>/&gt;</span></code></pre></div><ul><li>定义切入点</li></ul><blockquote><p>切入点：额外功能加入的位置</p><p>目的：由程序员根据自己的需要，决定额外功能加入给那个原始方法register、login</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 简单的测试：所有方法都做为切入点，都加入额外的功能 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *(..))&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></div><ul><li>组装 (2 3整合)</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/aop</span></span><span class="hljs-tag"><span class="hljs-string">                           https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.aop.UserServiceImpl&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 额外功能 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.aop.Before&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--切入点:额外功能的加入--&gt;</span>    <span class="hljs-comment">&lt;!--⽬的：由程序员根据⾃⼰的需要，决定额外功能加入给哪个原始方法(register、login)--&gt;</span>   <span class="hljs-comment">&lt;!-- 简单的测试：所有方法都做为切入点，都加入额外的功能--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* * (..))&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!--表达的含义: 所有的方法 都加入before的额外功能--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pc&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><ul><li>调用</li></ul><p>目的：获得 Spring 工厂创建的动态代理对象，并进行调用<br>注意： </p><ol><li>Spring 的工厂通过原始对象的 id 值获得的是代理对象</li><li>获得代理对象后，可以通过声明接口类型，进行对象的存储</li></ol><div class="hljs code-wrapper"><pre><code class="hljs java">目的：获得Spring工厂创建的动态代理对象，并进行调用  ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);注意：     <span class="hljs-number">1.</span> Spring的工厂通过原始对象的id值获得的是代理对象     <span class="hljs-number">2.</span> 获得代理对象后，可以通过声明接口类型，进行对象的存储     UserService userService=(UserService)ctx.getBean(<span class="hljs-string">&quot;userService&quot;</span>);userService.login(<span class="hljs-string">&quot;&quot;</span>);userService.register()</code></pre></div><h3 id="2-4-动态代理细节分析"><a href="#2-4-动态代理细节分析" class="headerlink" title="2.4 动态代理细节分析"></a>2.4 动态代理细节分析</h3><ul><li><strong>Spring创建的动态代理类在哪里？</strong></li></ul><blockquote><p>Spring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失</p><p>什么叫动态字节码技术:通过第三方动态字节码框架，在JVM中创建对应类的字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失</p><p>结论：动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理，类文件数量过多，影响项目管理的问题</p></blockquote><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200423165547079.png" alt="image-20200423165547079"></p><ul><li><strong>动态代理编程简化代理的开发</strong></li></ul><blockquote><p>在额外功能不改变的前提下，创建其他目标类（原始类）的代理对象时，只需要指定原始(目标)对象即可</p></blockquote><ul><li>动态代理额外功能的维护性大大增强</li></ul><h2 id="3-Spring动态代理详解"><a href="#3-Spring动态代理详解" class="headerlink" title="3. Spring动态代理详解"></a>3. Spring动态代理详解</h2><h3 id="3-1-额外功能的详解"><a href="#3-1-额外功能的详解" class="headerlink" title="3.1 额外功能的详解"></a>3.1 额外功能的详解</h3><ul><li><p>MethodBeforeAdvice分析</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Before</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 作用: 把需要运行在原始方法执行之前运行的额外功能, 书写在 before 方法中</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Method: 额外功能所增加给的那个原始方法</span><span class="hljs-comment">     *                          login</span><span class="hljs-comment">     *                          register</span><span class="hljs-comment">     *                          --------</span><span class="hljs-comment">     *                          showOrder</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Object[]:  额外功能所增加给的那个原始方法的参数</span><span class="hljs-comment">     *                          String name,String password</span><span class="hljs-comment">     *                          User</span><span class="hljs-comment">     *                          --------</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Object: 额外功能所增加给的那个原始对象</span><span class="hljs-comment">     *                          UserServiceImpl</span><span class="hljs-comment">     *                          ---------------</span><span class="hljs-comment">     *                          OrderServiceImpl</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;---new method before advice log---&quot;</span>);    &#125;&#125;</code></pre></div></li><li><p>MethodInterceptor(方法拦截器)</p><blockquote><p>methodinterceptor接口：额外功能可以根据需要运行在原始方法执行 前、后、前后</p></blockquote><ul><li>参数：<code>MethodInvocation</code>：额外功能所增加给的那个原始方法 (login, register)</li><li>返回值：<code>Object</code>：原始方法的返回值 (没有就返回 null)</li><li><code>invocation.proceed()</code>：原始方法运行</li></ul><p>额外功能运行在原始方法 <strong>之前</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Around</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;---额外功能运行在原始方法执行之前---&quot;</span>);        Object ret = methodInvocation.proceed(); <span class="hljs-comment">// 原始方法运行, 获取原始方法的返回值</span>        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre></div><p>额外功能运行在原始方法执行 <strong>之后</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Around</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        Object ret = methodInvocation.proceed(); <span class="hljs-comment">// 原始方法运行, 获取原始方法的返回值</span>        System.out.println(<span class="hljs-string">&quot;---额外功能运行在原始方法执行之后---&quot;</span>);        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre></div><p>额外功能运行在原始方法执行 <strong>之前，之后</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//常用于事务</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Around</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    System.out.println(<span class="hljs-string">&quot;---额外功能运行在原始方法执行之前---&quot;</span>);        Object ret = methodInvocation.proceed(); <span class="hljs-comment">// 原始方法运行, 获取原始方法的返回值</span>        System.out.println(<span class="hljs-string">&quot;---额外功能运行在原始方法执行之后---&quot;</span>);        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre></div><p>额外功能运行在原始方法抛出异常的时候</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Around</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        Object ret = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            ret = methodInvocation.proceed(); <span class="hljs-comment">// 原始方法运行, 获取原始方法的返回值</span>        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;            System.out.println(<span class="hljs-string">&quot;---额外功能运行在原始方法抛异常的时候---&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre></div><p>MethodInterceptor影响原始方法的返回值</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Around</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;---log---&quot;</span>);        Object ret = methodInvocation.proceed();      <span class="hljs-comment">//原始方法返回为true，这里设为false会影响</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div></li></ul><h3 id="3-2-切入点详解"><a href="#3-2-切入点详解" class="headerlink" title="3.2 切入点详解"></a>3.2 切入点详解</h3><p>切入点决定额外功能加入位置（方法）</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--execution(* * (..)) 匹配了所有方法--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* * (..))&quot;</span>/&gt;</span></code></pre></div><ul><li><code>execution()</code>：<strong>切入点函数</strong></li><li><code>* *(..)</code>：<strong>切入点表达式</strong></li></ul><h4 id="3-2-1-切入点表达式"><a href="#3-2-1-切入点表达式" class="headerlink" title="3.2.1 切入点表达式"></a>3.2.1 切入点表达式</h4><p>方法切入点表达式<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200425105040237.png" alt="image-20200425105040237"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> <span class="hljs-emphasis">* (..)    --&gt; 所有方法</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">*</span>  ---&gt;  修饰符 返回值<span class="hljs-bullet">*</span>  ---&gt;  方法名() ---&gt;  参数表.. ---&gt;  对于参数没有要求 (参数有没有，参数有⼏个都行，参数是什么类型的都行)</code></pre></div><ul><li><p>定义login方法作为切入点</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 定义login作为切入点 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login (..))&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- 定义register作为切入点 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* register (..))&quot;</span>/&gt;</span></code></pre></div></li><li><p>定义login方法且login方法有两个字符串类型的参数 作为切入点</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login (String,String))&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- ⾮ java.lang java.lang 包中的类型, 必须要写全限定名 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* register (com.yusael.proxy.User))&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--  ..可以和具体的参数类型连用 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login(String, ..))&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- === login(String), login(String,String), login(String,com.baizhi.edu.proxy.User) --&gt;</span></code></pre></div></li></ul><p>上诉表达式的切入点不够精准</p><p><strong>精准方法切入点限定</strong></p><p>修饰符 返回值         包.类.方法(参数)    *   </p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy.UserServiceImpl.login(..))&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy.UserServiceImpl.login(String, String))&quot;</span>/&gt;</span></code></pre></div><p><strong>类切入点</strong></p><blockquote><p>指定 **特定类作为切入点(额外功能加入的位置)**，这个类中的所有方法，都会加上对应的额外功能</p></blockquote><ul><li><p>语法1</p><div class="hljs code-wrapper"><pre><code class="hljs xml"># 类中所有的方法加入了额外功能<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy.UserServiceImpl.*(..))&quot;</span>/&gt;</span></code></pre></div></li><li><p>语法2 </p><div class="hljs code-wrapper"><pre><code class="hljs xml"># 忽略包1. 类只存在一级包<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *.UserServiceImpl.*(..))&quot;</span>/&gt;</span>2. 类存在多级包<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *..UserServiceImpl.*(..))&quot;</span>/&gt;</span></code></pre></div></li></ul><p><strong>包切入点表达式（实战用的多）</strong></p><blockquote><p>指定包作为额外功能加入的位置，自然包中的所有类及其方法都会加入额外的功能</p></blockquote><ul><li><p>语法1</p><div class="hljs code-wrapper"><pre><code class="hljs xml"># 切入点包中的所有类，必须在proxy中，不能在proxy包的⼦包中<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy.*.*(..))&quot;</span>/&gt;</span></code></pre></div></li><li><p>语法2</p><div class="hljs code-wrapper"><pre><code class="hljs xml"># 切入点当前包及其⼦包都生效<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy..*.*(..))&quot;</span>/&gt;</span></code></pre></div></li></ul><h4 id="3-2-2-切入点函数"><a href="#3-2-2-切入点函数" class="headerlink" title="3.2.2 切入点函数"></a>3.2.2 切入点函数</h4><blockquote><p>切入点函数：用于执行切入点表达式</p></blockquote><ul><li>execution</li></ul><p><code>execution</code> 是最为重要的切入点函数，功能最全；可以执行执行 <strong>方法切入点表达式</strong>、<strong>类切入点表达式</strong>、<strong>包切入点表达式</strong><br>弊端：<code>execution</code> 执⾏切入点表达式 ，书写麻烦</p><div class="hljs code-wrapper"><pre><code class="hljs xml">execution(* com.yusael.proxy..*.*(..))</code></pre></div><p>注意：其他的 切入点函数 简化的是 <code>execution</code> 的书写复杂度，功能上完全⼀致</p><ul><li>args</li></ul><p><code>args</code> 作用：主要用于 <strong>函数(方法) 参数的匹配</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml">切入点：方法参数必须得是 2 个字符串类型的参数# 使用 execution<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *(String, String))&quot;</span>/&gt;</span># 使用 args<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;args(String, String)&quot;</span>/&gt;</span></code></pre></div><ul><li>within</li></ul><p><code>within</code> 作用：主要用于进行 <strong>类、包切入点表达式</strong> 的匹配</p><div class="hljs code-wrapper"><pre><code class="hljs xml">切入点: UserServiceImpl 这个类# 使用 execution<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;expression(* *..UserServiceImpl.*(..))&quot;</span>/&gt;</span># 使用 within<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;within(*..UserServiceImpl)&quot;</span>/&gt;</span>切入点: com.yusael.proxy 这个包# 使用 execution<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy..*.*(..)&quot;</span>/&gt;</span># 使用 within<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;within(com.yusael.proxy..*)&quot;</span>/&gt;</span></code></pre></div><ul><li>@annotation</li></ul><p>作用：为具有特殊注解的 <strong>方法</strong> 加入额外功能。</p><p>例如我们自定义了一个注解：<code>Log</code></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Log &#123;&#125;</code></pre></div><p>然后我们要为使用了 <code>Log</code> 注解的方法加入额外功能</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;@annotation(com.yusael.Log)&quot;</span>/&gt;</span></code></pre></div><p><strong>切入点函数的逻辑运算</strong></p><blockquote><p>指的是 整合多个切入点函数一起配合工作，进而完成更为复杂的需求</p></blockquote><ul><li><p>and与操作</p><div class="hljs code-wrapper"><pre><code class="hljs xml">案例: 方法名叫 login 同时 参数是 2个字符串# execution<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login(String, String))&quot;</span>/&gt;</span># execution and args<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login(..)) and args(String, String))&quot;</span>/&gt;</span></code></pre></div></li><li><p>or或操作</p><div class="hljs code-wrapper"><pre><code class="hljs xml">案例: 方法名叫 register 或 login 的⽅法作为切⼊点<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login(..)) or execution(* register(..))&quot;</span>/&gt;</span></code></pre></div></li></ul><h2 id="4-AOP编程"><a href="#4-AOP编程" class="headerlink" title="4. AOP编程"></a>4. AOP编程</h2><h3 id="4-1-AOP概念"><a href="#4-1-AOP概念" class="headerlink" title="4.1 AOP概念"></a>4.1 AOP概念</h3><blockquote><p>POP (Producer Oriented Programing）</p><ul><li>面向过程（方法、函数）编程 —— C</li><li>以过程为基本单位的程序开发，通过过程间的彼此协同，相互调用，完成程序的构建</li></ul><p>OOP (Object Oritened Programing)</p><ul><li>面向对象编程 —— Java</li><li>以对象为基本单位的程序开发，通过对象间的彼此协同，相互调用，完成程序的构建</li></ul><p>AOP (Aspect Oriented Programing)</p><ul><li>面向切面编程 = Spring动态代理开发</li><li>以切面为基本单位的程序开发，通过切面间的彼此协同，相互调用，完成程序的构建</li><li>切面 = 切入点 + 额外功能</li></ul></blockquote><ul><li>本质就是 Spring 的动态代理开发，通过代理类为原始类增加额外功能</li><li>好处：利于原始类的维护</li><li>注意：AOP 编程不可能取代 OOP，AOP 是 OOP 编程的补充</li></ul><h3 id="4-2-AOP编程的开发步骤"><a href="#4-2-AOP编程的开发步骤" class="headerlink" title="4.2 AOP编程的开发步骤"></a>4.2 AOP编程的开发步骤</h3><ol><li>原始对象</li><li>额外功能 (<code>MethodInterceptor</code>)</li><li>切入点</li><li>组装切面 (额外功能+切入点)</li></ol><h3 id="4-3-切面的名词解释"><a href="#4-3-切面的名词解释" class="headerlink" title="4.3 切面的名词解释"></a>4.3 切面的名词解释</h3><p>切面 = 切入点 + 额外功能 几何学<br>面 = 点 + 相同的性质</p><p><strong>由各个类具有的相同额外功能，构成了一个切面</strong></p><p><strong>不同的额外功能，构成了多个切面</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200427134740273.png" alt="image-20200427134740273"></p><h2 id="5-AOP的底层实现原理"><a href="#5-AOP的底层实现原理" class="headerlink" title="5. AOP的底层实现原理"></a>5. AOP的底层实现原理</h2><h3 id="5-1-核心问题"><a href="#5-1-核心问题" class="headerlink" title="5.1 核心问题"></a>5.1 核心问题</h3><ul><li>AOP 如何创建动态代理类？<br><strong>动态字节码技术</strong></li><li>Spring 工厂如何加工创建代理对象？<br><strong>通过原始对象的 id 值，获得的是代理对象</strong></li></ul><h3 id="5-2-动态代理类的创建（重点）"><a href="#5-2-动态代理类的创建（重点）" class="headerlink" title="5.2 动态代理类的创建（重点）"></a>5.2 动态代理类的创建（重点）</h3><h4 id="5-2-1-JDK的动态代理"><a href="#5-2-1-JDK的动态代理" class="headerlink" title="5.2.1 JDK的动态代理"></a>5.2.1 JDK的动态代理</h4><ul><li><code>Proxy.newProxyInstance</code>方法参数详解<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200428175248912.png" alt="image-20200428175248912"></li></ul><p><strong>类加载器</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200428175316276.png" alt="image-20200428175316276"></p><ul><li><p>编码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJDKProxy</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以</span><span class="hljs-comment">     2. JDK8.x 前必须加 final</span><span class="hljs-comment">     final UserService userService = new UserServiceImpl();</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 1. 创建原始对象</span>        UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();        <span class="hljs-comment">// 2. JDK 动态代理</span>        InvocationHandler handler = <span class="hljs-keyword">new</span> InvocationHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                System.out.println(<span class="hljs-string">&quot;---- proxy log ----&quot;</span>);                <span class="hljs-comment">// 原始方法运行</span>                Object ret = method.invoke(userService, args);                <span class="hljs-keyword">return</span> ret;            &#125;        &#125;;        <span class="hljs-comment">//借用ClassLoader</span>        UserService userServiceProxy = (UserService) Proxy.                newProxyInstance(TestJDKProxy.class.getClassLoader(),                                userService.getClass().getInterfaces(),                                handler);        userServiceProxy.login(<span class="hljs-string">&quot;luci&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);        userServiceProxy.register(<span class="hljs-keyword">new</span> User());    &#125;&#125;</code></pre></div></li></ul><h4 id="5-2-2-CGlib的动态代理"><a href="#5-2-2-CGlib的动态代理" class="headerlink" title="5.2.2 CGlib的动态代理"></a>5.2.2 CGlib的动态代理</h4><blockquote><p>CGlib创建动态代理的原理：父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证2者方法一致，同时在代理类中提供新的实现(额外功能+原始方法)</p></blockquote><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200429111709226.png" alt="image-20200429111709226"></p><ul><li><p>CGlib编码 </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCglib</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 1. 创建原始对象</span>        UserService userService = <span class="hljs-keyword">new</span> UserService();        <span class="hljs-comment">/*</span><span class="hljs-comment">         2. 通过 cglib 方式创建动态代理对象</span><span class="hljs-comment">         对比 jdk 动态代理 ---&gt; Proxy.newProxyInstance(classLoader, interface, invocationHandler);</span><span class="hljs-comment"></span><span class="hljs-comment">         Enhancer.setClassLoader()</span><span class="hljs-comment">         Enhancer.setSuperClass()</span><span class="hljs-comment">         Enhancer.setCallBack() ---&gt; MethodInterceptor(cglib)</span><span class="hljs-comment">         Enhancer.createProxy() ---&gt; 创建代理对象</span><span class="hljs-comment">         */</span>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        enhancer.setClassLoader(TestCglib.class.getClassLoader());        enhancer.setSuperclass(userService.getClass());        MethodInterceptor interceptor = <span class="hljs-keyword">new</span> MethodInterceptor() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                System.out.println(<span class="hljs-string">&quot;--- cglib log ----&quot;</span>);                Object ret = method.invoke(userService, args); <span class="hljs-comment">// 执行原始方法</span>                <span class="hljs-keyword">return</span> ret;            &#125;        &#125;;<span class="hljs-comment">//额外功能</span>        enhancer.setCallback(interceptor);      <span class="hljs-comment">//创建代理</span>        UserService userServiceProxy = (UserService) enhancer.create();        userServiceProxy.login(<span class="hljs-string">&quot;zhenyu&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);        userServiceProxy.register(<span class="hljs-keyword">new</span> User());    &#125;&#125;</code></pre></div></li><li><p>总结</p><ol><li>JDK 动态代理<br><code>Proxy.newProxyInstance</code>：通过接口创建代理的实现类</li><li>Cglib 动态代理<br><code>Enhancer</code>：通过继承⽗类创建的代理类</li></ol></li></ul><h3 id="5-3-Spring工厂如何加工原始对象"><a href="#5-3-Spring工厂如何加工原始对象" class="headerlink" title="5.3 Spring工厂如何加工原始对象"></a>5.3 Spring工厂如何加工原始对象</h3><ul><li><p>思路分析：主要通过 <code>BeanPostProcessor</code> 将原始对象加工为代理对象<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200430113353205.png" alt="image-20200430113353205"></p></li><li><p>编码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        InvocationHandler handler = <span class="hljs-keyword">new</span> InvocationHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                System.out.println(<span class="hljs-string">&quot;--- new log ---&quot;</span>);                Object ret = method.invoke(bean, args);                <span class="hljs-keyword">return</span> ret;            &#125;        &#125;;        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(ProxyBeanPostProcessor.class.getClassLoader(), bean.getClass().getInterfaces(), handler);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.factory.UserServiceImpl&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--1. 实现 BeanPostProcessor 进行加工--&gt;</span><span class="hljs-comment">&lt;!--2. 配置文件中对 BeanPostProcessor 进行配置--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;proxyBeanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.factory.ProxyBeanPostProcessor&quot;</span>/&gt;</span></code></pre></div></li></ul><h2 id="6-基于注解的AOP编程"><a href="#6-基于注解的AOP编程" class="headerlink" title="6. 基于注解的AOP编程"></a>6. 基于注解的AOP编程</h2><h3 id="6-1-基于注解的AOP编程的开发步骤"><a href="#6-1-基于注解的AOP编程的开发步骤" class="headerlink" title="6.1 基于注解的AOP编程的开发步骤"></a>6.1 基于注解的AOP编程的开发步骤</h3><ul><li>原始对象</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.register 业务运算 + DAO&quot;</span>);        <span class="hljs-comment">// throw new RuntimeException(&quot;测试异常&quot;);</span>    &#125;    <span class="hljs-meta">@Log</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.login 业务运算 + DAO&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><ul><li><p>额外功能</p></li><li><p>切入点</p></li><li><p>组装切面</p> <div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">    1. 额外功能</span><span class="hljs-comment">        public class MyAround implements MethodInterceptor &#123;</span><span class="hljs-comment">            public Object invoke(MethodInvocation invocation) &#123;</span><span class="hljs-comment">                Object ret = invocation.invoke();</span><span class="hljs-comment">                return ret;</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        &lt;bean id=&quot;around&quot; class=&quot;com.yusael.dynamic.Around&quot;/&gt;</span><span class="hljs-comment"></span><span class="hljs-comment">    2. 切入点</span><span class="hljs-comment">        &lt;aop:config&gt;</span><span class="hljs-comment">            &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* login(..)))&quot;/&gt;</span><span class="hljs-comment">            &lt;aop:advisor advice-ref=&quot;around&quot; pointcut-ref=&quot;pc&quot;/&gt;</span><span class="hljs-comment">        &lt;/aop:config&gt;</span><span class="hljs-comment"> */</span><span class="hljs-comment">//通过切面类定义了额外功能 @Around </span><span class="hljs-comment">//切入点 @Around(&quot;execution(* login(..))&quot;)</span><span class="hljs-comment">//切面类 @Aspect</span><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;    <span class="hljs-meta">@Around(&quot;execution(* login(..))&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;---- aspect log ----&quot;</span>);        Object ret = joinPoint.proceed();        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre></div> <div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.aspect.UserServiceImpl&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        切面:</span><span class="hljs-comment">            1. 额外功能</span><span class="hljs-comment">            2. 切入点啊</span><span class="hljs-comment">            3. 组装切面</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;around&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.aspect.MyAspect&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--告知 Spring 基于注解进行 AOP 编程--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div></li></ul><h3 id="6-2-细节"><a href="#6-2-细节" class="headerlink" title="6.2 细节"></a>6.2 细节</h3><p><strong>切入点复用</strong>：在切面类中定义⼀个函数，上面用 <code>@Pointcut</code> 注解<br>通过这种方式定义切入点表达式，后续更加有利于切入点复用</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;    <span class="hljs-meta">@Pointcut(&quot;execution(* login(..))&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myPoincut</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-meta">@Around(value = &quot;myPoincut()&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;---- aspect log ----&quot;</span>);        Object ret = joinPoint.proceed();        <span class="hljs-keyword">return</span> ret;    &#125;    <span class="hljs-meta">@Around(value = &quot;myPoincut()&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around1</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">&quot;---- aspect transaction ----&quot;</span>);        Object ret = joinPoint.proceed();        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre></div><p><strong>动态代理的创建方式</strong> </p><p>AOP 底层实现 2 种代理创建方式：</p><ol><li>JDK：通过 <strong>实现接口，做新的实现类</strong> 创建代理对象</li><li>Cglib：通过 <strong>继承父类，做新的子类</strong> 创建代理对象</li></ol><p><strong>默认情况 AOP 编程 底层应用 JDK动态代理创建方式</strong>。</p><p>基于注解的 AOP 开发 中切换为 Cglib：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></code></pre></div><p>传统的 AOP 开发 中切换为 Cglib：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></div><h2 id="7-AOP开发中的一个坑"><a href="#7-AOP开发中的一个坑" class="headerlink" title="7. AOP开发中的一个坑"></a>7. AOP开发中的一个坑</h2><p><strong>坑！</strong>：在同⼀个业务类中，进⾏业务方法间的相互调用，只有最外层的方法，才是加入了额外功能(内部的方法，通过普通的方式调用，都调用的是原始方法)。如果想让内层的方法也调用代理对象的方法，就要实现 <code>AppicationContextAware</code> 获得⼯厂，进而获得代理对象</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span>, <span class="hljs-title">ApplicationContextAware</span> </span>&#123;    <span class="hljs-keyword">private</span> ApplicationContext ctx;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        <span class="hljs-keyword">this</span>.ctx = applicationContext;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.register 业务运算 + DAO&quot;</span>);        <span class="hljs-comment">// this.login(&quot;zhenyu&quot;, &quot;123456&quot;); // 这么写调用的是本类的 login 方法, 即原始对象的 login 方法</span>        <span class="hljs-comment">// 为什么不在这里创建一个工厂获取代理对象呢？</span>        <span class="hljs-comment">// Spring的工厂是重量级资源, 一个应用中应该只创建一个工厂.</span>        <span class="hljs-comment">// 因此我们必须通过 ApplicationContextAware 拿到已经创建好的工厂</span>        UserService userService = (UserService) ctx.getBean(<span class="hljs-string">&quot;userService&quot;</span>);        userService.login(<span class="hljs-string">&quot;yusael&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.login 业务运算 + DAO&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h2 id="8-AOP阶段知识总结"><a href="#8-AOP阶段知识总结" class="headerlink" title="8. AOP阶段知识总结"></a>8. AOP阶段知识总结</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200503162625116.png" alt="image-20200503162625116"></p><h1 id="第四章、Spring持久层"><a href="#第四章、Spring持久层" class="headerlink" title="第四章、Spring持久层"></a>第四章、Spring持久层</h1><hr><h2 id="1-持久层整合"><a href="#1-持久层整合" class="headerlink" title="1. 持久层整合"></a>1. 持久层整合</h2><h3 id="1-1Spring框架为什么要与持久层技术进行整合"><a href="#1-1Spring框架为什么要与持久层技术进行整合" class="headerlink" title="1.1Spring框架为什么要与持久层技术进行整合"></a>1.1Spring框架为什么要与持久层技术进行整合</h3><ul><li>JavaEE开发需要持久层进行数据库的访问操作</li><li>JDBC、Hibernate、MyBatis 进行持久开发过程存在大量的代码冗余</li><li>Spring 基于模板设计模式对于上述的持久层技术进行了封装</li></ul><h3 id="1-2-Spring可以与那些持久层技术进行整合？"><a href="#1-2-Spring可以与那些持久层技术进行整合？" class="headerlink" title="1.2 Spring可以与那些持久层技术进行整合？"></a>1.2 Spring可以与那些持久层技术进行整合？</h3><ul><li>JDBC —— <code>JDBCTemplate</code></li><li>Hibernate（JPA）—— <code>HibernateTemplate</code></li><li><strong>MyBatis</strong> —— <code>SqlSessionFactoryBean</code>、<code>MapperScannerConfigure</code></li></ul><h2 id="2-Spring与MyBatis整合"><a href="#2-Spring与MyBatis整合" class="headerlink" title="2. Spring与MyBatis整合"></a>2. Spring与MyBatis整合</h2><h3 id="2-1-MyBatis开发步骤的回顾"><a href="#2-1-MyBatis开发步骤的回顾" class="headerlink" title="2.1 MyBatis开发步骤的回顾"></a>2.1 MyBatis开发步骤的回顾</h3><ul><li>实体类 <code>User</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id, String name, String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.password = password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = password;    &#125;&#125;</code></pre></div><ul><li>实体别名 <code>mybatis-config.xml</code> 配置繁琐</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Confi 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.yusael.mybatis.User&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/yus?useSSL=false&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><ul><li>表 t_users</li></ul><div class="hljs code-wrapper"><pre><code class="hljs mysql">create table t_users values (id int(11) primary key auto_increment,name varchar(12),password varchar(12));</code></pre></div><ul><li>创建 DAO 接口：<code>UserDAO</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDAO</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(User user)</span></span>;&#125;</code></pre></div><ul><li>实现Mapper文件：<code>UserDAOMapper.xml</code> 配置繁琐 </li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.yusael.mybatis.UserDAO&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;save&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>        insert into t_users(name, password) values (#&#123;name&#125;, #&#123;password&#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><ul><li>注册 Mapper 文件 <code>mybatis-config.xml</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserDAOMapper.xml&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div><ul><li>MybatisAPI调用  代码冗余 </li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMybatis</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);        SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        SqlSession session = sqlSessionFactory.openSession();        UserDAO userDAO = session.getMapper(UserDAO.class);        User user = <span class="hljs-keyword">new</span> User();        user.setName(<span class="hljs-string">&quot;yusael&quot;</span>);        user.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);        userDAO.save(user);        session.commit();    &#125;&#125;</code></pre></div><h3 id="2-2-Mybatis在开发过程中存在问题"><a href="#2-2-Mybatis在开发过程中存在问题" class="headerlink" title="2.2 Mybatis在开发过程中存在问题"></a>2.2 Mybatis在开发过程中存在问题</h3><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 配置繁琐  代码冗余 </span><span class="hljs-bullet">1.</span> 实体<span class="hljs-bullet">2.</span> 实体别名         配置繁琐 <span class="hljs-bullet">3.</span> 表<span class="hljs-bullet">4.</span> 创建DAO接口<span class="hljs-bullet">5.</span> 实现Mapper文件<span class="hljs-bullet">6.</span> 注册Mapper文件   配置繁琐 <span class="hljs-bullet">7.</span> MybatisAPI调用  代码冗余</code></pre></div><h3 id="2-3-Spring与Mybatis整合思路分析"><a href="#2-3-Spring与Mybatis整合思路分析" class="headerlink" title="2.3 Spring与Mybatis整合思路分析"></a>2.3 Spring与Mybatis整合思路分析</h3><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200504141407141.png" alt="image-20200504141407141"></p><h3 id="2-4-Spring与Mybatis整合的开发步骤"><a href="#2-4-Spring与Mybatis整合的开发步骤" class="headerlink" title="2.4 Spring与Mybatis整合的开发步骤"></a>2.4 Spring与Mybatis整合的开发步骤</h3><ul><li><p>配置文件（<code>ApplicationContext.xml</code>) 进行相关配置</p><div class="hljs code-wrapper"><pre><code class="hljs xml">#配置 是需要配置一次 <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--创建SqlSessionFactory--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ssfb&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;SqlSessionFactoryBean&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span>&gt;</span>         指定 实体类所在的包  com.baizhiedu.entity  User                                                 Product    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span>&gt;</span>          指定 配置文件(映射文件)的路径 还有通用配置           com.baizhiedu.mapper/*Mapper.xml     <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--DAO接口的实现类</span><span class="hljs-comment">    session ---&gt;</span> session.getMapper() --- xxxDAO实现类对象     XXXDAO  ---&gt; xXXDAO--&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scanner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;MapperScannerConfigure&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ssfb&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePacakge&quot;</span>&gt;</span>        指定 DAO接口放置的包  com.baizhiedu.dao     <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div></li><li><p>编码</p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 实战经常根据需求 写的代码</span><span class="hljs-bullet">1.</span> 实体<span class="hljs-bullet">2.</span> 表<span class="hljs-bullet">3.</span> 创建DAO接口<span class="hljs-bullet">4.</span> 实现Mapper文件</code></pre></div></li></ul><h3 id="2-5-Spring与Mybatis整合编码"><a href="#2-5-Spring与Mybatis整合编码" class="headerlink" title="2.5 Spring与Mybatis整合编码"></a>2.5 Spring与Mybatis整合编码</h3><ul><li><p><strong>搭建开发环境(jar)</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p><strong>Spring配置文件的配置</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--连接池--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/suns?useSSL=false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.baizhiedu.entity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:com.baizhiedu.mapper/*Mapper.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scanner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.baizhiedu.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div></li><li><p><strong>编码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 实体<span class="hljs-bullet">2.</span> 表<span class="hljs-bullet">3.</span> DAO接口<span class="hljs-bullet">4.</span> Mapper文件配置</code></pre></div></li><li><p>实体 <code>com.yusael.entity.User</code></p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = password;    &#125;&#125;</code></pre></div><ul><li>表 <code>t_user</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs mysql">create table t_users values (id int(11) primary key auto_increment,name varchar(12),password varchar(12));</code></pre></div><ul><li>DAO接口 <code>com.yusael.dao.UserDAO</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDAO</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(User user)</span></span>;&#125;</code></pre></div><ul><li>Mapper文件配置 <code>resources/applicationContext.xml</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--连接池--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/yus?useSSL=false&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-comment">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.yusael.entity&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:com.yusael.dao/*Mapper.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-comment">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scanner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.yusael.dao&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><ul><li><code>UserDAOMapper.xml</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;save&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>insert into t_users (name,password) values (#&#123;name&#125;,#&#123;password&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><ul><li>测试</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于测试: Spring 与 Mybatis 的整合</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);    UserDAO userDAO = (UserDAO) ctx.getBean(<span class="hljs-string">&quot;userDAO&quot;</span>);    User user = <span class="hljs-keyword">new</span> User();    user.setName(<span class="hljs-string">&quot;xiaojr&quot;</span>);    user.setPassword(<span class="hljs-string">&quot;999999&quot;</span>);    userDAO.save(user);&#125;</code></pre></div><h3 id="2-6-Spring与Mybatis整合细节"><a href="#2-6-Spring与Mybatis整合细节" class="headerlink" title="2.6 Spring与Mybatis整合细节"></a>2.6 Spring与Mybatis整合细节</h3><p>问题：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？</p><ul><li>Mybatis 提供的连接池对象 —&gt; 创建<code> Connection Connection.setAutoCommit(false)</code> 手工的控制了事务，操作完成后，需要手工提交</li><li>Druid（C3P0、DBCP）作为连接池 —&gt; 创建<code>Connection Connection.setAutoCommit(true)</code>默认值为 true，保持自动控制事务，一条 sql 自动提交</li></ul><p>答案：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制<code>Connection.setAutoCommit(true)</code>，不需要手工进行事务的操作，也能进行事务的提交</p><p>注意：实战中，还是会手工控制事务（多条SQL一起成功，一起失败），后续Spring通过事务控制解决这个问题</p><h2 id="3-Spring的事务处理"><a href="#3-Spring的事务处理" class="headerlink" title="3. Spring的事务处理"></a>3. Spring的事务处理</h2><h3 id="3-1-什么是事务？"><a href="#3-1-什么是事务？" class="headerlink" title="3.1 什么是事务？"></a>3.1 什么是事务？</h3><blockquote><p>保证业务操作完整性的一种数据库机制</p><p>事务的4特点： <strong>A C I D</strong></p><ul><li>A 原子性</li><li>C 一致性</li><li>I 隔离性</li><li>D 持久性</li></ul></blockquote><h3 id="3-2-如何控制事务"><a href="#3-2-如何控制事务" class="headerlink" title="3.2 如何控制事务"></a>3.2 如何控制事务</h3><div class="hljs code-wrapper"><pre><code class="hljs markdown">JDBC:<span class="hljs-code">    Connection.setAutoCommit(false);</span><span class="hljs-code">    Connection.commit();</span><span class="hljs-code">    Connection.rollback();</span><span class="hljs-code">Mybatis：</span><span class="hljs-code">    Mybatis自动开启事务</span><span class="hljs-code">    </span><span class="hljs-code">    sqlSession(Connection).commit();</span><span class="hljs-code">    sqlSession(Connection).rollback();</span><span class="hljs-code"></span><span class="hljs-code">结论：控制事务的底层 都是Connection对象完成的</span></code></pre></div><h3 id="3-3-Spring控制事务的开发"><a href="#3-3-Spring控制事务的开发" class="headerlink" title="3.3 Spring控制事务的开发"></a>3.3 Spring控制事务的开发</h3><blockquote><p>Spring是通过AOP的方式进行事务开发</p></blockquote><h4 id="3-3-1-原始对象"><a href="#3-3-1-原始对象" class="headerlink" title="3.3.1 原始对象"></a>3.3.1 原始对象</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXXUserServiceImpl</span></span>&#123;   <span class="hljs-keyword">private</span> xxxDAO xxxDAO   set get   <span class="hljs-number">1.</span> 原始对象 ---&gt; 原始方法 ---&gt; 核心功能 (业务处理+DAO调用)   <span class="hljs-number">2.</span> DAO作为Service的成员变量，依赖注入的方式进行赋值&#125;</code></pre></div><h4 id="3-3-2-额外功能"><a href="#3-3-2-额外功能" class="headerlink" title="3.3.2 额外功能"></a>3.3.2 额外功能</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//以下代码Spring已经封装好，通过</span><span class="hljs-comment">//org.springframework.jdbc.datasource.DataSourceTransactionManager</span><span class="hljs-comment">//需要注入连接池DataSource </span><span class="hljs-number">1.</span> <span class="hljs-comment">//实现MethodInterceptor</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span></span>&#123;      <span class="hljs-keyword">try</span>&#123;        Connection.setAutoCommit(<span class="hljs-keyword">false</span>);        Object ret = invocation.proceed();        Connection.commit();      &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;        Connection.rollback();      &#125;        <span class="hljs-keyword">return</span> ret;   &#125;<span class="hljs-number">2.</span> <span class="hljs-comment">//使用注解@Aspect</span>   <span class="hljs-comment">//@Around </span></code></pre></div><h4 id="3-3-3-切入点"><a href="#3-3-3-切入点" class="headerlink" title="3.3.3 切入点"></a>3.3.3 切入点</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span> 事务的额外功能加入给那些业务方法。<span class="hljs-number">1.</span> 类上：类中所有的方法都会加入事务<span class="hljs-number">2.</span> 方法上：这个方法会加入事务</code></pre></div><h4 id="3-3-4-组装切面"><a href="#3-3-4-组装切面" class="headerlink" title="3.3.4 组装切面"></a>3.3.4 组装切面</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">1. 切入点2. 额外功能<span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span></code></pre></div><h3 id="3-4-Spring控制事务的编码"><a href="#3-4-Spring控制事务的编码" class="headerlink" title="3.4 Spring控制事务的编码"></a>3.4 Spring控制事务的编码</h3><ul><li><p>搭建开发环境 (jar)</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>编码</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.service.UserServiceImpl&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--DataSourceTransactionManager--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>@Transactionalpublic class UserServiceImpl implements UserService &#123;    private UserDAO userDAO;<span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></code></pre></div></li><li><p>细节</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--tx:annotation-driven要以tx结尾--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>进行动态代理底层实现的切换   proxy-target-class    默认 false JDK        true  Cglib</code></pre></div></li></ul><h2 id="4-Spring中的事务属性-Transaction-Attribute"><a href="#4-Spring中的事务属性-Transaction-Attribute" class="headerlink" title="4.  Spring中的事务属性(Transaction Attribute)"></a>4.  Spring中的事务属性(Transaction Attribute)</h2><h3 id="4-1-什么是事务属性"><a href="#4-1-什么是事务属性" class="headerlink" title="4.1 什么是事务属性"></a>4.1 什么是事务属性</h3><blockquote><p>属性：描述物体特征的一系列值<br>性别 身高 体重 …<br>事务属性：描述事务特征的一系列值 </p><ul><li>隔离属性</li><li>传播属性</li><li>只读属性</li><li>超时属性</li><li>异常属性 </li></ul></blockquote><h3 id="4-2-如何添加事务属性"><a href="#4-2-如何添加事务属性" class="headerlink" title="4.2 如何添加事务属性"></a>4.2 如何添加事务属性</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(isloation=,propagation=,readOnly=,timeout=,rollbackFor=,noRollbackFor=,)</code></pre></div><h3 id="4-3-事务属性详解"><a href="#4-3-事务属性详解" class="headerlink" title="4.3 事务属性详解"></a>4.3 事务属性详解</h3><h4 id="4-3-1-隔离属性-ISOLATION"><a href="#4-3-1-隔离属性-ISOLATION" class="headerlink" title="4.3.1 隔离属性 (ISOLATION)"></a>4.3.1 隔离属性 (ISOLATION)</h4><ul><li><p>隔离属性的概念</p><div class="hljs code-wrapper"><pre><code class="hljs markdown">概念：他描述了事务解决并发问题的特征<span class="hljs-bullet">1.</span> 什么是并发<span class="hljs-code">       多个事务(用户)在同一时间，访问操作了相同的数据</span><span class="hljs-code">       </span><span class="hljs-code">       同一时间：0.000几秒 微小前 微小后</span><span class="hljs-code">2. 并发会产生那些问题</span><span class="hljs-code">       1. 脏读</span><span class="hljs-code">       2. 不可重复读</span><span class="hljs-code">       3. 幻影读</span><span class="hljs-code">3. 并发问题如何解决</span><span class="hljs-code">       通过隔离属性解决，隔离属性中设置不同的值，解决并发处理过程中的问题。</span></code></pre></div></li><li><p>事务并发产生的问题</p><ul><li><p>脏读</p><blockquote><p>一个事务，读取了另一个事务中没有提交的数据。会在本事务中产生数据不一致的问题解决方案  @Transactional(isolation=Isolation.READ_COMMITTED)</p></blockquote></li><li><p>不可重复读</p><blockquote><p>一个事务中，多次读取相同的数据，但是读取结果不一样。会在本事务中产生数据不一致的问题注意：1 不是脏读 2 一个事务中解决方案 @Transactional(isolation=Isolation.REPEATABLE_READ)<br>本质： 一把行锁</p></blockquote></li><li><p>幻影读</p><blockquote><p>一个事务中，多次对整表进行查询统计，但是结果不一样，会在本事务中产生数据不一致的问题解决方案 @Transactional(isolation=Isolation.SERIALIZABLE)<br>本质：表锁 </p></blockquote></li><li><p>总结</p><blockquote><p>一个事务中，多次对整表进行查询统计，但是结果不一样，会在本事务中产生数据不一致的问题解决方案 @Transactional(isolation=Isolation.SERIALIZABLE)<br>本质：表锁 </p></blockquote></li></ul></li><li><p>数据库对于隔离属性的支持</p><table><thead><tr><th>隔离属性的值</th><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>ISOLATION_READ_COMMITTED</td><td>✅</td><td>✅</td></tr><tr><td>IOSLATION_REPEATABLE_READ</td><td>✅</td><td>❎</td></tr><tr><td>ISOLATION_SERIALIZABLE</td><td>✅</td><td>✅</td></tr></tbody></table><p>Oracle不支持REPEATABLE_READ值 如何解决不可重复读</p><p>采用的是多版本比对的方式 解决不可重复读的问题</p></li><li><p>默认隔离属性</p><div class="hljs code-wrapper"><pre><code class="hljs markdown">ISOLATION<span class="hljs-emphasis">_DEFAULT：会调用不同数据库所设置的默认隔离属性</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">MySQL : REPEATABLE_</span>READ Oracle: READ<span class="hljs-emphasis">_COMMITTED  </span></code></pre></div><ul><li><p>查看数据库默认隔离属性</p><ul><li><p>MySQL</p><div class="hljs code-wrapper"><pre><code class="hljs mysql">select @@tx_isolation;</code></pre></div></li><li><p>Oracle</p><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT s.sid, s.serial#,   CASE BITAND(t.flag, POWER(2, 28))      WHEN 0 THEN &#39;READ COMMITTED&#39;      ELSE &#39;SERIALIZABLE&#39;   END AS isolation_levelFROM v$transaction t JOIN v$session s ON t.addr &#x3D; s.taddrAND s.sid &#x3D; sys_context(&#39;USERENV&#39;, &#39;SID&#39;);</code></pre></div></li></ul></li></ul></li><li><p>隔离属性在实战中的建议</p><ul><li>推荐使用 Spring 默认指定的 <code>ISOLATION_DEFAULT</code></li><li>未来的实战中，遇到并发访问的情况，很少见</li><li>如果真的遇到并发问题，解决方案：<strong>乐观锁</strong><br>Hibernate(JPA)：version<br>MyBatis：通过拦截器自定义开发</li></ul></li></ul><h4 id="4-3-2-传播属性-PROPAGATION"><a href="#4-3-2-传播属性-PROPAGATION" class="headerlink" title="4.3.2 传播属性(PROPAGATION)"></a>4.3.2 传播属性(PROPAGATION)</h4><p><strong>传播属性的概念</strong></p><blockquote><p>概念：他描述了事务解决嵌套问题的特征</p><p>什么叫做事务的嵌套：他指的是一个大的事务中，包含了若干个小的事务</p><p>问题：大事务中融入了很多小的事务，他们彼此影响，最终就会导致外部大的事务，丧失了事务的原子性</p></blockquote><p><strong>传播属性的值及其用法</strong></p><table><thead><tr><th>传播属性的值</th><th>外部不存在事务</th><th>外部存在事务</th><th>用法</th><th>备注</th></tr></thead><tbody><tr><td>REQUIRED</td><td>开启新的事务</td><td>融合到外部事务中</td><td>@Transactional(propagation = Propagation.REQUIRED)</td><td>增删改方法</td></tr><tr><td>SUPPORTS</td><td>不开启事务</td><td>融合到外部事务中</td><td>@Transactional(propagation = Propagation.SUPPORTS)</td><td>查询方法</td></tr><tr><td>REQUIRES_NEW</td><td>开启新的事务</td><td>挂起外部事务，创建新的事务</td><td>@Transactional(propagation = Propagation.REQUIRES_NEW)</td><td>日志记录方法中</td></tr><tr><td>NOT_SUPPORTED</td><td>不开启事务</td><td>挂起外部事务</td><td>@Transactional(propagation = Propagation.NOT_SUPPORTED)</td><td>及其不常用</td></tr><tr><td>NEVER</td><td>不开启事务</td><td>抛出异常</td><td>@Transactional(propagation = Propagation.NEVER)</td><td>及其不常用</td></tr><tr><td>MANDATORY</td><td>抛出异常</td><td>融合到外部事务中</td><td>@Transactional(propagation = Propagation.MANDATORY)</td><td>及其不常用</td></tr></tbody></table><ul><li><p>默认的传播属性</p><blockquote><p>REQUIRED是传播属性的默认值</p></blockquote></li><li><p>推荐传播属性的使用方式</p><blockquote><p>增删改 方法：直接使用默认值REQUIRED 查询   </p><p>查询 方法：显示指定传播属性的值为SUPPORTS  </p></blockquote></li></ul><h4 id="4-3-3-只读属性-readOnly"><a href="#4-3-3-只读属性-readOnly" class="headerlink" title="4.3.3 只读属性(readOnly)"></a>4.3.3 只读属性(readOnly)</h4><blockquote><p>针对于只进行查询操作的业务方法，可以加入只读属性，提供运行效率<br>默认值：false </p><p>@Transactional(readOnly = true)</p></blockquote><h4 id="4-3-4-超时属性-timeout"><a href="#4-3-4-超时属性-timeout" class="headerlink" title="4.3.4 超时属性(timeout)"></a>4.3.4 超时属性(timeout)</h4><p>指定了事务等待的最长时间</p><ul><li>为什么事务会进行等待？<br>当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。</li><li>等待时间，单位是 秒</li><li>如何使用：@Transactional(timeout = 2)</li><li>超时属性的默认值：-1<br>-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）</li></ul><h4 id="4-3-5-异常属性"><a href="#4-3-5-异常属性" class="headerlink" title="4.3.5 异常属性"></a>4.3.5 异常属性</h4><p>Spring 事务处理过程中：</p><ul><li>默认对于 <code>RuntimeException</code> 及其子类，采用 <strong>回滚</strong> 的策略</li><li>默认对于 <code>Exception</code> 及其子类，采用 <strong>提交</strong> 的策略</li></ul><p>使用方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)</span><span class="hljs-meta">@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)</span></code></pre></div><h3 id="4-4-事务属性常见配置总结"><a href="#4-4-事务属性常见配置总结" class="headerlink" title="4.4 事务属性常见配置总结"></a>4.4 事务属性常见配置总结</h3><ul><li>隔离属性 默认值</li><li>传播属性 Required（默认值）增删改、Supports 查询操作</li><li>只读属性 readOnly=false 增删改，true 查询操作</li><li>超时属性 默认值 -1</li><li>异常属性 默认值</li></ul><p>增删改操作：<code>@Transactional</code><br>查询操作：<code>@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)</code></p><h3 id="4-5-基于标签的事务配置方式-事务开发的第二种形式"><a href="#4-5-基于标签的事务配置方式-事务开发的第二种形式" class="headerlink" title="4.5 基于标签的事务配置方式(事务开发的第二种形式)"></a>4.5 基于标签的事务配置方式(事务开发的第二种形式)</h3><p>基于注解 <code>@Transaction</code> 的事务配置回顾：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--DataSourceTransactionManager--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>@Transactionalpublic class UserServiceImpl implements UserService &#123;    private UserDAO userDAO;<span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></code></pre></div><p>基于标签的事务配置：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--DataSourceTransactionManager--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!--不同点--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;register&quot;</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">&quot;DEFAULT&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span>          <span class="hljs-comment">&lt;!--等效于 </span><span class="hljs-comment">          @Transactional(isolation=,propagation=,)</span><span class="hljs-comment">          public void register()&#123;</span><span class="hljs-comment">        </span><span class="hljs-comment">          &#125;--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.service.UserServiceImpl.register(..))&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pc&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></div><p>基于标签的事务配置在 <strong>实战</strong> 中的应用方式：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>       编程时候, service中负责进行增删改操作的方法 都以 modify 开头       查询操作 命名无所谓      tx的顺序表示匹配的顺序        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;register&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;modify*&quot;</span>/&gt;</span>除了modify*，*表示剩下的都满足...        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.service..*.*(..))&quot;</span>/&gt;</span>   应用的过程中, 将 service 都放到 service 包下    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pc&quot;</span>/&gt;</span>&lt;/aop:config</code></pre></div><h2 id="5-Spring开发过程中多配置文件的处理"><a href="#5-Spring开发过程中多配置文件的处理" class="headerlink" title="5. Spring开发过程中多配置文件的处理"></a>5. Spring开发过程中多配置文件的处理</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown">Spring会根据需要，把配置信息分门别类的放置在多个配置文件中，便于后续的管理及维护。DAO  ------  applicationContext-dao.xml Service ---  applicationContext-service.xmlAction  ---  applicationContext-action.xml注意：虽然提供了多个配置文件，但是后续应用的过程中，还要进行整合</code></pre></div><p>通配符方式</p><div class="hljs code-wrapper"><pre><code class="hljs xml">1. 非web环境   ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;/applicationContext-*.xml&quot;);2. web环境   <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext-*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span></code></pre></div><p>&lt;import标签</p><div class="hljs code-wrapper"><pre><code class="hljs xml">applicationContext.xml 目的 整合其他配置内容    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext-dao.xml &quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext-service.xml &quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext-action.xml &quot;</span> /&gt;</span>    1. 非web环境   ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;/applicationContext.xml&quot;);2. web环境   <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span></code></pre></div><h1 id="第五章、Spring注解编程"><a href="#第五章、Spring注解编程" class="headerlink" title="第五章、Spring注解编程"></a>第五章、Spring注解编程</h1><h2 id="1-注解基础概念"><a href="#1-注解基础概念" class="headerlink" title="1. 注解基础概念"></a>1. 注解基础概念</h2><h3 id="1-1-什么是注解编程"><a href="#1-1-什么是注解编程" class="headerlink" title="1.1 什么是注解编程"></a>1.1 什么是注解编程</h3><ul><li>在 类 或者 方法 上加入特定的注解（<code>@xxx</code>），完成特定功能的开发</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXX</span></span>&#123;&#125;</code></pre></div><h3 id="1-2-为什么要讲解注解编程"><a href="#1-2-为什么要讲解注解编程" class="headerlink" title="1.2 为什么要讲解注解编程"></a>1.2 为什么要讲解注解编程</h3><ul><li>注解开发方便，代码简单，开发速度大大提高</li><li>注解开发是 Spring 开发潮流<br>Spring 2.x 引入注解，Spring 3.x 完善注解，SpringBoot 普及、推广注解编程</li></ul><h3 id="1-3-注解的作用"><a href="#1-3-注解的作用" class="headerlink" title="1.3 注解的作用"></a>1.3 注解的作用</h3><ul><li><p>替换XML这种配置形式，简化配置</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200527164703807.png" alt="image-20200527164703807"></p></li><li><p>替换接口，实现调用双方的契约性 </p><blockquote><p>通过注解的方式，在功能调用者和功能提供者之间达成约定，进而进行功能的调用。因为注解应用更为方便灵活，所以在现在的开发中，更推荐通过注解的形式，完成</p></blockquote><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200527171704953.png" alt="image-20200527171704953"></p></li></ul><h3 id="1-4-Spring注解的发展历程"><a href="#1-4-Spring注解的发展历程" class="headerlink" title="1.4 Spring注解的发展历程"></a>1.4 Spring注解的发展历程</h3><ul><li>Spring 2.x： 开始支持注解编程 <code>@Component</code>、<code>@Service</code>、<code>@Scope</code>…<br>目的：提供的这些注解只是为了某些 XML 的配置，作为 XML 开发的有益补充。</li><li>Spring 3.x： <code>@Configuration</code>、<code>@Bean</code>…<br>目的：彻底替换 XML，基于纯注解</li><li>Spring 4.x： <strong>SpringBoot</strong> 提倡使用注解进行开发</li></ul><h3 id="1-5-Spring注解开发的一个问题"><a href="#1-5-Spring注解开发的一个问题" class="headerlink" title="1.5 Spring注解开发的一个问题"></a>1.5 Spring注解开发的一个问题</h3><blockquote><p>Spring基于注解进行配置后，还能否解耦合呢？</p><p>在Spring框架应用注解时，如果对注解配置的内容不满意，可以通过Spring配置文件进行覆盖的</p></blockquote><h2 id="2-Spring的基础注解（Spring2-x）"><a href="#2-Spring的基础注解（Spring2-x）" class="headerlink" title="2. Spring的基础注解（Spring2.x）"></a>2. Spring的基础注解（Spring2.x）</h2><blockquote><p>这个阶段的注解，仅仅是简化XML的配置，并不能完全替代XML</p></blockquote><h3 id="2-1-对象创建相关注解"><a href="#2-1-对象创建相关注解" class="headerlink" title="2.1 对象创建相关注解"></a>2.1 对象创建相关注解</h3><p><strong>搭建开发环境</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.baizhiedu&quot;</span>/&gt;</span>作用：让Spring框架在设置包及其子包中扫描对应的注解，使其生效。</code></pre></div><p><strong>对象创建相关注解</strong></p><h4 id="Component注解"><a href="#Component注解" class="headerlink" title="@Component注解"></a><code>@Component</code>注解</h4><p>作用：替换原有Spring配置文件中的 <code>&lt;bean&gt;</code> 标签</p><ul><li><code>id</code> 属性：在 <code>@Component</code> 中提供了默认的设置方式：首单词首字母小写（UserDAO –&gt; userDAO）</li><li><code>class</code> 属性：通过反射获得的 <code>class</code> 的内容</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200528112232356.png" alt="image-20200528112232356"></p><p><code>@Component </code>细节</p><ul><li><p>如何显示指定工厂创建对象的id值</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;u&quot;)</span></code></pre></div></li><li><p>Spring配置文件覆盖注解配置内容</p><div class="hljs code-wrapper"><pre><code class="hljs xml">applicationContext.xml<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.bean.User&quot;</span>/&gt;</span>id值 class的值 要和 注解中的设置保持一值</code></pre></div></li><li><p>@Component的衍生注解</p><ul><li><code>@Repository</code>、<code>@Service</code>、<code>@Controller</code> 都是 <code>@Component</code> 的 <strong>衍生注解</strong></li><li>本质上这些衍生注解就是 <code>@Component</code>，通过源码可以看见他们都使用了<code>@Component</code>，它们的存在是为了：<strong>更加准确的表达一个类型的作用</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDAO</span> </span>&#123;&#125;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;&#125;<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;&#125;</code></pre></div><p>注意：Spring 整合 Mybatis 开发过程中，不使用 <code>@Repository</code>、<code>@Component</code></p></li><li><p>```JAVA<br>@Repository  —&gt;  XXXDAO<br>  @Repository<br>  public class UserDAO{</p><p>  }<br>@Service<br>  @Service<br>  public class UserService{</p><p>  }<br>@Controller<br>  @Controller<br>  public class RegAction{</p><p>  }<br>注意：本质上这些衍生注解就是@Component </p><div class="hljs code-wrapper"><pre><code> 作用 &lt;bean   细节 @Service(&quot;s&quot;)</code></pre></div><p>目的：更加准确的表达一个类型的作用</p><p>注意：Spring整合Mybatis开发过程中 不使用@Repository @Component</p><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">#### `@Scope`注解作用：控制简单对象创建次数注意：不添加 `@Scope`，Spring 提供默认值 `singleton````xml&lt;bean id=<span class="hljs-string">&quot;&quot;</span> class=<span class="hljs-string">&quot;&quot;</span> scope=<span class="hljs-string">&quot;singleton|prototype&quot;</span>/&gt;</code></pre></div></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建单例对象</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Scope(&quot;singleton&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;&#125;<span class="hljs-comment">// 创建多例对象</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;&#125;</code></pre></div><h4 id="Lazy注解"><a href="#Lazy注解" class="headerlink" title="@Lazy注解"></a><code>@Lazy</code>注解</h4><p>作用：延迟创建单实例对象<br>注意：一旦使用 <code>@Lazy</code> 注解后，Spring 会在使用这个对象的时候，才创建这个对象</p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span></span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Lazy</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Account.Account&quot;</span>);    &#125;&#125;</code></pre></div><h4 id="生命周期方法相关注解"><a href="#生命周期方法相关注解" class="headerlink" title="生命周期方法相关注解"></a>生命周期方法相关注解</h4><p>初始化相关方法： <code>@PostConstruct</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml">InitializingBean<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span></code></pre></div><p>销毁方法：<code>@PreDestory</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml">DisposableBean<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">destory-method</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span></code></pre></div><p>注意：</p><ul><li>上述的两个注解并不是 Spring 提供的，由 <strong>JSR(JavaEE规范)520</strong> 提供</li><li>再次验证，通过注解实现了接口的契约性</li></ul><h3 id="2-2-注入相关注解"><a href="#2-2-注入相关注解" class="headerlink" title="2.2 注入相关注解"></a>2.2 注入相关注解</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a><code>@Autowired</code></h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200601114751016.png" alt="image-20200601114751016"></p><p><code>@Autowired</code> 注解 <strong>基于类型进行注入</strong> [推荐]：</p><ul><li>注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> UserDAO userDAO;</code></pre></div><p><code>@Autowired</code>、<code>@Qualifier</code> 注解联合实现 <strong>基于名字进行注入</strong> [了解]</p><ul><li>注入对象的 id 值，必须与 <code>@Qualifier</code> 注解中设置的名字相同</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-meta">@Qualifier(&quot;userDAOImpl&quot;)</span><span class="hljs-keyword">private</span> UserDAO userDAO;</code></pre></div><p><code>@Autowired</code> 注解放置位置：</p><ul><li>放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）</li><li><strong>直接放置在成员变量上</strong>，Spring 通过<strong>反射直接对成员变量进行赋值 [推荐]</strong></li></ul><p>JavaEE 规范中类似功能的注解：</p><ul><li>JSR250 提供的 <code>@Resource(name=&quot;xxx&quot;)</code> <strong>基于名字进行注入</strong><br>等价于 <code>@Autowired</code> 与 <code>@Qualifier</code> 联合实现的效果<br>注意：<code>@Resource</code> 注解如果名字没有配对成功，会继续 <strong>按照类型进行注入</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name=&quot;userDAOImpl&quot;)</span><span class="hljs-keyword">private</span> UserDAO userDAO;</code></pre></div><ul><li>JSR330 提供的 <code>@Injection</code> 作用与 <code>@Autowired</code> 完全一样，一般用在 EJB3.0 中</li></ul><h4 id="JDK类型-value、-PropertySource"><a href="#JDK类型-value、-PropertySource" class="headerlink" title="JDK类型@value、@PropertySource"></a>JDK类型<code>@value</code>、<code>@PropertySource</code></h4><p>方法一：<code>@value</code> 注解的基本使用：</p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 设置xxx.properties    id = 10   name = suns<span class="hljs-bullet">2.</span> Spring的工厂读取这个配置文件    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:/xxx.properties&quot;</span>/&gt;</span></span><span class="hljs-bullet">3.</span> 代码中进行注入   属性 @Value(&quot;$&#123;key&#125;&quot;)</code></pre></div><p>方法二：使用 <code>@PropertySource</code> 取代 xml配置：</p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 设置xxx.properties    id = 10   name = suns<span class="hljs-bullet">2.</span> 在实体类上应用@PropertySource(&quot;classpath:/xx.properties&quot;)<span class="hljs-bullet">3.</span> 代码   属性 @Value(&quot;$&#123;key&#125;&quot;)</code></pre></div><p><code>@value</code> 注解使用细节：</p><ul><li><code>@Value</code> 注解不能应用在静态成员变量上，如果使用，获取的值为 null</li><li><code>@Value</code> 注解 + Properties 这种方式，不能注入集合类型<ul><li>Spring 提供新的配置形式 <strong>YAML(YML)</strong> (更多的用于SpringBoot中)</li></ul></li></ul><h3 id="2-3-注解扫描详解"><a href="#2-3-注解扫描详解" class="headerlink" title="2.3 注解扫描详解"></a>2.3 注解扫描详解</h3><p>这样配置，会扫描当前包及其子包 </p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.baizhiedu&quot;</span>/&gt;</span></code></pre></div><h4 id="2-3-1-排除方式"><a href="#2-3-1-排除方式" class="headerlink" title="2.3.1 排除方式"></a>2.3.1 排除方式</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div><p><code>type=&quot;xxx&quot;</code>，<code>xxx</code> 有以下几个可选项：</p><ul><li><code>assignable</code>：排除特定的类型</li><li><code>annotation</code>：排除特定的注解</li><li><code>aspectj</code>：切入点表达式，比较常用<br>包切入点： <code>com.yusael.bean..*</code><br>类切入点： <code>*..User</code></li><li><code>regex</code>：正则表达式，不常用，与切入点类似</li><li><code>custom</code>：自定义排除策略，常用于框架底层开发（在 SpringBoot 源码中大量使用）</li></ul><p>排除策略可以叠加使用：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;assignable&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.yusael.bean.User&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;aspectj&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.yusael.injection..*&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div><h4 id="2-3-1-包含方式"><a href="#2-3-1-包含方式" class="headerlink" title="2.3.1 包含方式"></a>2.3.1 包含方式</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div><p>与排除方式使用的区别：</p><ul><li><code>use-default-filters=&quot;false&quot;</code> 让 Spring 默认的注解扫描方式失效</li><li><code>&lt;context:include-filter type=&quot;&quot; expression=&quot;&quot;/&gt;</code> 用于指定扫描哪些注解<br><code>type=&quot;xxx&quot;</code> 与排除方式完全一样，可以参考上面</li></ul><p>包含策略也可以叠加使用：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.baizhiedu&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div><h3 id="2-4-对于注解开发的思考"><a href="#2-4-对于注解开发的思考" class="headerlink" title="2.4 对于注解开发的思考"></a>2.4 对于注解开发的思考</h3><p>Spring 通过注解配置，与通过xml文件进行配置是互通的</p><div class="hljs code-wrapper"><pre><code class="hljs markdown">// 通过注解配置UserDAOImpl@Repositorypublic class UserDAOImpl&#123;&#125;public class UserServiceImpl&#123;   private UserDAO userDAO;   set    get&#125;// 通过xml配置创建userDAO对象<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.UserServiceImpl&quot;</span>&gt;</span></span>   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDAOImpl&quot;</span>/&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span></code></pre></div><p><strong>什么情况下使用注解 什么情况下使用配置文件</strong></p><p>基础注解（<code>@Component</code>、<code>@Autowired</code>、<code>@Value</code>）用于程序员开发类型的配置：</p><ul><li>在程序员开发的类型上，可以加入对应注解进行对象的创建<ul><li>User、UserService、UserDAO、UserAction… 这些类都很适合用注解</li></ul></li><li>应用其他非程序员开发的类型时（框架自带的类），需要使用<code>&lt;bean&gt;</code>标签进行配置<ul><li>SqlSessionFactoryBean、MapperScannerConfigure 等 Spring 创建的类，无法使用注解</li></ul></li></ul><h2 id="3-Spring的高级注解（Spring3-x-及以上"><a href="#3-Spring的高级注解（Spring3-x-及以上" class="headerlink" title="3. Spring的高级注解（Spring3.x 及以上)"></a>3. Spring的高级注解（Spring3.x 及以上)</h2><h3 id="3-1-配置Bean"><a href="#3-1-配置Bean" class="headerlink" title="3.1 配置Bean"></a>3.1 配置Bean</h3><p>Spring 在 3.x 提供的新的注解<code>@Configuration</code>，用于替换 XML 配置文件</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;&#125;</code></pre></div><ul><li>配置Bean在应用的过程中 替换了XML具体什么内容呢？</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200703100033265.png" alt="image-20200703100033265"></p><ul><li><strong>使用了 <code>@Configuration</code> 后，用 <code>AnnotationConfigApplicationContext</code> 创建工厂：</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">方法<span class="hljs-number">1</span>: 指定配置bean的ClassApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);方法<span class="hljs-number">2</span>: 指定配置bean所在的路径(某个包及其子包)ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<span class="hljs-string">&quot;com.yusael&quot;</span>);</code></pre></div><p><code>@Configuration</code> <strong>注解的本质</strong>：查看源码可知，它也是 <code>@Component</code> 注解的衍生注解<br>因此我们可以用 <code>&lt;context:component-scan</code> 进行扫描，但我们不会这么做，因为注解就是为了取代 xml</p><ul><li><p><strong>配置Bean开发的细节分析</strong></p><ul><li><p>基于注解开发使用日志</p><blockquote><p>Spring基于注解的开发不能集成Log4j，推荐使用集成logback，需要自己引入 </p></blockquote><ul><li><p>引入相关jar</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.logback-extensions<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-ext-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>引入logback配置文件 <code>(logback.xml)</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 控制台输出 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div></li></ul></li><li><p>@Configuration注解的本质</p><blockquote><p>本质：也是@Component注解的衍生注解</p><p>可以应用&lt;context:component-scan进行扫描，但是实际开发不常用</p></blockquote></li></ul></li></ul><h3 id="3-2-Bean注解"><a href="#3-2-Bean注解" class="headerlink" title="3.2 @Bean注解"></a>3.2 @Bean注解</h3><blockquote><p>@Bean注解在配置bean中进行使用，等同于XML配置文件中的&lt;bean标签</p></blockquote><h4 id="3-2-1-Bean注解的基本使用"><a href="#3-2-1-Bean注解的基本使用" class="headerlink" title="3.2.1 @Bean注解的基本使用"></a>3.2.1 @Bean注解的基本使用</h4><p>对象的创建</p><p><strong>简单对象</strong>：直接能够通过 new 方式创建的对象</p><ul><li>User、UserService、UserDAO</li></ul><p><strong>复杂对象</strong>：不能通过 new 的方式直接创建的对象</p><ul><li>Connection、SqlSessionFactory</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200703150632630.png" alt="image-20200703150632630"></p><p><code>@Bean</code> 注解<strong>创建复杂对象</strong>的注意事项：遗留系统整合</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">conn1</span><span class="hljs-params">()</span> </span>&#123;Connection conn = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;ConnectionFactoryBean factoryBean = <span class="hljs-keyword">new</span> ConnectionFactoryBean();conn = factoryBean.getObject();&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">return</span> conn;&#125;</code></pre></div><p><code>@Bean</code> 注解创建对象，<strong>自定义 id 值</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;id&quot;)</span></code></pre></div><p><code>@Bean</code> 注解创建对象，<strong>控制对象创建次数</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@Scope(&quot;singleton|prototype&quot;)</span> <span class="hljs-comment">//默认值 singleton</span></code></pre></div><h4 id="3-2-2-Bean注解的注入"><a href="#3-2-2-Bean注解的注入" class="headerlink" title="3.2.2  @Bean注解的注入"></a>3.2.2  @Bean注解的注入</h4><ul><li><p>用户自定义类型</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span></span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> UserDAO <span class="hljs-title">userDAO</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserDAOImpl();&#125;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">userService</span><span class="hljs-params">(UserDAO userDAO)</span> </span>&#123;UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();userService.setUserDAO(userDAO);<span class="hljs-keyword">return</span> userService;<span class="hljs-comment">//简化写法</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">userService</span><span class="hljs-params">()</span> </span>&#123;UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();userService.setUserDAO(userDAO());<span class="hljs-keyword">return</span> userService;&#125;  &#125;</code></pre></div></li><li><p>JDK类型的注入</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Customer <span class="hljs-title">customer</span><span class="hljs-params">()</span> </span>&#123;Customer customer = <span class="hljs-keyword">new</span> Customer();customer.setId(<span class="hljs-number">1</span>);customer.setName(<span class="hljs-string">&quot;xiaohei&quot;</span>);<span class="hljs-keyword">return</span> customer;&#125;</code></pre></div><ul><li><p>JDK类型注入的细节分析</p><p>如果直接在代码中进行 set 方法的调用，会存在耦合的问题，通过配置文件解决：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@PropertySource(&quot;classpath:/init.properties&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig1</span> </span>&#123;<span class="hljs-meta">@Value(&quot;$&#123;id&#125;&quot;)</span><span class="hljs-keyword">private</span> Integer id;<span class="hljs-meta">@Value(&quot;$&#123;name&#125;&quot;)</span><span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Customer <span class="hljs-title">customer</span><span class="hljs-params">()</span> </span>&#123;Customer customer = <span class="hljs-keyword">new</span> Customer();customer.setId(id);customer.setName(name);<span class="hljs-keyword">return</span> customer;&#125;&#125;</code></pre></div></li></ul></li></ul><h3 id="3-3-ComponentScan注解"><a href="#3-3-ComponentScan注解" class="headerlink" title="3.3  @ComponentScan注解"></a>3.3  @ComponentScan注解</h3><p><code>@ComponentScan</code> 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <code>&lt;context:component-scan&gt;</code> 标签</p><p>目的：进行相关注解的扫描（<code>@Component</code>、<code>@Value</code>、<code>@Autowired</code> …)</p><h4 id="3-3-1-基本使用"><a href="#3-3-1-基本使用" class="headerlink" title="3.3.1 基本使用"></a>3.3.1 基本使用</h4><ul><li>XML 方式：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael.scan&quot;</span>/&gt;</span></code></pre></div><ul><li>注解方式</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.yusael.scan&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig2</span> </span>&#123;&#125;</code></pre></div><h4 id="3-3-2-排除、包含的使用"><a href="#3-3-2-排除、包含的使用" class="headerlink" title="3.3.2 排除、包含的使用"></a>3.3.2 排除、包含的使用</h4><p><strong>排除</strong></p><ul><li>XML 方式：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;assignable&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.yusael.bean.User&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div><ul><li><strong>注解方式</strong>：<br>排除特定的注解：<code>type = FilterType.ANNOTATION, value=&#123;&#125;</code><br>排除特定的类型：<code>type = FilterType.ASSIGNABLE_TYPE , value=&#123;]</code><br>切入点表达式：<code>type = FilterType.ASPECTJ, pattern=&quot;&quot;</code><br>正则表达式：<code>type = FilterType.REGEX, pattern=&quot;&quot;</code><br>自定义排除策略：<code>type = FilterType.CUSTOM, pattern=&quot;&quot;</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.yusael.scan&quot;,</span><span class="hljs-meta"> excludeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION, value=&#123;Service.class&#125;),</span><span class="hljs-meta">                   @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = &quot;*..User1&quot;)&#125;)</span></code></pre></div><p><strong>包含</strong></p><ul><li>XML 方式：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div><ul><li>注解方式：参数与排除策略中一样</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.yusaael.scan&quot;,</span><span class="hljs-meta">useDefaultFilters = false,</span><span class="hljs-meta">includeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION,value=&#123;Service.class&#125;)&#125;)</span></code></pre></div><h3 id="3-4-Spring工厂创建对象的多种配置方式"><a href="#3-4-Spring工厂创建对象的多种配置方式" class="headerlink" title="3.4 Spring工厂创建对象的多种配置方式"></a>3.4 Spring工厂创建对象的多种配置方式</h3><h4 id="3-4-1-多种配置方式的应用场景"><a href="#3-4-1-多种配置方式的应用场景" class="headerlink" title="3.4.1 多种配置方式的应用场景"></a>3.4.1 多种配置方式的应用场景</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200706174301418.png" alt="image-20200706174301418"></p><h4 id="3-4-2-配置优先级"><a href="#3-4-2-配置优先级" class="headerlink" title="3.4.2 配置优先级"></a>3.4.2 配置优先级</h4><p>配置优先级：<code>@Component</code> 及其衍生注解   **&lt;**   <code>@Bean</code>    **&lt;**    配置文件<code>&lt;bean&gt;</code>标签</p><ul><li>优先级高的配置，会覆盖优先级低配置</li><li>配置覆盖：id 值需要保持一致</li></ul><p>通过配置优先级，可以解决基于注解进行配置的耦合问题：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-comment">//@ImportResource(&quot;applicationContext.xml&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig4</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDAO <span class="hljs-title">userDAO</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserDAOImpl();    &#125;&#125;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ImportResource(&quot;applicationContext.xml&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig5</span></span>&#123;  &#125;<span class="hljs-comment">//applicationContext.xml覆盖旧实现</span>&lt;bean id=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.baizhiedu.injection.UserDAOImplNew&quot;</span>/&gt;</code></pre></div><h3 id="3-5-整合多个配置信息"><a href="#3-5-整合多个配置信息" class="headerlink" title="3.5 整合多个配置信息"></a>3.5 整合多个配置信息</h3><p>为什么会有多个配置信息</p><blockquote><p>拆分多个配置bean的开发，是一种模块化开发的形式，也体现了面向对象各司其职的设计思想</p></blockquote><p>多配置信息整合的方式</p><ul><li>多个配置Bean的整合</li><li>配置Bean与<code>@Component</code>相关注解的整合</li><li>配置Bean与SpringXML配置文件的整合</li></ul><p>整合多种配置需要关注那些要点</p><ul><li>如何使多配置的信息汇总成一个整体</li><li>如何实现跨配置的注入</li></ul><h4 id="3-5-1-多个配置Bean的整合"><a href="#3-5-1-多个配置Bean的整合" class="headerlink" title="3.5.1. 多个配置Bean的整合"></a>3.5.1. 多个配置Bean的整合</h4><p><strong>多配置的信息汇总</strong></p><ul><li><p>base-package进行多个配置Bean的整合</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200707170421669.png" alt="image-20200707170421669"></p></li><li><p><code>@Import</code></p><ul><li>可以创建对象</li><li>多配置bean的整合</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200707170745814.png" alt="image-20200707170745814"></p></li><li><p>在工厂创建时，指定多个配置Bean的Class对象 【了解】</p><div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig1.class,AppConfig2.class);</code></pre></div></li><li><p>跨配置进行注入</p><p>在应用配置 Bean 的过程中，不管使用哪种方式进行配置信息的汇总，其操作方式都是通过成员变量加入 <code>@Autowired</code> 注解完成</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import(AppConfig2.class)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig1</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserDAO userDAO;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">userService</span><span class="hljs-params">()</span> </span>&#123;        UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();        userService.setUserDAO(userDAO);        <span class="hljs-keyword">return</span> userService;    &#125;&#125;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig2</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDAO <span class="hljs-title">userDAO</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserDAOImpl();    &#125;&#125;</code></pre></div></li></ul><h4 id="3-5-2-配置Bean与-Component相关注解的整合"><a href="#3-5-2-配置Bean与-Component相关注解的整合" class="headerlink" title="3.5.2 配置Bean与@Component相关注解的整合"></a>3.5.2 配置Bean与@Component相关注解的整合</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>/<span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDAOImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDAO</span></span>&#123;&#125;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(&quot;UserDao所在的包&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig3</span> </span>&#123;       <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserDAO userDAO;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">userService</span><span class="hljs-params">()</span> </span>&#123;        UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();        userService.setUserDAO(userDAO);        <span class="hljs-keyword">return</span> userService;    &#125;&#125;ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig3.class);</code></pre></div><h4 id="3-5-3-配置Bean与配置文件整合"><a href="#3-5-3-配置Bean与配置文件整合" class="headerlink" title="3.5.3  配置Bean与配置文件整合"></a>3.5.3  配置Bean与配置文件整合</h4><p>主要用于：</p><ul><li>遗留系统的整合</li><li>配置覆盖</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDAOImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDAO</span></span>&#123;&#125;&lt;bean id=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.baizhiedu.injection.UserDAOImpl&quot;</span>/&gt;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ImportResource(&quot;applicationContext.xml&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig4</span> </span>&#123;      <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserDAO userDAO;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">userService</span><span class="hljs-params">()</span> </span>&#123;        UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();        userService.setUserDAO(userDAO);        <span class="hljs-keyword">return</span> userService;    &#125;&#125;ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig4.class);</code></pre></div><h3 id="3-6-配置Bean底层实现原理"><a href="#3-6-配置Bean底层实现原理" class="headerlink" title="3.6 配置Bean底层实现原理"></a>3.6 配置Bean底层实现原理</h3><blockquote><p>Spring 在配置 Bean 中加入了 <code>@Configuration</code> 注解后，Spring底层就会通过AOP的方式来控制对象的创建次数，即 Cglib 的代理方式，来进行对象相关的配置、处理</p></blockquote><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200709114200371.png" alt="image-20200709114200371"> </p><h2 id="4-四维一体的开发思想"><a href="#4-四维一体的开发思想" class="headerlink" title="4. 四维一体的开发思想"></a>4. 四维一体的开发思想</h2><h3 id="4-1-什么是四维一体"><a href="#4-1-什么是四维一体" class="headerlink" title="4.1 什么是四维一体"></a>4.1 什么是四维一体</h3><blockquote><p>Spring开发一个功能的4种形式，虽然开发方式不同，但是最终效果是一样的</p><ul><li>基于schema </li><li>基于特定功能注解 </li><li>基于原始&lt;bean </li><li>基于@Bean注解</li></ul></blockquote><h3 id="4-2-四维一体的开发案例"><a href="#4-2-四维一体的开发案例" class="headerlink" title="4.2 四维一体的开发案例"></a>4.2 四维一体的开发案例</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>&lt;context:property-placehoder<span class="hljs-number">2.</span><span class="hljs-meta">@PropertySource</span>  【推荐】<span class="hljs-number">3.</span>&lt;bean id=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;PropertySourcePlaceholderConfigure&quot;</span>/&gt;  &lt;property name=<span class="hljs-string">&quot;location&quot;</span> value=<span class="hljs-string">&quot;classpath:xx.properties&quot;</span>/&gt;<span class="hljs-number">4.</span><span class="hljs-meta">@Bean</span>            【推荐】</code></pre></div><h2 id="5-纯注解版AOP编程"><a href="#5-纯注解版AOP编程" class="headerlink" title="5. 纯注解版AOP编程"></a>5. 纯注解版AOP编程</h2><h3 id="5-1-搭建环境"><a href="#5-1-搭建环境" class="headerlink" title="5.1 搭建环境"></a>5.1 搭建环境</h3><ul><li>应用配置Bean </li><li>注解扫描</li></ul><h3 id="5-2-开发步骤"><a href="#5-2-开发步骤" class="headerlink" title="5.2 开发步骤"></a>5.2 开发步骤</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span> 原始对象   <span class="hljs-meta">@Service</span>/<span class="hljs-meta">@Component</span>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;   &#125;<span class="hljs-number">2.</span> 创建切面类 （额外功能 切入点 组装切面）    <span class="hljs-meta">@Aspect</span>    <span class="hljs-meta">@Component</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;        <span class="hljs-meta">@Around(&quot;execution(* login(..))&quot;)</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">arround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;            System.out.println(<span class="hljs-string">&quot;----aspect log ------&quot;</span>);            Object ret = joinPoint.proceed();            <span class="hljs-keyword">return</span> ret;        &#125;    &#125;<span class="hljs-number">3.</span> Spring的配置文件中   &lt;aop:aspectj-autoproxy /&gt;   <span class="hljs-meta">@EnableAspectjAutoProxy</span> ---&gt; 配置Bean</code></pre></div><h3 id="5-3-注解AOP细节分析"><a href="#5-3-注解AOP细节分析" class="headerlink" title="5.3 注解AOP细节分析"></a>5.3 注解AOP细节分析</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span> 代理创建方式的切换 JDK Cglib    &lt;aop:aspectj-autoproxy proxy-target-<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-keyword">true</span>|<span class="hljs-keyword">false</span> /&gt;   <span class="hljs-meta">@EnableAspectjAutoProxy(proxyTargetClass = &quot;true|false&quot;)</span><span class="hljs-number">2.</span> SpringBoot AOP的开发方式     <span class="hljs-meta">@EnableAspectjAutoProxy</span> 已经设置好了     <span class="hljs-number">1.</span> 原始对象     <span class="hljs-meta">@Service(@Component)</span>     <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;     &#125;    <span class="hljs-number">2.</span> 创建切面类 （额外功能 切入点 组装切面）      <span class="hljs-meta">@Aspect</span>      <span class="hljs-meta">@Component</span>      <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;        <span class="hljs-meta">@Around(&quot;execution(* login(..))&quot;)</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">arround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;          System.out.println(<span class="hljs-string">&quot;----aspect log ------&quot;</span>);          Object ret = joinPoint.proceed();          <span class="hljs-keyword">return</span> ret;        &#125;      &#125;<span class="hljs-comment">//Spring AOP 代理默认实现 JDK  SpringBOOT AOP 代理默认实现 Cglib </span></code></pre></div><h3 id="5-4-纯注解版Spring-MyBatis整合"><a href="#5-4-纯注解版Spring-MyBatis整合" class="headerlink" title="5.4 纯注解版Spring+MyBatis整合"></a>5.4 纯注解版Spring+MyBatis整合</h3><p><strong>基础配置 （配置Bean）</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml">1. 连接池  <span class="hljs-comment">&lt;!--连接池--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/suns?useSSL=false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>   @Bean   public DataSource dataSource()&#123;      DruidDataSource dataSource = new DruidDataSource();      dataSource.setDriverClassName(&quot;&quot;);      dataSource.setUrl();      ...      return dataSource;   &#125;2. SqlSessionFactoryBean    <span class="hljs-comment">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.baizhiedu.entity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:com.baizhiedu.mapper/*Mapper.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    @Bean    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;         SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();         sqlSessionFactoryBean.setDataSource(dataSource);         sqlSessionFactoryBean.setTypeAliasesPackage(&quot;&quot;);         ...         return sqlSessionFactoryBean;    &#125;3. MapperScannerConfigure    <span class="hljs-comment">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scanner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.baizhiedu.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  @MapperScan(basePackages=&#123;&quot;com.baizhiedu.dao&quot;&#125;) ---&gt; 配置bean完成</code></pre></div><p><strong>编码</strong></p><ul><li>实体</li><li>表</li><li>DAO接口</li><li>Mapper文件 </li></ul><h4 id="5-4-1-MapperLocations编码时通配的写法"><a href="#5-4-1-MapperLocations编码时通配的写法" class="headerlink" title="5.4.1 MapperLocations编码时通配的写法"></a>5.4.1 MapperLocations编码时通配的写法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//设置Mapper文件的路径</span>sqlSessionFactoryBean.setMapperLocations(Resource..);Resource resouce = <span class="hljs-keyword">new</span> ClassPathResouce(<span class="hljs-string">&quot;UserDAOMapper.xml&quot;</span>)sqlSessionFactoryBean.setMapperLocations(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;UserDAOMapper.xml&quot;</span>));&lt;property name=<span class="hljs-string">&quot;mapperLocations&quot;</span>&gt;   &lt;list&gt;     &lt;value&gt;classpath:com.baizhiedu.mapper<span class="hljs-comment">/*Mapper.xml&lt;/value&gt;</span><span class="hljs-comment">   &lt;/list&gt;</span><span class="hljs-comment">&lt;/property&gt;</span><span class="hljs-comment">//传入的是一组Mapper文件，不适用上面setMapperLocations的方式</span></code></pre></div><p><strong>更好的写法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">ResourcePatternResolver resolver = <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver();Resource[] resources = resolver.getResources(<span class="hljs-string">&quot;com.baizhi.mapper/*Mapper.xml&quot;</span>);sqlSessionFactoryBean.setMapperLocations(resources)</code></pre></div><h4 id="5-4-2-配置Bean数据耦合的问题"><a href="#5-4-2-配置Bean数据耦合的问题" class="headerlink" title="5.4.2 配置Bean数据耦合的问题"></a>5.4.2 配置Bean数据耦合的问题</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">mybatis.driverClassName</span> = <span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-meta">mybatis.url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/suns?useSSL=false</span><span class="hljs-meta">mybatis.username</span> = <span class="hljs-string">root</span><span class="hljs-meta">mybatis.password</span> = <span class="hljs-string">123456</span><span class="hljs-meta">mybatis.typeAliasesPackages</span> = <span class="hljs-string">com.baizhiedu.mybatis</span><span class="hljs-meta">mybatis.mapperLocations</span> = <span class="hljs-string">com.baizhiedu.mapper/*Mapper.xml</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@PropertySource(&quot;classpath:mybatis.properties&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisProperties</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.driverClassName&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String driverClassName;    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.url&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String url;    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.username&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String username;    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.password&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String password;    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.typeAliasesPackages&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String typeAliasesPackages;    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String mapperLocations;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisAutoConfiguration</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MybatisProperties mybatisProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();        dataSource.setDriverClassName(mybatisProperties.getDriverClassName());        dataSource.setUrl(mybatisProperties.getUrl());        dataSource.setUsername(mybatisProperties.getUsername());        dataSource.setPassword(mybatisProperties.getPassword());        <span class="hljs-keyword">return</span> dataSource;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactoryBean <span class="hljs-title">sqlSessionFactoryBean</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(dataSource);        sqlSessionFactoryBean.setTypeAliasesPackage(mybatisProperties.getTypeAliasesPackages(<span class="hljs-string">&quot;&quot;</span>));        <span class="hljs-comment">//sqlSessionFactoryBean.setMapperLocations(new ClassPathResource(&quot;UserDAOMapper.xml&quot;));</span>        <span class="hljs-keyword">try</span> &#123;            ResourcePatternResolver resolver = <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver();            Resource[] resources = resolver.getResources(mybatisProperties.getMapperLocations());            sqlSessionFactoryBean.setMapperLocations(resources);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> sqlSessionFactoryBean;    &#125;&#125;</code></pre></div><h2 id="6-纯注解版事务编程"><a href="#6-纯注解版事务编程" class="headerlink" title="6. 纯注解版事务编程"></a>6. 纯注解版事务编程</h2><div class="hljs code-wrapper"><pre><code class="hljs xml">1. 原始对象 XXXService   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.service.UserServiceImpl&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>   @Service   public class UserServiceImpl implements UserService&#123;         @Autowired         private UserDAO userDAO;   &#125;2. 额外功能   <span class="hljs-comment">&lt;!--DataSourceTransactionManager--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    @Bean    public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource)&#123;          DataSourceTransactionManager dstm = new DataSourceTransactionManager();          dstm.setDataSource(dataSource);          return dstm;     &#125;3. 事务属性    @Transactional    @Service    public class UserServiceImpl implements UserService &#123;        @Autowired        private UserDAO userDAO;4. 基于Schema的事务配置    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span>   @EnableTransactionManager ---&gt; 配置Bean</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.baizhiedu.mybatis&quot;);   SpringBoot 实现思想<span class="hljs-bullet">2.</span> 注解版MVC整合，SpringMVC中进行详细讲解   SpringMyBatis ---&gt;DAO  事务基于注解 --&gt; Service   Controller    org.springframework.web.context.ContextLoaderListener ---&gt; XML工厂 无法提供 new AnnotationConfigApplicationContext</code></pre></div><h2 id="7-Spring框架中YML的使用"><a href="#7-Spring框架中YML的使用" class="headerlink" title="7. Spring框架中YML的使用"></a>7. Spring框架中YML的使用</h2><h3 id="7-1-什么是YML"><a href="#7-1-什么是YML" class="headerlink" title="7.1 什么是YML"></a>7.1 什么是YML</h3><blockquote><p>YML(YAML) 是一种新形式的配置文件，比 XML 更简单，比 Properties 更强大</p></blockquote><h3 id="7-2-Properties进行配置问题"><a href="#7-2-Properties进行配置问题" class="headerlink" title="7.2 Properties进行配置问题"></a>7.2 Properties进行配置问题</h3><blockquote><ul><li>Properties 表达过于繁琐，无法表达数据的内在联系</li><li>Properties 无法表达对象、集合类型</li></ul></blockquote><h3 id="7-3-YML语法简介"><a href="#7-3-YML语法简介" class="headerlink" title="7.3 YML语法简介"></a>7.3 YML语法简介</h3><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">定义yml文件</span>    <span class="hljs-string">xxx.yml</span> <span class="hljs-string">xxx.yaml</span><span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">语法</span>   <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">基本语法</span>      <span class="hljs-attr">name:</span> <span class="hljs-string">suns</span>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>   <span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">对象概念</span>       <span class="hljs-attr">account:</span>          <span class="hljs-attr">id:</span> <span class="hljs-number">1</span>         <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>   <span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">定义集合</span>       <span class="hljs-attr">service:</span>          <span class="hljs-bullet">-</span> <span class="hljs-number">11111</span>         <span class="hljs-bullet">-</span> <span class="hljs-number">22222</span></code></pre></div><h3 id="7-4-Spring与YML集成思路的分析"><a href="#7-4-Spring与YML集成思路的分析" class="headerlink" title="7.4 Spring与YML集成思路的分析"></a>7.4 Spring与YML集成思路的分析</h3><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 准备yml配置文件    init.yml   name: suns   password: 123456<span class="hljs-bullet">2.</span> 读取yml 转换成 Properties   YamlPropertiesFactoryBean.setResources( yml配置文件的路径 new ClassPathResource();)    YamlPropertiesFactoryBean.getObject() ---&gt; Properties <span class="hljs-bullet">3.</span> 应用PropertySourcesPlaceholderConfigurer   PropertySourcesPlaceholderConfigurer.setProperties();<span class="hljs-bullet">4.</span> 类中 @Value注解 注入</code></pre></div><h3 id="7-5-Spring与YML集成编码"><a href="#7-5-Spring与YML集成编码" class="headerlink" title="7.5 Spring与YML集成编码"></a>7.5 Spring与YML集成编码</h3><p><strong>环境搭建</strong></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>snakeyaml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>最低版本 1.18</code></pre></div><p><strong>编码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1. 准备yml配置文件</span><span class="hljs-comment">//2. 配置Bean中操作 完成YAML读取 与 PropertySourcePlaceholderConfigure的创建 </span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PropertySourcesPlaceholderConfigurer <span class="hljs-title">configurer</span><span class="hljs-params">()</span> </span>&#123;YamlPropertiesFactoryBean yamlPropertiesFactoryBean = <span class="hljs-keyword">new</span> YamlPropertiesFactoryBean();      <span class="hljs-comment">//读取</span>        yamlPropertiesFactoryBean.setResources(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;init.yml&quot;</span>));        Properties properties = yamlPropertiesFactoryBean.getObject();      <span class="hljs-comment">//创建好集合</span>PropertySourcesPlaceholderConfigurer configurer = <span class="hljs-keyword">new</span> PropertySourcesPlaceholderConfigurer();        configurer.setProperties(properties);        <span class="hljs-keyword">return</span> configurer;    &#125;<span class="hljs-comment">//3. 类 加入 @Value注解 </span></code></pre></div><h3 id="7-6-Spring与YML集成的问题"><a href="#7-6-Spring与YML集成的问题" class="headerlink" title="7.6 Spring与YML集成的问题"></a>7.6 Spring与YML集成的问题</h3><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 集合处理的问题   SpringEL表达式解决   list:111,222,333   @Value(&quot;#&#123;&#x27;$&#123;list&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)<span class="hljs-bullet">2.</span> 对象类型的YAML进行配置时 过于繁琐    @Value(&quot;$&#123;account.name&#125;&quot;)<span class="hljs-section"># SpringBoot解决了以上两个问题，利用@ConfigurationProperties</span></code></pre></div><h1 id="第六章、SpringMVC"><a href="#第六章、SpringMVC" class="headerlink" title="第六章、SpringMVC"></a>第六章、SpringMVC</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><blockquote><p>Spring Web MVC 是一种基于 Java 的实现了 Web MVC 设计模式的请求驱动类型的轻量级 Web 框架，即使用了 MVC 架构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC 也是要简化我们日常 Web 开发的。在 传统的 Jsp/Servlet 技术体系中，如果要开发接口，一个接口对应一个 Servlet，会导致我们开发出许多 Servlet，使用 SpringMVC 可以有效的简化这一步骤</p></blockquote><blockquote><p>Spring Web MVC 也是服务到工作者模式的实现，但进行可优化。前端控制器是 <code>DispatcherServlet</code>；应用控制器可以拆为处理器映射器<code>(Handler Mapping</code>)进行处理器管理和视图解析器(<code>View Resolver</code>)进行视图管理；页面控制器/动作/处理器为 Controller 接口（仅包含 <code>ModelAndView handleRequest</code>(request, response) 方法，也有人称作 Handler）的实现（也可以是任何的 POJO 类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持</p></blockquote><p><strong>Spring Web MVC能帮我们做什么</strong></p><ul><li>让我们能非常简单的设计出干净的 Web 层和薄薄的 Web 层；</li><li>进行更简洁的 Web 层的开发；</li><li>天生与 Spring 框架集成（如 IoC 容器、AOP 等）；</li><li>提供强大的约定大于配置的契约式编程支持；</li><li>能简单的进行 Web 层的单元测试；</li><li>支持灵活的 URL 到页面控制器的映射；</li><li>非常容易与其他视图技术集成，如 Velocity、FreeMarker 等等，因为模型数据不放在特定的 API 里，而是放在一个 Model 里（Map 数据结构实现，因此很容易被其他框架使用）；</li><li>非常灵活的数据验证、格式化和数据绑定机制，能使用任何对象进行数据绑定，不必实现特定框架的 API；</li><li>提供一套强大的 JSP 标签库，简化 JSP 开发；</li><li>支持灵活的本地化、主题等解析；</li><li>更加简单的异常处理；</li><li>对静态资源的支持；</li><li>支持 RESTful 风格</li></ul><h2 id="2-HelloWorld"><a href="#2-HelloWorld" class="headerlink" title="2. HelloWorld"></a>2. HelloWorld</h2><ul><li>在<code> pom.xml</code> 文件中，添加 spring-webmvc 的依赖：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><p>添加 <code>spring-webmvc</code> 依赖之后，<code>spring-web、spring-aop、spring-context</code>等等就全部都加入进来了</p><ul><li>准备一个 Controller，即一个处理浏览器请求的接口。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这就是一个请求处理接口</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req 这就是前端发送来的请求</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp 这就是服务端给前端的响应</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回值是一个 ModelAndView，Model 相当于是我们的数据模型，View 是我们的视图</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);        mv.addObject(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);        <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div><p>这里我们我们创建出来的 Controller 就是前端请求处理接口</p><ul><li>创建视图</li></ul><p>这里我们就采用 jsp 作为视图，在 webapp 目录下创建<code>hello.jsp</code>文件，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello $&#123;name&#125;!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><ul><li>在 <code>resources</code> 目录下，创建一个名为<code> spring-servlet.xml</code> 的 springmvc 的配置文件，这里，我们先写一个简单的 demo ，因此可以先不用添加 spring 的配置</li></ul><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--MyController实例--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.javaboy.helloworld.MyController&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;/hello&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--这个是处理器映射器，这种方式，请求地址其实就是一个 Bean 的名字，然后根据这个 bean 的名字查找对应的处理器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerMapping&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/hello&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>   <span class="hljs-comment">&lt;!--处理适配器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerAdapter&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--视图解析器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/jsp/&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><ul><li>加载 springmvc 配置文件</li></ul><p>在 web 项目启动时，加载 springmvc 配置文件，这个配置是在 <code>web.xml</code>中完成的。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre></div><p>所有请求都将自动拦截下来，拦截下来后，请求交给 <code>DispatcherServlet</code> 去处理，在加载 <code>DispatcherServlet</code> 时，还需要指定配置文件路径。这里有一个默认的规则，如果配置文件放在 <code>webapp/WEB-INF/ </code>目录下，并且配置文件的名字等于 <code>DispatcherServlet</code> 的名字+ <code>-servlet</code>（即这里的配置文件路径是 <code>webapp/WEB-INF/springmvc-servlet.xml</code>），如果是这样的话，可以不用添加<code> init-param</code> 参数，即不用手动配置 springmvc 的配置文件，框架会自动加载</p><ul><li><p>配置并启动项目</p></li><li><p>项目启动成功后，浏览器输入 <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> 就可以看到如下页面：</p></li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/2-1.png" alt="2-1.png"></p><h2 id="3-SpringMVC-工作流程"><a href="#3-SpringMVC-工作流程" class="headerlink" title="3. SpringMVC 工作流程"></a>3. SpringMVC 工作流程</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-1.png" alt="3-1.png"></p><ul><li><code>DispatcherServlet</code>：前端控制器</li></ul><p>用户请求到达前端控制器，它就相当于 mvc 模式中的c，DispatcherServlet 是整个流程控制的中心，相当于是 SpringMVC 的大脑，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p><ul><li><code>HandlerMapping</code>：处理器映射器</li></ul><p>HandlerMapping 负责根据用户请求找到 Handler 即处理器（也就是我们所说的 Controller），SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等，在实际开发中，我们常用的方式是注解方式。</p><ul><li><code>Handler</code>：处理器</li></ul><p>Handler 是继 DispatcherServlet 前端控制器的后端控制器，在DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。由于 Handler 涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发 Handler。（这里所说的 Handler 就是指我们的 Controller）</p><ul><li><code>HandlAdapter</code>：处理器适配器</li></ul><p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><ul><li><code>ViewResolver</code>：视图解析器</li></ul><p>ViewResolver 负责将处理结果生成 View 视图，ViewResolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p><h2 id="4-DispatcherServlet"><a href="#4-DispatcherServlet" class="headerlink" title="4. DispatcherServlet"></a>4. DispatcherServlet</h2><h3 id="4-1-DispatcherServlet作用"><a href="#4-1-DispatcherServlet作用" class="headerlink" title="4.1 DispatcherServlet作用"></a>4.1 DispatcherServlet作用</h3><p><code>DispatcherServlet </code>是前端控制器设计模式的实现，提供 Spring Web MVC 的集中访问点，而且负责职责的分派，而且与 Spring IoC 容器无缝集成，从而可以获得 Spring 的所有好处。<code>DispatcherServlet</code> 主要用作职责调度工作，本身主要用于控制流程，主要职责如下：</p><ul><li>文件上传解析，如果请求类型是 <code>multipart</code> 将通过 <code>MultipartResolver</code> 进行文件上传解析；</li><li>通过<code> HandlerMapping</code>，将请求映射到处理器（返回一个 <code>HandlerExecutionChain</code>，它包括一个处理器、多个 <code>HandlerInterceptor</code> 拦截器）；</li><li>通过 <code>HandlerAdapter</code> 支持多种类型的处理器(<code>HandlerExecutionChain </code>中的处理器)；</li><li>通过 <code>ViewResolver </code>解析逻辑视图名到具体视图实现；</li><li>本地化解析；</li><li>渲染具体的视图等；</li><li>如果执行过程中遇到异常将交给 <code>HandlerExceptionResolver </code>来解析</li></ul><h3 id="4-2-DispathcherServlet配置详解"><a href="#4-2-DispathcherServlet配置详解" class="headerlink" title="4.2 DispathcherServlet配置详解"></a>4.2 DispathcherServlet配置详解</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><ul><li><code>load-on-startup</code>：表示启动容器时初始化该 Servlet；</li><li><code>url-pattern</code>：表示哪些请求交给 Spring Web MVC 处理， “/” 是用来定义默认 servlet 映射的。也可以如 <code>*.html</code>表示拦截所有以 html 为扩展名的请求</li><li><code>contextConfigLocation</code>：表示 SpringMVC 配置文件的路径</li></ul><p>其他的参数配置：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">contextClass</td><td align="left">实现WebApplicationContext接口的类，当前的servlet用它来创建上下文。如果这个参数没有指定， 默认使用XmlWebApplicationContext。</td></tr><tr><td align="left">contextConfigLocation</td><td align="left">传给上下文实例（由contextClass指定）的字符串，用来指定上下文的位置。这个字符串可以被分成多个字符串（使用逗号作为分隔符） 来支持多个上下文（在多上下文的情况下，如果同一个bean被定义两次，后面一个优先）。</td></tr><tr><td align="left">namespace</td><td align="left">WebApplicationContext命名空间。默认值是[server-name]-servlet。</td></tr></tbody></table><h3 id="4-3-Spring-配置"><a href="#4-3-Spring-配置" class="headerlink" title="4.3 Spring 配置"></a>4.3 Spring 配置</h3><p>之前的案例中，只有 SpringMVC，没有 Spring，Web 项目也是可以运行的。在实际开发中，Spring 和 SpringMVC 是分开配置的，所以我们对上面的项目继续进行完善，添加 Spring 相关配置。</p><p>首先，项目添加一个 service 包，提供一个 HelloService 类，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;    &#125;&#125;</code></pre></div><p>现在，假设我需要将 HelloService 注入到 Spring 容器中并使用它，这个是属于 Spring 层的 Bean，所以我们一般将除了 Controller 之外的所有 Bean 注册到 Spring 容器中，而将 Controller 注册到 SpringMVC 容器中，现在，在 resources 目录下添加 <code>applicationContext.xml </code>作为 spring 的配置：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.javaboy&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>但是，这个配置文件，默认情况下，并不会被自动加载，所以，需要我们在 web.xml 中对其进行配置：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre></div><p>首先通过 <code>context-param</code> 指定 Spring 配置文件的位置，这个配置文件也有一些默认规则，它的配置文件名默认就叫 <code>applicationContext.xml </code>，并且，如果你将这个配置文件放在 WEB-INF 目录下，那么这里就可以不用指定配置文件位置了，只需要指定监听器就可以了。这段配置是 Spring 集成 Web 环境的通用配置；一般用于加载除 Web 层的 Bean（如DAO、Service 等），以便于与其他任何Web框架集成。</p><ul><li><code>contextConfigLocation</code>：表示用于加载 Bean 的配置文件；</li><li><code>contextClass</code>：表示用于加载 Bean 的 <code>ApplicationContext </code>实现类，默认<code> WebApplicationContext</code></li></ul><p>配置完成之后，还需要修改 MyController，在 MyController 中注入 HelloSerivce:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.springframework.stereotype.Controller(<span class="hljs-string">&quot;/hello&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HelloService helloService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这就是一个请求处理接口</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req 这就是前端发送来的请求</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp 这就是服务端给前端的响应</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回值是一个 ModelAndView，Model 相当于是我们的数据模型，View 是我们的视图</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(helloService.hello(<span class="hljs-string">&quot;javaboy&quot;</span>));        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);        mv.addObject(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);        <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div><p><strong>注意</strong></p><p>为了在 SpringMVC 容器中能够扫描到<code> MyController</code> ，这里给 <code>MyController</code> 添加了 <code>@Controller</code> 注解，同时，由于我们目前采用的<code>HandlerMapping</code>是 <code>BeanNameUrlHandlerMapping</code>（意味着请求地址就是处理器 Bean 的名字），所以，还需要手动指定<code>MyController</code>的名字。</p><p>最后，修改 SpringMVC 的配置文件，将 Bean 配置为扫描形式：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--只扫描Controller--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.javaboy.helloworld&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerMapping&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/hello&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerAdapter&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--视图解析器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/jsp/&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>配置完成后，再次启动项目，Spring 容器也将会被创建。访问 /hello 接口，<code>HelloService</code> 中的 hello 方法就会自动被调用</p><h3 id="4-4-两个容器"><a href="#4-4-两个容器" class="headerlink" title="4.4 两个容器"></a>4.4 两个容器</h3><p>当 Spring 和 SpringMVC 同时出现，我们的项目中将存在两个容器，一个是 Spring 容器，另一个是 SpringMVC 容器，Spring 容器通过 <code>ContextLoaderListener</code> 来加载，SpringMVC 容器则通过<code> DispatcherServlet</code> 来加载，这两个容器不一样：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5-4-1.png" alt="5-4-1.png"></p><p>从图中可以看出：</p><ul><li><code>ContextLoaderListener</code> 初始化的上下文加载的 Bean 是对于整个应用程序共享的，不管是使用什么表现层技术，一般如 DAO 层、Service 层 Bean；</li><li><code>DispatcherServlet</code> 初始化的上下文加载的 Bean 是只对 Spring Web MVC 有效的 Bean，如 Controller、HandlerMapping、HandlerAdapter 等等，该初始化上下文应该只加载 Web相关组件</li><li>所以Controller里面能<code>@Autowired</code>Service，而Service里不能<code>@Autowired</code>Controller</li></ul><p><strong>为什么不在 Spring 容器中扫描所有 Bean？</strong></p><p>这个是不可能的。因为请求达到服务端后，找 <code>DispatcherServlet</code> 去处理，只会去 SpringMVC 容器中找，这就意味着 Controller 必须在 SpringMVC 容器中扫描。</p><p><strong>为什么不在 SpringMVC 容器中扫描所有 Bean？</strong></p><p>这个是可以的，可以在 SpringMVC 容器中扫描所有 Bean。不写在一起，有两个方面的原因：</p><ul><li>为了方便配置文件的管理</li><li>在 Spring+SpringMVC+Hibernate 组合中，实际上也不支持这种写法</li></ul><h2 id="5-处理器详解"><a href="#5-处理器详解" class="headerlink" title="5. 处理器详解"></a>5. 处理器详解</h2><h3 id="5-1-HandlerMapping"><a href="#5-1-HandlerMapping" class="headerlink" title="5.1 HandlerMapping"></a>5.1 HandlerMapping</h3><blockquote><p>注意，下文所说的处理器即我们平时所见到的 Controller</p></blockquote><p><code>HandlerMapping</code> ，中文译作处理器映射器，在 SpringMVC 中，系统提供了很多 <code>HandlerMapping</code>：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/6-1.png" alt="6-1.png"></p><p><code>HandlerMapping</code> 是负责根据 request 请求找到对应的 Handler 处理器及 Interceptor 拦截器，将它们封装在 <code>HandlerExecutionChain </code>对象中返回给前端控制器。</p><ul><li><code>BeanNameUrlHandlerMapping</code></li></ul><p><code>BeanNameUrl</code> 处理器映射器，根据请求的 url 与 Spring 容器中定义的 bean 的 name 进行匹配，从而从 Spring 容器中找到 bean 实例，就是说，请求的 Url 地址就是处理器 Bean 的名字。</p><p>这个 <code>HandlerMapping</code> 配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerMapping&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/hello&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><ul><li><code>SimpleUrlHandlerMapping</code></li></ul><p><code>SimpleUrlHandlerMapping</code> 是 <code>BeanNameUrlHandlerMapping </code>的增强版本，它可以将 url 和处理器 bean 的 id 进行统一映射配置:</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerMapping&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mappings&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;/hello&quot;</span>&gt;</span>myController<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;/hello2&quot;</span>&gt;</span>myController2<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>注意，在 props 中，可以配置多个请求路径和处理器实例的映射关系</p><h3 id="5-2-HandlerAdapter"><a href="#5-2-HandlerAdapter" class="headerlink" title="5.2 HandlerAdapter"></a>5.2 HandlerAdapter</h3><p><code>HandlerAdapter</code>，中文译作处理器适配器</p><p><code>HandlerAdapter</code> 会根据适配器接口对后端控制器进行包装（适配），包装后即可对处理器进行执行，通过扩展处理器适配器可以执行多种类型的处理器，这里使用了适配器设计模式</p><p>在 SpringMVC 中，<code>HandlerAdapter</code> 也有诸多实现类：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/6-2.png" alt="6-2.png"></p><ul><li><code>SimpleControllerHandlerAdapter</code></li></ul><p><code>SimpleControllerHandlerAdapter</code> 简单控制器处理器适配器，所有实现了 <code>org.springframework.web.servlet.mvc.Controller</code> 接口的 Bean 通过此适配器进行适配、执行，也就是说，如果我们开发的接口是通过实现 Controller 接口来完成的（不是通过注解开发的接口），那么 HandlerAdapter 必须是 <code>SimpleControllerHandlerAdapter</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span> /&gt;</span></code></pre></div><ul><li><code>HttpRequestHandlerAdapter</code></li></ul><p><code>HttpRequestHandlerAdapter</code>，http 请求处理器适配器，所有实现了 <code>org.springframework.web.HttpRequestHandler</code> 接口的 Bean 通过此适配器进行适配、执行。</p><p>例如存在如下接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpRequestHandler</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        System.out.println(<span class="hljs-string">&quot;-----MyController2-----&quot;</span>);    &#125;&#125;&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span> id=<span class="hljs-string">&quot;handlerMapping&quot;</span>&gt;    &lt;property name=<span class="hljs-string">&quot;mappings&quot;</span>&gt;        &lt;props&gt;            &lt;prop key=&quot;/hello2&quot;&gt;myController2&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;</span> id=<span class="hljs-string">&quot;handlerAdapter&quot;</span>/&gt;</code></pre></div><h3 id="5-3-最佳实践"><a href="#5-3-最佳实践" class="headerlink" title="5.3 最佳实践"></a>5.3 最佳实践</h3><p>各种情况都大概了解了，我们看下项目中的具体实践。</p><ul><li>组件自动扫描</li></ul><p>web 开发中，我们基本上不再通过 XML 或者 Java 配置来创建一个 Bean 的实例，而是直接通过组件扫描来实现 Bean 的配置，如果要扫描多个包，多个包之间用 , 隔开即可：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.sang&quot;</span>/&gt;</span></code></pre></div><ul><li><code>HandlerMapping</code></li></ul><p>正常情况下，我们在项目中使用的是<code> RequestMappingHandlerMapping</code>，这个是根据处理器中的注解，来匹配请求（即<code> @RequestMapping</code> 注解中的 url 属性）。因为在上面我们都是通过实现类来开发接口的，相当于还是一个类一个接口，所以，我们可以通过<code>RequestMappingHandlerMapping</code>来做处理器映射器，这样我们可以在一个类中开发出多个接口</p><ul><li><code>HandlerAdapter</code></li></ul><p>对于上面提到的通过 <code>@RequestMapping </code>注解所定义出来的接口方法，这些方法的调用都是要通过 <code>RequestMappingHandlerAdapter </code>这个适配器来实现</p><p>例如我们开发一个接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController3</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/hello3&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello3&quot;</span>);    &#125;&#125;</code></pre></div><p>要能够访问到这个接口，我们需要 <code>RequestMappingHandlerMapping</code> 才能定位到需要执行的方法，需要 <code>RequestMappingHandlerAdapter</code>，才能执行定位到的方法，修改<code> spring-servlet.xml</code> 的配置文件如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.javaboy.helloworld&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--找到方法--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerMapping&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--执行方法--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerAdapter&quot;</span>/&gt;</span>      <span class="hljs-comment">&lt;!--视图解析器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/jsp/&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>然后，启动项目，访问 /hello3 接口，就可以看到相应的页面了。</p><ul><li><strong>继续优化</strong></li></ul><p>由于开发中，我们常用的是 <code>RequestMappingHandlerMapping </code>和 <code>RequestMappingHandlerAdapter </code>，这两个有一个简化的写法，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></code></pre></div><p>可以用这一行配置，代替 <code>RequestMappingHandlerMapping</code> 和 <code>RequestMappingHandlerAdapter</code> 的两行配置。</p><div class="hljs code-wrapper"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.javaboy.helloworld&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span>    <span class="hljs-comment">&lt;!--视图解析器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/jsp/&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>访问效果和上一步的效果一样。<strong>这是我们实际开发中，最终配置的形态</strong></p><h2 id="6-Controller"><a href="#6-Controller" class="headerlink" title="6. Controller"></a>6. Controller</h2><h3 id="6-1-RequestMapping"><a href="#6-1-RequestMapping" class="headerlink" title="6.1 @RequestMapping"></a>6.1 @RequestMapping</h3><p>这个注解用来标记一个接口，这算是我们在接口开发中，使用最多的注解之一</p><h4 id="6-1-1-请求-URL"><a href="#6-1-1-请求-URL" class="headerlink" title="6.1.1 请求 URL"></a>6.1.1 请求 URL</h4><p>标记请求 URL 很简单，只需要在相应的方法上添加该注解即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre></div><p>这里<code>@RequestMapping(“/hello”)</code>表示当请求地址为 /hello 的时候，这个方法会被触发。其中，地址可以是多个，就是可以多个地址映射到同一个方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&#123;&quot;/hello&quot;,&quot;/hello2&quot;&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre></div><p>这个配置，表示 /hello 和 /hello2 都可以访问到该方法</p><h4 id="6-1-2-请求窄化"><a href="#6-1-2-请求窄化" class="headerlink" title="6.1.2 请求窄化"></a>6.1.2 请求窄化</h4><p>同一个项目中，会存在多个接口，例如订单相关的接口都是 /order/xxx 格式的，用户相关的接口都是 /user/xxx 格式的。为了方便处理，这里的前缀（就是 /order、/user）可以统一在 Controller 上面处理。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&#123;&quot;/hello&quot;,&quot;/hello2&quot;&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre></div><p>当类上加了 <code>@RequestMapping</code> 注解之后，此时，要想访问到 hello ，地址就应该是 <code>/user/hello</code> 或者 <code>/user/hello2</code></p><h4 id="6-1-3-请求方法限定"><a href="#6-1-3-请求方法限定" class="headerlink" title="6.1.3 请求方法限定"></a>6.1.3 请求方法限定</h4><p>默认情况下，使用<code>@RequestMapping</code>注解定义好的方法，可以被 GET 请求访问到，也可以被 POST 请求访问到，但是 DELETE 请求以及 PUT 请求不可以访问到</p><p>当然，我们也可以指定具体的访问方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre></div><p>通过 <code>@RequestMapping</code> 注解，指定了该接口只能被 GET 请求访问到，此时，该接口就不可以被 POST 以及请求请求访问到了。强行访问会报如下错误：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/7-1-1.png" alt="7-1-1.png"></p><p>当然，限定的方法也可以有多个：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST,RequestMethod.PUT,RequestMethod.DELETE&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre></div><p>此时，这个接口就可以被 GET、POST、PUT、以及 DELETE 访问到了。但是，由于 JSP 支支持 GET、POST 以及 HEAD ，所以这个测试，不能使用 JSP 做页面模板。可以讲视图换成其他的，或者返回 JSON，这里就不影响了。</p><h3 id="6-2-Controller-方法的返回值"><a href="#6-2-Controller-方法的返回值" class="headerlink" title="6.2 Controller 方法的返回值"></a>6.2 Controller 方法的返回值</h3><h4 id="6-2-1-返回-ModelAndView"><a href="#6-2-1-返回-ModelAndView" class="headerlink" title="6.2.1 返回 ModelAndView"></a>6.2.1 返回 ModelAndView</h4><p>如果是前后端不分的开发，大部分情况下，我们返回 <code>ModelAndView</code>，即数据模型+视图：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);        mv.addObject(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);        <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div><p>Model 中，放我们的数据，然后在<code> ModelAndView</code> 中指定视图名称。</p><h4 id="6-2-2-返回-Void"><a href="#6-2-2-返回-Void" class="headerlink" title="6.2.2 返回 Void"></a>6.2.2 返回 Void</h4><p>没有返回值。没有返回值，并不一定真的没有返回值，只是方法的返回值为 void，我们可以通过其他方式给前端返回。<strong>实际上，这种方式也可以理解为 Servlet 中的那一套方案。</strong></p><blockquote><p>注意，由于默认的 Maven 项目没有 Servlet，因此这里需要额外添加一个依赖：</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ul><li>通过 <code>HttpServletRequest </code>做服务端跳转</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello2&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    req.getRequestDispatcher(<span class="hljs-string">&quot;/jsp/hello.jsp&quot;</span>).forward(req,resp);<span class="hljs-comment">//服务器端跳转</span>&#125;</code></pre></div><ul><li>通过 <code>HttpServletResponse</code> 做重定向</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello3&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello3</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    resp.sendRedirect(<span class="hljs-string">&quot;/hello.jsp&quot;</span>);&#125;</code></pre></div><p>也可以自己手动指定响应头去实现重定向：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello3&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello3</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    resp.setStatus(<span class="hljs-number">302</span>);    resp.addHeader(<span class="hljs-string">&quot;Location&quot;</span>, <span class="hljs-string">&quot;/jsp/hello.jsp&quot;</span>);&#125;</code></pre></div><ul><li>通过 <code>HttpServletResponse</code> 给出响应</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello4&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello4</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);    PrintWriter out = resp.getWriter();    out.write(<span class="hljs-string">&quot;hello javaboy!&quot;</span>);    out.flush();    out.close();&#125;</code></pre></div><p>这种方式，既可以返回 JSON，也可以返回普通字符串。</p><h4 id="6-2-3-返回字符串"><a href="#6-2-3-返回字符串" class="headerlink" title="6.2.3 返回字符串"></a>6.2.3 返回字符串</h4><ul><li><strong>返回逻辑视图名</strong></li></ul><p>前面的 ModelAndView 可以拆分为两部分，Model 和 View，在 SpringMVC 中，Model 我们可以直接在参数中指定，然后返回值是逻辑视图名：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello5&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello5</span><span class="hljs-params">(Model model)</span> </span>&#123;    model.addAttribute(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;lucifer&quot;</span>);<span class="hljs-comment">//这是数据模型</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//表示去查找一个名为 hello 的视图</span>&#125;</code></pre></div><ul><li><strong>服务端跳转</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello5&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello5</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/jsp/hello.jsp&quot;</span>;&#125;</code></pre></div><p>forward 后面跟上跳转的路径。</p><ul><li><strong>客户端跳转</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello5&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello5</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/hello&quot;</span>;&#125;</code></pre></div><p>这种，本质上就是浏览器重定向。</p><ul><li><strong>真的返回一个字符串</strong></li></ul><p>上面三个返回的字符串，都是由特殊含义的，如果一定要返回一个字符串，需要额外添加一个注意：<code>@ResponseBody</code> ，这个注解表示当前方法的返回值就是要展示出来返回值，没有特殊含义。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello5&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello5</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/hello&quot;</span>;&#125;</code></pre></div><p>上面代码表示就是想返回一段内容为 <code>redirect:/user/hello</code> 的字符串，他没有特殊含义。注意，这里如果单纯的返回一个中文字符串，是会乱码的，可以在 <code>@RequestMapping</code> 中添加 produces 属性来解决：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/hello5&quot;,produces = &quot;text/html;charset=utf-8&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello5</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Java 语言程序设计&quot;</span>;&#125;</code></pre></div><h3 id="6-3-参数绑定"><a href="#6-3-参数绑定" class="headerlink" title="6.3 参数绑定"></a>6.3 参数绑定</h3><h4 id="6-3-1-默认支持的参数类型"><a href="#6-3-1-默认支持的参数类型" class="headerlink" title="6.3.1 默认支持的参数类型"></a>6.3.1 默认支持的参数类型</h4><p>默认支持的参数类型，就是可以直接写在<code> @RequestMapping</code> 所注解的方法中的参数类型，一共有四类：</p><ul><li><strong>HttpServletRequest</strong></li><li><strong>HttpServletResponse</strong></li><li><strong>HttpSession</strong></li><li><strong>Model/ModelMap</strong></li></ul><p>这几个例子可以参考上一小节</p><p>在请求的方法中，默认的参数就是这几个，如果在方法中，刚好需要这几个参数，那么就可以把这几个参数加入到方法中。</p><h4 id="6-3-2-简单数据类型"><a href="#6-3-2-简单数据类型" class="headerlink" title="6.3.2 简单数据类型"></a>6.3.2 简单数据类型</h4><p><code>Integer、Boolean、Double </code>等等简单数据类型也都是支持的。例如添加一本书：</p><p>首先，在 /jsp/ 目录下创建 <code>add book.jsp</code> 作为图书添加页面：</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=<span class="hljs-string">&quot;/doAdd&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;书名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;作者：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;价格：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;是否上架：&lt;/td&gt;            &lt;td&gt;                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;是                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;false&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;否            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;           &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;               &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加&quot;</span>&gt;           &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><p>创建控制器，控制器提供两个功能，一个是访问 jsp 页面，另一个是提供添加接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addBook</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;addbook&quot;</span>;    &#125;    <span class="hljs-meta">@RequestMapping(value = &quot;/doAdd&quot;,method = RequestMethod.POST)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdd</span><span class="hljs-params">(String name,String author,Double price,Boolean ispublic)</span> </span>&#123;        System.out.println(name);        System.out.println(author);        System.out.println(price);        System.out.println(ispublic);    &#125;&#125;</code></pre></div><p>注意，由于 doAdd 方法确实不想返回任何值，所以需要给该方法添加 <code>@ResponseBody </code>注解，表示这个方法到此为止，不用再去查找相关视图了。另外， POST 请求传上来的中文会乱码，所以，我们在 <code>web.xml</code> 中再额外添加一个编码过滤器：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceRequestEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div><p>最后，浏览器中输入 <a href="http://localhost:8080/book">http://localhost:8080/book</a> ，就可以执行添加操作，服务端会打印出来相应的日志。</p><p>在上面的绑定中，有一个要求，表单中字段的 name 属性要和接口中的变量名一一对应，才能映射成功，否则服务端接收不到前端传来的数据。有一些特殊情况，我们的服务端的接口变量名可能和前端不一致，这个时候我们可以通过 <code>@RequestParam </code>注解来解决。</p><ul><li><code>@RequestParam</code></li></ul><p>这个注解的的功能主要有三方面：</p><ol><li>给变量取别名</li><li>设置变量是否必填</li><li>给变量设置默认值</li></ol><p>如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/doAdd&quot;,method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdd</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String bookname, String author, Double price, Boolean ispublic)</span> </span>&#123;    System.out.println(bookname);    System.out.println(author);    System.out.println(price);    System.out.println(ispublic);&#125;</code></pre></div><p>注解中的 “name” 表示给 bookname 这个变量取的别名，也就是说，bookname 将接收前端传来的 name 这个变量的值。在这个注解中，还可以添加 <code>required </code>属性和 <code>defaultValue</code> 属性，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/doAdd&quot;,method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdd</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;,required = true,defaultValue = &quot;三国演义&quot;)</span> String bookname, String author, Double price, Boolean ispublic)</span> </span>&#123;    System.out.println(bookname);    System.out.println(author);    System.out.println(price);    System.out.println(ispublic);&#125;</code></pre></div><p>required 属性默认为 true，即只要添加了 <code>@RequestParam</code> 注解，这个参数默认就是必填的，如果不填，请求无法提交，会报 400 错误，如果这个参数不是必填项，可以手动把 required 属性设置为 false。但是，如果同时设置了 defaultValue，这个时候，前端不传该参数到后端，即使 required 属性为 true，它也不会报错。</p><h4 id="6-3-3-实体类"><a href="#6-3-3-实体类" class="headerlink" title="6.3.3 实体类"></a>6.3.3 实体类</h4><p>参数除了是简单数据类型之外，也可以是实体类。实际上，在开发中，大部分情况下，都是实体类。</p><p>还是上面的例子，我们改用一个 Book 对象来接收前端传来的数据：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String author;    <span class="hljs-keyword">private</span> Double price;    <span class="hljs-keyword">private</span> Boolean ispublic;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Book&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, author=&#x27;&quot;</span> + author + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, price=&quot;</span> + price +                <span class="hljs-string">&quot;, ispublic=&quot;</span> + ispublic +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> author;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(String author)</span> </span>&#123;        <span class="hljs-keyword">this</span>.author = author;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> price;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(Double price)</span> </span>&#123;        <span class="hljs-keyword">this</span>.price = price;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">getIspublic</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> ispublic;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIspublic</span><span class="hljs-params">(Boolean ispublic)</span> </span>&#123;        <span class="hljs-keyword">this</span>.ispublic = ispublic;    &#125;&#125;</code></pre></div><p>服务端接收数据方式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/doAdd&quot;,method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdd</span><span class="hljs-params">(Book book)</span> </span>&#123;    System.out.println(book);&#125;</code></pre></div><p>前端页面传值的时候和上面的一样，只需要写属性名就可以了，不需要写 book 对象名。</p><p>当然，对象中可能还有对象。例如如下对象：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Double price;    <span class="hljs-keyword">private</span> Boolean ispublic;    <span class="hljs-keyword">private</span> Author author;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(Author author)</span> </span>&#123;        <span class="hljs-keyword">this</span>.author = author;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Book&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, price=&quot;</span> + price +                <span class="hljs-string">&quot;, ispublic=&quot;</span> + ispublic +                <span class="hljs-string">&quot;, author=&quot;</span> + author +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> price;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(Double price)</span> </span>&#123;        <span class="hljs-keyword">this</span>.price = price;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">getIspublic</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> ispublic;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIspublic</span><span class="hljs-params">(Boolean ispublic)</span> </span>&#123;        <span class="hljs-keyword">this</span>.ispublic = ispublic;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Author&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre></div><p>Book 对象中，有一个 Author 属性，如何给 Author 属性传值呢？前端写法如下：</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=<span class="hljs-string">&quot;/doAdd&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;书名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;作者姓名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author.name&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;作者年龄：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author.age&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;价格：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;是否上架：&lt;/td&gt;            &lt;td&gt;                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;是                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;false&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;否            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;           &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;               &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加&quot;</span>&gt;           &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><p>这样在后端直接用 Book 对象就可以接收到所有数据了。</p><h4 id="6-3-4-自定义参数绑定"><a href="#6-3-4-自定义参数绑定" class="headerlink" title="6.3.4 自定义参数绑定"></a>6.3.4 自定义参数绑定</h4><p>前面的转换，都是系统自动转换的，这种转换仅限于基本数据类型。特殊的数据类型，系统无法自动转换，例如日期。例如前端传一个日期到后端，后端不是用字符串接收，而是使用一个 Date 对象接收，这个时候就会出现参数类型转换失败。这个时候，需要我们手动定义参数类型转换器，将日期字符串手动转为一个 Date 对象。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String source)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> sdf.parse(source);        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p>在自定义的参数类型转换器中，将一个 String 转为 Date 对象，同时，将这个转换器注册为一个 Bean。</p><p>接下来，在 SpringMVC 的配置文件中，配置该 Bean，使之生效。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">conversion-service</span>=<span class="hljs-string">&quot;conversionService&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversionService&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;converters&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dateConverter&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>配置完成后，在服务端就可以接收前端传来的日期参数了。</p><h4 id="6-3-5-集合类的参数"><a href="#6-3-5-集合类的参数" class="headerlink" title="6.3.5 集合类的参数"></a>6.3.5 集合类的参数</h4><ul><li><strong>String 数组</strong></li></ul><p>String 数组可以直接用数组去接收，前端传递的时候，数组的传递其实就多相同的 key，这种一般用在 checkbox 中较多。</p><p>例如前端增加兴趣爱好一项：</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/doAdd&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;书名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;作者姓名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author.name&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;作者年龄：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author.age&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;出生日期：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;date&quot; name=&quot;author.birthday&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;兴趣爱好：&lt;/td&gt;            &lt;td&gt;                &lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;favorites&quot;</span> value=<span class="hljs-string">&quot;足球&quot;</span>&gt;足球                &lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;favorites&quot;</span> value=<span class="hljs-string">&quot;篮球&quot;</span>&gt;篮球                &lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;favorites&quot;</span> value=<span class="hljs-string">&quot;乒乓球&quot;</span>&gt;乒乓球            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;价格：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;是否上架：&lt;/td&gt;            &lt;td&gt;                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;是                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;false&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;否            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;           &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;               &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加&quot;</span>&gt;           &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;</code></pre></div><p>在服务端用一个数组去接收 favorites 对象：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/doAdd&quot;,method = RequestMethod.POST)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdd</span><span class="hljs-params">(Book book,String[] favorites)</span> </span>&#123;    System.out.println(Arrays.toString(favorites));    System.out.println(book);&#125;</code></pre></div><p>注意，前端传来的数组对象，服务端不可以使用 List 集合去接收。</p><ul><li><strong>List 集合</strong></li></ul><p>如果需要使用 List 集合接收前端传来的数据，List 集合本身需要放在一个封装对象中，这个时候，List 中，可以是基本数据类型，也可以是对象。例如有一个班级类，班级里边有学生，学生有多个：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> List&lt;Student&gt; students;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyClass&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, students=&quot;</span> + students +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">getStudents</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> students;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStudents</span><span class="hljs-params">(List&lt;Student&gt; students)</span> </span>&#123;        <span class="hljs-keyword">this</span>.students = students;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre></div><p>添加班级的时候，可以传递多个 Student，前端页面写法如下：</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/addclass&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;班级编号：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生编号：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[0].id&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生姓名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[0].name&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生编号：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[1].id&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生姓名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[1].name&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;                &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;</code></pre></div><p>服务端直接接收数据即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addclass&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addClass</span><span class="hljs-params">(MyClass myClass)</span> </span>&#123;    System.out.println(myClass);&#125;</code></pre></div><ul><li><strong>Map</strong></li></ul><p>相对于实体类而言，Map 是一种比较灵活的方案，但是，<strong>Map 可维护性比较差，因此一般不推荐使用</strong>。</p><p>例如给上面的班级类添加其他属性信息：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> List&lt;Student&gt; students;    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; info;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyClass&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, students=&quot;</span> + students +                <span class="hljs-string">&quot;, info=&quot;</span> + info +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> info;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInfo</span><span class="hljs-params">(Map&lt;String, Object&gt; info)</span> </span>&#123;        <span class="hljs-keyword">this</span>.info = info;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">getStudents</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> students;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStudents</span><span class="hljs-params">(List&lt;Student&gt; students)</span> </span>&#123;        <span class="hljs-keyword">this</span>.students = students;    &#125;&#125;</code></pre></div><p>在前端，通过如下方式给 info 这个 Map 赋值。</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/addclass&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;班级编号：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;班级名称：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;info[&#x27;name&#x27;]&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;班级位置：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;info[&#x27;pos&#x27;]&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生编号：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[0].id&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生姓名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[0].name&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生编号：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[1].id&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生姓名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[1].name&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;                &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;</code></pre></div><h3 id="6-4-ControllerAdvice"><a href="#6-4-ControllerAdvice" class="headerlink" title="6.4 @ControllerAdvice"></a>6.4 <strong>@ControllerAdvice</strong></h3><p><code>@ControllerAdvice </code>，很多初学者可能都没有听说过这个注解，实际上，这是一个非常有用的注解，顾名思义，这是一个增强的 Controller。使用这个 Controller ，可以实现三个方面的功能：</p><ul><li>全局异常处理</li><li>全局数据绑定</li><li>全局数据预处理</li></ul><blockquote><p>@ControllerAdvice返回的是页面，对应于@Controller；@RestControllerAdvice返回的是字符串，对应于@RestController</p></blockquote><p>灵活使用这三个功能，可以帮助我们简化很多工作，需要注意的是，这是 SpringMVC 提供的功能，在 Spring Boot 中可以直接使用，下面分别来看</p><h4 id="6-4-1-全局异常处理"><a href="#6-4-1-全局异常处理" class="headerlink" title="6.4.1 全局异常处理"></a>6.4.1 全局异常处理</h4><p>使用 <code>@ControllerAdvice </code>实现全局异常处理，只需要定义类，添加该注解即可定义方式如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGlobalExceptionHandler</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">customException</span><span class="hljs-params">(Exception e)</span> </span>&#123;        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();        mv.addObject(<span class="hljs-string">&quot;message&quot;</span>, e.getMessage());        mv.setViewName(<span class="hljs-string">&quot;myerror&quot;</span>);        <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div><p>在该类中，可以定义多个方法，不同的方法处理不同的异常，例如专门处理空指针的方法、专门处理数组越界的方法…，也可以直接向上面代码一样，在一个方法中处理所有的异常信息。</p><p><code>@ExceptionHandler</code> 注解用来指明异常的处理类型，即如果这里指定为<code> NullpointerException</code>，则数组越界异常就不会进到这个方法中来。</p><h4 id="6-4-2-全局数据绑定"><a href="#6-4-2-全局数据绑定" class="headerlink" title="6.4.2 全局数据绑定"></a>6.4.2 全局数据绑定</h4><p>全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了<code> @ControllerAdvice</code> 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。</p><p>使用步骤，首先定义全局数据，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGlobalExceptionHandler</span> </span>&#123;    <span class="hljs-meta">@ModelAttribute(name = &quot;md&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">mydata</span><span class="hljs-params">()</span> </span>&#123;        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">99</span>);        map.put(<span class="hljs-string">&quot;gender&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);        <span class="hljs-keyword">return</span> map;    &#125;&#125;</code></pre></div><p>使用<code>@ModelAttribute</code>注解标记该方法的返回数据是一个全局数据，默认情况下，这个全局数据的 key 就是返回的变量名，value 就是方法返回值，当然开发者可以通过 <code>@ModelAttribute</code> 注解的 name 属性去重新指定 key。</p><p>定义完成后，在任何一个Controller 的接口中，都可以获取到这里定义的数据：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;        Map&lt;String, Object&gt; map = model.asMap();        System.out.println(map);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello controller advice&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="6-4-3-全局数据预处理"><a href="#6-4-3-全局数据预处理" class="headerlink" title="6.4.3 全局数据预处理"></a>6.4.3 全局数据预处理</h4><p>考虑我有两个实体类，Book 和 Author，分别定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Long price;    <span class="hljs-comment">//getter/setter</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-comment">//getter/setter</span>&#125;</code></pre></div><p>此时，如果我定义一个数据添加接口，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/book&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book book, Author author)</span> </span>&#123;    System.out.println(book);    System.out.println(author);&#125;</code></pre></div><p>这个时候，添加操作就会有问题，因为两个实体类都有一个 name 属性，从前端传递时 ，无法区分。此时，通过<code>@ControllerAdvice</code>的全局数据预处理可以解决这个问题</p><p>解决步骤如下:</p><p>1.给接口中的变量取别名</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/book&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;b&quot;)</span> Book book, <span class="hljs-meta">@ModelAttribute(&quot;a&quot;)</span> Author author)</span> </span>&#123;    System.out.println(book);    System.out.println(author);&#125;</code></pre></div><p>2.进行请求数据预处理<br>在<code>@ControllerAdvice</code>标记的类中添加如下代码:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@InitBinder(&quot;b&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">(WebDataBinder binder)</span> </span>&#123;    binder.setFieldDefaultPrefix(<span class="hljs-string">&quot;b.&quot;</span>);&#125;<span class="hljs-meta">@InitBinder(&quot;a&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(WebDataBinder binder)</span> </span>&#123;    binder.setFieldDefaultPrefix(<span class="hljs-string">&quot;a.&quot;</span>);&#125;</code></pre></div><p><code>@InitBinder(“b”)</code> 注解表示该方法用来处理和Book和相关的参数,在方法中,给参数添加一个 b 前缀,即请求参数要有b前缀.</p><p>3.发送请求</p><p>请求发送时,通过给不同对象的参数添加不同的前缀,可以实现参数的区分.</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5-1.png" alt="img"></p><h4 id="6-3-4-总结"><a href="#6-3-4-总结" class="headerlink" title="6.3.4 总结"></a>6.3.4 总结</h4><p>这就是 <code>@ControllerAdvice </code>的几个简单用法，这些点既可以在传统的 SSM 项目中使用，也可以在 Spring Boot + Spring Cloud 微服务中使用</p><h2 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7. 文件上传"></a>7. 文件上传</h2><p>SpringMVC 中对文件上传做了封装，我们可以更加方便的实现文件上传。从 Spring3.1 开始，对于文件上传，提供了两个处理器：</p><ul><li><strong>CommonsMultipartResolver</strong></li><li><strong>StandardServletMultipartResolver</strong></li></ul><p>第一个处理器兼容性较好，可以兼容 Servlet3.0 之前的版本，但是它依赖了<code>commons-fileupload</code>这个第三方工具，所以如果使用这个，一定要添加 <code>commons-fileupload </code>依赖</p><p>第二个处理器兼容性较差，它适用于 Servlet3.0 之后的版本，它不依赖第三方工具，使用它，可以直接做文件上传</p><h3 id="7-1-CommonsMultipartResolver"><a href="#7-1-CommonsMultipartResolver" class="headerlink" title="7.1 CommonsMultipartResolver"></a>7.1 CommonsMultipartResolver</h3><p>使用<code> CommonsMultipartResolver</code> 做文件上传，需要首先添加 <code>commons-fileupload </code>依赖，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>然后，在 SpringMVC 的配置文件中，配置 <code>MultipartResolver</code>：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span>/&gt;</span></code></pre></div><p><strong>注意，这个 Bean 一定要有 id，并且 id 必须是 <code>multipartResolver</code></strong></p><p>接下来，创建 jsp 页面：</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/upload&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;    &lt;input type=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span>&gt;    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;上传&quot;</span>&gt;&lt;/form&gt;</code></pre></div><p>注意文件上传请求是 POST 请求，<code>enctype</code> 一定是<code> multipart/form-data</code>，同时<code>MultipartFile file</code>的<code>file</code>要和jsp中的一致</p><p>然后，开发文件上传接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController</span> </span>&#123;    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;/yyyy/MM/dd/&quot;</span>);    <span class="hljs-meta">@RequestMapping(&quot;/upload&quot;)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;      <span class="hljs-comment">//1.准备文件夹</span>        String format = sdf.format(<span class="hljs-keyword">new</span> Date());        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">&quot;/img&quot;</span>) + format;        File folder = <span class="hljs-keyword">new</span> File(realPath);        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;            folder.mkdirs();        &#125;      <span class="hljs-comment">//2.准备文件名</span>        String oldName = file.getOriginalFilename();        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));      <span class="hljs-comment">//3.存储</span>        <span class="hljs-keyword">try</span> &#123;            file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));        <span class="hljs-comment">//4.组装url</span>            String url = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + <span class="hljs-string">&quot;/img&quot;</span> + format + newName;            <span class="hljs-keyword">return</span> url;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;failed&quot;</span>;    &#125;&#125;</code></pre></div><p>这个文件上传方法中，一共做了四件事：</p><ul><li>解决文件保存路径，这里是保存在项目运行目录下的 img 目录下，然后利用日期继续宁分类</li><li>处理文件名问题，使用 UUID 做新的文件名，用来代替旧的文件名，可以有效防止文件名冲突</li><li>保存文件</li><li>生成文件访问路径</li></ul><blockquote><p>这里还有一个小问题，在 SpringMVC 中，静态资源默认都是被自动拦截的，无法访问，意味着上传成功的图片无法访问，因此，还需要我们在 SpringMVC 的配置文件中，再添加如下配置：</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/&quot;</span>/&gt;</span></code></pre></div><p>完成之后，就可以访问 jsp 页面，做文件上传了</p><p>当然，默认的配置不一定满足我们的需求，我们还可以自己手动配置文件上传大小等：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--默认的编码--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--上传的总文件大小--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1048576&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--上传的单个文件大小--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSizePerFile&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1048576&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--内存中最大的数据量，超过这个数据量，数据就要开始往硬盘中写了--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxInMemorySize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4096&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--临时目录，超过 maxInMemorySize 配置的大小后，数据开始往临时目录写，等全部上传完成后，再将数据合并到正式的文件上传目录--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;uploadTempDir&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;file:///E:\\tmp&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h3 id="7-2-StandardServletMultipartResolver"><a href="#7-2-StandardServletMultipartResolver" class="headerlink" title="7.2 StandardServletMultipartResolver"></a>7.2 StandardServletMultipartResolver</h3><p>这种文件上传方式，不需要依赖第三方 jar（主要是不需要添加<code>commons-fileupload</code>这个依赖），但是也不支持 Servlet3.0 之前的版本。</p><p>使用 <code>StandardServletMultipartResolver</code> ，那我们首先在 SpringMVC 的配置文件中，配置这个 Bean</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p><strong>注意，这里 Bean 的名字依然叫<code> multipartResolver</code></strong></p><p>配置完成后，注意，这个 Bean 无法直接配置上传文件大小等限制。需要在<code>web.xml</code>中进行配置（这里，即使不需要限制文件上传大小，也需要在 <code>web.xml </code>中配置 <code>multipart-config</code>）：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">multipart-config</span>&gt;</span>        <span class="hljs-comment">&lt;!--文件保存的临时目录，这个目录系统不会主动创建--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>E:\\temp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span>        <span class="hljs-comment">&lt;!--上传的单个文件大小--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">max-file-size</span>&gt;</span>1048576<span class="hljs-tag">&lt;/<span class="hljs-name">max-file-size</span>&gt;</span>        <span class="hljs-comment">&lt;!--上传的总文件大小--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">max-request-size</span>&gt;</span>1048576<span class="hljs-tag">&lt;/<span class="hljs-name">max-request-size</span>&gt;</span>        <span class="hljs-comment">&lt;!--这个就是内存中保存的文件最大大小--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file-size-threshold</span>&gt;</span>4096<span class="hljs-tag">&lt;/<span class="hljs-name">file-size-threshold</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">multipart-config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p>配置完成后，就可以测试文件上传了，测试方式和上面一样。</p><h3 id="7-3-多文件上传"><a href="#7-3-多文件上传" class="headerlink" title="7.3 多文件上传"></a>7.3 多文件上传</h3><p>多文件上传分为两种，一种是 key 相同的文件，另一种是 key 不同的文件。</p><h4 id="8-3-1-key-相同的文件"><a href="#8-3-1-key-相同的文件" class="headerlink" title="8.3.1 key 相同的文件"></a>8.3.1 key 相同的文件</h4><p>这种上传，前端页面一般如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload2&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;files&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p>主要是 input 节点中多了 <code>multiple</code> 属性。后端用一个数组来接收文件即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/upload2&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upload2</span><span class="hljs-params">(MultipartFile[] files, HttpServletRequest req)</span> </span>&#123;    String format = sdf.format(<span class="hljs-keyword">new</span> Date());    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">&quot;/img&quot;</span>) + format;    File folder = <span class="hljs-keyword">new</span> File(realPath);    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;        folder.mkdirs();    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span> (MultipartFile file : files) &#123;            String oldName = file.getOriginalFilename();            String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));            file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));            String url = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + <span class="hljs-string">&quot;/img&quot;</span> + format + newName;            System.out.println(url);        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><h4 id="8-3-2-key-不同的文件"><a href="#8-3-2-key-不同的文件" class="headerlink" title="8.3.2 key 不同的文件"></a>8.3.2 key 不同的文件</h4><p>key 不同的，一般前端定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload3&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file2&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p>这种，在后端用不同的变量来接收就行了：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/upload3&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upload3</span><span class="hljs-params">(MultipartFile file1, MultipartFile file2, HttpServletRequest req)</span> </span>&#123;    String format = sdf.format(<span class="hljs-keyword">new</span> Date());    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">&quot;/img&quot;</span>) + format;    File folder = <span class="hljs-keyword">new</span> File(realPath);    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;        folder.mkdirs();    &#125;    <span class="hljs-keyword">try</span> &#123;        String oldName = file1.getOriginalFilename();        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));        file1.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));        String url1 = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + <span class="hljs-string">&quot;/img&quot;</span> + format + newName;        System.out.println(url1);        String oldName2 = file2.getOriginalFilename();        String newName2 = UUID.randomUUID().toString() + oldName2.substring(oldName2.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));        file2.transferTo(<span class="hljs-keyword">new</span> File(folder, newName2));        String url2 = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + <span class="hljs-string">&quot;/img&quot;</span> + format + newName2;        System.out.println(url2);    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><h2 id="8-全局异常处理"><a href="#8-全局异常处理" class="headerlink" title="8. 全局异常处理"></a>8. 全局异常处理</h2><p>项目中，可能会抛出多个异常，我们不可以直接将异常的堆栈信息展示给用户，有两个原因：</p><ul><li>用户体验不好</li><li>非常不安全</li></ul><p>所以，针对异常，我们可以自定义异常处理，SpringMVC 中，针对全局异常也提供了相应的解决方案，主要是通过 <code>@ControllerAdvice</code> 和 <code>@ExceptionHandler </code>两个注解来处理的。</p><p>以第八节的文件上传大小超出限制为例，自定义异常，只需要提供一个异常处理类即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-comment">//表示这是一个增强版的 Controller，主要用来做全局数据处理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">fileuploadException</span><span class="hljs-params">(Exception e)</span> </span>&#123;        ModelAndView error = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>);        error.addObject(<span class="hljs-string">&quot;error&quot;</span>, e.getMessage());        <span class="hljs-keyword">return</span> error;    &#125;&#125;</code></pre></div><p>在这里：</p><ul><li><code>@ControllerAdvice</code> 表示这是一个增强版的 Controller，主要用来做全局数据处理</li><li><code>@ExceptionHandler</code> 表示这是一个异常处理方法，这个注解的参数，表示需要拦截的异常，参数为 Exception 表示拦截所有异常，这里也可以具体到某一个异常，如果具体到某一个异常，那么发生了其他异常则不会被拦截到。</li><li>异常方法的定义，和 Controller 中方法的定义一样，可以返回 <code>ModelAndview</code>，也可以返回 String 或者 void</li></ul><p>例如如下代码，指挥拦截文件上传异常，其他异常和它没关系，不会进入到自定义异常处理的方法中来。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-comment">//表示这是一个增强版的 Controller，主要用来做全局数据处理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler(MaxUploadSizeExceededException.class)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">fileuploadException</span><span class="hljs-params">(MaxUploadSizeExceededException e)</span> </span>&#123;        ModelAndView error = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>);        error.addObject(<span class="hljs-string">&quot;error&quot;</span>, e.getMessage());        <span class="hljs-keyword">return</span> error;    &#125;&#125;</code></pre></div><h2 id="9-服务端数据校验"><a href="#9-服务端数据校验" class="headerlink" title="9. 服务端数据校验"></a>9. 服务端数据校验</h2><p>B/S 系统中对 http 请求数据的校验多数在客户端进行，这也是出于简单及用户体验性上考虑，但是在一些安全性要求高的系统中服务端校验是不可缺少的，实际上，几乎所有的系统，凡是涉及到数据校验，都需要在服务端进行二次校验。为什么要在服务端进行二次校验呢？这需要理解客户端校验和服务端校验各自的目的。</p><ol><li>客户端校验，我们主要是为了提高用户体验，例如用户输入一个邮箱地址，要校验这个邮箱地址是否合法，没有必要发送到服务端进行校验，直接在前端用 js 进行校验即可。但是大家需要明白的是，前端校验无法代替后端校验，前端校验可以有效的提高用户体验，但是无法确保数据完整性，因为在 B/S 架构中，用户可以方便的拿到请求地址，然后直接发送请求，传递非法参数。</li><li>服务端校验，虽然用户体验不好，但是可以有效的保证数据安全与完整性。</li><li>综上，实际项目中，两个一起用。</li></ol><p>Spring 支持 JSR-303 验证框架，JSR-303 是 JAVA EE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是 Hibernate Validator（与Hibernate ORM 没有关系），JSR-303 用于对 Java Bean 中的字段的值进行验证。</p><h3 id="9-1-普通校验"><a href="#9-1-普通校验" class="headerlink" title="9.1 普通校验"></a>9.1 普通校验</h3><p>普通校验，是这里最基本的用法。</p><p>首先，我们需要加入校验需要的依赖：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.0.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>接下来，在 SpringMVC 的配置文件中配置校验的 Bean：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;validatorFactoryBean&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;providerClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.hibernate.validator.HibernateValidator&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">validator</span>=<span class="hljs-string">&quot;validatorFactoryBean&quot;</span>/&gt;</span></code></pre></div><p>配置时，提供一个 <code>LocalValidatorFactoryBean</code> 的实例，然后 Bean 的校验使用<code> HibernateValidator</code></p><p>接下来，我们提供一个添加学生的页面：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/addstudent&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>学生编号：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>学生姓名：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>学生邮箱：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>学生年龄：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p>在这里需要提交的数据中，假设学生编号不能为空，学生姓名长度不能超过 10 且不能为空，邮箱地址要合法，年龄不能超过 150。那么在定义实体类的时候，就可以加入这个判断条件了。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-meta">@NotNull</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@NotNull</span>    <span class="hljs-meta">@Size(min = 2,max = 10)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Email</span>    <span class="hljs-keyword">private</span> String email;    <span class="hljs-meta">@Max(150)</span>    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmail</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> email;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, email=&#x27;&quot;</span> + email + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmail</span><span class="hljs-params">(String email)</span> </span>&#123;        <span class="hljs-keyword">this</span>.email = email;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre></div><p>在这里：</p><ul><li><code>@NotNull </code>表示这个字段不能为空</li><li><code>@Size </code>中描述了这个字符串长度的限制</li><li><code>@Email </code>表示这个字段的值必须是一个邮箱地址</li><li><code>@Max </code>表示这个字段的最大值</li></ul><p>定义完成后，接下来，在 Controller 中定义接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/addstudent&quot;)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Validated</span> Student student, BindingResult result)</span> </span>&#123;        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//校验未通过，获取所有的异常信息并展示出来</span>            List&lt;ObjectError&gt; allErrors = result.getAllErrors();            <span class="hljs-keyword">for</span> (ObjectError allError : allErrors) &#123;                System.out.println(allError.getObjectName()+<span class="hljs-string">&quot;:&quot;</span>+allError.getDefaultMessage());            &#125;        &#125;    &#125;&#125;</code></pre></div><p>在这里：</p><ul><li><code>@Validated </code>表示 Student 中定义的校验规则将会生效</li><li><code>BindingResult</code> 表示出错信息，如果这个变量不为空，表示有错误，否则校验通过。</li></ul><p>接下来就可以启动项目了。访问 jsp 页面，然后添加 Student，查看校验规则是否生效。</p><p>默认情况下，打印出来的错误信息时系统默认的错误信息，这个错误信息，我们也可以自定义。自定义方式如下：</p><p>由于 properties 文件中的中文会乱码，所以需要我们先修改一下 IDEA 配置，点<code> File–&gt;Settings-&gt;Editor–&gt;File Encodings</code>，如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/10-1-20210520170449224.png" alt="10-1.png"></p><p>然后定义错误提示文本，在 resources 目录下新建一个 MyMessage.properties 文件，内容如下：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">student.id.notnull</span>=<span class="hljs-string">id 不能为空</span><span class="hljs-meta">student.name.notnull</span>=<span class="hljs-string">name 不能为空</span><span class="hljs-meta">student.name.length</span>=<span class="hljs-string">name 最小长度为 2 ，最大长度为 10</span><span class="hljs-meta">student.email.error</span>=<span class="hljs-string">email 地址非法</span><span class="hljs-meta">student.age.error</span>=<span class="hljs-string">年龄不能超过 150</span></code></pre></div><p>接下来，在 SpringMVC 配置中，加载这个配置文件：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;validatorFactoryBean&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;providerClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.hibernate.validator.HibernateValidator&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;validationMessageSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bundleMessageSource&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bundleMessageSource&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basenames&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>          <span class="hljs-comment">&lt;!--没有后缀 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:MyMessage<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheSeconds&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;300&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">validator</span>=<span class="hljs-string">&quot;validatorFactoryBean&quot;</span>/&gt;</span></code></pre></div><p>最后，在实体类上的注解中，加上校验出错时的信息：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-meta">@NotNull(message = &quot;&#123;student.id.notnull&#125;&quot;)</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@NotNull(message = &quot;&#123;student.name.notnull&#125;&quot;)</span>    <span class="hljs-meta">@Size(min = 2,max = 10,message = &quot;&#123;student.name.length&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Email(message = &quot;&#123;student.email.error&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String email;    <span class="hljs-meta">@Max(value = 150,message = &quot;&#123;student.age.error&#125;&quot;)</span>    <span class="hljs-keyword">private</span> Integer age;</code></pre></div><p>配置完成后，如果校验再出错，就会展示我们自己的出错信息了。</p><h3 id="9-2-分组校验"><a href="#9-2-分组校验" class="headerlink" title="9.2 分组校验"></a>9.2 分组校验</h3><p>由于校验规则都是定义在实体类上面的，但是，在不同的数据提交环境下，校验规则可能不一样。例如，用户的 id 是自增长的，添加的时候，可以不用传递用户 id，但是修改的时候则必须传递用户 id，这种情况下，就需要使用分组校验。</p><p>分组校验，首先需要定义校验组，所谓的校验组，其实就是<strong>空接口</strong>：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidationGroup1</span> </span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidationGroup2</span> </span>&#123;&#125;</code></pre></div><p>然后，在实体类中，指定每一个校验规则所属的组：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-meta">@NotNull(message = &quot;&#123;student.id.notnull&#125;&quot;,groups = ValidationGroup1.class)</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@NotNull(message = &quot;&#123;student.name.notnull&#125;&quot;,groups = &#123;ValidationGroup1.class, ValidationGroup2.class&#125;)</span>    <span class="hljs-meta">@Size(min = 2,max = 10,message = &quot;&#123;student.name.length&#125;&quot;,groups = &#123;ValidationGroup1.class, ValidationGroup2.class&#125;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Email(message = &quot;&#123;student.email.error&#125;&quot;,groups = &#123;ValidationGroup1.class, ValidationGroup2.class&#125;)</span>    <span class="hljs-keyword">private</span> String email;    <span class="hljs-meta">@Max(value = 150,message = &quot;&#123;student.age.error&#125;&quot;,groups = &#123;ValidationGroup2.class&#125;)</span>    <span class="hljs-keyword">private</span> Integer age;</code></pre></div><p>在 group 中指定每一个校验规则所属的组，一个规则可以属于一个组，也可以属于多个组。</p><p>最后，在接收参数的地方，指定校验组：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/addstudent&quot;)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Validated(ValidationGroup2.class)</span> Student student, BindingResult result)</span> </span>&#123;        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//校验未通过，获取所有的异常信息并展示出来</span>            List&lt;ObjectError&gt; allErrors = result.getAllErrors();            <span class="hljs-keyword">for</span> (ObjectError allError : allErrors) &#123;                System.out.println(allError.getObjectName()+<span class="hljs-string">&quot;:&quot;</span>+allError.getDefaultMessage());            &#125;        &#125;    &#125;&#125;</code></pre></div><p>配置完成后，属于<code> ValidationGroup2</code> 这个组的校验规则，才会生效。</p><h3 id="9-3-校验注解"><a href="#9-3-校验注解" class="headerlink" title="9.3 校验注解"></a>9.3 校验注解</h3><p>校验注解，主要有如下几种：</p><ul><li>@Null 被注解的元素必须为 null</li><li>@NotNull 被注解的元素必须不为 null</li><li>@AssertTrue 被注解的元素必须为 true</li><li>@AssertFalse 被注解的元素必须为 false</li><li>@Min(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@Max(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@DecimalMin(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@DecimalMax(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@Size(max=, min=) 被注解的元素的大小必须在指定的范围内</li><li>@Digits (integer, fraction) 被注解的元素必须是一个数字，其值必须在可接受的范围内</li><li>@Past 被注解的元素必须是一个过去的日期</li><li>@Future 被注解的元素必须是一个将来的日期</li><li>@Pattern(regex=,flag=) 被注解的元素必须符合指定的正则表达式</li><li>@NotBlank(message =) 验证字符串非 null，且长度必须大于0</li><li>@Email 被注解的元素必须是电子邮箱地址</li><li>@Length(min=,max=) 被注解的字符串的大小必须在指定的范围内</li><li>@NotEmpty 被注解的字符串的必须非空</li><li>@Range(min=,max=,message=) 被注解的元素必须在合适的范围内</li></ul><h2 id="10-数据回显"><a href="#10-数据回显" class="headerlink" title="10. 数据回显"></a>10. 数据回显</h2><h3 id="10-1-数据回显基本用法"><a href="#10-1-数据回显基本用法" class="headerlink" title="10.1 数据回显基本用法"></a>10.1 数据回显基本用法</h3><p>数据回显就是当用户数据提交失败时，自动填充好已经输入的数据。一般来说，如果使用 Ajax 来做数据提交，基本上是没有数据回显这个需求的，但是如果是通过表单做数据提交，那么数据回显就非常有必要了。</p><h4 id="10-1-1-简单数据类型"><a href="#10-1-1-简单数据类型" class="headerlink" title="10.1.1 简单数据类型"></a>10.1.1 简单数据类型</h4><p>简单数据类型，实际上框架在这里没有提供任何形式的支持，就是我们自己手动配置。我们继续在第 10 小节的例子上演示 Demo。加入提交的 Student 数据不符合要求，那么重新回到添加 Student 页面，并且预设之前已经填好的数据。</p><p>首先我们先来改造一下<code> student.jsp</code> 页面：</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/addstudent&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;学生编号：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;$&#123;id&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生姓名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;name&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生邮箱：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;email&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生年龄：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;$&#123;age&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;                &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;</code></pre></div><p>在接收数据时，使用简单数据类型去接收：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addstudent&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStudent2</span><span class="hljs-params">(Integer id, String name, String email, Integer age, Model model)</span> </span>&#123;    model.addAttribute(<span class="hljs-string">&quot;id&quot;</span>, id);    model.addAttribute(<span class="hljs-string">&quot;name&quot;</span>, name);    model.addAttribute(<span class="hljs-string">&quot;email&quot;</span>, email);    model.addAttribute(<span class="hljs-string">&quot;age&quot;</span>, age);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&quot;</span>;&#125;</code></pre></div><p>这种方式，相当于框架没有做任何工作，就是我们手动做数据回显的。此时访问页面，服务端会再次定位到该页面，而且数据已经预填好</p><h4 id="10-1-2-实体类"><a href="#10-1-2-实体类" class="headerlink" title="10.1.2 实体类"></a>10.1.2 实体类</h4><p>上面这种简单数据类型的回显，实际上非常麻烦，因为需要开发者在服务端一个一个手动设置。如果使用对象的话，就没有这么麻烦了，因为 SpringMVC 在页面跳转时，会自动将对象填充进返回的数据中</p><p>此时，首先修改一下<code> student.jsp</code> 页面：</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/addstudent&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;学生编号：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;$&#123;student.id&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生姓名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;student.name&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生邮箱：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;student.email&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生年龄：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;$&#123;student.age&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;                &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;</code></pre></div><p>注意，在预填数据中，多了一个 <code>student.</code> 前缀。这 student 就是服务端接收数据的变量名，服务端的变量名和这里的 student 要保持一致。服务端定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addstudent&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Validated(ValidationGroup2.class)</span> Student student, BindingResult result)</span> </span>&#123;    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//校验未通过，获取所有的异常信息并展示出来</span>        List&lt;ObjectError&gt; allErrors = result.getAllErrors();        <span class="hljs-keyword">for</span> (ObjectError allError : allErrors) &#123;            System.out.println(allError.getObjectName()+<span class="hljs-string">&quot;:&quot;</span>+allError.getDefaultMessage());        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;&#125;</code></pre></div><p>注意，服务端什么都不用做，就说要返回的页面就行了，student 这个变量会被自动填充到返回的 Model 中。变量名就是填充时候的 key。如果想自定义这个 key，可以在参数中写出来 Model，然后手动加入 Student 对象，就像简单数据类型回显那样。</p><p>另一种定义回显变量别名的方式，就是使用<code>@ModelAttribute</code>注解</p><h3 id="10-2-ModelAttribute"><a href="#10-2-ModelAttribute" class="headerlink" title="10.2 @ModelAttribute"></a>10.2 @ModelAttribute</h3><p><code>@ModelAttribute</code> 这个注解，主要有两方面的功能：</p><ul><li>在数据回显时，给变量定义别名</li><li>定义全局数据</li></ul><h4 id="10-2-1-定义别名"><a href="#10-2-1-定义别名" class="headerlink" title="10.2.1 定义别名"></a>10.2.1 定义别名</h4><p>在数据回显时，给变量定义别名，非常容易，直接加这个注解即可：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addstudent&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;s&quot;)</span> <span class="hljs-meta">@Validated(ValidationGroup2.class)</span> Student student, BindingResult result)</span> </span>&#123;    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//校验未通过，获取所有的异常信息并展示出来</span>        List&lt;ObjectError&gt; allErrors = result.getAllErrors();        <span class="hljs-keyword">for</span> (ObjectError allError : allErrors) &#123;            System.out.println(allError.getObjectName()+<span class="hljs-string">&quot;:&quot;</span>+allError.getDefaultMessage());        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;&#125;</code></pre></div><p>这样定义完成后，在前端再次访问回显的变量时，变量名称就不是 student 了，而是 s：</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/addstudent&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;学生编号：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;$&#123;s.id&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生姓名：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;s.name&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生邮箱：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;s.email&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;学生年龄：&lt;/td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;$&#123;s.age&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;                &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;</code></pre></div><h4 id="10-2-2-定义全局数据"><a href="#10-2-2-定义全局数据" class="headerlink" title="10.2.2 定义全局数据"></a>10.2.2 定义全局数据</h4><p>假设有一个 Controller 中有很多方法，每个方法都会返回数据给前端，但是每个方法返回给前端的数据又不太一样，虽然不太一样，但是没有方法的返回值又有一些公共的部分。可以将这些公共的部分提取出来单独封装成一个方法，用 <code>@ModelAttribute </code>注解来标记。</p><p>例如在一个 Controller 中 ，添加如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute(&quot;info&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;lucifer&quot;</span>);    map.put(<span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;www.github.com&quot;</span>);    <span class="hljs-keyword">return</span> map;&#125;</code></pre></div><p>当用户访问当前 Controller 中的任意一个方法，在返回数据时，都会将添加了<code>@ModelAttribute</code>注解的方法的返回值，一起返回给前端。<code>@ModelAttribute </code>注解中的 info 表示返回数据的 key</p><h2 id="11-JSON"><a href="#11-JSON" class="headerlink" title="11. JSON"></a>11. JSON</h2><h3 id="11-1-返回-JSON"><a href="#11-1-返回-JSON" class="headerlink" title="11.1 返回 JSON"></a>11.1 返回 JSON</h3><p>目前主流的 JSON 处理工具主要有三种：</p><ul><li><strong>jackson</strong></li><li><strong>gson</strong></li><li><strong>fastjson</strong></li></ul><p>在 SpringMVC 中，对 jackson 和 gson 都提供了相应的支持，就是如果使用这两个作为 JSON 转换器，只需要添加对应的依赖就可以了，返回的对象和返回的集合、Map 等都会自动转为 JSON，但是，如果使用 fastjson，除了添加相应的依赖之外，还需要自己手动配置 <code>HttpMessageConverter</code> 转换器。其实前两个也是使用 <code>HttpMessageConverter </code>转换器，但是是 SpringMVC 自动提供的，SpringMVC 没有给 fastjson 提供相应的转换器</p><h4 id="11-1-1-jackson"><a href="#11-1-1-jackson" class="headerlink" title="11.1.1 jackson"></a>11.1.1 jackson</h4><p>jackson 是一个使用比较多，时间也比较长的 JSON 处理工具，在 SpringMVC 中使用 jackson ，只需要添加 jackson 的依赖即可：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>依赖添加成功后，凡是在接口中直接返回的对象，集合等等，都会自动转为 JSON。如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String author;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> author;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(String author)</span> </span>&#123;        <span class="hljs-keyword">this</span>.author = author;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getBookById</span><span class="hljs-params">()</span> </span>&#123;    Book book = <span class="hljs-keyword">new</span> Book();    book.setId(<span class="hljs-number">1</span>);    book.setName(<span class="hljs-string">&quot;三国演义&quot;</span>);    book.setAuthor(<span class="hljs-string">&quot;罗贯中&quot;</span>);    <span class="hljs-keyword">return</span> book;&#125;</code></pre></div><p>这里返回一个对象，但是在前端接收到的则是一个 JSON 字符串，这个对象会通过 <code>HttpMessageConverter </code>自动转为 JSON 字符串</p><p>如果想返回一个 JSON 数组，写法如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title">getAllBooks</span><span class="hljs-params">()</span> </span>&#123;    List&lt;Book&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Book&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        Book book = <span class="hljs-keyword">new</span> Book();        book.setId(i);        book.setName(<span class="hljs-string">&quot;三国演义:&quot;</span> + i);        book.setAuthor(<span class="hljs-string">&quot;罗贯中:&quot;</span> + i);        list.add(book);    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></div><p>添加了 jackson ，就能够自动返回 JSON，这个依赖于一个名为<code> HttpMessageConverter</code> 的类，这本身是一个接口，从名字上就可以看出，它的作用是 Http 消息转换器，既然是消息转换器，它提供了两方面的功能：</p><ul><li>将返回的对象转为 JSON</li><li>将前端提交上来的 JSON 转为对象</li></ul><p>但是，<code>HttpMessageConverter </code>只是一个接口，由各个 JSON 工具提供相应的实现，在 jackson 中，实现的名字叫做 <code>MappingJackson2HttpMessageConverter</code>，而这个东西的初始化，则由 SpringMVC 来完成。除非自己有一些自定义配置的需求，否则一般来说不需要自己提供 <code>MappingJackson2HttpMessageConverter</code></p><p>举一个简单的应用场景，例如每一本书，都有一个出版日期，修改 Book 类如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String author;    <span class="hljs-keyword">private</span> Date publish;    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getPublish</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> publish;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPublish</span><span class="hljs-params">(Date publish)</span> </span>&#123;        <span class="hljs-keyword">this</span>.publish = publish;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> author;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(String author)</span> </span>&#123;        <span class="hljs-keyword">this</span>.author = author;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;</code></pre></div><p>然后在构造 Book 时添加日期属性：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getBookById</span><span class="hljs-params">()</span> </span>&#123;    Book book = <span class="hljs-keyword">new</span> Book();    book.setId(<span class="hljs-number">1</span>);    book.setName(<span class="hljs-string">&quot;三国演义&quot;</span>);    book.setAuthor(<span class="hljs-string">&quot;罗贯中&quot;</span>);    book.setPublish(<span class="hljs-keyword">new</span> Date());    <span class="hljs-keyword">return</span> book;&#125;</code></pre></div><p>访问 <code>/book </code>接口，返回的 json 格式如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/12-1-1.png" alt="12-1-1.png"></p><p>如果我们想自己定制返回日期的格式，简单的办法，可以通过添加注解来实现：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String author;    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;,timezone = &quot;Asia/Shanghai&quot;)</span>    <span class="hljs-keyword">private</span> Date publish;</code></pre></div><p>注意这里一定要设置时区</p><p>这样，就可以定制返回的日期格式了</p><p>但是，这种方式有一个弊端，这个注解可以加在属性上，也可以加在类上，也就说，最大可以作用到一个类中的所有日期属性上。如果项目中有很多实体类都需要做日期格式化，使用这种方式就比较麻烦了，这个时候，我们可以自己提供一个 jackson 的 <code>HttpMesageConverter </code>实例，在这个实例中，自己去配置相关属性，这里的配置将是一个全局配置</p><p>在 SpringMVC 配置文件中，添加如下配置：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;objectMapper&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateFormat&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.text.SimpleDateFormat&quot;</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;timeZone&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>添加完成后，去掉 Book 实体类中日期格式化的注解，再进行测试，结果如下：</p><h4 id="11-1-2-gson"><a href="#11-1-2-gson" class="headerlink" title="11.1.2 gson"></a>11.1.2 gson</h4><p>gson 是 Google 推出的一个 JSON 解析器，主要在 Android 开发中使用较多，不过，Web 开发中也是支持这个的，而且 SpringMVC 还针对 Gson 提供了相关的自动化配置，以致我们在项目中只要添加 gson 依赖，就可以直接使用 gson 来做 JSON 解析</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>如果项目中，同时存在 jackson 和 gson 的话，那么默认使用的是 jackson，在 <code>org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter</code> 类的构造方法中，加载顺序就是先加载 jackson 的 <code>HttpMessageConverter</code>，后加载 gson 的<code> HttpMessageConverter</code></p><p>加完依赖之后，就可以直接返回 JSON 字符串了。使用 Gson 时，如果想做自定义配置，则需要自定义 <code>HttpMessageConverter</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.GsonHttpMessageConverter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gson&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.google.gson.Gson&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;gsonBuilder&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;create&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.google.gson.GsonBuilder&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;gsonBuilder&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateFormat&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="11-1-3-fastjson"><a href="#11-1-3-fastjson" class="headerlink" title="11.1.3 fastjson"></a>11.1.3 fastjson</h4><p>fastjson 号称最快的 JSON 解析器，但是也是这三个中 BUG 最多的一个。在 SpringMVC 并没针对 fastjson 提供相应的<code> HttpMessageConverter</code>，所以，fastjson 在使用时，一定要自己手动配置 <code>HttpMessageConverter</code>（前面两个如果没有特殊需要，直接添加依赖就可以了）</p><p>使用 fastjson，我们首先添加 fastjson 依赖：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.60<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>然后在 SpringMVC 的配置文件中配置 <code>HttpMessageConverter</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fastJsonConfig&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateFormat&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>fastjson 默认中文乱码，添加如下配置解决</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fastJsonConfig&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateFormat&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;supportedMediaTypes&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>application/json;charset=utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h3 id="12-2-接收-JSON"><a href="#12-2-接收-JSON" class="headerlink" title="12.2 接收 JSON"></a>12.2 接收 JSON</h3><p>浏览器传来的参数，可以是 <code>key/value </code>形式的，也可以是一个 JSON 字符串。在 <code>Jsp/Servlet</code> 中，我们接收 <code>key/value</code> 形式的参数，一般是通过<code>getParameter</code>方法。如果客户端商户传入的是 JSON 数据，我们可以通过如下格式进行解析：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addbook2&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook2</span><span class="hljs-params">(HttpServletRequest req)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();    Book book = om.readValue(req.getInputStream(), Book.class);    System.out.println(book);&#125;</code></pre></div><p>但是这种解析方式有点麻烦，在 SpringMVC 中，我们可以通过一个注解来快速的将一个 JSON 字符串转为一个对象：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addbook3&quot;)</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook3</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Book book)</span> </span>&#123;    System.out.println(book);&#125;</code></pre></div><p>这样就可以直接收到前端传来的 JSON 字符串了。这也是 <code>HttpMessageConverter </code>提供的第二个功能</p><h2 id="12-RESTful"><a href="#12-RESTful" class="headerlink" title="12. RESTful"></a>12. RESTful</h2><p>越来越多的人开始意识到，网站即软件，而且是一种新型的软件。这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，现在我们必须考虑，如何开发在互联网环境中使用的软件。</p><p>RESTful 架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p><p>RESTful 它不是一个具体的架构，不是一个软件，不是一个框架，<strong>而是一种规范</strong>。在移动互联网兴起之前，我们都很少提及 RESTful，主要是因为用的少，移动互联网兴起后，RESTful 得到了非常广泛的应用，因为在移动互联网兴起之后，我们再开发后端应用，就不仅仅只是开发一个网站了，还对应了多个前端（Android、iOS、HTML5 等等），这个时候，我们在设计后端接口是，就需要考虑接口的形式，格式，参数的传递等等诸多问题了。</p><h3 id="12-1-起源"><a href="#12-1-起源" class="headerlink" title="12.1 起源"></a>12.1 起源</h3><p>REST 这个词，是 Roy Thomas Fielding 在他 2000 年的博士论文中提出的。</p><p>Fielding 是一个非常重要的人，他是 HTTP 协议（1.0版和1.1版）的主要设计者、Apache 服务器软件的作者之一、Apache 基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p><p>他这样介绍论文的写作目的：</p><p>“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”</p><h3 id="12-2-名称"><a href="#12-2-名称" class="headerlink" title="12.2 名称"></a>12.2 名称</h3><p>Fielding 将他对互联网软件的架构原则，定名为REST，即 Representational State Transfer 的缩写。我对这个词组的翻译是”表现层状态转化”。</p><p>如果一个架构符合 REST 原则，就称它为 RESTful 架构。</p><p>要理解 RESTful 架构，最好的方法就是去理解 Representational State Transfer 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会 REST 是一种什么样的设计。</p><h3 id="12-3-资源（Resources）"><a href="#12-3-资源（Resources）" class="headerlink" title="12.3 资源（Resources）"></a>12.3 资源（Resources）</h3><p>REST 的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个 URI （统一资源定位符）指向它，每种资源对应一个特定的 URI。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的 URI。</p><blockquote><p>在 RESTful 风格的应用中，每一个 URI 都代表了一个资源。</p></blockquote><h3 id="12-4-表现层（Representation）"><a href="#12-4-表现层（Representation）" class="headerlink" title="12.4 表现层（Representation）"></a>12.4 表现层（Representation）</h3><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p><p>比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。</p><p>URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的 “.html” 后缀名是不必要的，因为这个后缀名表示格式，属于 “表现层” 范畴，而 URI 应该只代表”资源”的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对”表现层”的描述。</p><h3 id="12-5-状态转化（State-Transfer）"><a href="#12-5-状态转化（State-Transfer）" class="headerlink" title="12.5 状态转化（State Transfer）"></a>12.5 状态转化（State Transfer）</h3><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p><p>客户端用到的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：</p><ul><li>GET 用来获取资源</li><li>POST 用来新建资源（也可以用于更新资源）</li><li>PUT 用来更新资源</li><li>DELETE 用来删除资源</li></ul><h3 id="12-6-综述"><a href="#12-6-综述" class="headerlink" title="12.6 综述"></a>12.6 综述</h3><p>综合上面的解释，我们总结一下什么是 RESTful 架构：</p><ul><li><strong>每一个 URI 代表一种资源；</strong></li><li><strong>客户端和服务器之间，传递这种资源的某种表现层；</strong></li><li><strong>客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化”</strong></li></ul><h3 id="12-7-误区"><a href="#12-7-误区" class="headerlink" title="12.7 误区"></a>12.7 误区</h3><p>RESTful 架构有一些典型的设计误区。</p><p>最常见的一种设计错误，就是 URI 包含动词。因为”资源”表示一种实体，所以应该是名词，URI 不应该有动词，动词应该放在 HTTP 协议中。</p><p>举例来说，某个 URI 是 /posts/show/1，其中 show 是动词，这个 URI 就设计错了，正确的写法应该是 /posts/1，然后用 GET 方法表示 show。</p><p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户 1 向账户 2 汇款 500 元，错误的 URI 是：</p><ul><li>POST /accounts/1/transfer/500/to/2</li></ul><p>正确的写法是把动词 transfer 改成名词 transaction，资源不能是动词，但是可以是一种服务：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">POST</span> <span class="hljs-string">/transaction HTTP/1.1</span><span class="hljs-attr">Host</span>: <span class="hljs-string">127.0.0.1</span><span class="hljs-attr">from</span>=<span class="hljs-string">1&amp;to=2&amp;amount=500.00</span></code></pre></div><p>另一个设计误区，就是在URI中加入版本号：</p><ul><li><a href="http://www.example.com/app/1.0/foo">http://www.example.com/app/1.0/foo</a></li><li><a href="http://www.example.com/app/1.1/foo">http://www.example.com/app/1.1/foo</a></li><li><a href="http://www.example.com/app/2.0/foo">http://www.example.com/app/2.0/foo</a></li></ul><p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个 URI。版本号可以在 HTTP 请求头信息的 Accept 字段中进行区分（参见 Versioning REST Services）：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">Accept</span>: <span class="hljs-string">vnd.example-com.foo+json; version=1.0</span><span class="hljs-attr">Accept</span>: <span class="hljs-string">vnd.example-com.foo+json; version=1.1</span><span class="hljs-attr">Accept</span>: <span class="hljs-string">vnd.example-com.foo+json; version=2.0</span></code></pre></div><h3 id="12-8-命名规则"><a href="#12-8-命名规则" class="headerlink" title="12.8 命名规则"></a>12.8 命名规则</h3><p>路径又称”终点”（endpoint），表示 API 的具体网址。实际开发中常见的规范如下：</p><ol><li><strong>网址中不能有动词，只能有名词，API 中的名词也应该使用复数。</strong>因为 REST 中的资源往往和数据库中的表对应，而数据库中的表都是同种记录的”集合”（collection）。如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。比如：<code>GET /calculate?param1=11&amp;param2=33</code> 。</li><li><strong>不用大写字母，建议用中杠 - 不用下杠 _</strong> 。比如邀请码写成 <code>invitation-code</code>而不是 <del>invitation_code</del> 。</li><li><strong>善用版本化 API</strong>。当我们的 API 发生了重大改变而不兼容前期版本的时候，我们可以通过 URL 来实现版本化，比如 <code>Http://api.example.com/v1</code>、<code>http://apiv1.example.com</code> 。版本不必非要是数字，只是数字用的最多，日期、季节都可以作为版本标识符，项目团队达成共识就可。</li><li><strong>接口尽量使用名词，避免使用动词。</strong> RESTful API 操作（HTTP Method）的是资源（名词）而不是动作（动词）。</li></ol><blockquote><p>GET    /classes：列出所有班级<br>POST   /classes：新建一个班级<br>GET    /classes/classId：获取某个指定班级的信息<br>PUT    /classes/classId：更新某个指定班级的信息（一般倾向整体更新）<br>PATCH  /classes/classId：更新某个指定班级的信息（一般倾向部分更新）<br>DELETE /classes/classId：删除某个班级<br>GET    /classes/classId/teachers：列出某个指定班级的所有老师的信息<br>GET    /classes/classId/students：列出某个指定班级的所有学生的信息<br>DELETE classes/classId/teachers/ID：删除某个指定班级下的指定的老师的信息</p></blockquote><p>理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源:<code>/schools</code>，老师: <code>/schools/teachers</code>，学生: <code>/schools/students</code> 就是二级资源</p><p><strong>过滤信息（Filtering）</strong></p><p>如果我们在查询的时候需要添加特定条件的话，建议使用 url 参数的形式。比如我们要查询 state 状态为 active 并且 name 为 guidegege 的班级：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">GET</span>    <span class="hljs-string">/classes?state=active&amp;name=guidegege</span></code></pre></div><p>比如我们要实现分页查询：</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">GET</span>    <span class="hljs-string">/classes?page=1&amp;size=10 //指定第1页，每页10个数据</span></code></pre></div><p><strong>状态码（Status Codes）</strong></p><table><thead><tr><th>2xx：成功</th><th>3xx：重定向</th><th>4xx：客户端错误</th><th>5xx：服务器错误</th></tr></thead><tbody><tr><td>200 成功</td><td>301 永久重定向</td><td>400 错误请求</td><td>500 服务器错误</td></tr><tr><td>201 创建</td><td>304 资源未修改</td><td>401 未授权</td><td>502 网关错误</td></tr><tr><td></td><td></td><td>403 禁止访问</td><td>504 网关超时</td></tr><tr><td></td><td></td><td>404 未找到</td><td></td></tr><tr><td></td><td></td><td>405 请求方法不对</td><td></td></tr></tbody></table><h3 id="12-9-SpringMVC-的支持"><a href="#12-9-SpringMVC-的支持" class="headerlink" title="12.9 SpringMVC 的支持"></a>12.9 SpringMVC 的支持</h3><p>SpringMVC 对 RESTful 提供了非常全面的支持，主要有如下几个注解：</p><ul><li><code>@RestController</code></li></ul><p>这个注解是一个组合注解：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Controller</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RestController &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * The value may indicate a suggestion for a logical component name,</span><span class="hljs-comment"> * to be turned into a Spring bean in case of an autodetected component.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 4.0.1</span><span class="hljs-comment"> */</span><span class="hljs-meta">@AliasFor(annotation = Controller.class)</span><span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;&#125;</code></pre></div><p>一般，直接用 <code>@RestController</code> 来标记 Controller，可以不使用 <code>@Controller</code></p><p>请求方法中，提供了常见的请求方法：</p><ul><li><code>@PostMapping</code></li><li><code>@GetMapping</code></li><li><code>@PutMapping</code></li><li><code>@DeleteMapping</code></li></ul><p>另外还有一个提取请求地址中的参数的注解 <code>@PathVariable</code></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/book/&#123;id&#125;&quot;)</span><span class="hljs-comment">//http://localhost:8080/book/2</span><span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;    Book book = <span class="hljs-keyword">new</span> Book();    book.setId(id);    <span class="hljs-keyword">return</span> book;&#125;</code></pre></div><p>参数 2 将被传递到 id 这个变量上</p><h2 id="13-静态资源访问"><a href="#13-静态资源访问" class="headerlink" title="13. 静态资源访问"></a>13. 静态资源访问</h2><p>在 SpringMVC 中，静态资源，默认都是被拦截的，例如 html、js、css、jpg、png、txt、pdf 等等，都是无法直接访问的。因为所有请求都被拦截了，所以，针对静态资源，我们要做额外处理，处理方式很简单，直接在 SpringMVC 的配置文件中，添加如下内容：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/static/html/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/html/&quot;</span>/&gt;</span></code></pre></div><p>mapping 表示映射规则，也是拦截规则，就是说，如果请求地址是<code>/static/html</code>这样的格式的话，那么对应的资源就去<code>/static/html/</code>这个目录下查找。</p><p>在映射路径的定义中，最后是两个 *，这是一种 Ant 风格的路径匹配符号，一共有三个通配符：</p><table><thead><tr><th align="left">通配符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">**</td><td align="left">匹配多层路径</td></tr><tr><td align="left">*</td><td align="left">匹配一层路径</td></tr><tr><td align="left">?</td><td align="left">匹配任意单个字符</td></tr></tbody></table><p>一个比较原始的配置方式可能如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/static/html/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/html/&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/static/js/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/js/&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/static/css/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/css/&quot;</span>/&gt;</span></code></pre></div><p>但是，由于 ** 可以表示多级路径，所以，以上配置，我们可以进行简化：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/&quot;</span>/&gt;</span></code></pre></div><h2 id="14-拦截器"><a href="#14-拦截器" class="headerlink" title="14. 拦截器"></a>14. 拦截器</h2><p>SpringMVC 中的拦截器，相当于<code>Jsp/Servlet</code>中的过滤器，只不过拦截器的功能更为强大。</p><p>拦截器的定义非常容易：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyInterceptor1:preHandle&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyInterceptor1:postHandle&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyInterceptor1:afterCompletion&quot;</span>);    &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyInterceptor2:preHandle&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyInterceptor2:postHandle&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyInterceptor2:afterCompletion&quot;</span>);    &#125;&#125;</code></pre></div><p>拦截器定义好之后，需要在 SpringMVC 的配置文件中进行配置：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;myInterceptor1&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;myInterceptor2&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></code></pre></div><p>如果存在多个拦截器，拦截规则如下：</p><ul><li>preHandle 按拦截器定义顺序调用</li><li>postHandler 按拦截器定义逆序调用</li><li>afterCompletion 按拦截器定义逆序调用</li><li>postHandler 在拦截器链内所有拦截器返成功调用</li><li>afterCompletion 只有 preHandle 返回 true 才调用</li></ul><h1 id="第七章、SpringMVC整合"><a href="#第七章、SpringMVC整合" class="headerlink" title="第七章、SpringMVC整合"></a>第七章、SpringMVC整合</h1><h2 id="1-MVC框架整合思想"><a href="#1-MVC框架整合思想" class="headerlink" title="1. MVC框架整合思想"></a>1. MVC框架整合思想</h2><h3 id="1-1-搭建Web运行环境"><a href="#1-1-搭建Web运行环境" class="headerlink" title="1.1 搭建Web运行环境"></a>1.1 搭建Web运行环境</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjrt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="1-2-为什么要整合MVC框架"><a href="#1-2-为什么要整合MVC框架" class="headerlink" title="1.2 为什么要整合MVC框架"></a>1.2 为什么要整合MVC框架</h3><ul><li>MVC框架提供了控制器(Controller)调用Service<br>DAO —&gt; Service </li><li>请求响应的处理</li><li>接受请求参数 request.getParameter(“”)</li><li>控制程序的运行流程</li><li>视图解析 (JSP JSON Freemarker Thyemeleaf )</li></ul><h3 id="1-3-Spring可以整合那些MVC框架"><a href="#1-3-Spring可以整合那些MVC框架" class="headerlink" title="1.3 Spring可以整合那些MVC框架"></a>1.3 Spring可以整合那些MVC框架</h3><ul><li>struts1 </li><li>webwork</li><li>jsf</li><li>struts2</li><li>springMVC </li></ul><h3 id="1-4-Spring整合MVC框架的核心思路"><a href="#1-4-Spring整合MVC框架的核心思路" class="headerlink" title="1.4 Spring整合MVC框架的核心思路"></a>1.4 Spring整合MVC框架的核心思路</h3><h4 id="1-4-1-准备工厂"><a href="#1-4-1-准备工厂" class="headerlink" title="1.4.1 准备工厂"></a>1.4.1 准备工厂</h4><p><strong>Web 开发过程中如何创建工厂?</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationContext ctx = <span class="hljs-keyword">new</span> WebXmlApplicationContext(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);</code></pre></div><p><strong>如何保证工厂唯一，同时被共用？</strong></p><ul><li>共用：工厂存储在 <code>ServletContext</code> 这个作用域中，<code>ServletContext.setAttribute(&quot;xxx&quot;, ctx);</code></li><li>唯一：在 <code>ServletContext</code> 对象创建的同时创建工厂<ul><li><code>ServletContextListener</code> 在 <code>ServletContext</code> 对象创建的同时，被调用（只会被调用一次），把创建工厂的代码写在 <code>ServletContextListener</code> 中，也会保证只调用一次，保证了工厂的唯一性</li></ul></li></ul><p><strong>Spring 封装了一个 <code>ContextLoaderListener</code>，主要做了两件事：</strong></p><ol><li>创建工厂</li><li>把工厂存在 <code>ServletContext</code> 中</li></ol><p><code>ContextLoaderListener</code> 使用方式：<code>web.xml</code> 中</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span> org.springframework.web.context.ContextLoaderListener <span class="hljs-tag">&lt;/<span class="hljs-name">listen-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span> contextConfigLocation <span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span> classpath:applicationContext.xml <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre></div><p>同时需要在<code>web.xml</code> 中也需要加上MVC相关</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>      <span class="hljs-comment">&lt;!--MVC的配置文件--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><h4 id="1-4-2-代码整合"><a href="#1-4-2-代码整合" class="headerlink" title="1.4.2 代码整合"></a>1.4.2 代码整合</h4><blockquote><p>依赖注入：把Sevice对象注入个控制器对象</p></blockquote><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200520143653347.png" alt="image-20200520143653347"></p><h2 id="2-基于注解SpringMVC"><a href="#2-基于注解SpringMVC" class="headerlink" title="2 .基于注解SpringMVC"></a>2 .基于注解SpringMVC</h2><h3 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1 创建工程"></a>2.1 创建工程</h3><p>创建一个普通的 Maven 工程（注意，这里可以不必创建 Web 工程），并添加 SpringMVC 的依赖，同时，这里环境的搭建需要用到 Servlet ，所以我们还需要引入 Servlet 的依赖（一定不能使用低版本的 Servlet），最终的 pom.xml 文件如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="2-2-添加-Spring-配置"><a href="#2-2-添加-Spring-配置" class="headerlink" title="2.2 添加 Spring 配置"></a>2.2 添加 Spring 配置</h3><p>工程创建成功之后，首先添加 Spring 的配置文件，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;, useDefaultFilters = true, excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class)&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>&#123;&#125;</code></pre></div><ul><li><code>@Configuration</code> 注解表示这是一个配置类，在我们这里，这个配置的作用类似于<code> applicationContext.xml</code></li><li><code>@ComponentScan </code>注解表示配置包扫描，里边的属性和 xml 配置中的属性都是一一对应的，<code>useDefaultFilters</code> 表示使用默认的过滤器，然后又除去 Controller 注解，即在 Spring 容器中扫描除了 Controller 之外的其他所有 Bean 。</li></ul><h3 id="2-3-添加-SpringMVC-配置"><a href="#2-3-添加-SpringMVC-配置" class="headerlink" title="2.3 添加 SpringMVC 配置"></a>2.3 添加 SpringMVC 配置</h3><p>接下来再来创建 springmvc 的配置文件：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;,useDefaultFilters = false,includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION,classes = Controller.class)&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> </span>&#123;&#125;</code></pre></div><p><strong>注意，如果不需要在 SpringMVC 中添加其他的额外配置，这样就可以了。即 视图解析器、JSON 解析、文件上传……等等，如果都不需要配置的话，这样就可以了</strong></p><h3 id="2-4-配置-web-xml"><a href="#2-4-配置-web-xml" class="headerlink" title="2.4 配置 web.xml"></a>2.4 配置 web.xml</h3><p>此时，我们并没有 web.xml 文件，这时，我们可以使用 Java 代码去代替 web.xml 文件，这里会用到 <code>WebApplicationInitializer</code> ，具体定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebInit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebApplicationInitializer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        <span class="hljs-comment">//首先来加载 SpringMVC 的配置文件</span>        AnnotationConfigWebApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigWebApplicationContext();        ctx.register(SpringMVCConfig.class);        <span class="hljs-comment">// 添加 DispatcherServlet</span>        ServletRegistration.Dynamic springmvc = servletContext.addServlet(<span class="hljs-string">&quot;springmvc&quot;</span>, <span class="hljs-keyword">new</span> DispatcherServlet(ctx));        <span class="hljs-comment">// 给 DispatcherServlet 添加路径映射</span>        springmvc.addMapping(<span class="hljs-string">&quot;/&quot;</span>);        <span class="hljs-comment">// 给 DispatcherServlet 添加启动时机</span>        springmvc.setLoadOnStartup(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><p><code>WebInit</code> 的作用类似于 web.xml，这个类需要实现 <code>WebApplicationInitializer</code> 接口，并实现接口中的方法，当项目启动时，<code>onStartup</code> 方法会被自动执行，我们可以在这个方法中做一些项目初始化操作，例如加载 SpringMVC 容器，添加过滤器，添加 Listener、添加 Servlet 等。</p><p><strong>注意：</strong></p><p>由于我们在 WebInit 中只是添加了 SpringMVC 的配置，这样项目在启动时只会去加载 SpringMVC 容器，而不会去加载 Spring 容器，如果一定要加载 Spring 容器，需要我们修改 SpringMVC 的配置，在 SpringMVC 配置的包扫描中也去扫描<code>@Configuration</code>注解，进而加载 Spring 容器，还有一种方案可以解决这个问题，就是直接在项目中舍弃 Spring 配置，直接将所有配置放到 SpringMVC 的配置中来完成，这个在 SSM 整合时是没有问题的，在实际开发中，较多采用第二种方案，第二种方案，SpringMVC 的配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> </span>&#123;&#125;</code></pre></div><p>这种方案中，所有的注解都在 SpringMVC 中扫描，采用这种方案的话，则 Spring 的配置文件就可以删除了</p><h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><p>最后，添加一个 HelloController ，然后启动项目进行测试：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;&#125;</code></pre></div><p>启动项目，访问接口，结果如下：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/10-1.png" alt="img"></p><h3 id="2-6-其他配置"><a href="#2-6-其他配置" class="headerlink" title="2.6 其他配置"></a>2.6 其他配置</h3><h4 id="2-6-1-静态资源过滤"><a href="#2-6-1-静态资源过滤" class="headerlink" title="2.6.1 静态资源过滤"></a>2.6.1 静态资源过滤</h4><p>静态资源过滤在 SpringMVC 的 XML 中的配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/&quot;</span>/&gt;</span></code></pre></div><p>在 Java 配置的 SSM 环境中，如果要配置静态资源过滤，需要让 SpringMVC 的配置继承 <code>WebMvcConfigurationSupport </code>，进而重写 <code>WebMvcConfigurationSupport </code>中的方法，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;        registry.addResourceHandler(<span class="hljs-string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/&quot;</span>);    &#125;&#125;</code></pre></div><p>重写 addResourceHandlers 方法，在这个方法中配置静态资源过滤，这里我将静态资源放在 resources 目录下，所以资源位置是 <code>classpath:/</code> ，当然，资源也可以放在 webapp 目录下，此时只需要修改配置中的资源位置即可。如果采用 Java 来配置 SSM 环境，一般来说，可以不必使用 webapp 目录，除非要使用 JSP 做页面模板，否则可以忽略 webapp 目录。</p><h4 id="2-6-2-视图解析器"><a href="#2-6-2-视图解析器" class="headerlink" title="2.6.2 视图解析器"></a>2.6.2 视图解析器</h4><p>在 XML 文件中，通过如下方式配置视图解析器：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>如果通过 Java 类，一样也可以实现类似功能。</p><p>首先为我们的项目添加 webapp 目录，webapp 目录中添加一个 jsp 目录，jsp 目录中添加 jsp 文件：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/10-2.png" alt="img"></p><p>然后引入 JSP 的依赖：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>然后，在配置类中，继续重写方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>&#123;        registry.jsp(<span class="hljs-string">&quot;/jsp/&quot;</span>, <span class="hljs-string">&quot;.jsp&quot;</span>);    &#125;&#125;</code></pre></div><p>接下来，在 <code>Controller</code> 中添加控制器即可访问 JSP 页面：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController2</span> </span>&#123;    <span class="hljs-meta">@GetMapping(&quot;/hello2&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="2-6-3-路径映射"><a href="#2-6-3-路径映射" class="headerlink" title="2.6.3 路径映射"></a>2.6.3 路径映射</h4><p>有的时候，我们的控制器的作用仅仅只是一个跳转，就像上面小节中的控制器，里边没有任何业务逻辑，像这种情况，可以不用定义方法，可以直接通过路径映射来实现页面访问。如果在 <code>XML</code> 中配置路径映射，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">status-code</span>=<span class="hljs-string">&quot;200&quot;</span>/&gt;</span></code></pre></div><p>这行配置，表示如果用户访问 <code>/hello</code> 这个路径，则直接将名为 <code>hello</code> 的视图返回给用户，并且响应码为 <code>200</code>，这个配置就可以替代 <code>Controller</code> 中的方法。</p><p>相同的需求，如果在 <code>Java</code> 代码中，写法如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        registry.addViewController(<span class="hljs-string">&quot;/hello3&quot;</span>).setViewName(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre></div><p>此时，用户访问 <code>/hello3</code> 接口，就能看到名为 <code>hello</code> 的视图文件</p><h4 id="2-6-4-JSON-配置"><a href="#2-6-4-JSON-配置" class="headerlink" title="2.6.4 JSON 配置"></a>2.6.4 JSON 配置</h4><p>SpringMVC 可以接收JSON 参数，也可以返回 JSON 参数，这一切依赖于 <code>HttpMessageConverter</code></p><p><code>HttpMessageConverter </code>可以将一个 JSON 字符串转为 对象，也可以将一个对象转为 JSON 字符串，实际上它的底层还是依赖于具体的 JSON 库</p><p>所有的 JSON 库要在 SpringMVC 中自动返回或者接收 JSON，都必须提供和自己相关的 <code>HttpMessageConverter </code></p><p>SpringMVC 中，默认提供了<code>Jackson</code>和 <code>gson </code>的 <code>HttpMessageConverter</code> ，分别是：<code>MappingJackson2HttpMessageConverter</code> 和 <code>GsonHttpMessageConverter </code></p><p>正因为如此，我们在 SpringMVC 中，如果要使用 JSON ，对于 jackson 和 gson 我们只需要添加依赖，加完依赖就可以直接使用了。具体的配置是在 <code>AllEncompassingFormHttpMessageConverter</code> 类中完成的</p><p>如果开发者使用了<code> fastjson</code>，那么默认情况下，SpringMVC 并没有提供<code> fastjson</code> 的 <code>HttpMessageConverter </code>，这个需要我们自己提供，如果是在 XML 配置中，<code>fastjson</code> 除了加依赖，还要显式配置 <code>HttpMessageConverter</code>，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></code></pre></div><p>在 Java 配置的 SSM 中，我们一样也可以添加这样的配置：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;        FastJsonHttpMessageConverter converter = <span class="hljs-keyword">new</span> FastJsonHttpMessageConverter();        converter.setDefaultCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));        FastJsonConfig fastJsonConfig = <span class="hljs-keyword">new</span> FastJsonConfig();        fastJsonConfig.setCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));        converter.setFastJsonConfig(fastJsonConfig);        converters.add(converter);    &#125;&#125;</code></pre></div><p>然后，就可以在接口中直接返回 JSON 了，此时的 JSON 数据将通过<code>fastjson</code>生成</p><h2 id="3-Spring-Boot-中自定义-SpringMVC"><a href="#3-Spring-Boot-中自定义-SpringMVC" class="headerlink" title="3.Spring Boot 中自定义 SpringMVC"></a>3.Spring Boot 中自定义 SpringMVC</h2><p>用过 Spring Boot 的小伙伴都知道，我们只需要在项目中引入 <code>spring-boot-starter-web</code> 依赖，SpringMVC 的一整套东西就会自动给我们配置好，但是，真实的项目环境比较复杂，系统自带的配置不一定满足我们的需求，往往我们还需要结合实际情况自定义配置。</p><h3 id="3-1-概览"><a href="#3-1-概览" class="headerlink" title="3.1 概览"></a>3.1 概览</h3><p>首先我们需要明确，跟自定义 SpringMVC 相关的类和注解主要有如下四个：</p><ul><li>WebMvcConfigurerAdapter</li><li>WebMvcConfigurer</li><li>WebMvcConfigurationSupport</li><li>@EnableWebMvc</li></ul><p>这四个中，除了第四个是注解，另外三个两个类一个接口，里边的方法看起来好像都类似，但是实际使用效果却大不相同，因此很多小伙伴容易搞混。</p><h3 id="3-2-WebMvcConfigurerAdapter"><a href="#3-2-WebMvcConfigurerAdapter" class="headerlink" title="3.2 WebMvcConfigurerAdapter"></a>3.2 WebMvcConfigurerAdapter</h3><p>我们先来看 WebMvcConfigurerAdapter，这个是在 Spring Boot 1.x 中我们自定义 SpringMVC 时继承的一个抽象类，这个抽象类本身是实现了 WebMvcConfigurer 接口，然后抽象类里边都是空方法，我们来看一下这个类的声明：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-comment">//各种 SpringMVC 配置的方法</span>&#125;</code></pre></div><p>再来看看这个类的注释：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * An implementation of &#123;<span class="hljs-doctag">@link</span> WebMvcConfigurer&#125; with empty methods allowing</span><span class="hljs-comment"> * subclasses to override only the methods they&#x27;re interested in.</span><span class="hljs-comment"> * <span class="hljs-doctag">@deprecated</span> as of 5.0 &#123;<span class="hljs-doctag">@link</span> WebMvcConfigurer&#125; has default methods (made</span><span class="hljs-comment"> * possible by a Java 8 baseline) and can be implemented directly without the</span><span class="hljs-comment"> * need for this adapter</span><span class="hljs-comment"> */</span></code></pre></div><p>这段注释关于这个类说的很明白了。同时我们也看到，从 Spring5 开始，由于我们要使用 Java8，而 Java8 中的接口允许存在 default 方法，因此官方建议我们直接实现 WebMvcConfigurer 接口，而不是继承 WebMvcConfigurerAdapter 。</p><p><strong>也就是说，在 Spring Boot 1.x 的时代，如果我们需要自定义 SpringMVC 配置，直接继承 WebMvcConfigurerAdapter 类即可。</strong></p><h3 id="3-3-WebMvcConfigurer"><a href="#3-3-WebMvcConfigurer" class="headerlink" title="3.3 WebMvcConfigurer"></a>3.3 WebMvcConfigurer</h3><p>根据上一小节的解释，小伙伴们已经明白了，WebMvcConfigurer 是我们在 Spring Boot 2.x 中实现自定义配置的方案。</p><p>WebMvcConfigurer 是一个接口，接口中的方法和 WebMvcConfigurerAdapter 中定义的空方法其实一样，所以用法上来说，基本上没有差别，从 Spring Boot 1.x 切换到 Spring Boot 2.x ，只需要把继承类改成实现接口即可。</p><p>松哥在之前的案例中(<a href="https://mp.weixin.qq.com/s/tm1IqiEvRZwDAb-F5yJ5Aw">40 篇原创干货，带你进入 Spring Boot 殿堂！</a>)，凡是涉及到自定义 SpringMVC 配置的地方，也都是通过实现 WebMvcConfigurer 接口来完成的。</p><h3 id="3-4-WebMvcConfigurationSupport"><a href="#3-4-WebMvcConfigurationSupport" class="headerlink" title="3.4 WebMvcConfigurationSupport"></a>3.4 WebMvcConfigurationSupport</h3><p>前面两个都好理解，还有一个 WebMvcConfigurationSupport ，这个又是干什么用的呢？</p><p>松哥之前有一篇文章中用过这个类，不知道小伙伴们有没有留意，就是下面这篇：</p><ul><li><a href="https://mp.weixin.qq.com/s/NC_0oaeBzRjCB34U_ZWxIQ">纯 Java 代码搭建 SSM 环境</a></li></ul><p>这篇文章我放弃了 Spring 和 SpringMVC 的 xml 配置文件，转而用 Java 代替这两个 xml 配置。那么在这里我自定义 SpringMVC 配置的时候，就是通过继承 WebMvcConfigurationSupport 类来实现的。在 WebMvcConfigurationSupport 类中，提供了用 Java 配置 SpringMVC 所需要的所有方法。我们来看一下这个方法的摘要：</p><p><a href="http://www.javaboy.org/images/boot/37-1.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/37-1.png" alt="img"></a></p><p>有一点眼熟，可能有小伙伴发现了，这里的方法其实和前面两个类中的方法基本是一样的。</p><p>在这里首先大家需要明确的是，WebMvcConfigurationSupport 类本身是没有问题的，我们自定义 SpringMVC 的配置是可以通过继承 WebMvcConfigurationSupport 来实现的。但是继承 WebMvcConfigurationSupport 这种操作我们一般只在 Java 配置的 SSM 项目中使用，Spring Boot 中基本上不会这么写，为什么呢？</p><p>小伙伴们知道，Spring Boot 中，SpringMVC 相关的自动化配置是在 WebMvcAutoConfiguration 配置类中实现的，那么我们来看看这个配置类的生效条件：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><span class="hljs-meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><span class="hljs-meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><span class="hljs-meta">ValidationAutoConfiguration.class &#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;&#125;</code></pre></div><p>我们从这个类的注解中可以看到，它的生效条件有一条，就是当不存在 WebMvcConfigurationSupport 的实例时，这个自动化配置才会生生效。因此，如果我们在 Spring Boot 中自定义 SpringMVC 配置时选择了继承 WebMvcConfigurationSupport，就会导致 Spring Boot 中 SpringMVC 的自动化配置失效。</p><blockquote><p>Spring Boot 给我们提供了很多自动化配置，很多时候当我们修改这些配置的时候，并不是要全盘否定 Spring Boot 提供的自动化配置，我们可能只是针对某一个配置做出修改，其他的配置还是按照 Spring Boot 默认的自动化配置来，而继承 WebMvcConfigurationSupport 来实现对 SpringMVC 的配置会导致所有的 SpringMVC 自动化配置失效，因此，一般情况下我们不选择这种方案。</p></blockquote><p>在 Java 搭建的 SSM 项目中(<a href="https://mp.weixin.qq.com/s/NC_0oaeBzRjCB34U_ZWxIQ">纯 Java 代码搭建 SSM 环境</a>)，因为本身就没什么自动化配置，所以我们使用了继承 WebMvcConfigurationSupport。</p><h3 id="3-5-EnableWebMvc"><a href="#3-5-EnableWebMvc" class="headerlink" title="3.5 @EnableWebMvc"></a>3.5 @EnableWebMvc</h3><p>最后还有一个 @EnableWebMvc 注解，这个注解很好理解，它的作用就是启用 WebMvcConfigurationSupport。我们来看看这个注解的定义：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Adding this annotation to an &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class imports the Spring MVC</span><span class="hljs-comment"> * configuration from &#123;<span class="hljs-doctag">@link</span> WebMvcConfigurationSupport&#125;, e.g.:</span></code></pre></div><p>可以看到，加了这个注解，就会自动导入 WebMvcConfigurationSupport，所以在 Spring Boot 中，我们也不建议使用 @EnableWebMvc 注解，因为它一样会导致 Spring Boot 中的 SpringMVC 自动化配置失效。</p><h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><ul><li>Spring Boot 1.x 中，自定义 SpringMVC 配置可以通过继承 WebMvcConfigurerAdapter 来实现。</li><li>Spring Boot 2.x 中，自定义 SpringMVC 配置可以通过实现 WebMvcConfigurer 接口来完成。</li><li>如果在 Spring Boot 中使用继承 WebMvcConfigurationSupport 来实现自定义 SpringMVC 配置，或者在 Spring Boot 中使用了 @EnableWebMvc 注解，都会导致 Spring Boot 中默认的 SpringMVC 自动化配置失效。</li><li>在纯 Java 配置的 SSM 环境中，如果我们要自定义 SpringMVC 配置，有两种办法，第一种就是直接继承自 WebMvcConfigurationSupport 来完成 SpringMVC 配置，还有一种方案就是实现 WebMvcConfigurer 接口来完成自定义 SpringMVC 配置，如果使用第二种方式，则需要给 SpringMVC 的配置类上额外添加 @EnableWebMvc 注解，表示启用 WebMvcConfigurationSupport，这样配置才会生效。换句话说，在纯 Java 配置的 SSM 中，如果你需要自定义 SpringMVC 配置，你离不开 WebMvcConfigurationSupport ，所以在这种情况下建议通过继承 WebMvcConfigurationSupport 来实现自动化配置。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2021/08/01/Redis/"/>
    <url>/2021/08/01/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote><p>本文整理Redis相关基础以及应用的知识，供参考</p></blockquote><h1 id="1-NoSQL的引言"><a href="#1-NoSQL的引言" class="headerlink" title="1.  NoSQL的引言"></a>1.  NoSQL的引言</h1><p><strong>NoSQL</strong>(<code> Not Only SQL</code> )，意即<strong>不仅仅是SQL</strong>, 泛指非关系型的数据库。Nosql这个技术门类,早期就有人提出,发展至2009年趋势越发高涨。</p><h1 id="2-为什么是NoSQL"><a href="#2-为什么是NoSQL" class="headerlink" title="2. 为什么是NoSQL"></a>2. 为什么是NoSQL</h1><p>随着互联网网站的兴起，传统的关系数据库在应付动态网站，特别是超大规模和高并发的纯动态网站已经显得力不从心，暴露了很多难以克服的问题。如<code>商城网站中对商品数据频繁查询</code>、<code>对热搜商品的排行统计</code>、<code>订单超时问题</code>、以及微信朋友圈（音频，视频）存储等相关使用传统的关系型数据库实现就显得非常复杂，虽然能实现相应功能但是在性能上却不是那么乐观。nosql这个技术门类的出现，更好的解决了这些问题，它告诉了世界不仅仅是sql。</p><h1 id="3-NoSQL的四大分类"><a href="#3-NoSQL的四大分类" class="headerlink" title="3. NoSQL的四大分类"></a>3. NoSQL的四大分类</h1><h2 id="3-1-键值-Key-Value-存储数据库"><a href="#3-1-键值-Key-Value-存储数据库" class="headerlink" title="3.1 键值(Key-Value)存储数据库"></a>3.1 键值(Key-Value)存储数据库</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明: </span><span class="hljs-bullet">-</span> 这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。<span class="hljs-section"># 2.特点</span><span class="hljs-bullet">-</span> Key/value模型对于IT系统来说的优势在于简单、易部署。  <span class="hljs-bullet">-</span> 但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。<span class="hljs-section"># 3.相关产品</span><span class="hljs-bullet">-</span> Tokyo Cabinet/Tyrant,<span class="hljs-bullet">-</span> <span class="hljs-code">`Redis`</span>内存<span class="hljs-bullet">-</span> <span class="hljs-code">`SSDB`</span>硬盘<span class="hljs-bullet">-</span> Voldemort <span class="hljs-bullet">-</span> Oracle BDB</code></pre></div><h2 id="3-2-列存储数据库"><a href="#3-2-列存储数据库" class="headerlink" title="3.2 列存储数据库"></a>3.2 列存储数据库</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明</span><span class="hljs-bullet">-</span> 这部分数据库通常是用来应对分布式存储的海量数据。<span class="hljs-section"># 2.特点</span><span class="hljs-bullet">-</span> 键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。<span class="hljs-section"># 3.相关产品</span><span class="hljs-bullet">-</span> Cassandra、<span class="hljs-code">`HBase`</span>、Riak.</code></pre></div><h2 id="3-3-文档型数据库"><a href="#3-3-文档型数据库" class="headerlink" title="3.3 文档型数据库"></a>3.3 文档型数据库</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明</span><span class="hljs-bullet">-</span> 文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高<span class="hljs-section"># 2.特点</span><span class="hljs-bullet">-</span> 以文档形式存储<span class="hljs-section"># 3.相关产品</span><span class="hljs-bullet">-</span> <span class="hljs-code">`MongoDB`</span>、CouchDB、 MongoDb(4.x). 国内也有文档型数据库SequoiaDB，已经开源。</code></pre></div><h2 id="3-4-图形-Graph-数据库"><a href="#3-4-图形-Graph-数据库" class="headerlink" title="3.4 图形(Graph)数据库"></a>3.4 图形(Graph)数据库</h2> <div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明</span><span class="hljs-bullet">-</span> 图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。<span class="hljs-section"># 2.特点</span><span class="hljs-bullet">-</span> NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。<span class="hljs-section"># 3.相关产品</span><span class="hljs-bullet">-</span> Neo4J、<span class="hljs-code">`InfoGrid`</span>、 Infinite Graph、</code></pre></div><hr><h1 id="4-NoSQL应用场景"><a href="#4-NoSQL应用场景" class="headerlink" title="4. NoSQL应用场景"></a>4. NoSQL应用场景</h1><ul><li><p>数据模型比较简单</p></li><li><p>需要灵活性更强的IT系统</p></li><li><p>对数据库性能要求较高</p></li><li><p>不需要高度的数据一致性（Nosql对事务的支持不太好）</p></li></ul><h1 id="5-什么是Redis"><a href="#5-什么是Redis" class="headerlink" title="5. 什么是Redis"></a>5. 什么是Redis</h1><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623121234046.png" alt="image-20200623121234046"></p><blockquote><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p></blockquote><p>Redis 开源  遵循 BSD  基于内存数据存储被用于作为<strong>数据库缓存消息中间件</strong></p><p>Redis 在数据内存中，持久化机制，定期写入磁盘中</p><ul><li>总结: Redis是一个内存型的数据库</li></ul><h1 id="6-Redis特点"><a href="#6-Redis特点" class="headerlink" title="6. Redis特点"></a>6. Redis特点</h1><ul><li><p> Redis是一个高性能key/value内存型数据库</p></li><li><p>Redis支持丰富的数据类型 </p></li><li><p>Redis支持持久化 </p></li><li><p>Redis单线程，单进程，线性安全，Redis实现分布式锁</p></li></ul><hr><h1 id="7-Redis安装"><a href="#7-Redis安装" class="headerlink" title="7. Redis安装"></a>7. Redis安装</h1><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 0.准备环境</span><span class="hljs-bullet">-</span> vmware15.x+<span class="hljs-bullet">-</span> centos7.x+<span class="hljs-section"># 1.下载redis源码包</span><span class="hljs-bullet">-</span> https://redis.io/</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623121621195.png" alt="image-20200623121621195"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 2.下载完整源码包</span><span class="hljs-bullet">-</span> redis-4.0.10.tar.gz</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623123918876.png" alt="image-20200623123918876"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 3.将下载redis资料包上传到Linux中</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623124327319.png" alt="image-20200623124327319"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 4.解压缩文件</span>[root@localhost ~]# tar -zxvf redis-4.0.10.tar.gz[root@localhost ~]# ll</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623124522026.png" alt="image-20200623124522026"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 5.安装gcc  </span><span class="hljs-bullet">-</span> yum install -y gcc<span class="hljs-section"># 6.进入解压缩目录执行如下命令</span><span class="hljs-bullet">-</span> make MALLOC=libc<span class="hljs-section"># 7.编译完成后执行如下命令</span><span class="hljs-bullet">-</span> make install PREFIX=/usr/redis<span class="hljs-section"># 8.进入/usr/redis目录启动redis服务 </span><span class="hljs-bullet">-</span> ./redis-server</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623125420505.png" alt="image-20200623125420505"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 9.Redis服务端口默认是 6379</span><span class="hljs-section"># 10.进入bin目录执行客户端连接操作</span><span class="hljs-bullet">-</span> ./redis-cli –p 6379</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623125716013.png" alt="image-20200623125716013"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 11.连接成功出现上面界面连接成功</span><span class="hljs-bullet">-</span> 默认在安装redis后，安装目录没有任何配置文件，需要拷贝原码目录中的配置文件redis.conf到usr下的redis目录下<span class="hljs-section"># 12.加载配置文件的启动</span><span class="hljs-bullet">-</span> ./redis-server ../redis.conf</code></pre></div><h1 id="8-Redis数据库相关指令"><a href="#8-Redis数据库相关指令" class="headerlink" title="8. Redis数据库相关指令"></a>8. Redis数据库相关指令</h1><h2 id="8-1-数据库操作指令"><a href="#8-1-数据库操作指令" class="headerlink" title="8.1 数据库操作指令"></a>8.1 数据库操作指令</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.Redis中库说明</span><span class="hljs-bullet">-</span> 使用redis的默认配置器动redis服务后,默认会存在16个库,编号从0-15，默认0号库<span class="hljs-bullet">-</span> 可以使用select 库的编号 来选择一个redis的库<span class="hljs-section"># 2.Redis中操作库的指令</span><span class="hljs-bullet">-</span> 清空当前的库  FLUSHDB<span class="hljs-bullet">-</span> 清空全部的库  FLUSHALL<span class="hljs-section"># 3.redis客户端显示中文</span><span class="hljs-bullet">-</span>./redis-cli  -p 7000 --raw</code></pre></div><h2 id="8-2-操作key相关指令"><a href="#8-2-操作key相关指令" class="headerlink" title="8.2 操作key相关指令"></a>8.2 操作key相关指令</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.DEL指令</span><span class="hljs-bullet">-</span> 语法 :  DEL key [key ...] <span class="hljs-bullet">-</span> 作用 :  删除给定的一个或多个key 。不存在的key 会被忽略。<span class="hljs-bullet">-</span> 可用版本： &gt;= 1.0.0<span class="hljs-bullet">-</span> 返回值： 被删除key 的数量。 <span class="hljs-section"># 2.EXISTS指令</span><span class="hljs-bullet">-</span> 语法:  EXISTS key<span class="hljs-bullet">-</span> 作用:  检查给定key 是否存在。<span class="hljs-bullet">-</span> 可用版本： &gt;= 1.0.0<span class="hljs-bullet">-</span> 返回值： 若key 存在，返回1 ，否则返回0。<span class="hljs-section"># 3.EXPIRE</span><span class="hljs-bullet">-</span> 语法:  EXPIRE key seconds<span class="hljs-bullet">-</span> 作用:  为给定key 设置生存时间，当key 过期时(生存时间为0 )，它会被自动删除。<span class="hljs-bullet">-</span> 可用版本： &gt;= 1.0.0<span class="hljs-bullet">-</span> 时间复杂度： O(1)<span class="hljs-bullet">-</span> 返回值：设置成功返回1 。<span class="hljs-section"># 4.KEYS</span><span class="hljs-bullet">-</span> 语法 :  KEYS pattern<span class="hljs-bullet">-</span> 作用 :  查找所有符合给定模式pattern 的key 。<span class="hljs-bullet">-</span> 语法:<span class="hljs-code">KEYS * 匹配数据库中所有key 。</span><span class="hljs-code">KEYS h?llo 匹配hello ，hallo 和hxllo 等。</span><span class="hljs-code">KEYS h*llo 匹配hllo 和heeeeello 等。</span><span class="hljs-code">KEYS h[ae]llo 匹配hello 和hallo ，但不匹配hillo 。特殊符号用 &quot;\&quot; 隔开</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值： 符合给定模式的key 列表。</span><span class="hljs-code"></span><span class="hljs-code"># 5.MOVE</span><span class="hljs-code">- 语法 :  MOVE key db</span><span class="hljs-code">- 作用 :  将当前数据库的key 移动到给定的数据库db 当中。</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值： 移动成功返回1 ，失败则返回0 。</span><span class="hljs-code"></span><span class="hljs-code"># 6.PEXPIRE</span><span class="hljs-code">- 语法 :  PEXPIRE key milliseconds</span><span class="hljs-code">- 作用 :  这个命令和EXPIRE 命令的作用类似，但是它以毫秒为单位设置key 的生存时间，而不像EXPIRE 命令那样，以秒为单位。</span><span class="hljs-code">- 可用版本： &gt;= 2.6.0</span><span class="hljs-code">- 时间复杂度： O(1)</span><span class="hljs-code">- 返回值：设置成功，返回1  key 不存在或设置失败，返回0</span><span class="hljs-code"></span><span class="hljs-code"># 7.PEXPIREAT</span><span class="hljs-code">- 语法 :  PEXPIREAT key milliseconds-timestamp</span><span class="hljs-code">- 作用 :  这个命令和EXPIREAT 命令类似，但它以毫秒为单位设置key 的过期unix 时间戳，而不是像EXPIREAT那样，以秒为单位。</span><span class="hljs-code">- 可用版本： &gt;= 2.6.0</span><span class="hljs-code">- 返回值：如果生存时间设置成功，返回1 。当key 不存在或没办法设置生存时间时，返回0 。(查看EXPIRE 命令获取更多信息)</span><span class="hljs-code"></span><span class="hljs-code"># 8.TTL</span><span class="hljs-code">- 语法 :   TTL key</span><span class="hljs-code">- 作用 :   以秒为单位，返回给定key 的剩余生存时间(TTL, time to live)。</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值：</span><span class="hljs-code">当key 不存在时，返回-2 。</span><span class="hljs-code">当key 存在但没有设置剩余生存时间时，返回-1 。</span><span class="hljs-code">否则，以秒为单位，返回key 的剩余生存时间。</span><span class="hljs-code">- Note : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span><span class="hljs-code"></span><span class="hljs-code"># 9.PTTL</span><span class="hljs-code">- 语法 :  PTTL key</span><span class="hljs-code">- 作用 :  这个命令类似于TTL 命令，但它以毫秒为单位返回key 的剩余生存时间，而不是像TTL 命令那样，以秒为单位。</span><span class="hljs-code">- 可用版本： &gt;= 2.6.0</span><span class="hljs-code">- 返回值： 当key 不存在时，返回-2 。当key 存在但没有设置剩余生存时间时，返回-1 。</span><span class="hljs-code">- 否则，以毫秒为单位，返回key 的剩余生存时间。</span><span class="hljs-code">- 注意 : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span><span class="hljs-code"></span><span class="hljs-code"># 10.RANDOMKEY</span><span class="hljs-code">- 语法 :  RANDOMKEY</span><span class="hljs-code">- 作用 :  从当前数据库中随机返回(不删除) 一个key 。</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值：当数据库不为空时，返回一个key 。当数据库为空时，返回nil 。</span><span class="hljs-code"></span><span class="hljs-code"># 11.RENAME</span><span class="hljs-code">- 语法 :  RENAME key newkey</span><span class="hljs-code">- 作用 :  将key 改名为newkey 。当key 和newkey 相同，或者key 不存在时，返回一个错误。当newkey 已经存在时，RENAME 命令将覆盖旧值。</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值： 改名成功时提示OK ，失败时候返回一个错误。</span><span class="hljs-code"></span><span class="hljs-code"># 12.TYPE</span><span class="hljs-code">- 语法 :  TYPE key</span><span class="hljs-code">- 作用 :  返回key 所储存的值的类型。</span><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><span class="hljs-code">- 返回值：</span><span class="hljs-code">none (key 不存在)</span><span class="hljs-code">string (字符串)</span><span class="hljs-code">list (列表)</span><span class="hljs-code">set (集合)</span><span class="hljs-code">zset (有序集)</span><span class="hljs-code">hash (哈希表)</span></code></pre></div><h2 id="8-3-String类型"><a href="#8-3-String类型" class="headerlink" title="8.3 String类型"></a>8.3 String类型</h2><h4 id="1-内存存储模型"><a href="#1-内存存储模型" class="headerlink" title="1. 内存存储模型"></a>1. 内存存储模型</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623132104399.png" alt="image-20200623132104399"></p><h4 id="2-常用操作命令"><a href="#2-常用操作命令" class="headerlink" title="2. 常用操作命令"></a>2. 常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>set</td><td>设置一个key/value</td></tr><tr><td>get</td><td>根据key获得对应的value</td></tr><tr><td>mset</td><td>一次设置多个key value</td></tr><tr><td>mget</td><td>一次获得多个key的value</td></tr><tr><td>getset</td><td>获得原始key的值，同时设置新值</td></tr><tr><td>strlen</td><td>获得对应key存储value的长度</td></tr><tr><td>append</td><td>为对应key的value追加内容</td></tr><tr><td>getrange 索引0开始</td><td>截取value的内容</td></tr><tr><td>setex</td><td>设置一个key存活的有效期（秒）</td></tr><tr><td>psetex</td><td>设置一个key存活的有效期（毫秒）</td></tr><tr><td>setnx</td><td>存在不做任何操作,不存在添加</td></tr><tr><td>msetnx原子操作(只要有一个存在不做任何操作)</td><td>可以同时设置多个key,只有有一个存在都不保存</td></tr><tr><td>decr</td><td>进行数值类型的-1操作</td></tr><tr><td>decrby</td><td>根据提供的数据进行减法操作</td></tr><tr><td>Incr</td><td>进行数值类型的+1操作</td></tr><tr><td>incrby</td><td>根据提供的数据进行加法操作</td></tr><tr><td>Incrbyfloat</td><td>根据提供的数据加入浮点数</td></tr></tbody></table><h2 id="8-4-List类型"><a href="#8-4-List类型" class="headerlink" title="8.4 List类型"></a>8.4 List类型</h2><p>list 列表 相当于java中list 集合  特点  元素有序  且 可以重复</p><h4 id="1-内存存储模型-1"><a href="#1-内存存储模型-1" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623161114380.png" alt="image-20200623161114380"></p><h4 id="2-常用操作指令"><a href="#2-常用操作指令" class="headerlink" title="2.常用操作指令"></a>2.常用操作指令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>lpush</td><td>将某个值加入到一个key列表头部</td></tr><tr><td>lpushx</td><td>同lpush,但是必须要保证这个key存在</td></tr><tr><td>rpush</td><td>将某个值加入到一个key列表末尾</td></tr><tr><td>rpushx</td><td>同rpush,但是必须要保证这个key存在</td></tr><tr><td>lpop</td><td>返回和移除列表左边的第一个元素</td></tr><tr><td>rpop</td><td>返回和移除列表右边的第一个元素</td></tr><tr><td>lrange</td><td>获取某一个下标区间内的元素</td></tr><tr><td>llen</td><td>获取列表元素个数</td></tr><tr><td>lset</td><td>设置某一个指定索引的值(索引必须存在)</td></tr><tr><td>lindex</td><td>获取某一个指定索引位置的元素</td></tr><tr><td>lrem</td><td>删除重复元素</td></tr><tr><td>ltrim</td><td>保留列表中特定区间内的元素</td></tr><tr><td>linsert</td><td>在某一个元素之前，之后插入新元素</td></tr></tbody></table><h2 id="8-5-Set类型"><a href="#8-5-Set类型" class="headerlink" title="8.5 Set类型"></a>8.5 Set类型</h2><p>特点: Set类型 Set集合 元素无序  不可以重复</p><h4 id="1-内存存储模型-2"><a href="#1-内存存储模型-2" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623193634316.png" alt="image-20200623193634316"></p><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>sadd</td><td>为集合添加元素</td></tr><tr><td>smembers</td><td>显示集合中所有元素 无序</td></tr><tr><td>scard</td><td>返回集合中元素的个数</td></tr><tr><td>spop</td><td>随机返回一个元素 并将元素在集合中删除</td></tr><tr><td>smove</td><td>从一个集合中向另一个集合移动元素  必须是同一种类型</td></tr><tr><td>srem</td><td>从集合中删除一个元素</td></tr><tr><td>sismember</td><td>判断一个集合中是否含有这个元素</td></tr><tr><td>srandmember</td><td>随机返回元素</td></tr><tr><td>sdiff</td><td>去掉第一个集合中其它集合含有的相同元素</td></tr><tr><td>sinter</td><td>求交集</td></tr><tr><td>sunion</td><td>求和集</td></tr></tbody></table><h2 id="8-6-ZSet类型"><a href="#8-6-ZSet类型" class="headerlink" title="8.6 ZSet类型"></a>8.6 ZSet类型</h2><p>特点: 可排序的set集合  排序  不可重复 </p><p>ZSET 官方  可排序SET  sortSet   利用带的分数</p><h4 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623194903967.png" alt="image-20200623194903967"></p><h4 id="2-常用命令-1"><a href="#2-常用命令-1" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>zadd</td><td>添加一个有序集合元素</td></tr><tr><td>zcard</td><td>返回集合的元素个数</td></tr><tr><td>zrange 升序 zrevrange 降序</td><td>返回一个范围内的元素</td></tr><tr><td>zrangebyscore</td><td>按照分数查找一个范围内的元素</td></tr><tr><td>zrank</td><td>返回排名</td></tr><tr><td>zrevrank</td><td>倒序排名</td></tr><tr><td>zscore</td><td>显示某一个元素的分数</td></tr><tr><td>zrem</td><td>移除某一个元素</td></tr><tr><td>zincrby</td><td>给某个特定元素加分</td></tr></tbody></table><h2 id="8-7-hash类型"><a href="#8-7-hash类型" class="headerlink" title="8.7 hash类型"></a>8.7 hash类型</h2><p>特点: value 是一个map结构 存在key value  key 无序的  </p><h4 id="1-内存模型-1"><a href="#1-内存模型-1" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623200348408.png" alt="image-20200623200348408"></p><h4 id="2-常用命令-2"><a href="#2-常用命令-2" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>hset</td><td>设置一个key/value对</td></tr><tr><td>hget</td><td>获得一个key对应的value</td></tr><tr><td>hgetall</td><td>获得所有的key/value对</td></tr><tr><td>hdel</td><td>删除某一个key/value对</td></tr><tr><td>hexists</td><td>判断一个key是否存在</td></tr><tr><td>hkeys</td><td>获得所有的key</td></tr><tr><td>hvals</td><td>获得所有的value</td></tr><tr><td>hmset</td><td>设置多个key/value</td></tr><tr><td>hmget</td><td>获得多个key的value</td></tr><tr><td>hsetnx</td><td>设置一个不存在的key的值</td></tr><tr><td>hincrby</td><td>为value进行加法运算</td></tr><tr><td>hincrbyfloat</td><td>为value加入浮点值</td></tr></tbody></table><hr><h1 id="9-持久化机制"><a href="#9-持久化机制" class="headerlink" title="9. 持久化机制"></a>9. 持久化机制</h1><p>client  redis[内存] —–&gt;  内存数据- 数据持久化–&gt;磁盘</p><p>Redis官方提供了两种不同的持久化方法来将数据存储到硬盘里面分别是:</p><ul><li>快照(Snapshot)</li><li>AOF (Append Only File) 只追加日志文件</li></ul><h2 id="9-1-快照-Snapshot"><a href="#9-1-快照-Snapshot" class="headerlink" title="9.1 快照(Snapshot)"></a>9.1 快照(Snapshot)</h2><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><p>这种方式可以将某一时刻的所有数据都写入硬盘中,当然这也是<strong>redis的默认开启持久化方式</strong>,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623204303074.png" alt="image-20200623204303074"></p><h4 id="2-快照生成方式"><a href="#2-快照生成方式" class="headerlink" title="2.快照生成方式"></a>2.快照生成方式</h4><ul><li>客户端方式: BGSAVE 和 SAVE指令</li><li>服务器配置自动触发</li></ul><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.客户端方式之BGSAVE</span><span class="hljs-bullet">-</span> a.客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork¹来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。<span class="hljs-code"></span><span class="hljs-code">`名词解释: fork当一个进程创建子进程的时候,底层的操作系统会创建该进程的一个副本,在类unix系统中创建子进程的操作会进行优化:在刚开始的时候,父子进程共享相同内存,直到父进程或子进程对内存进行了写之后,两者分开，对被写入的内存的共享才会结束服务`</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623205132460.png" alt="image-20200623205132460"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 2.客户端方式之SAVE</span><span class="hljs-bullet">-</span> b.客户端还可以使用SAVE命令来创建一个快照,接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623205444101.png" alt="image-20200623205444101"></p><ul><li><strong>注意: SAVE命令并不常用,使用SAVE命令在快照创建完毕之前,redis处于阻塞状态,无法对外服务</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 3.服务器配置方式之满足配置自动触发</span><span class="hljs-bullet">-</span> 如果用户在redis.conf中设置了save配置选项,redis会在save选项条件满足之后自动触发一次BGSAVE命令,如果设置多个save配置选项,当任意一个save配置选项条件满足,redis也会触发一次BGSAVE命令</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623210021012.png" alt="image-20200623210021012"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 4.服务器接收客户端shutdown指令</span><span class="hljs-bullet">-</span> 当redis通过shutdown指令接收到关闭服务器的请求时,会执行一个save命令,阻塞所有的客户端,不再执行客户端执行发送的任何命令,并且在save命令执行完毕之后关闭服务器</code></pre></div><h4 id="3-配置生成快照名称和位置"><a href="#3-配置生成快照名称和位置" class="headerlink" title="3.配置生成快照名称和位置"></a>3.配置生成快照名称和位置</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.修改生成快照名称</span><span class="hljs-bullet">-</span> dbfilename dump.rdb<span class="hljs-section"># 2.修改生成位置</span><span class="hljs-bullet">-</span> dir ./</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623210352448.png" alt="image-20200623210352448"></p><hr><h2 id="9-2-AOF-只追加日志文件"><a href="#9-2-AOF-只追加日志文件" class="headerlink" title="9.2 AOF 只追加日志文件"></a>9.2 AOF 只追加日志文件</h2><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><p>这种方式可以将所有客户端执行的写命令记录到日志文件中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis**从头到尾执行一次AOF文件所包含的所有写命令,**就可以恢复AOF文件的记录的数据集.</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623211330798.png" alt="image-20200623211330798"></p><h4 id="2-开启AOF持久化"><a href="#2-开启AOF持久化" class="headerlink" title="2.开启AOF持久化"></a>2.开启AOF持久化</h4><p>在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启</p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.开启AOF持久化</span><span class="hljs-bullet">-</span> a.修改 appendonly yes 开启持久化<span class="hljs-bullet">-</span> b.修改 appendfilename &quot;appendonly.aof&quot; 指定生成文件名称</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623211508987.png" alt="image-20200623211508987"></p><h4 id="3-日志追加频率"><a href="#3-日志追加频率" class="headerlink" title="3.日志追加频率"></a>3.日志追加频率</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.always 【谨慎使用】</span><span class="hljs-bullet">-</span> 说明: 每个redis写命令都要同步写入硬盘,严重降低redis速度<span class="hljs-bullet">-</span> 解释: 如果用户使用了always选项,那么每个redis写命令都会被写入硬盘,从而将发生系统崩溃时出现的数据丢失减到最少;遗憾的是,因为这种同步策略需要对硬盘进行大量的写入操作,所以redis处理命令的速度会受到硬盘性能的限制;<span class="hljs-bullet">-</span> 注意: 转盘式硬盘在这种频率下200左右个命令/s ; 固态硬盘(SSD) 几百万个命令/s;<span class="hljs-bullet">-</span> 警告: 使用SSD用户请谨慎使用always选项,这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题,导致将固态硬盘的寿命从原来的几年降低为几个月。<span class="hljs-section"># 2.everysec 【推荐】</span><span class="hljs-bullet">-</span> 说明: 每秒执行一次同步显式的将多个写命令同步到磁盘<span class="hljs-bullet">-</span> 解释： 为了兼顾数据安全和写入性能,用户可以考虑使用everysec选项,让redis每秒一次的频率对AOF文件进行同步;redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几,而通过每秒同步一次AOF文件,redis可以保证,即使系统崩溃,用户最多丢失一秒之内产生的数据。<span class="hljs-section"># 3.no【不推荐】</span><span class="hljs-bullet">-</span> 说明: 由操作系统决定何时同步 <span class="hljs-bullet">-</span> 解释：最后使用no选项,将完全有操作系统决定什么时候同步AOF日志文件,这个选项不会对redis性能带来影响但是系统崩溃时,会丢失不定数量的数据,另外如果用户硬盘处理写入操作不够快的话,当缓冲区被等待写入硬盘数据填满时,redis会处于阻塞状态,并导致redis的处理命令请求的速度变慢。</code></pre></div><h4 id="4-修改同步频率"><a href="#4-修改同步频率" class="headerlink" title="4.修改同步频率"></a>4.修改同步频率</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.修改日志同步频率</span><span class="hljs-bullet">-</span> 修改appendfsync everysec|always|no 指定</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623211658910.png" alt="image-20200623211658910"></p><hr><h2 id="9-3-AOF文件的重写"><a href="#9-3-AOF文件的重写" class="headerlink" title="9.3 AOF文件的重写"></a>9.3 AOF文件的重写</h2><h4 id="1-AOF带来的问题"><a href="#1-AOF带来的问题" class="headerlink" title="1. AOF带来的问题"></a>1. AOF带来的问题</h4><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写(ReWriter)机制。</p><h4 id="2-AOF重写"><a href="#2-AOF重写" class="headerlink" title="2. AOF重写"></a>2. AOF重写</h4><p>用来在一定程度上减小AOF文件的体积</p><h4 id="3-触发重写方式"><a href="#3-触发重写方式" class="headerlink" title="3. 触发重写方式"></a>3. 触发重写方式</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.客户端方式触发重写</span><span class="hljs-bullet">-</span> 执行BGREWRITEAOF命令  不会阻塞redis的服务<span class="hljs-section"># 2.服务器配置方式自动触发</span><span class="hljs-bullet">-</span> 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓<span class="hljs-bullet">-</span> 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623212547775.png" alt="image-20200623212547775"></p><h4 id="4-重写原理"><a href="#4-重写原理" class="headerlink" title="4. 重写原理"></a>4. 重写原理</h4><p> <strong>注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 重写流程</span><span class="hljs-bullet">-</span> 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令<span class="hljs-bullet">-</span> 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。<span class="hljs-bullet">-</span> 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。<span class="hljs-bullet">-</span> 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623214843123.png" alt="image-20200623214843123"></p><hr><h2 id="9-4-持久化总结"><a href="#9-4-持久化总结" class="headerlink" title="9.4 持久化总结"></a>9.4 持久化总结</h2><p>两种持久化方案既可以同时使用(aof),又可以单独使用,在某种情况下也可以都不使用,具体使用那种持久化方案取决于用户的数据和应用决定。</p><p>无论使用AOF还是快照机制持久化,将数据持久化到硬盘都是有必要的,除了持久化外,用户还应该对持久化的文件进行备份(最好备份在多个不同地方)。</p><hr><h1 id="10-java操作Redis"><a href="#10-java操作Redis" class="headerlink" title="10. java操作Redis"></a>10. java操作Redis</h1><h2 id="10-1-环境准备"><a href="#10-1-环境准备" class="headerlink" title="10.1 环境准备"></a>10.1 环境准备</h2><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入jedis连接依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="2-创建jedis对象"><a href="#2-创建jedis对象" class="headerlink" title="2.创建jedis对象"></a>2.创建jedis对象</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">//1.创建jedis对象</span>    <span class="hljs-comment">//1.redis服务必须关闭防火墙  2.redis服务必须开启远程连接</span>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;172.16.211.4&quot;</span>, <span class="hljs-number">6379</span>);    <span class="hljs-comment">//选择操作的库默认0号库</span>    jedis.select(<span class="hljs-number">0</span>);    <span class="hljs-comment">//2.执行相关操作</span>    Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);    keys.forEach(key -&gt; System.out.println(<span class="hljs-string">&quot;key = &quot;</span> + key));    <span class="hljs-comment">//3.释放资源</span>    jedis.close();&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210512113801560.png" alt="image-20210512113801560"></p><h2 id="10-2-操作key相关API"><a href="#10-2-操作key相关API" class="headerlink" title="10.2 操作key相关API"></a>10.2 操作key相关API</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;    <span class="hljs-meta">@Before</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">this</span>.jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;172.16.211.4&quot;</span>, <span class="hljs-number">6379</span>);    &#125;    <span class="hljs-meta">@After</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;        jedis.close();    &#125;    <span class="hljs-comment">//测试key相关</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testKeys</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//删除一个key</span>        jedis.del(<span class="hljs-string">&quot;name&quot;</span>);        <span class="hljs-comment">//删除多个key</span>        jedis.del(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>);        <span class="hljs-comment">//判断一个key是否存在exits</span>        Boolean name = jedis.exists(<span class="hljs-string">&quot;name&quot;</span>);        System.out.println(name);        <span class="hljs-comment">//设置一个key超时时间 expire pexpire</span>        Long age = jedis.expire(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">100</span>);        System.out.println(age);        <span class="hljs-comment">//获取一个key超时时间 ttl</span>        Long age1 = jedis.ttl(<span class="hljs-string">&quot;newage&quot;</span>);        System.out.println(age1);        <span class="hljs-comment">//随机获取一个key</span>        String s = jedis.randomKey();        <span class="hljs-comment">//修改key名称</span>        jedis.rename(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;newage&quot;</span>);        <span class="hljs-comment">//查看可以对应值的类型</span>        String name1 = jedis.type(<span class="hljs-string">&quot;name&quot;</span>);        System.out.println(name1);        String maps = jedis.type(<span class="hljs-string">&quot;maps&quot;</span>);        System.out.println(maps);    &#125;</code></pre></div><h2 id="10-3操作String相关API"><a href="#10-3操作String相关API" class="headerlink" title="10.3操作String相关API"></a>10.3操作String相关API</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试String相关</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testString</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//set</span>        jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;小陈&quot;</span>);        <span class="hljs-comment">//get</span>        String s = jedis.get(<span class="hljs-string">&quot;name&quot;</span>);        System.out.println(s);        <span class="hljs-comment">//mset</span>        jedis.mset(<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;好人&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;海淀区&quot;</span>);        <span class="hljs-comment">//mget</span>        List&lt;String&gt; mget = jedis.mget(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;address&quot;</span>);        mget.forEach(v-&gt; System.out.println(<span class="hljs-string">&quot;v = &quot;</span> + v));        <span class="hljs-comment">//getset</span>        String set = jedis.getSet(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小明&quot;</span>);        System.out.println(set);        <span class="hljs-comment">//............</span>    &#125;</code></pre></div><h2 id="10-4操作List相关API"><a href="#10-4操作List相关API" class="headerlink" title="10.4操作List相关API"></a>10.4操作List相关API</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试List相关</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testList</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//lpush</span>        jedis.lpush(<span class="hljs-string">&quot;names1&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-string">&quot;赵柳&quot;</span>,<span class="hljs-string">&quot;win7&quot;</span>);        <span class="hljs-comment">//rpush</span>        jedis.rpush(<span class="hljs-string">&quot;names1&quot;</span>,<span class="hljs-string">&quot;xiaomingming&quot;</span>);        <span class="hljs-comment">//lrange</span>        List&lt;String&gt; names1 = jedis.lrange(<span class="hljs-string">&quot;names1&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);        names1.forEach(name-&gt; System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name));        <span class="hljs-comment">//lpop rpop</span>        String names11 = jedis.lpop(<span class="hljs-string">&quot;names1&quot;</span>);        System.out.println(names11);        <span class="hljs-comment">//llen</span>        jedis.linsert(<span class="hljs-string">&quot;lists&quot;</span>, BinaryClient.LIST_POSITION.BEFORE,<span class="hljs-string">&quot;xiaohei&quot;</span>,<span class="hljs-string">&quot;xiaobai&quot;</span>);      <span class="hljs-comment">//........</span>    &#125;</code></pre></div><h2 id="10-5操作Set的相关API"><a href="#10-5操作Set的相关API" class="headerlink" title="10.5操作Set的相关API"></a>10.5操作Set的相关API</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试SET相关</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSet</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//sadd</span>  jedis.sadd(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);  <span class="hljs-comment">//smembers</span>  jedis.smembers(<span class="hljs-string">&quot;names&quot;</span>);  <span class="hljs-comment">//sismember</span>  jedis.sismember(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-string">&quot;xiaochen&quot;</span>);  <span class="hljs-comment">//...</span>&#125;</code></pre></div><h2 id="10-6-操作ZSet相关API"><a href="#10-6-操作ZSet相关API" class="headerlink" title="10.6 操作ZSet相关API"></a>10.6 操作ZSet相关API</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试ZSET相关</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testZset</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//zadd</span>  jedis.zadd(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&quot;张三&quot;</span>);  <span class="hljs-comment">//zrange</span>  jedis.zrange(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);  <span class="hljs-comment">//zcard</span>  jedis.zcard(<span class="hljs-string">&quot;names&quot;</span>);  <span class="hljs-comment">//zrangeByScore</span>  jedis.zrangeByScore(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);  <span class="hljs-comment">//..</span>&#125;</code></pre></div><h2 id="10-7-操作Hash相关API"><a href="#10-7-操作Hash相关API" class="headerlink" title="10.7 操作Hash相关API"></a>10.7 操作Hash相关API</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试HASH相关</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHash</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//hset</span>  jedis.hset(<span class="hljs-string">&quot;maps&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);  <span class="hljs-comment">//hget</span>  jedis.hget(<span class="hljs-string">&quot;maps&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>);  <span class="hljs-comment">//hgetall</span>  jedis.hgetAll(<span class="hljs-string">&quot;mps&quot;</span>);  <span class="hljs-comment">//hkeys</span>  jedis.hkeys(<span class="hljs-string">&quot;maps&quot;</span>);  <span class="hljs-comment">//hvals</span>  jedis.hvals(<span class="hljs-string">&quot;maps&quot;</span>);  <span class="hljs-comment">//....</span>&#125;</code></pre></div><h1 id="11-SpringBoot整合Redis"><a href="#11-SpringBoot整合Redis" class="headerlink" title="11.SpringBoot整合Redis"></a>11.SpringBoot整合Redis</h1><p>Spring Boot Data(数据) Redis 中提供了<strong>RedisTemplate和StringRedisTemplate</strong>，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同，<strong>RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。</strong></p><p><code>注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口</code></p><h2 id="11-1-环境准备"><a href="#11-1-环境准备" class="headerlink" title="11.1 环境准备"></a>11.1 环境准备</h2><h4 id="1-引入依赖-1"><a href="#1-引入依赖-1" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="2-配置application-propertie"><a href="#2-配置application-propertie" class="headerlink" title="2.配置application.propertie"></a>2.配置application.propertie</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">localhost</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span></code></pre></div><h2 id="11-2-StringRedisTemplate和RedisTemplate"><a href="#11-2-StringRedisTemplate和RedisTemplate" class="headerlink" title="11.2 StringRedisTemplate和RedisTemplate"></a>11.2 StringRedisTemplate和RedisTemplate</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;  <span class="hljs-comment">//对字符串支持比较友好,不能存储对象</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;  <span class="hljs-comment">//存储对象</span><span class="hljs-comment">//RedisTemplate</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRedisTemplate</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-comment">/**</span><span class="hljs-comment">      * redistemplate对象中key和value的序列化都是JdkSerializationRedisSerializer</span><span class="hljs-comment">      */</span>        System.out.println(redisTemplate);        <span class="hljs-comment">//设置redistemplate值使用对象序列化策略</span>      <span class="hljs-comment">//指定值使用对象序列化---&gt;new StringRedisSerilalizer()或者其他</span>        redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> JdkSerializationRedisSerializer());        <span class="hljs-comment">//redisTemplate.opsForValue().set(&quot;user&quot;,new User(&quot;21&quot;,&quot;小黑&quot;,23,new Date()));</span>        User user = (User) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user&quot;</span>);        System.out.println(user);<span class="hljs-comment">//      Set keys = redisTemplate.keys(&quot;*&quot;);</span><span class="hljs-comment">//      keys.forEach(key -&gt; System.out.println(key));</span>        <span class="hljs-comment">/*Object name = redisTemplate.opsForValue().get(&quot;name&quot;);</span><span class="hljs-comment">        System.out.println(name);*/</span>        <span class="hljs-comment">//Object xiaohei = redisTemplate.opsForValue().get(&quot;xiaohei&quot;);</span>        <span class="hljs-comment">//System.out.println(xiaohei);</span>        <span class="hljs-comment">/*redisTemplate.opsForValue().set(&quot;name&quot;,&quot;xxxx&quot;);</span><span class="hljs-comment">        Object name = redisTemplate.opsForValue().get(&quot;name&quot;);</span><span class="hljs-comment">        System.out.println(name);*/</span>        <span class="hljs-comment">/*redisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;xxxx&quot;,&quot;1111&quot;);</span><span class="hljs-comment">        List lists = redisTemplate.opsForList().range(&quot;lists&quot;, 0, -1);</span><span class="hljs-comment">        lists.forEach(list-&gt; System.out.println(list));*/</span>    &#125;<span class="hljs-comment">//StringRedisTemplate</span>    <span class="hljs-comment">//hash相关操作 opsForHash</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHash</span><span class="hljs-params">()</span></span>&#123;        stringRedisTemplate.opsForHash().put(<span class="hljs-string">&quot;maps&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;小黑&quot;</span>);        Object o = stringRedisTemplate.opsForHash().get(<span class="hljs-string">&quot;maps&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);        System.out.println(o);    &#125;    <span class="hljs-comment">//zset相关操作 opsForZSet</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testZSet</span><span class="hljs-params">()</span></span>&#123;        stringRedisTemplate.opsForZSet().add(<span class="hljs-string">&quot;zsets&quot;</span>,<span class="hljs-string">&quot;小黑&quot;</span>,<span class="hljs-number">10</span>);        Set&lt;String&gt; zsets = stringRedisTemplate.opsForZSet().range(<span class="hljs-string">&quot;zsets&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);        zsets.forEach(value-&gt; System.out.println(value));    &#125;    <span class="hljs-comment">//set相关操作 opsForSet</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSet</span><span class="hljs-params">()</span></span>&#123;        stringRedisTemplate.opsForSet().add(<span class="hljs-string">&quot;sets&quot;</span>,<span class="hljs-string">&quot;xiaosan&quot;</span>,<span class="hljs-string">&quot;xiaosi&quot;</span>,<span class="hljs-string">&quot;xiaowu&quot;</span>);        Set&lt;String&gt; sets = stringRedisTemplate.opsForSet().members(<span class="hljs-string">&quot;sets&quot;</span>);        sets.forEach(value-&gt; System.out.println(value));    &#125;    <span class="hljs-comment">//list相关的操作opsForList</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testList</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// stringRedisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);</span>        List&lt;String&gt; lists = stringRedisTemplate.opsForList().range(<span class="hljs-string">&quot;lists&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);        lists.forEach(key -&gt; System.out.println(key));    &#125;    <span class="hljs-comment">//String相关的操作 opsForValue</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testString</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//stringRedisTemplate.opsForValue().set(&quot;166&quot;,&quot;好同学&quot;);</span>        String s = stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;166&quot;</span>);        System.out.println(s);        Long size = stringRedisTemplate.opsForValue().size(<span class="hljs-string">&quot;166&quot;</span>);        System.out.println(size);    &#125;    <span class="hljs-comment">//key相关的操作</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        Set&lt;String&gt; keys = stringRedisTemplate.keys(<span class="hljs-string">&quot;*&quot;</span>);<span class="hljs-comment">//查看所有key</span>        Boolean name = stringRedisTemplate.hasKey(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//判断某个key是否存在</span>        stringRedisTemplate.delete(<span class="hljs-string">&quot;age&quot;</span>);<span class="hljs-comment">//根据指定key删除</span>        stringRedisTemplate.rename(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//修改key的名称</span>        stringRedisTemplate.expire(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">10</span>, TimeUnit.HOURS);      <span class="hljs-comment">//设置key超时时间 参数1:设置key名 参数2:时间 参数3:时间的单位</span>        stringRedisTemplate.move(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//移动key</span>    &#125;</code></pre></div><h2 id="11-3-绑定操作"><a href="#11-3-绑定操作" class="headerlink" title="11.3 绑定操作"></a><strong>11.3 绑定操作</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//key的绑定操作 如果日后对某一个key的操作及其频繁,可以将这个key绑定到对应redistemplate中,日后基于绑定操作都是操作这个key</span><span class="hljs-comment">//boundValueOps 用来对String值绑定key</span><span class="hljs-comment">//boundListOps 用来对List值绑定key</span><span class="hljs-comment">//boundSetOps 用来对Set值绑定key</span><span class="hljs-comment">//boundZsetOps 用来对Zset值绑定key</span><span class="hljs-comment">//boundHashOps 用来对Hash值绑定key</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBoundKey</span><span class="hljs-params">()</span></span>&#123;    BoundValueOperations&lt;String, String&gt; nameValueOperations = stringRedisTemplate.boundValueOps(<span class="hljs-string">&quot;name&quot;</span>);  <span class="hljs-comment">//所有的操作都是在对&quot;name&quot;操作</span>    nameValueOperations.set(<span class="hljs-string">&quot;1&quot;</span>);    nameValueOperations.set(<span class="hljs-string">&quot;2&quot;</span>);    String s = nameValueOperations.get();    System.out.println(s);&#125;</code></pre></div><h1 id="12-Redis应用场景"><a href="#12-Redis应用场景" class="headerlink" title="12. Redis应用场景"></a>12. Redis应用场景</h1><ul><li>利用Redis中<strong>字符串类型</strong>完成项目中<strong>手机验证码存储的实现</strong></li><li>利用Redis中<strong>字符串类型</strong>完成具有<strong>失效性业务功能</strong>如12306、淘宝：订单还有20分钟</li><li>利用Redis中<strong>分布式集群</strong>系统的<strong>Session共享</strong></li><li>利用Redis中<strong>zset类型</strong>、<strong>可排序set类型</strong>完成<strong>排行榜</strong>等功能的实现，[商品id，商品销量]</li><li>利用Redis中<strong>分布式缓存</strong>实现查询等功能</li><li>利用Redis<strong>存储认证之后token信息</strong>实现微信小程序、公众号中登录后基于用户的唯一标识openid<strong>生成认证后的令牌token</strong></li><li>利用Redis 解决<strong>分布式集群系统中分布式锁</strong>问题</li></ul><h1 id="13-Redis分布式缓存"><a href="#13-Redis分布式缓存" class="headerlink" title="13.Redis分布式缓存"></a>13.Redis分布式缓存</h1><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513210302795.png" alt="image-20210513210302795"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513210340915.png" alt="image-20210513210340915"></p><p>mybatis是里面有个<code>&lt;cache&gt;&lt;/cache&gt;</code>便签，可以实现分布式缓存，只要把里面的实现替换成redis的实现，就可以实现分布式缓存</p><p>注意，增删改都会清除缓存</p><h2 id="13-1-自定义Redis缓存"><a href="#13-1-自定义Redis缓存" class="headerlink" title="13.1 自定义Redis缓存"></a>13.1 自定义Redis缓存</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//自定义Redis缓存实现</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cache</span> </span>&#123;<span class="hljs-comment">//当前放入缓存的mapper的namespace</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<span class="hljs-comment">//必须存在构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisCache</span><span class="hljs-params">(String id)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;id:=====================&gt; &quot;</span> + id);    <span class="hljs-keyword">this</span>.id = id;&#125;<span class="hljs-comment">//返回cache唯一标识</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;&#125; <span class="hljs-comment">//用来获取springboot创建好的工厂</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextUtils</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;    <span class="hljs-comment">//保留下来工厂</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;    <span class="hljs-comment">//将创建好工厂以参数形式传递给这个类</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        <span class="hljs-keyword">this</span>.applicationContext = applicationContext;    &#125;    <span class="hljs-comment">//提供在工厂中获取对象的方法 //RedisTemplate  redisTemplate</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String beanName)</span></span>&#123;        <span class="hljs-keyword">return</span> applicationContext.getBean(beanName);    &#125;&#125;  <span class="hljs-comment">//缓存放入值  redis RedisTemplate   StringRedisTemplate</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putObject</span><span class="hljs-params">(Object key, Object value)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + key.toString());    System.out.println(<span class="hljs-string">&quot;value:&quot;</span> + value);    <span class="hljs-comment">//        //通过application工具类获取redisTemplate</span><span class="hljs-comment">//        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(&quot;redisTemplate&quot;);</span><span class="hljs-comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><span class="hljs-comment">//        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span>    <span class="hljs-comment">//使用redishash类型作为缓存存储模型  key   hashkey  value</span>    getRedisTemplate().opsForHash().put(id.toString(),getKeyToMD5(key.toString()),value);        <span class="hljs-keyword">if</span>(id.equals(<span class="hljs-string">&quot;com.baizhi.dao.UserDAO&quot;</span>))&#123;        <span class="hljs-comment">//缓存超时  client  用户   client  员工</span>        getRedisTemplate().expire(id.toString(),<span class="hljs-number">1</span>, TimeUnit.HOURS);    &#125;        <span class="hljs-keyword">if</span>(id.equals(<span class="hljs-string">&quot;com.baizhi.dao.CityDAO&quot;</span>))&#123;        <span class="hljs-comment">//缓存超时  client  用户   client  员工</span>        getRedisTemplate().expire(id.toString(),<span class="hljs-number">30</span>, TimeUnit.MINUTES);    &#125;    <span class="hljs-comment">//.....指定不同业务模块设置不同缓存超时时间</span>    &#125;<span class="hljs-comment">//获取中获取数据</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">(Object key)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + key.toString());    <span class="hljs-comment">//      通过application工具类获取redisTemplate</span><span class="hljs-comment">//        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(&quot;redisTemplate&quot;);</span><span class="hljs-comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><span class="hljs-comment">//        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span>    <span class="hljs-comment">//根据key 从redis的hash类型中获取数据</span>    <span class="hljs-keyword">return</span> getRedisTemplate().opsForHash().get(id.toString(), getKeyToMD5(key.toString()));&#125;<span class="hljs-comment">//注意:这个方法为mybatis保留方法 默认没有实现 后续版本可能会实现</span><span class="hljs-comment">//缓存排除策略所用</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">removeObject</span><span class="hljs-params">(Object key)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;根据指定key删除缓存&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;清空缓存~~~&quot;</span>);    <span class="hljs-comment">//清空namespace</span>    getRedisTemplate().delete(id.toString());<span class="hljs-comment">//清空缓存</span>&#125;<span class="hljs-comment">//用来计算缓存数量</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//获取hash中key value数量</span>    <span class="hljs-keyword">return</span> getRedisTemplate().opsForHash().size(id.toString()).intValue();&#125;<span class="hljs-comment">//封装redisTemplate</span><span class="hljs-function"><span class="hljs-keyword">private</span> RedisTemplate <span class="hljs-title">getRedisTemplate</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//通过application工具类获取redisTemplate</span>    RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(<span class="hljs-string">&quot;redisTemplate&quot;</span>);    redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());    redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());    <span class="hljs-keyword">return</span> redisTemplate;&#125;<span class="hljs-comment">//封装一个对key进行md5处理方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getKeyToMD5</span><span class="hljs-params">(String key)</span></span>&#123;    <span class="hljs-keyword">return</span> DigestUtils.md5DigestAsHex(key.getBytes());&#125;&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5.redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98(%E4%BA%8C).png" alt="5.redis分布式缓存(二)"></p><p>缓存的Clear只能清除单表的缓存，当业务中有多表的时候，并不能清除所有表的缓存</p><p>解决方法：共享缓存，使用<code>&lt;cache-ref&gt;</code>标签</p><h2 id="13-2-缓存优化"><a href="#13-2-缓存优化" class="headerlink" title="13.2 缓存优化"></a>13.2 缓存优化</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/6.redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98(%E4%B8%89).png" alt="6.redis分布式缓存(三)"></p><p>Spring中利用<code>DigestUtils.md5DigestAsHex(key.getBytes())</code>进行MD5算法加密</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透<strong>访问了不存在的数据</strong>，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p><p><strong>数据库服务器崩溃</strong></p><ul><li>系统平稳运行过程中</li><li>应用服务器流量随时间增量较大</li><li>Redis服务器命中率随时间逐步降低</li><li>Redis内存平稳，内存无压力</li><li>Redis服务器CPU占用激增</li><li>数据库服务器压力激增</li><li>数据库崩溃</li></ul><p><strong>问题排查</strong></p><ul><li>Redis中大面积出现未命中</li><li>出现非正常URL访问</li></ul><p><strong>问题分析</strong></p><ul><li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li><li>Redis获取到null数据未进行持久化，直接返回</li><li>下次此类数据到达重复上述过程</li><li>出现黑客攻击服务器</li></ul><p><strong>解决方案</strong></p><ul><li>缓存null<br>对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</li><li>白名单策略<br>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）、使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</li><li>实施监控<br>实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比<br>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象<br>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象<br>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li><li>key加密<br>问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验<br>例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问。</li></ul><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿就是<strong>单个高热数据过期的瞬间</strong>，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可</p><p><strong>数据库服务器崩溃</strong></p><ul><li>系统平稳运行过程中</li><li>数据库连接量瞬间激增</li><li>Redis服务器无大量key过期</li><li>Redis内存平稳，无波动</li><li>Redis服务器CPU正常</li><li>数据库崩溃</li></ul><p><strong>问题排查</strong></p><ul><li>Redis中某个key过期，该key访问量巨大</li><li>多个数据请求从服务器直接压到Redis后，均未命中</li><li>Redis在短时间内发起了大量对数据库中同一数据的访问</li></ul><p><strong>问题分析</strong></p><ul><li>单个key高热数据</li><li>key过期</li></ul><p><strong>解决方案</strong></p><ul><li>预先设定<br>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长<br>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</li><li>现场调整<br>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li><li>后台刷新数据<br>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li><li>二级缓存<br>设置不同的失效时间，保障不会被同时淘汰就行</li><li>加锁<br>分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</li></ul><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h4><p>缓存雪崩就是<strong>瞬间过期了一大组数据量</strong>，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整</p><p><strong>数据库服务器崩溃</strong></p><ul><li>系统平稳运行过程中，忽然数据库连接量激增</li><li>应用服务器无法及时处理请求</li><li>大量408，500错误页面出现</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据库后再次被瞬间流量放倒</li></ul><p><strong>问题排查</strong></p><ul><li>在一个较短的时间内，缓存中较多的key集中过期</li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li><li>数据库同时接收到大量的请求无法及时处理</li><li>Redis大量请求被积压，开始出现超时现象</li><li>数据库流量激增，数据库崩溃</li><li>重启后仍然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解</li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想</li></ul><p><strong>问题分析</strong></p><ul><li>短时间范围内</li><li>大量key集中过期</li></ul><p><strong>解决方案（道）</strong></p><ul><li>更多的页面静态化处理</li><li>构建多级缓存架构<br>Nginx缓存+redis缓存+ehcache缓存</li><li>检测Mysql严重耗时业务进行优化<br>对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li><li>灾难预警机制<br>监控redis服务器性能指标<br>CPU占用、CPU使用率<br>内存容量<br>查询平均响应时间<br>线程数</li><li>限流、降级<br>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li></ul><p><strong>解决方案（术）</strong></p><ul><li>LRU与LFU切换</li><li>数据有效期策略调整<br>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟<br>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li><li>超热数据使用永久key</li><li>定期维护（自动+人工）<br>对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li><li>加锁，慎用！</li></ul><h1 id="14-Redis-主从复制"><a href="#14-Redis-主从复制" class="headerlink" title="14. Redis 主从复制"></a>14. Redis 主从复制</h1><h2 id="14-1-主从复制"><a href="#14-1-主从复制" class="headerlink" title="14.1 主从复制"></a>14.1 主从复制</h2><p>主从复制架构仅仅用来解决数据的冗余备份,从节点仅仅用来同步数据</p><p><strong>无法解决: 1.master节点出现故障的自动故障转移</strong></p><h2 id="14-2-主从复制架构图"><a href="#14-2-主从复制架构图" class="headerlink" title="14.2 主从复制架构图"></a>14.2 主从复制架构图</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627201722700.png" alt="image-20200627201722700"></p><h2 id="14-3-搭建主从复制"><a href="#14-3-搭建主从复制" class="headerlink" title="14.3 搭建主从复制"></a>14.3 搭建主从复制</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.准备3台机器并修改配置</span><span class="hljs-bullet">-</span> master<span class="hljs-code">port 6379</span><span class="hljs-code">bind 0.0.0.0</span><span class="hljs-code"></span><span class="hljs-code">- slave1</span><span class="hljs-code">port 6380</span><span class="hljs-code">bind 0.0.0.0</span><span class="hljs-code">slaveof master的ip master的port</span><span class="hljs-code"></span><span class="hljs-code">- slave2</span><span class="hljs-code">port 6381</span><span class="hljs-code">bind 0.0.0.0</span><span class="hljs-code">slaveof master的ip master的port</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627202443388.png" alt="image-20200627202443388"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 2.启动3台机器进行测试</span><span class="hljs-bullet">-</span> cd /usr/redis/bin<span class="hljs-bullet">-</span> ./redis-server /root/master/redis.conf<span class="hljs-bullet">-</span> ./redis-server /root/slave1/redis.conf<span class="hljs-bullet">-</span> ./redis-server /root/slave2/redis.conf</code></pre></div><hr><h1 id="15-Redis哨兵机制"><a href="#15-Redis哨兵机制" class="headerlink" title="15. Redis哨兵机制"></a>15. Redis哨兵机制</h1><h2 id="15-1-哨兵Sentinel机制"><a href="#15-1-哨兵Sentinel机制" class="headerlink" title="15.1 哨兵Sentinel机制"></a>15.1 哨兵Sentinel机制</h2><p>Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。简单的说哨兵就是带有<strong>自动故障转移功能的主从架构</strong>。</p><p><strong>无法解决: 1.单节点并发压力问题   2.单节点内存和磁盘物理上限</strong></p><h2 id="15-2-哨兵架构原理"><a href="#15-2-哨兵架构原理" class="headerlink" title="15.2 哨兵架构原理"></a>15.2 哨兵架构原理</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627204422750.png" alt="image-20200627204422750"></p><h2 id="15-3-搭建哨兵架构"><a href="#15-3-搭建哨兵架构" class="headerlink" title="15.3 搭建哨兵架构"></a>15.3 搭建哨兵架构</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.在主节点上创建哨兵配置</span><span class="hljs-bullet">-</span> 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；<span class="hljs-section"># 2.配置哨兵，在sentinel.conf文件中填入内容：</span><span class="hljs-bullet">-</span> sentinel monitor 哨兵架构的命名（自己起名字） ip port 1(如果master不可达，那么需要多少个哨兵都不可达，才能判定真正的不可达，这个后面的数字1,是指当有两个及以上的sentinel服务检测到master宕机，才会去执行主从切换的功能)</code></pre></div><p>启动的时候要到源码目录</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513224116080.png" alt="image-20210513224116080"></p><p>找到<code>redis-sentinel</code>，复制到<code>/usr/redis/bin</code></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513224142401.png" alt="image-20210513224142401"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 3.启动哨兵模式进行测试</span><span class="hljs-bullet">-</span> ./redis-sentinel  /usr/redis/sentinel.conf<span class="hljs-bullet">-</span> 或者./redis-sentinel ../sentinel.conf</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513225408094.png" alt="image-20210513225408094"></p><h2 id="15-4-通过springboot操作哨兵"><a href="#15-4-通过springboot操作哨兵" class="headerlink" title="15.4 通过springboot操作哨兵"></a>15.4 通过springboot操作哨兵</h2><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># redis sentinel 配置</span><span class="hljs-comment"># master书写是使用哨兵监听的那个名称</span><span class="hljs-meta">spring.redis.sentinel.master</span>=<span class="hljs-string">mymaster</span><span class="hljs-comment"># 连接的不再是一个具体redis主机,书写的是多个哨兵节点</span><span class="hljs-meta">spring.redis.sentinel.nodes</span>=<span class="hljs-string">192.168.202.206:26379</span></code></pre></div><ul><li><strong>注意:如果连接过程中出现如下错误:RedisConnectionException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2)</strong></li><li><strong>解决方案:在哨兵的配置文件<code>sentinel.conf</code>中加入bind 0.0.0.0 开启远程连接权限</strong></li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200629154647970.png" alt="image-20200629154647970"></p><h1 id="16-Redis集群"><a href="#16-Redis集群" class="headerlink" title="16. Redis集群"></a>16. Redis集群</h1><h2 id="16-1-集群"><a href="#16-1-集群" class="headerlink" title="16.1 集群"></a>16.1 集群</h2><p>Redis在3.0后开始支持Cluster(模式)模式,目前redis的集群支持节点的自动发现,支持slave-master选举和容错,支持在线分片(sharding shard )等特性。</p><h2 id="16-2-集群架构图"><a href="#16-2-集群架构图" class="headerlink" title="16.2 集群架构图"></a>16.2 集群架构图</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/wpsgRnQP8.jpg" alt="img"></p><h2 id="16-3-集群细节"><a href="#16-3-集群细节" class="headerlink" title="16.3 集群细节"></a>16.3 集群细节</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.<span class="hljs-bullet">-</span> 节点的fail是通过集群中超过半数的节点检测失效时才生效. <span class="hljs-bullet">-</span> 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可<span class="hljs-bullet">-</span> redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value<span class="hljs-bullet">-</span> reshared，添加新的物理节点，需要重新分配，从旧的物理节点拿出slot给新物理节点</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200629165226329.png" alt="image-20200629165226329"></p><h2 id="16-4-集群搭建"><a href="#16-4-集群搭建" class="headerlink" title="16.4 集群搭建"></a>16.4 集群搭建</h2><p>判断一个是集群中的节点是否可用,是集群中的所用主节点选举过程,如果半数以上的节点认为当前节点挂掉,那么当前节点就是挂掉了,所以搭建redis集群时建议节点数最好为奇数，<strong>搭建集群至少需要三个主节点,三个从节点,至少需要6个节点</strong>。</p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.准备环境安装ruby以及redis集群依赖</span><span class="hljs-bullet">-</span> yum install -y ruby rubygems<span class="hljs-section"># redis.gem不能通过yum安装，上传后到目录下通过命令安装</span><span class="hljs-bullet">-</span> gem install redis-xxx.gem</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627193219366.png" alt="image-20200627193219366"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627193348905.png" alt="image-20200627193348905"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210514121617248.png" alt="image-20210514121617248"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 2.在一台机器创建7个目录</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627193849867.png" alt="image-20200627193849867"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 3.每个目录复制一份配置文件</span>[root@localhost ~]# cp redis-4.0.10/redis.conf 7000/[root@localhost ~]# cp redis-4.0.10/redis.conf 7001/[root@localhost ~]# cp redis-4.0.10/redis.conf 7002/[root@localhost ~]# cp redis-4.0.10/redis.conf 7003/[root@localhost ~]# cp redis-4.0.10/redis.conf 7004/[root@localhost ~]# cp redis-4.0.10/redis.conf 7005/[root@localhost ~]# cp redis-4.0.10/redis.conf 7006/</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627194103354.png" alt="image-20200627194103354"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 4.修改不同目录配置文件</span><span class="hljs-bullet">-</span> port 6379 .....                 //修改端口<span class="hljs-bullet">-</span> bind  0.0.0.0                    //开启远程连接<span class="hljs-bullet">-</span> cluster-enabled  yes          //开启集群模式<span class="hljs-bullet">-</span> daemonize yes //开启守护线程启动<span class="hljs-bullet">-</span> dbfilename dump-port.rdb.  //修改rdb命名<span class="hljs-bullet">-</span> cluster-config-file  nodes-port.conf //集群节点配置文件<span class="hljs-bullet">-</span> cluster-node-timeout  5000         //集群节点超时时间<span class="hljs-bullet">-</span> appendonly  yes                  //必须开启AOF持久化<span class="hljs-section"># 5.指定不同目录配置文件启动七个节点</span><span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7000/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7001/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7002/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7003/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7004/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7005/redis.conf<span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7006/redis.conf</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627194913866.png" alt="image-20200627194913866"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 6.查看进程</span><span class="hljs-bullet">-</span> [root@localhost bin]# ps aux|grep redis</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627194954143.png" alt="image-20200627194954143"></p><h4 id="1-创建集群"><a href="#1-创建集群" class="headerlink" title="1.创建集群"></a>1.创建集群</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.复制集群操作脚本到bin目录中</span><span class="hljs-bullet">-</span> [root@localhost src]# cp redis-trib.rb /usr/redis/bin/<span class="hljs-section"># 2.创建集群</span><span class="hljs-bullet">-</span> ./redis-trib.rb create --replicas 1 <span class="hljs-code">`前三个作为物理节点`</span>192.168.202.205:7000 192.168.202.205:7001 192.168.202.205:7002 192.168.202.205:7003 192.168.202.205:7004 192.168.202.205:7005</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627195601307.png" alt="image-20200627195601307"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 3.集群创建成功出现如下提示</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200627195647767.png" alt="image-20200627195647767"></p><h4 id="2-查看集群状态"><a href="#2-查看集群状态" class="headerlink" title="2.查看集群状态"></a>2.查看集群状态</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.查看集群状态 check [原始集群中任意节点] [无]</span><span class="hljs-bullet">-</span> ./redis-trib.rb check 192.168.202.205:7000<span class="hljs-section"># 2.集群节点状态说明</span><span class="hljs-bullet">-</span> 主节点 <span class="hljs-code">主节点存在hash slots,且主节点的hash slots 没有交叉</span><span class="hljs-code">主节点不能删除</span><span class="hljs-code">一个主节点可以有多个从节点</span><span class="hljs-code">主节点宕机时多个副本之间自动选举主节点</span><span class="hljs-code"></span><span class="hljs-code">- 从节点</span><span class="hljs-code">从节点没有hash slots</span><span class="hljs-code">从节点可以删除</span><span class="hljs-code">从节点不负责数据的写,只负责数据的同步</span></code></pre></div><h4 id="3-添加主节点"><a href="#3-添加主节点" class="headerlink" title="3.添加主节点"></a>3.添加主节点</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.添加主节点 add-node [新加入节点] [原始集群中任意节点]</span><span class="hljs-bullet">-</span> ./redis-trib.rb  add-node 192.168.1.158:7006  192.168.1.158:7005<span class="hljs-bullet">-</span> 注意:<span class="hljs-code">1.该节点必须以集群模式启动</span><span class="hljs-code">2.默认情况下该节点就是以master节点形式添加</span></code></pre></div><h4 id="4-添加从节点"><a href="#4-添加从节点" class="headerlink" title="4.添加从节点"></a>4.添加从节点</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.添加从节点 add-node --slave [新加入节点] [集群中任意节点]</span><span class="hljs-bullet">-</span> ./redis-trib.rb  add-node --slave 192.168.1.158:7006 192.168.1.158:7000<span class="hljs-bullet">-</span> 注意:<span class="hljs-code">当添加副本节点时没有指定主节点,redis会随机给副本节点较少的主节点添加当前副本节点</span><span class="hljs-code"></span><span class="hljs-code"># 2.为确定的master节点添加主节点 add-node --slave --master-id master节点id [新加入节点] [集群任意节点]</span><span class="hljs-code">- ./redis-trib.rb  add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006  127.0.0.1:7000</span></code></pre></div><h4 id="5-删除副本节点"><a href="#5-删除副本节点" class="headerlink" title="5.删除副本节点"></a>5.删除副本节点</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.删除节点 del-node [集群中任意节点] [删除节点id]</span><span class="hljs-bullet">-</span> ./redis-trib.rb  del-node 127.0.0.1:7002 0ca3f102ecf0c888fc7a7ce43a13e9be9f6d3dd1<span class="hljs-bullet">-</span> 注意: 1.被删除的节点必须是从节点或没有被分配hash slots的节点</code></pre></div><h4 id="6-集群在线分片"><a href="#6-集群在线分片" class="headerlink" title="6.集群在线分片"></a>6.集群在线分片</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.在线分片 reshard [集群中任意节点] [无]</span><span class="hljs-bullet">-</span> ./redis-trib.rb  reshard  192.168.1.158:7000</code></pre></div><h4 id="7-操作集群"><a href="#7-操作集群" class="headerlink" title="7.操作集群"></a>7.操作集群</h4><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.终端操作</span><span class="hljs-bullet">-</span> ./redis-cli -p port -c <span class="hljs-code">`加入-c操作集群`</span><span class="hljs-section"># 2.Springboot操作</span><span class="hljs-bullet">-</span> spring.redis.cluster.nodes=192.168.1.158:7000,192.168.1.158:7001,192.168.1.158:7002...写上所有的节点，保证宕机时还有备用</code></pre></div><h1 id="17-Redis实现分布式Session管理"><a href="#17-Redis实现分布式Session管理" class="headerlink" title="17.Redis实现分布式Session管理"></a>17.Redis实现分布式Session管理</h1><h2 id="17-1-管理机制"><a href="#17-1-管理机制" class="headerlink" title="17.1 管理机制"></a>17.1 管理机制</h2><p><strong>Memcached Session Manager</strong>与<strong>Redis</strong>的Session管理对比</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/7.Redis%E7%9A%84session%E7%AE%A1%E7%90%86%E5%92%8CMemcached%E7%9A%84session%E7%AE%A1%E7%90%86%E4%B8%8D%E5%90%8C.jpg" alt="7.Redis的session管理和Memcached的session管理不同"></p><p><strong>redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200628201643358.png" alt="image-20200628201643358"></p><h2 id="17-2-开发Session管理"><a href="#17-2-开发Session管理" class="headerlink" title="17.2 开发Session管理"></a>17.2 开发Session管理</h2><h4 id="1-引入依赖-2"><a href="#1-引入依赖-2" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="2-开发Session管理配置类"><a href="#2-开发Session管理配置类" class="headerlink" title="2. 开发Session管理配置类"></a>2. 开发Session管理配置类</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableRedisHttpSession</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisSessionManager</span> </span>&#123;   &#125;</code></pre></div><h4 id="3-TestController"><a href="#3-TestController" class="headerlink" title="3. TestController"></a>3. TestController</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping(&quot;test&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-comment">// redis  session   list    1</span>    <span class="hljs-comment">// jvm  list 地址    list.add   list.size  2</span>    <span class="hljs-comment">//使用redis 的session管理  </span>  <span class="hljs-comment">//注意:当session中数据发生变化时必须将session中变化的数据同步到redis中</span>  <span class="hljs-comment">//add方法是加入jvm中，jvm发生变化，但是redis并没有变化，所以需要同步</span>    <span class="hljs-meta">@RequestMapping(&quot;test&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;              List&lt;String&gt; list = (List&lt;String&gt;) request.getSession().getAttribute(<span class="hljs-string">&quot;list&quot;</span>);        <span class="hljs-keyword">if</span>(list==<span class="hljs-keyword">null</span>)&#123;            list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        &#125;        list.add(<span class="hljs-string">&quot;xxxx&quot;</span>);        <span class="hljs-comment">//每次session变化都要同步session</span>        request.getSession().setAttribute(<span class="hljs-string">&quot;list&quot;</span>,list);        response.getWriter().println(<span class="hljs-string">&quot;size: &quot;</span>+list.size());        response.getWriter().println(<span class="hljs-string">&quot;sessionid: &quot;</span>+request.getSession().getId());    &#125;      <span class="hljs-meta">@RequestMapping(&quot;logout&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;        <span class="hljs-comment">//退出登录</span>        request.getSession().invalidate();<span class="hljs-comment">//失效</span>    &#125;</code></pre></div><h4 id="4-入口类"><a href="#4-入口类" class="headerlink" title="4. 入口类"></a>4. 入口类</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisSessionManagerApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(RedisSessionManagerApplication.class, args);    &#125;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;        <span class="hljs-keyword">return</span> builder.sources(RedisSessionManagerApplication.class);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2021/07/26/MySQL/"/>
    <url>/2021/07/26/MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul><li>DQL（Data Query Language）：数据查询语言<br>select </li><li>DML(Data Manipulate Language):数据操作语言<br>insert 、update、delete</li><li>DDL（Data Define Languge）：数据定义语言<br>create、drop、alter</li><li>TCL（Transaction Control Language）：事务控制语言<br>commit、rollback</li></ul><h1 id="一、基本知识"><a href="#一、基本知识" class="headerlink" title="一、基本知识"></a>一、基本知识</h1><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h4 id="对库的操作"><a href="#对库的操作" class="headerlink" title="对库的操作"></a>对库的操作</h4><p><strong>创建数据库</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> book;</code></pre></div><p><strong>修改数据库</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#修改字符集<span class="hljs-keyword">ALTER</span> DATABASE books <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> gbk;</code></pre></div><p><strong>展示数据库</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;</code></pre></div><p><strong>删除指定数据库</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> database_xx;</code></pre></div><p><strong>使用指定数据库</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">USE database_xx;</code></pre></div><h4 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h4><p><strong>创建表</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(    s_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">PRIMARY</span> KEY COMMENT<span class="hljs-string">&#x27;学生学号&#x27;</span>,    s_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;学生姓名 不能为空&#x27;</span>,    s_sex <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;学生性别&#x27;</span>,    s_birthday DATETIME COMMENT<span class="hljs-string">&#x27;学生生日&#x27;</span>,    s_class <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT<span class="hljs-string">&#x27;学生所在的班级&#x27;</span>);</code></pre></div><p><strong>展示表</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DESCRIBE</span> table_xx;<span class="hljs-keyword">DESC</span> table_xx;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200807154719.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200807154719.png" alt="img"></a></p><p><strong>修改表</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span><span class="hljs-operator">|</span><span class="hljs-keyword">drop</span><span class="hljs-operator">|</span>modify<span class="hljs-operator">|</span>change <span class="hljs-keyword">column</span> 列名 【列类型 约束】;#①修改列名<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> book CHANGE <span class="hljs-keyword">COLUMN</span> publishdate pubDate DATETIME;#②修改列的类型或约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> book MODIFY <span class="hljs-keyword">COLUMN</span> pubdate <span class="hljs-type">TIMESTAMP</span>;#③添加新列<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> author <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> annual <span class="hljs-keyword">DOUBLE</span>; #④删除列<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> book_author <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span>  annual;#⑤修改表名<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> author RENAME <span class="hljs-keyword">TO</span> book_author;</code></pre></div><p><strong>删除表</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> 旧表名;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>  表名();</code></pre></div><p><strong>复制表</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#<span class="hljs-number">1.</span>仅仅复制表的结构<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">copy</span> <span class="hljs-keyword">LIKE</span> author;#<span class="hljs-number">2.</span>复制表的结构<span class="hljs-operator">+</span>数据<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> copy2 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> author;#只复制部分数据<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> copy3<span class="hljs-keyword">SELECT</span> id,au_name<span class="hljs-keyword">FROM</span> author <span class="hljs-keyword">WHERE</span> nation<span class="hljs-operator">=</span><span class="hljs-string">&#x27;中国&#x27;</span>;#仅仅复制某些字段<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> copy4 <span class="hljs-keyword">SELECT</span> id,au_name<span class="hljs-keyword">FROM</span> author<span class="hljs-keyword">WHERE</span> <span class="hljs-number">0</span>;</code></pre></div><p><strong>查看版本</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> version();</code></pre></div><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><div class="hljs code-wrapper"><pre><code class="hljs sql">#从表中查询所有<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name; #从表中指定查询<span class="hljs-keyword">SELECT</span> `last_name`, `first_name` <span class="hljs-keyword">FROM</span> table_name;#起别名<span class="hljs-keyword">SELECT</span> last_name <span class="hljs-keyword">AS</span> &quot;别名1&quot;,       first_name <span class="hljs-keyword">AS</span> &quot;别名2&quot;<span class="hljs-keyword">FROM</span> employees;#或者用空格<span class="hljs-keyword">SELECT</span> last_name 别名<span class="hljs-number">1</span>,       first_name 别名<span class="hljs-number">2</span><span class="hljs-keyword">FROM</span> employees;#去重<span class="hljs-keyword">DISTINCT</span>查询<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id <span class="hljs-keyword">FROM</span> employees;#拼接<span class="hljs-keyword">SELECT</span> CONCAT(first_name,last_name ) oo<span class="hljs-keyword">FROM</span> employees;#如果为<span class="hljs-keyword">NULL</span>，返回<span class="hljs-number">0</span>或者指定的数字<span class="hljs-keyword">SELECT</span> IFNULL(last_name,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> xx <span class="hljs-keyword">FROM</span> employees;#字母字符统一转为<span class="hljs-number">0</span><span class="hljs-keyword">SELECT</span> <span class="hljs-number">0</span> <span class="hljs-operator">=</span> ‘a’; <span class="hljs-comment">---1</span><span class="hljs-keyword">SELECT</span> <span class="hljs-number">0</span> <span class="hljs-operator">=</span> ‘abc’; <span class="hljs-comment">---1</span>#数字字符统一转为数字<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> ‘<span class="hljs-number">1</span>’; <span class="hljs-comment">---1</span><span class="hljs-keyword">SELECT</span> <span class="hljs-number">2</span> <span class="hljs-operator">=</span> ‘<span class="hljs-number">2</span>’; <span class="hljs-comment">---1</span></code></pre></div><h4 id="进阶查询"><a href="#进阶查询" class="headerlink" title="进阶查询"></a><strong>进阶查询</strong></h4><blockquote><p>select<br>        要查询的字段|表达式|常量值|函数<br>from<br>        表<br>where<br>        条件 ;</p></blockquote><p>分类：</p><ul><li><p>条件表达式</p><ul><li><code>&gt;</code>   <code> &lt;</code>   <code>=</code>    <code>&lt;=</code>   <code>&lt;&gt;是不等于</code></li><li>安全等于<code>&lt;=&gt;</code>既可以判断NULL，又可以判断普通值</li></ul></li><li><p>逻辑表达式<br>示例：<code>salary&gt;10000 &amp;&amp; salary&lt;20000</code></p><p>  AND（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false<br>  OR(||)：两个条件只要有一个成立，结果为true，否则为false<br>  NOT(!)：如果条件成立，则not后为false，否则为true<br>  IS NULL：不能用 xx=NULL</p></li><li><p>模糊查询</p><ul><li>%任意多个字符，如包含a的信息：<code>last_name LIKE &#39;%a%&#39;</code></li><li>_任意单个字符，如第三个e，第五个为a： <code>last_name LIKE &#39;___e_a%&#39;</code></li><li>在100-200之间，包含：<code>BETWEEN 100 AND 200 </code></li><li>在包含某些条件的信息：<code>last_name IN (&#39;Lucifer&#39; , &#39;Melrose&#39; , &#39;Xiaowei&#39;)</code>等价于<code>last_name = lucifer OR last_name = melrose OR ....</code></li></ul></li></ul><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a><strong>排序查询</strong></h4><blockquote><p>select<br>   要查询的东西<br>from<br>   表<br>where<br>   条件</p><p>order by 排序的字段|表达式|函数|别名 【asc|desc】</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql">#降序<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>;#升序<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">ASC</span>;</code></pre></div><h4 id="常见函数✨"><a href="#常见函数✨" class="headerlink" title="常见函数✨"></a>常见函数✨</h4><blockquote><p>SELECT 函数名(实参列表) FROM 表</p></blockquote><p><strong>单行函数</strong></p><ol><li>字符函数<ul><li>concat拼接</li><li>substr截取子串(MySQL中索引从1开始)</li><li>upper转换成大写</li><li>lower转换成小写</li><li>trim去前后指定的空格和字符</li><li>ltrim去左边空格</li><li>rtrim去右边空格</li><li>replace替换</li><li>lpad左填充</li><li>rpad右填充</li><li>instr返回子串第一次出现的索引</li><li>length 获取字节个数</li></ul></li><li>数学函数<ul><li>round 四舍五入</li><li>rand 随机数</li><li>floor向下取整</li><li>ceil向上取整</li><li>mod取余</li><li>truncate截断</li></ul></li><li>日期函数<ul><li>now当前系统日期+时间</li><li>curdate当前系统日期</li><li>curtime当前系统时间</li><li>str_to_date 将字符转换成日期</li><li>date_format将日期转换成字符</li><li>datedief两个日期相隔的天数</li></ul></li><li>流程控制函数<ul><li>if 处理双分支</li><li>case语句 处理多分支<ul><li>情况1：处理等值判断</li><li>情况2：处理条件判断</li></ul></li></ul></li><li>其他函数<ul><li>version版本</li><li>database当前库</li><li>user当前连接用户</li></ul></li></ol><p><strong>分组函数</strong></p><ul><li><p>sum 求和</p></li><li><p>max 最大值</p></li><li><p>min 最小值</p></li><li><p>avg 平均值</p></li><li><p>count 计数</p><blockquote><p>特点：</p><ul><li>以上五个分组函数都忽略null值，除了count(<em>)</em></li><li><em>sum和avg一般用于处理数值型</em></li><li><em>max、min、count可以处理任何数据类型</em></li><li><em>都可以搭配distinct使用，用于统计去重后的结果</em></li><li><em>count的参数可以支持：字段、</em>常量值，一般放1，建议使用 count(*)，效果都一样</li></ul></blockquote></li></ul><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a><strong>分组查询</strong></h4><blockquote><p>select<br>        查询的字段，分组函数<br>from<br>        表</p><p>where 筛选条件</p><p>group by<br>        分组的字段</p><p>order by 子句</p></blockquote><p>1、可以按单个字段分组<br>2、和分组函数一同查询的字段最好是分组后的字段<br>3、分组筛选</p><blockquote><p>​        针对的表    位置            关键字<br>分组前筛选：    原始表        group by的前面        where<br>分组后筛选：    分组后的结果集    group by的后面        having</p></blockquote><p>4、可以按多个字段分组，字段之间用逗号隔开<br>5、可以支持排序<br>6、having后可以支持别名</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#查询邮箱中包含a字符，每个部门的平均工资<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary),department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> email <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id#查询那个部门的员工个数<span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>#首先查询每个部门的员工个数<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>),department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;#然后根据结果筛选，查询那个部门的员工个数<span class="hljs-operator">&gt;</span><span class="hljs-number">2</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>),department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>;#每个工种有奖金的员工的最高工资<span class="hljs-operator">&gt;</span><span class="hljs-number">12000</span>的工种编号和最高工资<span class="hljs-keyword">SELECT</span> job_id,<span class="hljs-built_in">MAX</span>(salary)<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">MAX</span>(salary)<span class="hljs-operator">&gt;</span><span class="hljs-number">12000</span>;</code></pre></div><h4 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h4><p>笛卡尔乘积：如果连接条件省略或无效则会出现<br>解决办法：添加上连接条件</p><p><strong>一、传统模式下的连接 ：等值连接——非等值连接</strong></p><ul><li>等值连接的结果 = 多个表的交集</li><li>n表连接，至少需要n-1个连接条件</li><li>多个表不分主次，没有顺序要求</li><li>一般为表起别名，提高阅读性和性能</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql">#<span class="hljs-number">1.</span>显示所有员工的姓名，部门号和部门名称。USE myemployees;<span class="hljs-keyword">SELECT</span> last_name,d.department_id,department_name<span class="hljs-keyword">FROM</span> employees e,departments d<span class="hljs-keyword">WHERE</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;#<span class="hljs-number">2.</span>查询<span class="hljs-number">90</span>号部门员工的job_id和<span class="hljs-number">90</span>号部门的location_id<span class="hljs-keyword">SELECT</span> job_id,location_id<span class="hljs-keyword">FROM</span> employees e,departments d<span class="hljs-keyword">WHERE</span> e.`department_id`<span class="hljs-operator">=</span>d.`department_id`<span class="hljs-keyword">AND</span> e.`department_id`<span class="hljs-operator">=</span><span class="hljs-number">90</span>;#<span class="hljs-number">3.</span>选择所有有奖金的员工的last_name , department_name , location_id , city<span class="hljs-keyword">SELECT</span> last_name , department_name , l.location_id , city<span class="hljs-keyword">FROM</span> employees e,departments d,locations l<span class="hljs-keyword">WHERE</span> e.department_id <span class="hljs-operator">=</span> d.department_id<span class="hljs-keyword">AND</span> d.location_id<span class="hljs-operator">=</span>l.location_id<span class="hljs-keyword">AND</span> e.commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;#<span class="hljs-number">4.</span>选择city在Toronto工作的员工的last_name , job_id , department_id , department_name <span class="hljs-keyword">SELECT</span> last_name , job_id , d.department_id , department_name <span class="hljs-keyword">FROM</span> employees e,departments d ,locations l<span class="hljs-keyword">WHERE</span> e.department_id <span class="hljs-operator">=</span> d.department_id<span class="hljs-keyword">AND</span> d.location_id<span class="hljs-operator">=</span>l.location_id<span class="hljs-keyword">AND</span> city <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Toronto&#x27;</span>;#<span class="hljs-number">5.</span>查询每个工种、每个部门的部门名、工种名和最低工资<span class="hljs-keyword">SELECT</span> department_name,job_title,<span class="hljs-built_in">MIN</span>(salary) 最低工资<span class="hljs-keyword">FROM</span> employees e,departments d,jobs j<span class="hljs-keyword">WHERE</span> e.`department_id`<span class="hljs-operator">=</span>d.`department_id`<span class="hljs-keyword">AND</span> e.`job_id`<span class="hljs-operator">=</span>j.`job_id`<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_name,job_title;#<span class="hljs-number">6.</span>查询每个国家下的部门个数大于<span class="hljs-number">2</span>的国家编号<span class="hljs-keyword">SELECT</span> country_id,<span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) 部门个数<span class="hljs-keyword">FROM</span> departments d,locations l<span class="hljs-keyword">WHERE</span> d.`location_id`<span class="hljs-operator">=</span>l.`location_id`<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> country_id<span class="hljs-keyword">HAVING</span> 部门个数<span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>;#<span class="hljs-number">7</span>、选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式employeesEmp#managerMgr#kochhar<span class="hljs-number">101</span>king<span class="hljs-number">100</span><span class="hljs-keyword">SELECT</span> e.last_name employees,e.employee_id &quot;Emp#&quot;,m.last_name manager,m.employee_id &quot;Mgr#&quot;<span class="hljs-keyword">FROM</span> employees e,employees m<span class="hljs-keyword">WHERE</span> e.manager_id <span class="hljs-operator">=</span> m.employee_id<span class="hljs-keyword">AND</span> e.last_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;kochhar&#x27;</span>;</code></pre></div><p><strong>二、sql99语法：通过join关键字实现连接</strong></p><ul><li>内连接（inner）<ul><li>等值连接</li><li>非等值连接 </li><li>自连接</li></ul></li><li>外连接<ul><li>左外连接（left 【outer】)</li><li>右外连接（right 【outer】）</li><li>全外连接（full【outer】）</li></ul></li><li>交叉连接 cross</li></ul><p><strong>语法</strong></p><blockquote><p>select 字段，…<br>from 表1<br>【inner|left outer|right outer|cross】join 表2<br>【on  连接条件】<br>【inner|left outer|right outer|cross】join 表3<br>【on  连接条件】<br>【where 筛选条件】<br>【group by 分组字段】<br>【having 分组后的筛选条件】<br>【order by 排序的字段或表达式】</p></blockquote><p>好处：语句上，连接条件和筛选条件实现了分离，简洁明了</p><p><strong>没有创建外键时，可以使用内外查询将两个表的内容合并在一起查询</strong></p><blockquote><p><strong>内连接</strong></p></blockquote><p><strong>内联查询：两张表通过某个字段合并起来，查询出相关数据</strong></p><p><strong>等值连接</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1.</span>查询员工名、部门名<span class="hljs-keyword">SELECT</span> last_name,department_name<span class="hljs-keyword">FROM</span> departments d<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>  employees e<span class="hljs-keyword">ON</span> e.`department_id` <span class="hljs-operator">=</span> d.`department_id`;#案例<span class="hljs-number">2.</span>查询名字中包含e的员工名和工种名（添加筛选）<span class="hljs-keyword">SELECT</span> last_name,job_title<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> jobs j<span class="hljs-keyword">ON</span> e.`job_id`<span class="hljs-operator">=</span>  j.`job_id`<span class="hljs-keyword">WHERE</span> e.`last_name` <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%e%&#x27;</span>;#<span class="hljs-number">3.</span> 查询部门个数<span class="hljs-operator">&gt;</span><span class="hljs-number">3</span>的城市名和部门个数，（添加分组<span class="hljs-operator">+</span>筛选）#①查询每个城市的部门个数#②在①结果上筛选满足条件的<span class="hljs-keyword">SELECT</span> city,<span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) 部门个数<span class="hljs-keyword">FROM</span> departments d<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> locations l<span class="hljs-keyword">ON</span> d.`location_id`<span class="hljs-operator">=</span>l.`location_id`<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> city<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">3</span>;#案例<span class="hljs-number">4.</span>查询哪个部门的员工个数<span class="hljs-operator">&gt;</span><span class="hljs-number">3</span>的部门名和员工个数，并按个数降序（添加排序）#①查询每个部门的员工个数<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>),department_name<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> departments d<span class="hljs-keyword">ON</span> e.`department_id`<span class="hljs-operator">=</span>d.`department_id`<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_name#② 在①结果上筛选员工个数<span class="hljs-operator">&gt;</span><span class="hljs-number">3</span>的记录，并排序<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) 个数,department_name<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> departments d<span class="hljs-keyword">ON</span> e.`department_id`<span class="hljs-operator">=</span>d.`department_id`<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_name<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">3</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">DESC</span>;#<span class="hljs-number">5.</span>查询员工名、部门名、工种名，并按部门名降序（添加三表连接）<span class="hljs-keyword">SELECT</span> last_name,department_name,job_title<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> departments d <span class="hljs-keyword">ON</span> e.`department_id`<span class="hljs-operator">=</span>d.`department_id`<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> jobs j <span class="hljs-keyword">ON</span> e.`job_id` <span class="hljs-operator">=</span> j.`job_id`<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> department_name <span class="hljs-keyword">DESC</span>;</code></pre></div><p><strong>非等值连接</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#查询员工的工资级别<span class="hljs-keyword">SELECT</span> salary,grade_level<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">JOIN</span> job_grades g<span class="hljs-keyword">ON</span> e.`salary` <span class="hljs-keyword">BETWEEN</span> g.`lowest_sal` <span class="hljs-keyword">AND</span> g.`highest_sal`;  #查询工资级别的个数<span class="hljs-operator">&gt;</span><span class="hljs-number">20</span>的个数，并且按工资级别降序<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>),grade_level<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">JOIN</span> job_grades g<span class="hljs-keyword">ON</span> e.`salary` <span class="hljs-keyword">BETWEEN</span> g.`lowest_sal` <span class="hljs-keyword">AND</span> g.`highest_sal`<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> grade_level<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">20</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade_level <span class="hljs-keyword">DESC</span>;</code></pre></div><blockquote><p><strong>自连接</strong></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql">#查询员工名和直接上级的名称，从自己的表中查询两次#sql99<span class="hljs-keyword">SELECT</span> e.last_name,m.last_name<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">JOIN</span> employees m <span class="hljs-keyword">ON</span> e.`manager_id`<span class="hljs-operator">=</span>m.`employee_id`;#sql92<span class="hljs-keyword">SELECT</span> e.last_name,m.last_name<span class="hljs-keyword">FROM</span> employees e,employees m <span class="hljs-keyword">WHERE</span> e.`manager_id`<span class="hljs-operator">=</span>m.`employee_id`;#查询员工的名字、上级的名字<span class="hljs-keyword">SELECT</span> e.last_name,m.last_name<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">JOIN</span> employees m<span class="hljs-keyword">ON</span> e.`manager_id`<span class="hljs-operator">=</span> m.`employee_id`;#查询姓名中包含字符k的员工的名字、上级的名字<span class="hljs-keyword">SELECT</span> e.last_name,m.last_name<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">JOIN</span> employees m<span class="hljs-keyword">ON</span> e.`manager_id`<span class="hljs-operator">=</span> m.`employee_id`<span class="hljs-keyword">WHERE</span> e.`last_name` <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%k%&#x27;</span>;</code></pre></div><blockquote><p><strong>外连接</strong></p></blockquote><p><strong>应用场景：用于查询一个表中有，另一个表没有的记录</strong></p><ul><li>特点：</li><li>外连接的查询结果为主表中的所有记录<ul><li>如果从表中有和它匹配的，则显示匹配的值</li><li>如果从表中没有和它匹配的，则显示null</li><li><strong>外连接查询结果=内连接结果+主表中有而从表没有的记录</strong></li></ul></li><li>左外连接，left join左边的是主表</li><li>右外连接，right join右边的是主表</li><li>左外和右外交换两个表的顺序，可以实现同样的效果 </li><li>全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的</li></ul><p><strong>左外连接</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> ... <span class="hljs-keyword">ON</span> ...或<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> ... <span class="hljs-keyword">ON</span> ...</code></pre></div><p>举例：</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#引入：查询男朋友 不在男神表的的女神名<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> beauty;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> boys;#bo<span class="hljs-operator">=</span>boys b<span class="hljs-operator">=</span>beauty#左外连接<span class="hljs-keyword">SELECT</span> b.name,bo.<span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> beauty b<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> boys bo<span class="hljs-keyword">ON</span> b.`boyfriend_id` <span class="hljs-operator">=</span> bo.`id`<span class="hljs-keyword">WHERE</span> bo.`id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;#案例<span class="hljs-number">1</span>：查询哪个部门没有员工#左外<span class="hljs-keyword">SELECT</span> d.<span class="hljs-operator">*</span>,e.employee_id<span class="hljs-keyword">FROM</span> departments d<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> employees e<span class="hljs-keyword">ON</span> d.`department_id` <span class="hljs-operator">=</span> e.`department_id`<span class="hljs-keyword">WHERE</span> e.`employee_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><p><strong>右外连接</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> ... <span class="hljs-keyword">ON</span> ...或<span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> ... <span class="hljs-keyword">ON</span> ...</code></pre></div><p>举例：</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#右外<span class="hljs-keyword">SELECT</span> d.<span class="hljs-operator">*</span>,e.employee_id<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> departments d<span class="hljs-keyword">ON</span> d.`department_id` <span class="hljs-operator">=</span> e.`department_id`<span class="hljs-keyword">WHERE</span> e.`employee_id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;](MySQL.assets<span class="hljs-operator">/</span><span class="hljs-number">20200810195526.</span>png)](https:<span class="hljs-operator">/</span><span class="hljs-operator">/</span>nyimapicture.oss<span class="hljs-operator">-</span>cn<span class="hljs-operator">-</span>beijing.aliyuncs.com<span class="hljs-operator">/</span>img<span class="hljs-operator">/</span><span class="hljs-number">20200810195526.</span>png)</code></pre></div><p><strong>PS：全外连接<code>FULL</code>是两者的并集，全外连接<code>CROSS</code>是所有的排列组合，是一个笛卡尔乘积</strong></p><p><strong>三种连接的图解</strong></p><p><strong>内连接</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810200025.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200810200025.png" alt="img"></a></p><p><strong>左连接</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810200040.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200810200040.png" alt="img"></a></p><p><strong>右连接</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810200104.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200810200104.png" alt="img"></a></p><p><strong>额外情况</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210428161509573.png" alt="image-20210428161509573"></p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>含义：</p><ul><li>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询</li><li>在外面的查询语句，称为主查询或外查询</li></ul><p>特点：</p><ul><li>子查询都放在小括号内</li><li>子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧</li><li>子查询优先于主查询执行，主查询使用了子查询的执行结果</li><li>子查询根据查询结果的行数不同分为以下两类：<ul><li>标量子查询<ul><li>结果集只有一行</li><li>一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= </li><li>非法使用子查询的情况：<div class="hljs code-wrapper"><pre><code>a、子查询的结果为一组值b、子查询的结果为空</code></pre></div></li></ul></li><li>列子查询<ul><li>结果集有多行 </li><li>一般搭配多行操作符使用：any、all、in、not in </li><li>in： 属于子查询结果中的任意一个就行 </li><li>any：和子查询的某一个比较（可代替）</li><li>all：和子查询的所有比较（可代替）</li></ul></li></ul></li><li><strong>按结果集的行列数不同：</strong><ul><li>标量子查询（结果集只有一行一列）</li><li>列子查询（结果集只有一列多行）</li><li>行子查询（结果集有一行多列）</li><li>表子查询（结果集一般为多行多列）</li></ul></li></ul><blockquote><p>select后面：<br>  仅仅支持标量子查询</p><p>from后面：<br>  支持表子查询<br>where或having后面：★<br>  标量子查询（单行） √<br>  列子查询  （多行） √<br>   行子查询</p><p>exists后面（相关子查询）<br>  表子查询</p></blockquote><p><strong>标量子查询举例：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1</span>：谁的工资比 Abel 高?#①查询Abel的工资<span class="hljs-keyword">SELECT</span> salary<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Abel&#x27;</span>#②查询员工的信息，满足 salary<span class="hljs-operator">&gt;</span>①结果<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> salary<span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">SELECT</span> salary<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Abel&#x27;</span>);#案例<span class="hljs-number">2</span>：返回job_id与<span class="hljs-number">141</span>号员工相同，salary比<span class="hljs-number">143</span>号员工多的员工 姓名，job_id 和工资#①查询<span class="hljs-number">141</span>号员工的job_id<span class="hljs-keyword">SELECT</span> job_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">141</span>#②查询<span class="hljs-number">143</span>号员工的salary<span class="hljs-keyword">SELECT</span> salary<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">143</span>#③查询员工的姓名，job_id 和工资，要求job_id<span class="hljs-operator">=</span>①并且salary<span class="hljs-operator">&gt;</span>②<span class="hljs-keyword">SELECT</span> last_name,job_id,salary<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> job_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> job_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">141</span>) <span class="hljs-keyword">AND</span> salary<span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">SELECT</span> salary<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">143</span>);#案例<span class="hljs-number">3</span>：返回公司工资最少的员工的last_name,job_id和salary#①查询公司的最低工资<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<span class="hljs-keyword">FROM</span> employees#②查询last_name,job_id和salary，要求salary<span class="hljs-operator">=</span>①<span class="hljs-keyword">SELECT</span> last_name,job_id,salary<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> salary<span class="hljs-operator">=</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary)<span class="hljs-keyword">FROM</span> employees);#案例<span class="hljs-number">4</span>：查询最低工资大于<span class="hljs-number">50</span>号部门最低工资的部门id和其最低工资#①查询<span class="hljs-number">50</span>号部门的最低工资<span class="hljs-keyword">SELECT</span>  <span class="hljs-built_in">MIN</span>(salary)<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">50</span>#②查询每个部门的最低工资<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary),department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id#③ 在②基础上筛选，满足<span class="hljs-built_in">min</span>(salary)<span class="hljs-operator">&gt;</span>①<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(salary),department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">MIN</span>(salary)<span class="hljs-operator">&gt;</span>(<span class="hljs-keyword">SELECT</span>  <span class="hljs-built_in">MIN</span>(salary)<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">50</span>);</code></pre></div><p><strong>列子查询举例：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1</span>：返回location_id是<span class="hljs-number">1400</span>或<span class="hljs-number">1700</span>的部门中的所有员工姓名#①查询location_id是<span class="hljs-number">1400</span>或<span class="hljs-number">1700</span>的部门编号<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id<span class="hljs-keyword">FROM</span> departments<span class="hljs-keyword">WHERE</span> location_id <span class="hljs-keyword">IN</span>(<span class="hljs-number">1400</span>,<span class="hljs-number">1700</span>)#②查询员工姓名，要求部门号是①列表中的某一个<span class="hljs-keyword">SELECT</span> last_name<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> department_id <span class="hljs-keyword">IN</span>( #<span class="hljs-operator">&lt;&gt;</span><span class="hljs-keyword">ALL</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id<span class="hljs-keyword">FROM</span> departments<span class="hljs-keyword">WHERE</span> location_id <span class="hljs-keyword">IN</span>(<span class="hljs-number">1400</span>,<span class="hljs-number">1700</span>));#案例<span class="hljs-number">2</span>：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary#①查询job_id为‘IT_PROG’部门任一工资<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> salary<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> job_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;IT_PROG&#x27;</span>#②查询员工号、姓名、job_id 以及salary，salary<span class="hljs-operator">&lt;</span>(①)的任意一个<span class="hljs-keyword">SELECT</span> last_name,employee_id,job_id,salary<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> salary<span class="hljs-operator">&lt;</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary)<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> job_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;IT_PROG&#x27;</span>) <span class="hljs-keyword">AND</span> job_id<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;IT_PROG&#x27;</span>;</code></pre></div><p><strong>行子查询距离</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：查询员工编号最小并且工资最高的员工信息<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> (employee_id,salary)<span class="hljs-operator">=</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(employee_id),<span class="hljs-built_in">MAX</span>(salary)<span class="hljs-keyword">FROM</span> employees);#等同于#①查询最小的员工编号<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(employee_id)<span class="hljs-keyword">FROM</span> employees#②查询最高工资<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary)<span class="hljs-keyword">FROM</span> employees#③查询员工信息<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> employee_id<span class="hljs-operator">=</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(employee_id)<span class="hljs-keyword">FROM</span> employees)<span class="hljs-keyword">AND</span> salary<span class="hljs-operator">=</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary)<span class="hljs-keyword">FROM</span> employees);</code></pre></div><p><strong>select后面的标量子查询</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：查询每个部门的员工个数<span class="hljs-keyword">SELECT</span> d.<span class="hljs-operator">*</span>,(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">WHERE</span> e.department_id <span class="hljs-operator">=</span> d.`department_id` ) 个数 <span class="hljs-keyword">FROM</span> departments d;  #案例<span class="hljs-number">2</span>：查询员工号<span class="hljs-operator">=</span><span class="hljs-number">102</span>的部门名<span class="hljs-keyword">SELECT</span> (<span class="hljs-keyword">SELECT</span> department_name<span class="hljs-keyword">FROM</span> departments d<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> employees e<span class="hljs-keyword">ON</span> d.department_id<span class="hljs-operator">=</span>e.department_id<span class="hljs-keyword">WHERE</span> e.employee_id<span class="hljs-operator">=</span><span class="hljs-number">102</span>) 部门名;</code></pre></div><p><strong>from后面将子查询结果充当一张表，要求必须起别名</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：查询每个部门的平均工资的工资等级#①查询每个部门的平均工资<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary),department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> job_grades;#②连接①的结果集和job_grades表，筛选条件平均工资 <span class="hljs-keyword">between</span> lowest_sal <span class="hljs-keyword">and</span> highest_sal<span class="hljs-keyword">SELECT</span>  ag_dep.<span class="hljs-operator">*</span>,g.`grade_level`<span class="hljs-keyword">FROM</span> (   <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) ag,department_id   <span class="hljs-keyword">FROM</span> employees   <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id) ag_dep<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> job_grades g<span class="hljs-keyword">ON</span> ag_dep.ag <span class="hljs-keyword">BETWEEN</span> lowest_sal <span class="hljs-keyword">AND</span> highest_sal;</code></pre></div><p><strong>exists后面（相关子查询）</strong></p><p>exists(完整的查询语句)，结果：<code>1或0</code></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1</span>：查询有员工的部门名#<span class="hljs-keyword">in</span><span class="hljs-keyword">SELECT</span> department_name<span class="hljs-keyword">FROM</span> departments d<span class="hljs-keyword">WHERE</span> d.`department_id` <span class="hljs-keyword">IN</span>(   <span class="hljs-keyword">SELECT</span> department_id   <span class="hljs-keyword">FROM</span> employees);#<span class="hljs-keyword">exists</span><span class="hljs-keyword">SELECT</span> department_name<span class="hljs-keyword">FROM</span> departments d<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span>(   <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>   <span class="hljs-keyword">FROM</span> employees e   <span class="hljs-keyword">WHERE</span> d.`department_id`<span class="hljs-operator">=</span>e.`department_id`);#案例<span class="hljs-number">2</span>：查询没有女朋友的男神信息#<span class="hljs-keyword">in</span><span class="hljs-keyword">SELECT</span> bo.<span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> boys bo<span class="hljs-keyword">WHERE</span> bo.id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span>(<span class="hljs-keyword">SELECT</span> boyfriend_id<span class="hljs-keyword">FROM</span> beauty);#<span class="hljs-keyword">exists</span><span class="hljs-keyword">SELECT</span> bo.<span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> boys bo<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> boyfriend_id<span class="hljs-keyword">FROM</span> beauty b<span class="hljs-keyword">WHERE</span> bo.`id`<span class="hljs-operator">=</span>b.`boyfriend_id`);</code></pre></div><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a><strong>分页查询</strong></h4><p>应用场景：</p><p>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</p><p>语法：</p><blockquote><p>select 字段|表达式,…<br>from 表<br>【where 条件】<br>【group by 分组字段】<br>【having 条件】<br>【order by 排序的字段】<br>limit 【起始的条目索引offset】条目数size;</p></blockquote><p>特点：</p><ul><li><strong>起始条目索引从0开始</strong></li><li>limit子句放在查询语句的最后</li><li>公式：<code>select * from  表 limit （page-1）*sizePerPage,sizePerPage</code><ul><li>假如:<br>每页显示条目数sizePerPage<br>要显示的页数 page</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1</span>：查询前五条员工信息<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span>  employees LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span>  employees LIMIT <span class="hljs-number">5</span>;#案例<span class="hljs-number">2</span>：查询第<span class="hljs-number">11</span>条——第<span class="hljs-number">25</span>条<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employeesLIMIT <span class="hljs-number">10</span>,<span class="hljs-number">15</span>;#案例<span class="hljs-number">3</span>：有奖金的员工信息，并且工资较高的前<span class="hljs-number">10</span>名显示出来<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> commission_pct <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>LIMIT <span class="hljs-number">10</span>;</code></pre></div><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p><strong>引入</strong><br>union 联合、合并</p><p><strong>语法</strong></p><blockquote><p>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】<br>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】<br>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】<br>…..<br>select 字段|常量|表达式|函数 【from 表】 【where 条件】</p></blockquote><p><strong>特点</strong></p><ul><li>多条查询语句的查询的列数必须是一致的</li><li>多条查询语句的查询的列的类型几乎相同</li><li>union代表去重，union all代表不去重</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql">#引入的案例：查询部门编号<span class="hljs-operator">&gt;</span><span class="hljs-number">90</span>或邮箱包含a的员工信息<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> email <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span>   <span class="hljs-keyword">OR</span> department_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">90</span>;;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> email <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">90</span>;#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息<span class="hljs-keyword">SELECT</span> id,cname <span class="hljs-keyword">FROM</span> t_ca <span class="hljs-keyword">WHERE</span> csex<span class="hljs-operator">=</span><span class="hljs-string">&#x27;男&#x27;</span><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><span class="hljs-keyword">SELECT</span> t_id,tname <span class="hljs-keyword">FROM</span> t_ua <span class="hljs-keyword">WHERE</span> tGender<span class="hljs-operator">=</span><span class="hljs-string">&#x27;male&#x27;</span>;</code></pre></div><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>建表语句及插入语句</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(    s_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">PRIMARY</span> KEY COMMENT<span class="hljs-string">&#x27;学生学号&#x27;</span>,    s_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;学生姓名 不能为空&#x27;</span>,    s_sex <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;学生性别&#x27;</span>,    s_birthday DATETIME COMMENT<span class="hljs-string">&#x27;学生生日&#x27;</span>,    s_class <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT<span class="hljs-string">&#x27;学生所在的班级&#x27;</span>);<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> teacher(    t_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">PRIMARY</span> KEY COMMENT<span class="hljs-string">&#x27;教师编号&#x27;</span>,    t_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;教师姓名&#x27;</span>,    t_sex <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;教师性别&#x27;</span>,    t_birthday DATETIME COMMENT<span class="hljs-string">&#x27;教师生日&#x27;</span>,    t_rof <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;教师职称&#x27;</span>,    t_depart <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;教师所在的部门&#x27;</span>);<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> course(    c_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">PRIMARY</span> KEY COMMENT<span class="hljs-string">&#x27;课程号&#x27;</span>,    c_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;课程名称&#x27;</span>,    t_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;教师编号 外键关联teacher表&#x27;</span>,    <span class="hljs-keyword">FOREIGN</span> KEY(t_no) <span class="hljs-keyword">references</span> teacher(t_no));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> score (    s_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;成绩表的编号 依赖学生学号&#x27;</span>,        c_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT<span class="hljs-string">&#x27;课程号 依赖于课程表中的c_id&#x27;</span>,    sc_degree <span class="hljs-type">decimal</span>,    <span class="hljs-keyword">foreign</span> key(s_no) <span class="hljs-keyword">references</span> student(s_no),    <span class="hljs-keyword">foreign</span> key(c_no) <span class="hljs-keyword">references</span> course(c_no),    <span class="hljs-keyword">PRIMARY</span> KEY(s_no,c_no)); <span class="hljs-comment">--学生表数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;101&#x27;</span>,<span class="hljs-string">&#x27;曾华&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;1977-09-01&#x27;</span>,<span class="hljs-string">&#x27;95033&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;102&#x27;</span>,<span class="hljs-string">&#x27;匡明&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;1975-10-02&#x27;</span>,<span class="hljs-string">&#x27;95031&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;103&#x27;</span>,<span class="hljs-string">&#x27;王丽&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;1976-01-23&#x27;</span>,<span class="hljs-string">&#x27;95033&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;104&#x27;</span>,<span class="hljs-string">&#x27;李军&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;1976-02-20&#x27;</span>,<span class="hljs-string">&#x27;95033&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;105&#x27;</span>,<span class="hljs-string">&#x27;王芳&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;1975-02-10&#x27;</span>,<span class="hljs-string">&#x27;95031&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;106&#x27;</span>,<span class="hljs-string">&#x27;陆军&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;1974-06-03&#x27;</span>,<span class="hljs-string">&#x27;95031&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;107&#x27;</span>,<span class="hljs-string">&#x27;王尼玛&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;1976-02-20&#x27;</span>,<span class="hljs-string">&#x27;95033&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;108&#x27;</span>,<span class="hljs-string">&#x27;张全蛋&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;1975-02-10&#x27;</span>,<span class="hljs-string">&#x27;95031&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;109&#x27;</span>,<span class="hljs-string">&#x27;赵铁柱&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;1974-06-03&#x27;</span>,<span class="hljs-string">&#x27;95031&#x27;</span>);<span class="hljs-comment">--教师表数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> teacher <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;804&#x27;</span>,<span class="hljs-string">&#x27;李诚&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;1958-12-02&#x27;</span>,<span class="hljs-string">&#x27;副教授&#x27;</span>,<span class="hljs-string">&#x27;计算机系&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> teacher <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;856&#x27;</span>,<span class="hljs-string">&#x27;张旭&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;1969-03-12&#x27;</span>,<span class="hljs-string">&#x27;讲师&#x27;</span>,<span class="hljs-string">&#x27;电子工程系&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> teacher <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;825&#x27;</span>,<span class="hljs-string">&#x27;王萍&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;1972-05-05&#x27;</span>,<span class="hljs-string">&#x27;助教&#x27;</span>,<span class="hljs-string">&#x27;计算机系&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> teacher <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;831&#x27;</span>,<span class="hljs-string">&#x27;刘冰&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;1977-08-14&#x27;</span>,<span class="hljs-string">&#x27;助教&#x27;</span>,<span class="hljs-string">&#x27;电子工程系&#x27;</span>);<span class="hljs-comment">--添加课程表</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> course <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;3-105&#x27;</span>,<span class="hljs-string">&#x27;计算机导论&#x27;</span>,<span class="hljs-string">&#x27;825&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> course <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;3-245&#x27;</span>,<span class="hljs-string">&#x27;操作系统&#x27;</span>,<span class="hljs-string">&#x27;804&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> course <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;6-166&#x27;</span>,<span class="hljs-string">&#x27;数字电路&#x27;</span>,<span class="hljs-string">&#x27;856&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> course <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;9-888&#x27;</span>,<span class="hljs-string">&#x27;高等数学&#x27;</span>,<span class="hljs-string">&#x27;831&#x27;</span>);<span class="hljs-comment">--添加成绩表</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;103&#x27;</span>,<span class="hljs-string">&#x27;3-245&#x27;</span>,<span class="hljs-string">&#x27;86&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;105&#x27;</span>,<span class="hljs-string">&#x27;3-245&#x27;</span>,<span class="hljs-string">&#x27;75&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;109&#x27;</span>,<span class="hljs-string">&#x27;3-245&#x27;</span>,<span class="hljs-string">&#x27;68&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;103&#x27;</span>,<span class="hljs-string">&#x27;3-105&#x27;</span>,<span class="hljs-string">&#x27;92&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;105&#x27;</span>,<span class="hljs-string">&#x27;3-105&#x27;</span>,<span class="hljs-string">&#x27;88&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;109&#x27;</span>,<span class="hljs-string">&#x27;3-105&#x27;</span>,<span class="hljs-string">&#x27;76&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;103&#x27;</span>,<span class="hljs-string">&#x27;6-166&#x27;</span>,<span class="hljs-string">&#x27;85&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;105&#x27;</span>,<span class="hljs-string">&#x27;6-166&#x27;</span>,<span class="hljs-string">&#x27;79&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> score <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;109&#x27;</span>,<span class="hljs-string">&#x27;6-166&#x27;</span>,<span class="hljs-string">&#x27;81&#x27;</span>);</code></pre></div><ul><li>查询student表中所有记录的s_name,s_sex和s_class列</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no,s_name,s_class <span class="hljs-keyword">FROM</span>  student;</code></pre></div><ul><li>查询教师所有的单位但是不重复的t_depart列</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span>(t_depart) <span class="hljs-keyword">FROM</span> teacher;</code></pre></div><ul><li>查询score表中成绩在60-80之间所有的记录(sc_degree)</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no, sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">60</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">80</span>;<span class="hljs-keyword">SELECT</span> s_no, sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree <span class="hljs-operator">&gt;</span> <span class="hljs-number">60</span> <span class="hljs-keyword">AND</span> sc_degree <span class="hljs-operator">&lt;</span> <span class="hljs-number">80</span>;</code></pre></div><ul><li>查询score表中成绩为85, 86, 或者88的记录(sc_degree)</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no, sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree <span class="hljs-keyword">IN</span>(<span class="hljs-number">85</span>, <span class="hljs-number">86</span>, <span class="hljs-number">88</span>);</code></pre></div><ul><li>查询student表中’95031’班或者性别为’女’的同学记录</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_class <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95031&#x27;</span> <span class="hljs-keyword">OR</span> s_sex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>;</code></pre></div><ul><li>以sc_degree降序查询score表中所有的记录</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no, sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sc_degree <span class="hljs-keyword">DESC</span>;</code></pre></div><ul><li>查询’95031’班的学生人数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_class <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95031&#x27;</span>;</code></pre></div><ul><li>查询score表中的最高分数的学生号和课程号</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no, c_no <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(sc_degree) <span class="hljs-keyword">FROM</span> score);</code></pre></div><ul><li>查询每门课的平均成绩</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c_no, <span class="hljs-built_in">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c_no;</code></pre></div><ul><li>查询score表中至少有2名学生选修的,并且以3开头的课程的平均分</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c_no, <span class="hljs-built_in">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c_no <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(c_no) <span class="hljs-operator">&gt;=</span><span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> c_no <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;3%&#x27;</span>;</code></pre></div><ul><li>查询所有的学生 s_name , c_no, sc_degree列</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name, c_no, sc_degree <span class="hljs-keyword">FROM</span> student, score <span class="hljs-keyword">WHERE</span> student.s_no <span class="hljs-operator">=</span> score.s_no;</code></pre></div><ul><li>查询所有学生的s_no, c_name, sc_degree列</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_no, c_name, sc_degree <span class="hljs-keyword">FROM</span> student, score, course <span class="hljs-keyword">WHERE</span> student.s_no <span class="hljs-operator">=</span> score.s_no <span class="hljs-keyword">AND</span> score.c_no <span class="hljs-operator">=</span> course.c_no;</code></pre></div><ul><li>查询所有的学生 s_name , c_name, sc_degree列</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name, c_name, sc_degree <span class="hljs-keyword">FROM</span> student, score, course <span class="hljs-keyword">WHERE</span> student.s_no <span class="hljs-operator">=</span> score.s_no <span class="hljs-keyword">AND</span> score.c_no <span class="hljs-operator">=</span> course.c_no;</code></pre></div><ul><li>查询班级是’95031’班学生每门课的平均分</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c_no, <span class="hljs-built_in">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> s_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> s_no <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_class <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95031&#x27;</span>) <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>(c_no);<span class="hljs-keyword">SELECT</span> c_no, <span class="hljs-built_in">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> score <span class="hljs-keyword">AS</span> sc <span class="hljs-keyword">ON</span> s.s_no <span class="hljs-operator">=</span> sc.s_no <span class="hljs-keyword">WHERE</span> s_class <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95031&#x27;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c_no;<span class="hljs-comment">--查询内容包含课程名（c_name）</span><span class="hljs-keyword">SELECT</span> c.c_no, c.c_name, <span class="hljs-built_in">AVG</span>(sc.sc_degree) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s, course <span class="hljs-keyword">AS</span> c, score <span class="hljs-keyword">AS</span> sc <span class="hljs-keyword">WHERE</span> s.s_no <span class="hljs-operator">=</span> sc.s_no <span class="hljs-keyword">AND</span> sc.c_no <span class="hljs-operator">=</span> c.c_no <span class="hljs-keyword">AND</span> s.s_class <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;95031&#x27;</span>  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c.c_no;</code></pre></div><ul><li>查询选修”3-105”课程的成绩高于’109’号同学’3-105’成绩 的所有同学的记录</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s, score <span class="hljs-keyword">AS</span> sc <span class="hljs-keyword">WHERE</span> sc.sc_degree <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> s_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;109&#x27;</span> <span class="hljs-keyword">AND</span> c_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;3-105&#x27;</span>) <span class="hljs-keyword">AND</span> sc.c_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;3-105&#x27;</span> <span class="hljs-keyword">AND</span> s.s_no <span class="hljs-operator">=</span> sc.s_no;</code></pre></div><ul><li>查询所有与学号为108.101的同学同年出生的所有学生的s_no,s_name和s_birthday</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(s_birthday) <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">YEAR</span>(s_birthday) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_no <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-string">&#x27;108&#x27;</span>));</code></pre></div><ul><li>查询 张旭 教师任课的学生的成绩</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.s_name, sc.sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">AS</span> sc, student <span class="hljs-keyword">AS</span> s <span class="hljs-keyword">WHERE</span> c_no <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> c_no <span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">WHERE</span> t_no <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> t_no <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张旭&#x27;</span>)) <span class="hljs-keyword">AND</span> s.s_no <span class="hljs-operator">=</span> sc.s_no;</code></pre></div><ul><li>查询95033班和95031班全体学生的记录</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_class <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;95033&#x27;</span>, <span class="hljs-string">&#x27;95031&#x27;</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> s_class;</code></pre></div><ul><li>查询存在85分以上成绩的c_name和对应的老师</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t_name, c_name <span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">AS</span> c, teacher <span class="hljs-keyword">AS</span> t <span class="hljs-keyword">WHERE</span> c_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> c_no <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree <span class="hljs-operator">&gt;</span> <span class="hljs-number">85</span>) <span class="hljs-keyword">AND</span> c.t_no <span class="hljs-operator">=</span> t.t_no;</code></pre></div><ul><li>查出所有’计算机系’ 教师所教课程的教师信息、课程信息及学生信息</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">AS</span> t, course <span class="hljs-keyword">AS</span> c, student <span class="hljs-keyword">AS</span> s, score <span class="hljs-keyword">AS</span> sc <span class="hljs-keyword">WHERE</span> s.s_no <span class="hljs-operator">=</span> sc.s_no <span class="hljs-keyword">AND</span> c.t_no <span class="hljs-operator">=</span> t.t_no <span class="hljs-keyword">AND</span> sc.c_no <span class="hljs-operator">=</span> c.c_no <span class="hljs-keyword">AND</span> t.t_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> t_no <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_depart <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;计算机系&#x27;</span>);</code></pre></div><ul><li>查询’计算机系’与’电子工程系’ 不同职称的教师的name和rof</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_depart <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;计算机系&#x27;</span> <span class="hljs-keyword">AND</span> t_rof <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> t_rof <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_depart <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;电子工程系&#x27;</span>)<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_depart <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;电子工程系&#x27;</span> <span class="hljs-keyword">AND</span> t_rof <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> t_rof <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_depart <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;计算机系&#x27;</span>);</code></pre></div><ul><li>查询选修编号为”3-105”课程且成绩<strong>至少</strong>高于选修编号为’3-245’同学的c_no,s_no和sc_degree,并且按照sc_degree从高到地次序排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> c_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;3-105&#x27;</span> <span class="hljs-keyword">AND</span> sc_degree <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ANY</span>(<span class="hljs-keyword">SELECT</span> sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> c_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;3-245&#x27;</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sc_degree <span class="hljs-keyword">DESC</span>;</code></pre></div><ul><li>查询选修编号为”3-105”且成绩高于选修编号为”3-245”课程的同学c_no.s_no和sc_degree</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> c_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;3-105&#x27;</span> <span class="hljs-keyword">AND</span> sc_degree <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALL</span>(<span class="hljs-keyword">SELECT</span> sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> c_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;3-245&#x27;</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sc_degree <span class="hljs-keyword">DESC</span>;</code></pre></div><ul><li>查出学生的信息,课程名称,分数(s_name c_name,sc_degree)</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.s_name, c.c_name, sc.sc_degree <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s, course <span class="hljs-keyword">AS</span> c, score <span class="hljs-keyword">AS</span> sc<span class="hljs-keyword">WHERE</span> s.s_no <span class="hljs-operator">=</span> sc.s_no<span class="hljs-keyword">AND</span> c.c_no <span class="hljs-operator">=</span> sc.c_no<span class="hljs-keyword">AND</span> sc.sc_degree <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALL</span>(<span class="hljs-keyword">SELECT</span> sc_degree <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> c_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;3-245&#x27;</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sc_degree <span class="hljs-keyword">DESC</span>;</code></pre></div><p>总结:</p><ul><li><p>ANY 和 ALL</p><ul><li>ANY:表示任何一个就行了,如;数组A中的值比数组B中任何一个都要大,那么只要A和B中最小的比较就行了</li><li>ALL:表示所有都要比较,如:数组A中的值比数组B中所有的数都要大,那么A要和B中最大的值比较才行</li></ul></li><li><p>查询所有教师和同学的 name ,sex, birthday</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name, s_sex, s_birthday <span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> t_name, t_sex, t_birthday <span class="hljs-keyword">FROM</span> teacher;</code></pre></div><ul><li>查询所有’女’教师和’女’学生的name,sex,birthday</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name, s_sex, s_birthday <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_sex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> t_name, t_sex, t_birthday <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_sex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>;</code></pre></div><ul><li>查询成绩比该课程平均成绩低的同学的成绩表</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">AS</span> a <span class="hljs-keyword">WHERE</span> sc_degree <span class="hljs-operator">&lt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">WHERE</span> a.c_no <span class="hljs-operator">=</span> b.c_no);</code></pre></div><ul><li>查询成绩比该课程平均成绩低的同学的成绩表，并显示出学生name,课程name以及分数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.s_name <span class="hljs-keyword">AS</span> 学生姓名, c.c_name <span class="hljs-keyword">AS</span> 课程名, a.sc_degree <span class="hljs-keyword">AS</span> 成绩  <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">AS</span> a, student <span class="hljs-keyword">AS</span> s, course <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">WHERE</span> sc_degree <span class="hljs-operator">&lt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(sc_degree) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">WHERE</span> a.c_no <span class="hljs-operator">=</span> b.c_no)<span class="hljs-keyword">AND</span> s.s_no <span class="hljs-operator">=</span> a.s_no<span class="hljs-keyword">AND</span> c.c_no <span class="hljs-operator">=</span> a.c_no;</code></pre></div><ul><li>查询所有任课教师的t_name 和 t_depart(要在分数表中可以查得到)</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">WHERE</span> t_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> t_no <span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">WHERE</span> c_no <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> c_no <span class="hljs-keyword">FROM</span> score));</code></pre></div><ul><li>查出至少有2名男生的班号</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_class <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_sex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s_class <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(s_no) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;</code></pre></div><ul><li>查询student 表中 不姓”王”的同学的记录</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_name <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;王%&#x27;</span>;</code></pre></div><ul><li>查询student 中每个学生的姓名和年龄(当前时间 - 出生年份)</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name <span class="hljs-keyword">AS</span> 姓名, (<span class="hljs-keyword">YEAR</span>(NOW())<span class="hljs-operator">-</span><span class="hljs-keyword">YEAR</span>(s_birthday)) <span class="hljs-keyword">AS</span> 年龄 <span class="hljs-keyword">FROM</span> student;</code></pre></div><ul><li>查询student中最大和最小的 s_birthday的值</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(s_birthday), <span class="hljs-built_in">MIN</span>(s_birthday) <span class="hljs-keyword">FROM</span> student;</code></pre></div><ul><li>以班级号和年龄从大到小的顺序查询student表中的全部记录</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> s_class <span class="hljs-keyword">DESC</span>, (<span class="hljs-keyword">YEAR</span>(NOW()) <span class="hljs-operator">-</span> <span class="hljs-keyword">YEAR</span>(s_birthday)) <span class="hljs-keyword">DESC</span>;</code></pre></div><ul><li>查询”男”教师 及其所上的课</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t.t_name, c.c_name <span class="hljs-keyword">FROM</span> teacher <span class="hljs-keyword">AS</span> t, course <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">WHERE</span> t.t_sex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>  <span class="hljs-keyword">AND</span> t.t_no <span class="hljs-operator">=</span> c.t_no;</code></pre></div><ul><li>查询最高分同学的s_no c_no 和 sc_degree;</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_no <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> s_no <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> sc_degree  <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(sc_degree) <span class="hljs-keyword">FROM</span> score));</code></pre></div><ul><li>查询和”李军”同性别的所有同学的s_name</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_sex <span class="hljs-operator">=</span>  (<span class="hljs-keyword">SELECT</span> s_sex <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李军&#x27;</span>);</code></pre></div><ul><li>查询和”李军”同性别并且同班的所有同学的s_name</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s_name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_sex <span class="hljs-operator">=</span>  (<span class="hljs-keyword">SELECT</span> s_sex <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李军&#x27;</span>)<span class="hljs-keyword">AND</span> s_class <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> s_class <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> s_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李军&#x27;</span>);</code></pre></div><ul><li>查询所有选修’计算机导论’课程的’男’同学的成绩表，并显示出s_name,c_name</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.s_name, c.c_name, sc.sc_degree <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s, score <span class="hljs-keyword">AS</span> sc, course <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">WHERE</span> s.s_no <span class="hljs-operator">=</span> sc.s_no <span class="hljs-keyword">AND</span> c.c_no <span class="hljs-operator">=</span> sc.c_no <span class="hljs-keyword">AND</span> c.c_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;计算机导论&#x27;</span><span class="hljs-keyword">AND</span> s.s_sex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;</code></pre></div><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p><strong>方式一</strong></p><blockquote><p>INSERT INTO table<br>VALUES (‘’, ‘’…); </p></blockquote><p><strong>举例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#<span class="hljs-number">1.</span>插入的值的类型要与列的类型一致或兼容<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">13</span>,<span class="hljs-string">&#x27;唐艺昕&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;1990-4-23&#x27;</span>,<span class="hljs-string">&#x27;1898888888&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">2</span>);#<span class="hljs-number">2.</span>不可以为<span class="hljs-keyword">null</span>的列必须插入值。可以为<span class="hljs-keyword">null</span>的列如何插入值？#方式一：<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">13</span>,<span class="hljs-string">&#x27;唐艺昕&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;1990-4-23&#x27;</span>,<span class="hljs-string">&#x27;1898888888&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">2</span>);#方式二：<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> beauty(id,NAME,sex,phone)<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">15</span>,<span class="hljs-string">&#x27;娜扎&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;1388888888&#x27;</span>);#<span class="hljs-number">4.</span>列数和值的个数必须一致<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> beauty(NAME,sex,id,phone)<span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;关晓彤&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">17</span>,<span class="hljs-string">&#x27;110&#x27;</span>);#<span class="hljs-number">5.</span>可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> beauty<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;张飞&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;119&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>);</code></pre></div><p><strong>方式二</strong></p><blockquote><p>insert into 表名<br>set 列名=值,列名=值,…</p></blockquote><p><strong>举例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> beauty<span class="hljs-keyword">SET</span> id<span class="hljs-operator">=</span><span class="hljs-number">19</span>,NAME<span class="hljs-operator">=</span><span class="hljs-string">&#x27;刘涛&#x27;</span>,phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;999&#x27;</span>;</code></pre></div><p><strong>两种方式的比较</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#<span class="hljs-number">1</span>、方式一支持插入多行,方式二不支持<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> beauty<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">23</span>,<span class="hljs-string">&#x27;唐艺昕1&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;1990-4-23&#x27;</span>,<span class="hljs-string">&#x27;1898888888&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">24</span>,<span class="hljs-string">&#x27;唐艺昕2&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;1990-4-23&#x27;</span>,<span class="hljs-string">&#x27;1898888888&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">25</span>,<span class="hljs-string">&#x27;唐艺昕3&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;1990-4-23&#x27;</span>,<span class="hljs-string">&#x27;1898888888&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">2</span>);#<span class="hljs-number">2</span>、方式一支持子查询，方式二不支持<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> beauty(id,NAME,phone)<span class="hljs-keyword">SELECT</span> <span class="hljs-number">26</span>,<span class="hljs-string">&#x27;宋茜&#x27;</span>,<span class="hljs-string">&#x27;11809866&#x27;</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> beauty(id,NAME,phone)<span class="hljs-keyword">SELECT</span> id,boyname,<span class="hljs-string">&#x27;1234567&#x27;</span><span class="hljs-keyword">FROM</span> boys <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">&lt;</span><span class="hljs-number">3</span>;</code></pre></div><p><strong>练习</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#方式一：<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> my_employees<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;patel&#x27;</span>,<span class="hljs-string">&#x27;Ralph&#x27;</span>,<span class="hljs-string">&#x27;Rpatel&#x27;</span>,<span class="hljs-number">895</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Dancs&#x27;</span>,<span class="hljs-string">&#x27;Betty&#x27;</span>,<span class="hljs-string">&#x27;Bdancs&#x27;</span>,<span class="hljs-number">860</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Biri&#x27;</span>,<span class="hljs-string">&#x27;Ben&#x27;</span>,<span class="hljs-string">&#x27;Bbiri&#x27;</span>,<span class="hljs-number">1100</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Newman&#x27;</span>,<span class="hljs-string">&#x27;Chad&#x27;</span>,<span class="hljs-string">&#x27;Cnewman&#x27;</span>,<span class="hljs-number">750</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Ropeburn&#x27;</span>,<span class="hljs-string">&#x27;Audrey&#x27;</span>,<span class="hljs-string">&#x27;Aropebur&#x27;</span>,<span class="hljs-number">1550</span>);<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> my_employees;#方式二：<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> my_employees<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>,<span class="hljs-string">&#x27;patel&#x27;</span>,<span class="hljs-string">&#x27;Ralph&#x27;</span>,<span class="hljs-string">&#x27;Rpatel&#x27;</span>,<span class="hljs-number">895</span> <span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Dancs&#x27;</span>,<span class="hljs-string">&#x27;Betty&#x27;</span>,<span class="hljs-string">&#x27;Bdancs&#x27;</span>,<span class="hljs-number">860</span> <span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Biri&#x27;</span>,<span class="hljs-string">&#x27;Ben&#x27;</span>,<span class="hljs-string">&#x27;Bbiri&#x27;</span>,<span class="hljs-number">1100</span> <span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Newman&#x27;</span>,<span class="hljs-string">&#x27;Chad&#x27;</span>,<span class="hljs-string">&#x27;Cnewman&#x27;</span>,<span class="hljs-number">750</span> <span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Ropeburn&#x27;</span>,<span class="hljs-string">&#x27;Audrey&#x27;</span>,<span class="hljs-string">&#x27;Aropebur&#x27;</span>,<span class="hljs-number">1550</span>;</code></pre></div><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a><strong>删除操作</strong></h4><p><strong>方式一：DELETE</strong></p><p><strong>单表的删除★</strong></p><blockquote><p>DELETE FROM table<br>WHERE cow = ‘’; </p></blockquote><p><strong>举例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：删除手机号以<span class="hljs-number">9</span>结尾的女神信息<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> beauty <span class="hljs-keyword">WHERE</span> phone <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%9&#x27;</span>;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> beauty;</code></pre></div><p><strong>多表的删除</strong></p><blockquote><p>#sql92语法：<br>delete 表1的别名,表2的别名<br>from 表1 别名,表2 别名<br>where 连接条件<br>and 筛选条件;</p><p>#sql99语法：</p><p>delete 表1的别名,表2的别名<br>from 表1 别名<br>inner|left|right join 表2 别名 on 连接条件<br>where 筛选条件;</p></blockquote><p><strong>举例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：删除张无忌的女朋友的信息<span class="hljs-keyword">DELETE</span> b<span class="hljs-keyword">FROM</span> beauty b<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> boys bo <span class="hljs-keyword">ON</span> b.`boyfriend_id` <span class="hljs-operator">=</span> bo.`id`<span class="hljs-keyword">WHERE</span> bo.`boyName`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;张无忌&#x27;</span>;#案例：删除黄晓明的信息以及他女朋友的信息<span class="hljs-keyword">DELETE</span> b,bo<span class="hljs-keyword">FROM</span> beauty b<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> boys bo <span class="hljs-keyword">ON</span> b.`boyfriend_id`<span class="hljs-operator">=</span>bo.`id`<span class="hljs-keyword">WHERE</span> bo.`boyName`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;黄晓明&#x27;</span>;</code></pre></div><p><strong>方式二：truncate语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：将魅力值<span class="hljs-operator">&gt;</span><span class="hljs-number">100</span>的男神信息删除<span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> boys ;</code></pre></div><p><strong>比较</strong></p><ul><li>delete 可以加where 条件，truncate不能加</li><li>truncate删除，效率高一丢丢</li><li>假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。</li><li>truncate删除没有返回值，delete删除有返回值</li><li>truncate删除不能回滚，delete删除可以回滚.</li></ul><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a><strong>修改数据</strong></h4><p><strong>修改单表的记录★</strong></p><blockquote><p>update 表名<br>set 列=新值,列=新值,…<br>where 筛选条件;</p></blockquote><p><strong>举例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1</span>：修改beauty表中姓唐的女神的电话为<span class="hljs-number">13899888899</span>UPDATE beauty <span class="hljs-keyword">SET</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;13899888899&#x27;</span><span class="hljs-keyword">WHERE</span> NAME <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;唐%&#x27;</span>;#案例<span class="hljs-number">2</span>：修改boys表中id好为<span class="hljs-number">2</span>的名称为张飞，魅力值 <span class="hljs-number">10</span>UPDATE boys <span class="hljs-keyword">SET</span> boyname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;张飞&#x27;</span>,usercp<span class="hljs-operator">=</span><span class="hljs-number">10</span><span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;</code></pre></div><p><strong>修改多表的记录</strong></p><blockquote><p>#sql92语法：<br>update 表1 别名,表2 别名<br>set 列=值,…<br>where 连接条件<br>and 筛选条件;</p><p>#sql99语法：<br>update 表1 别名<br>inner|left|right join 表2 别名<br>on 连接条件<br>set 列=值,…<br>where 筛选条件;</p></blockquote><p><strong>举例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例 <span class="hljs-number">1</span>：修改张无忌的女朋友的手机号为<span class="hljs-number">114</span>UPDATE boys bo<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> beauty b <span class="hljs-keyword">ON</span> bo.`id`<span class="hljs-operator">=</span>b.`boyfriend_id`<span class="hljs-keyword">SET</span> b.`phone`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;119&#x27;</span>,bo.`userCP`<span class="hljs-operator">=</span><span class="hljs-number">1000</span><span class="hljs-keyword">WHERE</span> bo.`boyName`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;张无忌&#x27;</span>;#案例<span class="hljs-number">2</span>：修改没有男朋友的女神的男朋友编号都为<span class="hljs-number">2</span>号UPDATE boys bo<span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> beauty b <span class="hljs-keyword">ON</span> bo.`id`<span class="hljs-operator">=</span>b.`boyfriend_id`<span class="hljs-keyword">SET</span> b.`boyfriend_id`<span class="hljs-operator">=</span><span class="hljs-number">2</span><span class="hljs-keyword">WHERE</span> bo.`id` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> boys;</code></pre></div><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><blockquote><p>说明：变量由系统定义，不是用户定义，属于服务器层面<br>注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别<br>使用步骤：<br>1、查看所有系统变量<br>show global|【session】variables;<br>2、查看满足条件的部分系统变量<br>show global|【session】 variables like ‘%char%’;<br>3、查看指定的系统变量的值<br>select @@global|【session】系统变量名;<br>4、为某个系统变量赋值<br>方式一：<br>set global|【session】系统变量名=值;<br>方式二：<br>set @@global|【session】系统变量名=值;</p></blockquote><p><strong>全局变量</strong></p><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#①查看所有全局变量<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> VARIABLES;#②查看满足条件的部分系统变量<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%char%&#x27;</span>;#③查看指定的系统变量的值<span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@global</span>.autocommit;#④为某个系统变量赋值<span class="hljs-keyword">SET</span> @<span class="hljs-variable">@global</span>.autocommit<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> autocommit<span class="hljs-operator">=</span><span class="hljs-number">0</span>;</code></pre></div><p><strong>会话变量</strong></p><p>作用域：针对于当前会话（连接）有效</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#①查看所有会话变量<span class="hljs-keyword">SHOW</span> SESSION VARIABLES;#②查看满足条件的部分会话变量<span class="hljs-keyword">SHOW</span> SESSION VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%char%&#x27;</span>;#③查看指定的会话变量的值<span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@autocommit</span>;<span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@session</span>.tx_isolation;#④为某个会话变量赋值<span class="hljs-keyword">SET</span> @<span class="hljs-variable">@session</span>.tx_isolation<span class="hljs-operator">=</span><span class="hljs-string">&#x27;read-uncommitted&#x27;</span>;<span class="hljs-keyword">SET</span> SESSION tx_isolation<span class="hljs-operator">=</span><span class="hljs-string">&#x27;read-committed&#x27;</span>;</code></pre></div><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><blockquote><p>说明：变量由用户自定义，而不是系统提供的<br>使用步骤：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）</p></blockquote><p><strong>用户变量</strong></p><p>作用域：针对于当前会话（连接）有效，作用域同于会话变量</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#①声明并初始化,<span class="hljs-operator">=</span>或:<span class="hljs-operator">=</span><span class="hljs-keyword">SET</span> @变量名<span class="hljs-operator">=</span>值;<span class="hljs-keyword">SET</span> @变量名:<span class="hljs-operator">=</span>值;<span class="hljs-keyword">SELECT</span> @变量名:<span class="hljs-operator">=</span>值;#②赋值（更新变量的值）#方式一：   <span class="hljs-keyword">SET</span> @变量名<span class="hljs-operator">=</span>值;   <span class="hljs-keyword">SET</span> @变量名:<span class="hljs-operator">=</span>值;   <span class="hljs-keyword">SELECT</span> @变量名:<span class="hljs-operator">=</span>值;#方式二：   <span class="hljs-keyword">SELECT</span> 字段 <span class="hljs-keyword">INTO</span> @变量名   <span class="hljs-keyword">FROM</span> 表;#③使用（查看变量的值）<span class="hljs-keyword">SELECT</span> @变量名;</code></pre></div><p><strong>局部变量</strong></p><p>作用域：仅仅在定义它的begin end块中有效<br>应用在 begin end中的第一句话</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#①声明<span class="hljs-keyword">DECLARE</span> 变量名 类型;<span class="hljs-keyword">DECLARE</span> 变量名 类型 【<span class="hljs-keyword">DEFAULT</span> 值】;#②赋值（更新变量的值）#方式一：   <span class="hljs-keyword">SET</span> 局部变量名<span class="hljs-operator">=</span>值;   <span class="hljs-keyword">SET</span> 局部变量名:<span class="hljs-operator">=</span>值;   <span class="hljs-keyword">SELECT</span> @局部变量名:<span class="hljs-operator">=</span>值;#方式二：   <span class="hljs-keyword">SELECT</span> 字段 <span class="hljs-keyword">INTO</span> 具备变量名   <span class="hljs-keyword">FROM</span> 表;   #③使用（查看变量的值）<span class="hljs-keyword">SELECT</span> 局部变量名;</code></pre></div><p><strong>举例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：声明两个变量，求和并打印#用户变量<span class="hljs-keyword">SET</span> <span class="hljs-variable">@m</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>;<span class="hljs-keyword">SET</span> <span class="hljs-variable">@n</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>;<span class="hljs-keyword">SET</span> <span class="hljs-variable">@sum</span><span class="hljs-operator">=</span><span class="hljs-variable">@m</span><span class="hljs-operator">+</span><span class="hljs-variable">@n</span>;<span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@sum</span>;#局部变量<span class="hljs-keyword">DECLARE</span> m <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">DECLARE</span> n <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">DECLARE</span> SUM <span class="hljs-type">INT</span>;<span class="hljs-keyword">SET</span> SUM<span class="hljs-operator">=</span>m<span class="hljs-operator">+</span>n;<span class="hljs-keyword">SELECT</span> SUM;</code></pre></div><blockquote><div class="hljs code-wrapper"><pre><code class="hljs ada">       作用域          定义位置      语法用户变量   当前会话      会话的任何地方       加@符号，不用指定类型局部变量   定义它的<span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">END</span>中     <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">END</span>的第一句话 一般不用加@,需要指定类型</code></pre></div></blockquote><h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><p>提高代码的重用性，简化操作</p><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><blockquote><p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p></blockquote><p><strong>语法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名(参数列表)<span class="hljs-keyword">BEGIN</span>   存储过程体（一组合法的<span class="hljs-keyword">SQL</span>语句）<span class="hljs-keyword">END</span></code></pre></div><p><strong>参数列表包含三部分</strong></p><ul><li>参数模式  </li><li>参数名  </li><li>参数类型</li></ul><p>例如：<code>in stuname varchar(20)</code></p><p><strong>参数模式：</strong></p><ul><li>in：该参数可以作为输入，也就是该参数需要调用方传入值</li><li>out：该参数可以作为输出，也就是该参数可以作为返回值</li><li>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</li></ul><p><strong>特别需要注意的是：</strong></p><ul><li>如果存储过程体仅仅只有一句话，begin end可以省略</li><li>存储过程体中的每条sql语句的结尾要求必须加分号</li><li>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br>delimiter 结束标记<br>案例：<br>delimiter $</li></ul><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> 存储过程名(实参列表);</code></pre></div><p><strong>空参列表</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：插入到admin表中五条记录DELIMITER $<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> myp1()<span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> admin(username,`password`)    <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;john1&#x27;</span>,<span class="hljs-string">&#x27;0000&#x27;</span>),(<span class="hljs-string">&#x27;lily&#x27;</span>,<span class="hljs-string">&#x27;0000&#x27;</span>),(<span class="hljs-string">&#x27;rose&#x27;</span>,<span class="hljs-string">&#x27;0000&#x27;</span>),(<span class="hljs-string">&#x27;jack&#x27;</span>,<span class="hljs-string">&#x27;0000&#x27;</span>),(<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-string">&#x27;0000&#x27;</span>);<span class="hljs-keyword">END</span> $<span class="hljs-keyword">CALL</span> myp1()$</code></pre></div><p><strong>创建带in模式参数的存储过程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1</span>：创建存储过程实现 根据女神名，查询对应的男神信息DELIMITER $<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> myp2(<span class="hljs-keyword">IN</span> beautyName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>))<span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">SELECT</span> bo.<span class="hljs-operator">*</span>   <span class="hljs-keyword">FROM</span> boys bo   <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> beauty b <span class="hljs-keyword">ON</span> bo.id <span class="hljs-operator">=</span> b.boyfriend_id   <span class="hljs-keyword">WHERE</span> b.name<span class="hljs-operator">=</span>beautyName;   <span class="hljs-keyword">END</span> $#调用<span class="hljs-keyword">CALL</span> myp2(<span class="hljs-string">&#x27;柳岩&#x27;</span>)$#案例<span class="hljs-number">2</span> ：创建存储过程实现，用户是否登录成功<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> myp4(<span class="hljs-keyword">IN</span> username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<span class="hljs-keyword">IN</span> PASSWORD <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>))<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> <span class="hljs-keyword">result</span> <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;#声明并初始化<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">result</span>#赋值<span class="hljs-keyword">FROM</span> admin<span class="hljs-keyword">WHERE</span> admin.username <span class="hljs-operator">=</span> username<span class="hljs-keyword">AND</span> admin.password <span class="hljs-operator">=</span> PASSWORD;<span class="hljs-keyword">SELECT</span> IF(<span class="hljs-keyword">result</span><span class="hljs-operator">&gt;</span><span class="hljs-number">0</span>,<span class="hljs-string">&#x27;成功&#x27;</span>,<span class="hljs-string">&#x27;失败&#x27;</span>);#使用<span class="hljs-keyword">END</span> $#调用<span class="hljs-keyword">CALL</span> myp3(<span class="hljs-string">&#x27;张飞&#x27;</span>,<span class="hljs-string">&#x27;8888&#x27;</span>)$</code></pre></div><p><strong>创建out模式参数的存储过程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1</span>：根据输入的女神名，返回对应的男神名<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> myp6(<span class="hljs-keyword">IN</span> beautyName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<span class="hljs-keyword">OUT</span> boyName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>))<span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">SELECT</span> bo.boyname <span class="hljs-keyword">INTO</span> boyname   <span class="hljs-keyword">FROM</span> boys bo   <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span>   beauty b <span class="hljs-keyword">ON</span> b.boyfriend_id <span class="hljs-operator">=</span> bo.id   <span class="hljs-keyword">WHERE</span> b.name<span class="hljs-operator">=</span>beautyName ;   <span class="hljs-keyword">END</span> $<span class="hljs-keyword">CALL</span> myp6(<span class="hljs-string">&#x27;Luci&#x27;</span>,<span class="hljs-variable">@bname</span>)$<span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@bname</span>$#案例<span class="hljs-number">2</span>：根据输入的女神名，返回对应的男神名和魅力值<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> myp7(<span class="hljs-keyword">IN</span> beautyName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<span class="hljs-keyword">OUT</span> boyName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<span class="hljs-keyword">OUT</span> usercp <span class="hljs-type">INT</span>) <span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">SELECT</span> boys.boyname ,boys.usercp <span class="hljs-keyword">INTO</span> boyname,usercp<span class="hljs-keyword">FROM</span> boys <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span>beauty b <span class="hljs-keyword">ON</span> b.boyfriend_id <span class="hljs-operator">=</span> boys.id<span class="hljs-keyword">WHERE</span> b.name<span class="hljs-operator">=</span>beautyName ;<span class="hljs-keyword">END</span> $#调用<span class="hljs-keyword">CALL</span> myp7(<span class="hljs-string">&#x27;小昭&#x27;</span>,<span class="hljs-variable">@name</span>,<span class="hljs-variable">@cp</span>)$<span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@name</span>,<span class="hljs-variable">@cp</span>$</code></pre></div><p><strong>创建带inout模式参数的存储过程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1</span>：传入a和b两个值，最终a和b都翻倍并返回<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> myp8(<span class="hljs-keyword">INOUT</span> a <span class="hljs-type">INT</span> ,<span class="hljs-keyword">INOUT</span> b <span class="hljs-type">INT</span>)<span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">SET</span> a<span class="hljs-operator">=</span>a<span class="hljs-operator">*</span><span class="hljs-number">2</span>;   <span class="hljs-keyword">SET</span> b<span class="hljs-operator">=</span>b<span class="hljs-operator">*</span><span class="hljs-number">2</span>;<span class="hljs-keyword">END</span> $#调用<span class="hljs-keyword">SET</span> <span class="hljs-variable">@m</span><span class="hljs-operator">=</span><span class="hljs-number">10</span>$<span class="hljs-keyword">SET</span> <span class="hljs-variable">@n</span><span class="hljs-operator">=</span><span class="hljs-number">20</span>$<span class="hljs-keyword">CALL</span> myp8(<span class="hljs-variable">@m</span>,<span class="hljs-variable">@n</span>)$<span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@m</span>,<span class="hljs-variable">@n</span>$</code></pre></div><p><strong>删除存储过程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> p1;<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> p2,p3;#不支持删除多个</code></pre></div><p><strong>查看存储过程的信息</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span>  myp2;</code></pre></div><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><blockquote><p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p></blockquote><p><strong>区别</strong></p><p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p><p><strong>语法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> 函数名(参数列表) <span class="hljs-keyword">RETURNS</span> 返回类型<span class="hljs-keyword">BEGIN</span>   函数体<span class="hljs-keyword">END</span></code></pre></div><p><strong>注意</strong></p><blockquote><p>1.参数列表 包含两部分： 参数名 参数类型</p><p>2.函数体：肯定会有return语句，如果没有会报错 如果return语句没有放在函数体的最后也不报错，但不建议</p><p>3.函数体中仅有一句话，则可以省略begin end 4.使用 delimiter语句设置结束标记</p></blockquote><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 函数名(参数列表)</code></pre></div><p><strong>无参有返回</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：返回公司的员工个数<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> myf1() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span><span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">DECLARE</span> c <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;#定义局部变量   <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">INTO</span> c#赋值   <span class="hljs-keyword">FROM</span> employees;   <span class="hljs-keyword">RETURN</span> c;   <span class="hljs-keyword">END</span> $<span class="hljs-keyword">SELECT</span> myf1()$</code></pre></div><p><strong>有参有返回</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1</span>：根据员工名，返回它的工资<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> myf2(empName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)) <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">DOUBLE</span><span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">SET</span> <span class="hljs-variable">@sal</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>;#定义用户变量    <span class="hljs-keyword">SELECT</span> salary <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@sal</span>   #赋值   <span class="hljs-keyword">FROM</span> employees   <span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> empName;      <span class="hljs-keyword">RETURN</span> <span class="hljs-variable">@sal</span>;<span class="hljs-keyword">END</span> $<span class="hljs-keyword">SELECT</span> myf2(<span class="hljs-string">&#x27;k_ing&#x27;</span>) $#案例<span class="hljs-number">2</span>：根据部门名，返回该部门的平均工资<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> myf3(deptName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)) <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">DOUBLE</span><span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">DECLARE</span> sal <span class="hljs-keyword">DOUBLE</span> ;   <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">INTO</span> sal   <span class="hljs-keyword">FROM</span> employees e   <span class="hljs-keyword">JOIN</span> departments d <span class="hljs-keyword">ON</span> e.department_id <span class="hljs-operator">=</span> d.department_id   <span class="hljs-keyword">WHERE</span> d.department_name<span class="hljs-operator">=</span>deptName;   <span class="hljs-keyword">RETURN</span> sal;<span class="hljs-keyword">END</span> $<span class="hljs-keyword">SELECT</span> myf3(<span class="hljs-string">&#x27;IT&#x27;</span>)$</code></pre></div><p><strong>查看函数</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> myf3;</code></pre></div><p><strong>删除函数</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> myf3;</code></pre></div><p><strong>案例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#一、创建函数，实现传入两个<span class="hljs-type">float</span>，返回二者之和<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> test_fun1(num1 <span class="hljs-type">FLOAT</span>,num2 <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">FLOAT</span><span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">DECLARE</span> SUM <span class="hljs-type">FLOAT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;   <span class="hljs-keyword">SET</span> SUM<span class="hljs-operator">=</span>num1<span class="hljs-operator">+</span>num2;   <span class="hljs-keyword">RETURN</span> SUM;<span class="hljs-keyword">END</span> $<span class="hljs-keyword">SELECT</span> test_fun1(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)$</code></pre></div><h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h4 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h4><blockquote><p>语法：if(条件,值1，值2)<br>功能：实现双分支<br>应用在begin end中或外面</p></blockquote><h4 id="case函数"><a href="#case函数" class="headerlink" title="case函数"></a>case函数</h4><blockquote><p>情况1：类似于switch<br>case 变量或表达式<br>when 判断的值1 then 返回的值1或语句;<br>when 判断的值2 then 返回的值2或语句;<br>…<br>else 返回的值n或语句;<br>end </p><p>情况2：<br>case<br>when 判断的值1 then 返回的值1或语句;<br>when 判断的值2 then 返回的值2或语句;<br>…<br>else 返回的值n或语句;<br>end </p><p>应用在begin end 中或外面</p><p>ps:如果是语句，只能放在begin end中</p></blockquote><h4 id="if结构"><a href="#if结构" class="headerlink" title="if结构"></a>if结构</h4><blockquote><p>if 条件1 then 语句1;<br>elseif 条件2 then 语句2;<br>….<br>else 语句n;<br>end if;<br>功能：类似于多重if</p><p>只能应用在begin end 中</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例<span class="hljs-number">1</span>：创建函数，实现传入成绩，如果成绩<span class="hljs-operator">&gt;</span><span class="hljs-number">90</span>,返回A，如果成绩<span class="hljs-operator">&gt;</span><span class="hljs-number">80</span>,返回B，如果成绩<span class="hljs-operator">&gt;</span><span class="hljs-number">60</span>,返回C，否则返回D<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> test_if(score <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">CHAR</span><span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">DECLARE</span> ch <span class="hljs-type">CHAR</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;A&#x27;</span>;   IF score<span class="hljs-operator">&gt;</span><span class="hljs-number">90</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;A&#x27;</span>;   ELSEIF score<span class="hljs-operator">&gt;</span><span class="hljs-number">80</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;B&#x27;</span>;   ELSEIF score<span class="hljs-operator">&gt;</span><span class="hljs-number">60</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;C&#x27;</span>;   <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">SET</span> ch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;D&#x27;</span>;   <span class="hljs-keyword">END</span> IF;   <span class="hljs-keyword">RETURN</span> ch;      <span class="hljs-keyword">END</span> $<span class="hljs-keyword">SELECT</span> test_if(<span class="hljs-number">87</span>)$#案例<span class="hljs-number">2</span>：创建存储过程，如果工资<span class="hljs-operator">&lt;</span><span class="hljs-number">2000</span>,则删除，如果<span class="hljs-number">5000</span><span class="hljs-operator">&gt;</span>工资<span class="hljs-operator">&gt;</span><span class="hljs-number">2000</span>,则涨工资<span class="hljs-number">1000</span>，否则涨工资<span class="hljs-number">500</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> test_if_pro(<span class="hljs-keyword">IN</span> sal <span class="hljs-keyword">DOUBLE</span>)<span class="hljs-keyword">BEGIN</span>   IF sal<span class="hljs-operator">&lt;</span><span class="hljs-number">2000</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> employees.salary<span class="hljs-operator">=</span>sal;   ELSEIF sal<span class="hljs-operator">&gt;=</span><span class="hljs-number">2000</span> <span class="hljs-keyword">AND</span> sal<span class="hljs-operator">&lt;</span><span class="hljs-number">5000</span> <span class="hljs-keyword">THEN</span> UPDATE employees <span class="hljs-keyword">SET</span> salary<span class="hljs-operator">=</span>salary<span class="hljs-operator">+</span><span class="hljs-number">1000</span> <span class="hljs-keyword">WHERE</span> employees.`salary`<span class="hljs-operator">=</span>sal;   <span class="hljs-keyword">ELSE</span> UPDATE employees <span class="hljs-keyword">SET</span> salary<span class="hljs-operator">=</span>salary<span class="hljs-operator">+</span><span class="hljs-number">500</span> <span class="hljs-keyword">WHERE</span> employees.`salary`<span class="hljs-operator">=</span>sal;   <span class="hljs-keyword">END</span> IF;   <span class="hljs-keyword">END</span> $<span class="hljs-keyword">CALL</span> test_if_pro(<span class="hljs-number">2100</span>)$#案例<span class="hljs-number">3</span>：创建函数，实现传入成绩，如果成绩<span class="hljs-operator">&gt;</span><span class="hljs-number">90</span>,返回A，如果成绩<span class="hljs-operator">&gt;</span><span class="hljs-number">80</span>,返回B，如果成绩<span class="hljs-operator">&gt;</span><span class="hljs-number">60</span>,返回C，否则返回D<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> test_case(score <span class="hljs-type">FLOAT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">CHAR</span><span class="hljs-keyword">BEGIN</span>    <span class="hljs-keyword">DECLARE</span> ch <span class="hljs-type">CHAR</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;A&#x27;</span>;      <span class="hljs-keyword">CASE</span>    <span class="hljs-keyword">WHEN</span> score<span class="hljs-operator">&gt;</span><span class="hljs-number">90</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;A&#x27;</span>;   <span class="hljs-keyword">WHEN</span> score<span class="hljs-operator">&gt;</span><span class="hljs-number">80</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;B&#x27;</span>;   <span class="hljs-keyword">WHEN</span> score<span class="hljs-operator">&gt;</span><span class="hljs-number">60</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">SET</span> ch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;C&#x27;</span>;   <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">SET</span> ch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;D&#x27;</span>;   <span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;      <span class="hljs-keyword">RETURN</span> ch;<span class="hljs-keyword">END</span> $<span class="hljs-keyword">SELECT</span> test_case(<span class="hljs-number">56</span>)$</code></pre></div><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><blockquote><p>【标签:】while 循环条件 do<br>   循环体;<br>end while【 标签】;</p><p>联想：</p><p>while(循环条件){</p><p>   循环体;<br>}</p></blockquote><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><blockquote><p>【标签:】loop<br>   循环体;<br>end loop 【标签】;</p><p>可以用来模拟简单的死循环</p></blockquote><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><blockquote><p>【标签：】repeat<br>   循环体;<br>until 结束循环的条件<br>end repeat 【标签】;</p></blockquote><p><strong>没有添加循环控制语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：批量插入，根据次数插入到admin表中多条记录<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> pro_while1$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> pro_while1(<span class="hljs-keyword">IN</span> insertCount <span class="hljs-type">INT</span>)<span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>;   WHILE i<span class="hljs-operator">&lt;=</span>insertCount DO      <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> admin(username,`password`) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;Rose&#x27;</span>,i),<span class="hljs-string">&#x27;666&#x27;</span>);      <span class="hljs-keyword">SET</span> i<span class="hljs-operator">=</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;   <span class="hljs-keyword">END</span> WHILE;   <span class="hljs-keyword">END</span> $<span class="hljs-keyword">CALL</span> pro_while1(<span class="hljs-number">100</span>)$</code></pre></div><p>iterate类似于 continue，继续，结束本次循环，继续下一次<br>leave 类似于  break，跳出，结束当前所在的循环</p><p><strong>添加leave语句</strong>（此时必须加名称）</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：批量插入，根据次数插入到admin表中多条记录，如果次数<span class="hljs-operator">&gt;</span><span class="hljs-number">20</span>则停止<span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> admin$<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> test_while1$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> test_while1(<span class="hljs-keyword">IN</span> insertCount <span class="hljs-type">INT</span>)<span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>;   a:WHILE i<span class="hljs-operator">&lt;=</span>insertCount DO      <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> admin(username,`password`) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;xiaohua&#x27;</span>,i),<span class="hljs-string">&#x27;0000&#x27;</span>);      IF i<span class="hljs-operator">&gt;=</span><span class="hljs-number">20</span> <span class="hljs-keyword">THEN</span> LEAVE a;      <span class="hljs-keyword">END</span> IF;      <span class="hljs-keyword">SET</span> i<span class="hljs-operator">=</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;   <span class="hljs-keyword">END</span> WHILE a;<span class="hljs-keyword">END</span> $<span class="hljs-keyword">CALL</span> test_while1(<span class="hljs-number">100</span>)$</code></pre></div><p><strong>添加iterate语句</strong>（此时必须加名称）</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次<span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> admin$<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> test_while1$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> test_while1(<span class="hljs-keyword">IN</span> insertCount <span class="hljs-type">INT</span>)<span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;   a:WHILE i<span class="hljs-operator">&lt;=</span>insertCount DO      <span class="hljs-keyword">SET</span> i<span class="hljs-operator">=</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;      IF <span class="hljs-built_in">MOD</span>(i,<span class="hljs-number">2</span>)<span class="hljs-operator">!=</span><span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> ITERATE a;      <span class="hljs-keyword">END</span> IF;            <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> admin(username,`password`) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;xiaohua&#x27;</span>,i),<span class="hljs-string">&#x27;0000&#x27;</span>);         <span class="hljs-keyword">END</span> WHILE a;<span class="hljs-keyword">END</span> $<span class="hljs-keyword">CALL</span> test_while1(<span class="hljs-number">100</span>)$</code></pre></div><p><strong>案例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">/*已知表stringcontent</span><span class="hljs-comment">其中字段：</span><span class="hljs-comment">id 自增长</span><span class="hljs-comment">content varchar(20)</span><span class="hljs-comment"></span><span class="hljs-comment">向该表插入指定个数的，随机的字符串</span><span class="hljs-comment">*/</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> stringcontent;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> stringcontent(   id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,   content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)   );DELIMITER $<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> test_randstr_insert(<span class="hljs-keyword">IN</span> insertCount <span class="hljs-type">INT</span>)<span class="hljs-keyword">BEGIN</span>   <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>;   <span class="hljs-keyword">DECLARE</span> str <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">26</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;   <span class="hljs-keyword">DECLARE</span> startIndex <span class="hljs-type">INT</span>;#代表初始索引   <span class="hljs-keyword">DECLARE</span> len <span class="hljs-type">INT</span>;#代表截取的字符长度   WHILE i<span class="hljs-operator">&lt;=</span>insertcount DO      <span class="hljs-keyword">SET</span> startIndex<span class="hljs-operator">=</span><span class="hljs-built_in">FLOOR</span>(RAND()<span class="hljs-operator">*</span><span class="hljs-number">26</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>);#代表初始索引，随机范围<span class="hljs-number">1</span><span class="hljs-number">-26</span>      <span class="hljs-keyword">SET</span> len<span class="hljs-operator">=</span><span class="hljs-built_in">FLOOR</span>(RAND()<span class="hljs-operator">*</span>(<span class="hljs-number">20</span><span class="hljs-operator">-</span>startIndex<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<span class="hljs-operator">+</span><span class="hljs-number">1</span>);#代表截取长度，随机范围<span class="hljs-number">1</span><span class="hljs-operator">-</span>（<span class="hljs-number">20</span><span class="hljs-operator">-</span>startIndex<span class="hljs-operator">+</span><span class="hljs-number">1</span>）,content<span class="hljs-number">-20</span>      <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> stringcontent(content) <span class="hljs-keyword">VALUES</span>(SUBSTR(str,startIndex,len));      <span class="hljs-keyword">SET</span> i<span class="hljs-operator">=</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;   <span class="hljs-keyword">END</span> WHILE;<span class="hljs-keyword">END</span> $<span class="hljs-keyword">CALL</span> test_randstr_insert(<span class="hljs-number">10</span>)$</code></pre></div><h1 id="二、约束"><a href="#二、约束" class="headerlink" title="二、约束"></a>二、约束</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><ul><li>数值型：<br>   整型<br>   小数：<div class="hljs code-wrapper"><pre><code>  定点数  浮点数</code></pre></div></li><li>字符型：<br>   较短的文本：char、varchar<br>   较长的文本：text、blob（较长的二进制数据）</li><li>日期型：</li></ul></blockquote><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p><strong>分类</strong></p><blockquote><p>tinyint、smallint、mediumint、int/integer、bigint<br>1               2                3                  4                 8         (字节)</p></blockquote><p><strong>特点</strong></p><p>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加<code>unsigned</code>关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配<code>zerofill</code>使用！</p><p><strong>如何设置无符号和有符号</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tab_int;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tab_int(   t1 <span class="hljs-type">INT</span>(<span class="hljs-number">7</span>) unsigned,   t2 <span class="hljs-type">INT</span>(<span class="hljs-number">7</span>) ZEROFILL );<span class="hljs-keyword">DESC</span> tab_int;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tab_int <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">-123456</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tab_int <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">-123456</span>,<span class="hljs-number">-123456</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tab_int <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2147483648</span>,<span class="hljs-number">4294967296</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tab_int <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">123</span>,<span class="hljs-number">123</span>);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tab_int;</code></pre></div><h4 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h4><p><strong>分类</strong></p><blockquote><ul><li>浮点型<br>float(M,D)<br>double(M,D)</li><li>定点型<br>dec(M，D)<br>decimal(M,D)</li></ul></blockquote><p><strong>特点</strong></p><ul><li>M：整数部位+小数部位，D：小数部位<ul><li>如果超过范围，则插入临界值</li></ul></li><li>M和D都可以省略<ul><li>如果是decimal，则M默认为10，D默认为0</li><li>如果是float和double，则会根据插入的数值的精度来决定精度</li></ul></li><li>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</li></ul><p><strong>原则</strong></p><p>所选择的类型越简单越好，能保存数值的类型越小越好</p><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p><strong>分类</strong></p><blockquote><ul><li>较短的文本：<ul><li>char</li><li>varchar</li></ul></li><li>其他：<ul><li>binary和varbinary用于保存较短的二进制</li><li>enum用于保存枚举</li><li>set用于保存集合</li></ul></li><li>较长的文本：<ul><li>text</li><li>blob(较大的二进制)</li></ul></li></ul></blockquote><p><strong>特点</strong></p><blockquote><p>写法                                            M的意思                                       特点                   空间的耗费              效率<br>char   char(M)               最大的字符数，可以省略，默认为1       固定长度的字符       比较耗费               高</p><p>varchar varchar(M)         最大的字符数，不可以省略                  可变长度的字符       比较节省               低</p></blockquote><h4 id="日期型"><a href="#日期型" class="headerlink" title="日期型"></a>日期型</h4><p><strong>分类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;time_zone&#x27;</span>;<span class="hljs-keyword">SET</span> time_zone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;+9:00&#x27;</span>;</code></pre></div><blockquote><ul><li>date只保存日期</li><li>time 只保存时间</li><li>year只保存年</li><li>datetime保存日期+时间</li><li>timestamp保存日期+时间 （用得多）</li></ul></blockquote><p><strong>特点</strong></p><blockquote><div class="hljs code-wrapper"><pre><code>                         字节                范围                            时区等的影响</code></pre></div><p>datetime                  8          1000——9999                          不受 </p><p>timestamp              4               1970-2038                              受</p></blockquote><p><strong>更改时区</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;time_zone&#x27;</span>;<span class="hljs-keyword">SET</span> time_zone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;+9:00&#x27;</span>;</code></pre></div><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><blockquote><p>PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空<br>比如学号、员工编号等<br>能够唯一确定表中的一条记录。我们通过给某个字段添加该约束，就可以使得该字段不重复且不为空。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>));</code></pre></div><p><strong>联合主键</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user2 (id <span class="hljs-type">INT</span>,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),    <span class="hljs-keyword">PRIMARY</span> KEY(id, name));</code></pre></div><p>此处字段id和name一同作为主键，联合主键要求每个字段<strong>加起来不同即可</strong>（无需每个字段都不同）</p><p><strong>建表后添加主键</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">ALERT <span class="hljs-keyword">TABLE</span> user2 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (id);</code></pre></div><p>或者通过<strong>修改字段</strong>的方式来添加主键</p><div class="hljs code-wrapper"><pre><code class="hljs sql">ALERT <span class="hljs-keyword">TABLE</span> user2 MODIFY id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY;</code></pre></div><p><strong>建表后删除主键</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">ALERT <span class="hljs-keyword">TABLE</span> user2 <span class="hljs-keyword">DROP</span>  <span class="hljs-keyword">PRIMARY</span> KEY (id);</code></pre></div><h2 id="自增约束"><a href="#自增约束" class="headerlink" title="自增约束"></a>自增约束</h2><blockquote><p>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？至多一个！<br>3、标识列的类型只能是数值型<br>4、标识列可以通过 SET auto_increment_increment=3;设置步长<br>可以通过手动插入值，设置起始值</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user3 (id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREAMENT,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user3 (name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span>插入成功，自动生成了id #设置自增<span class="hljs-keyword">SET</span> auto_increment_increment<span class="hljs-operator">=</span><span class="hljs-number">3</span>;</code></pre></div><p>自增约束一般<strong>与主键搭配使用</strong></p><h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><blockquote><p>UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空<br>比如座位号<br>约束修饰的字段不可以重复</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREAMENT <span class="hljs-keyword">UNIQUE</span>,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>));</code></pre></div><p>或者</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREAMENT,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<span class="hljs-keyword">UNIQUE</span>(id, name));</code></pre></div><h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><blockquote><p>NOT NULL：非空，用于保证该字段的值不能为空<br>比如姓名、学号等</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),);</code></pre></div><h2 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h2><blockquote><p>DEFAULT:默认，用于保证该字段有默认值<br>比如性别</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (id <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">10</span>,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),);</code></pre></div><p>如果我们插入字段时没有传值，就会<strong>使用默认值</strong></p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><blockquote><p>FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值<br>在从表添加外键约束，用于引用主表中某列的值<br>比如学生表的专业编号，员工表的部门编号，员工表的工种编号</p></blockquote><p>主表</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> master(id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>));</code></pre></div><p>从表</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> pet(id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),master_id <span class="hljs-type">int</span>,<span class="hljs-keyword">FOREIGN</span> KEY(master_id) <span class="hljs-keyword">REFERENCES</span> master(id));</code></pre></div><ul><li>主表中没有的数据，在副表中是不可以使用的</li><li>主表中的数据被副标引用时，是不可以删除的</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(   字段名 字段类型 列级约束,   字段名 字段类型,   表级约束)</code></pre></div><p>约束的添加分类：</p><ul><li>列级约束：<ul><li>六大约束语法上都支持，但外键约束没有效果</li></ul></li><li>表级约束：<ul><li>除了非空、默认，其他的都支持</li></ul></li></ul><p><strong>列级约束</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> stuinfo(id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,#主键stuName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>,#非空gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">CHECK</span>(gender<span class="hljs-operator">=</span><span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">OR</span> gender <span class="hljs-operator">=</span><span class="hljs-string">&#x27;女&#x27;</span>),#检查,mysql中不支持seat <span class="hljs-type">INT</span> <span class="hljs-keyword">UNIQUE</span>,#唯一age <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span>  <span class="hljs-number">18</span>,#默认约束majorId <span class="hljs-type">INT</span> <span class="hljs-keyword">REFERENCES</span> major(id)#外键);#查看stuinfo中的所有索引，包括主键、外键、唯一<span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> stuinfo;</code></pre></div><p><strong>表级约束</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> stuinfo(   id <span class="hljs-type">INT</span>,   stuname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),   gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>),   seat <span class="hljs-type">INT</span>,   age <span class="hljs-type">INT</span>,   majorid <span class="hljs-type">INT</span>,     #【<span class="hljs-keyword">constraint</span> 约束名】 约束类型(字段名) .   <span class="hljs-keyword">CONSTRAINT</span> pk <span class="hljs-keyword">PRIMARY</span> KEY(id),#主键   <span class="hljs-keyword">CONSTRAINT</span> uq <span class="hljs-keyword">UNIQUE</span>(seat),#唯一键   <span class="hljs-keyword">CONSTRAINT</span> ck <span class="hljs-keyword">CHECK</span>(gender <span class="hljs-operator">=</span><span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">OR</span> gender  <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>),#检查,mysql中不支持   <span class="hljs-keyword">CONSTRAINT</span> fk_stuinfo_major <span class="hljs-keyword">FOREIGN</span> KEY(majorid) <span class="hljs-keyword">REFERENCES</span> major(id)#外键</code></pre></div><blockquote><p>   位置                        支持的约束类型                                      是否可以起约束名</p><p>列级约束：  列的后面   语法都支持，但外键没有效果                  不可以<br>表级约束：  所有列的下面 默认和非空不支持，其他支持              可以（主键没有效果）</p></blockquote><p><strong>主键和唯一的大对比</strong></p><blockquote><p>保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合(有一个满足就成立)</p><p>主键 √                  ×                     至多有1个                   √，但不推荐<br>唯一 √                  √                     可以有多个                  √，但不推荐</p></blockquote><p><strong>外键</strong></p><p>1、要求在从表设置外键关系<br>2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>3、主表的关联列必须是一个key（一般是主键或唯一）<br>4、插入数据时，先插入主表，再插入从表</p><p><strong>删除数据时，先删除从表，再删除主表</strong></p><p>可以通过以下两种方法删除主表中的记录</p><p><strong>级联删除</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stu <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_stu_major <span class="hljs-keyword">FOREIGN</span> KEY (majorid) <span class="hljs-keyword">REFERENCES</span> major(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE;</code></pre></div><p><strong>级联置空</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stu <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_stu_major <span class="hljs-keyword">FOREIGN</span> KEY (majorid) <span class="hljs-keyword">REFERENCES</span> major(id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><h2 id="修改表的约束"><a href="#修改表的约束" class="headerlink" title="修改表的约束"></a>修改表的约束</h2><div class="hljs code-wrapper"><pre><code class="hljs sql">#添加列级约束<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 字段名 字段类型 新约束;#添加表级约束<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> 【<span class="hljs-keyword">constraint</span> 约束名】 约束类型(字段名) 【外键的引用】;</code></pre></div><p><strong>举例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#<span class="hljs-number">1.</span>添加非空约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo MODIFY <span class="hljs-keyword">COLUMN</span> stuname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;#<span class="hljs-number">2.</span>添加默认约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo MODIFY <span class="hljs-keyword">COLUMN</span> age <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">18</span>;#<span class="hljs-number">3.</span>添加主键#①列级约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo MODIFY <span class="hljs-keyword">COLUMN</span> id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY;#②表级约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY(id);#<span class="hljs-number">4.</span>添加唯一#①列级约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo MODIFY <span class="hljs-keyword">COLUMN</span> seat <span class="hljs-type">INT</span> <span class="hljs-keyword">UNIQUE</span>;#②表级约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span>(seat);#<span class="hljs-number">5.</span>添加外键<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_stuinfo_major <span class="hljs-keyword">FOREIGN</span> KEY(majorid) <span class="hljs-keyword">REFERENCES</span> major(id); #<span class="hljs-number">1.</span>删除非空约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo MODIFY <span class="hljs-keyword">COLUMN</span> stuname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NULL</span>;#<span class="hljs-number">2.</span>删除默认约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo MODIFY <span class="hljs-keyword">COLUMN</span> age <span class="hljs-type">INT</span> ;#<span class="hljs-number">3.</span>删除主键<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;#<span class="hljs-number">4.</span>删除唯一<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> INDEX seat;#<span class="hljs-number">5.</span>删除外键<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stuinfo <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY fk_stuinfo_major;</code></pre></div><h1 id="三、数据库的三大范式"><a href="#三、数据库的三大范式" class="headerlink" title="三、数据库的三大范式"></a>三、数据库的三大范式</h1><h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p><strong>字段还可以拆分的，就不满足第一范式</strong></p><p>比如地址如果写为</p><div class="hljs code-wrapper"><pre><code class="hljs plain">地址：四川省成都市高新区天府一街</code></pre></div><p>就是可以被拆分的</p><p>如果字段写为</p><div class="hljs code-wrapper"><pre><code class="hljs plain">省份：四川省城市：成都市区域：高新区街名：天府一街</code></pre></div><p>就是不可拆分的</p><p>建表如下</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCRAEMENT,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),province <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),city <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),area <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),street: <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>));</code></pre></div><p>就是<strong>符合第一范式</strong>的，但<strong>并不是拆分的越详细越好</strong></p><h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><ul><li>满足第一范式的条件下，第二范式要求：<strong>除主键外的每一列，都必须完全依赖于主键</strong></li><li>如果出现不完全依赖，则只可能发生在<strong>联合主键</strong>的情况下</li></ul><p><strong>不满足第二范式的例子</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(product_id <span class="hljs-type">INT</span>,customer_id <span class="hljs-type">INT</span>,product_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),    <span class="hljs-keyword">PRIMARY</span> KEY(product_id, customer_id));</code></pre></div><p>此处product_name只依赖于product_id，customer_name只依赖于customer_id，是完全依赖</p><p><strong>满足第二范式的例子</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,product_id <span class="hljs-type">INT</span>,customer_id <span class="hljs-type">INT</span>);<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> product(id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer(id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>));</code></pre></div><h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><ul><li>满足第二范式，除主键外的其他列之间不能有传递依赖关系</li></ul><p><strong>不满足第三范式的例子</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,product_id <span class="hljs-type">INT</span>,customer_id <span class="hljs-type">INT</span>,customer_phone <span class="hljs-type">INT</span>);</code></pre></div><p>此处customer_phone又依赖于customer_id，存在传递依赖关系，不满足第三范式</p><p><strong>满足第三范式的例子</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,product_id <span class="hljs-type">INT</span>,customer_id <span class="hljs-type">INT</span>);<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer(id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),    phone <span class="hljs-type">INT</span>);</code></pre></div><h1 id="四、视图"><a href="#四、视图" class="headerlink" title="四、视图"></a>四、视图</h1><p>是一种虚拟表，和普通表一样使用<br>mysql5.1版本出现的新特性，是通过表动态生成的数据</p><blockquote><p>​                创建语法的关键字            是否实际占用物理空间                                         使用</p><p>视图          create view                           只是保存了sql逻辑                         增删改查，只是一般不能增删改</p><p>表               create table                              保存了数据                                                     增删改查</p></blockquote><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>利用<code>CREATE VIEW xx AS</code>封装</p><div class="hljs code-wrapper"><pre><code class="hljs sql">#案例：查询姓张的学生名和专业名<span class="hljs-keyword">SELECT</span> stuname,majorname<span class="hljs-keyword">FROM</span> stuinfo s<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> major m <span class="hljs-keyword">ON</span> s.`majorid`<span class="hljs-operator">=</span> m.`id`<span class="hljs-keyword">WHERE</span> s.`stuname` <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;张%&#x27;</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> v1<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> stuname,majorname<span class="hljs-keyword">FROM</span> stuinfo s<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> major m <span class="hljs-keyword">ON</span> s.`majorid`<span class="hljs-operator">=</span> m.`id`;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> v1 <span class="hljs-keyword">WHERE</span> stuname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;张%&#x27;</span>;#<span class="hljs-number">2.</span>查询各部门的平均工资级别#①创建视图查看每个部门的平均工资<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> myv2<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) ag,department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;#②使用<span class="hljs-keyword">SELECT</span> myv2.`ag`,g.grade_level<span class="hljs-keyword">FROM</span> myv2<span class="hljs-keyword">JOIN</span> job_grades g<span class="hljs-keyword">ON</span> myv2.`ag` <span class="hljs-keyword">BETWEEN</span> g.`lowest_sal` <span class="hljs-keyword">AND</span> g.`highest_sal`;</code></pre></div><h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><blockquote><p>create or replace view  视图名<br>as</p><p>查询语句;</p><p>或者</p><p>alter view 视图名<br>as<br>查询语句;</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql">#<span class="hljs-number">1</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">VIEW</span> myv3<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary),job_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id;#<span class="hljs-number">2</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">VIEW</span> myv3<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees;</code></pre></div><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> emp_v1,emp_v2,myv3;</code></pre></div><h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DESC</span> myv3;<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> myv3;</code></pre></div><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">VIEW</span> myv1<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> last_name,email<span class="hljs-keyword">FROM</span> employees;#<span class="hljs-number">1.</span>插入<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> myv1 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;张飞&#x27;</span>,<span class="hljs-string">&#x27;zf@qq.com&#x27;</span>);#<span class="hljs-number">2.</span>修改UPDATE myv1 <span class="hljs-keyword">SET</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张无忌&#x27;</span> <span class="hljs-keyword">WHERE</span> last_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;张飞&#x27;</span>;#<span class="hljs-number">3.</span>删除<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> myv1 <span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张无忌&#x27;</span>;</code></pre></div><p><strong>具备以下特点的视图不允许更新</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#①包含以下关键字的<span class="hljs-keyword">sql</span>语句：分组函数、<span class="hljs-keyword">distinct</span>、<span class="hljs-keyword">group</span>  <span class="hljs-keyword">by</span>、<span class="hljs-keyword">having</span>、<span class="hljs-keyword">union</span>或者<span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">VIEW</span> myv1<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary) m,department_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;#更新失败UPDATE myv1 <span class="hljs-keyword">SET</span> m<span class="hljs-operator">=</span><span class="hljs-number">9000</span> <span class="hljs-keyword">WHERE</span> department_id<span class="hljs-operator">=</span><span class="hljs-number">10</span>;#②常量视图<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">VIEW</span> myv2<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;john&#x27;</span> NAME;#更新失败UPDATE myv2 <span class="hljs-keyword">SET</span> NAME<span class="hljs-operator">=</span><span class="hljs-string">&#x27;lucy&#x27;</span>;#③<span class="hljs-keyword">Select</span>中包含子查询<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">VIEW</span> myv3<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> department_id,(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(salary) <span class="hljs-keyword">FROM</span> employees) 最高工资<span class="hljs-keyword">FROM</span> departments;#更新失败UPDATE myv3 <span class="hljs-keyword">SET</span> 最高工资<span class="hljs-operator">=</span><span class="hljs-number">100000</span>;#④<span class="hljs-keyword">join</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">VIEW</span> myv4<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> last_name,department_name<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">JOIN</span> departments d<span class="hljs-keyword">ON</span> e.department_id  <span class="hljs-operator">=</span> d.department_id;#更新成功，插入失败UPDATE myv4 <span class="hljs-keyword">SET</span> last_name  <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张飞&#x27;</span> <span class="hljs-keyword">WHERE</span> last_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Whalen&#x27;</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> myv4 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;陈真&#x27;</span>,<span class="hljs-string">&#x27;xxxx&#x27;</span>);#⑤<span class="hljs-keyword">from</span>一个不能更新的视图<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">VIEW</span> myv5<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> myv3;#更新失败UPDATE myv5 <span class="hljs-keyword">SET</span> 最高工资<span class="hljs-operator">=</span><span class="hljs-number">10000</span> <span class="hljs-keyword">WHERE</span> department_id<span class="hljs-operator">=</span><span class="hljs-number">60</span>;#⑥<span class="hljs-keyword">where</span>子句的子查询引用了<span class="hljs-keyword">from</span>子句中的表<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">VIEW</span> myv6<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> last_name,email,salary<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-keyword">IN</span>(<span class="hljs-keyword">SELECT</span>  manager_id<span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> manager_id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>);#更新失败UPDATE myv6 <span class="hljs-keyword">SET</span> salary<span class="hljs-operator">=</span><span class="hljs-number">10000</span> <span class="hljs-keyword">WHERE</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;k_ing&#x27;</span>;</code></pre></div><h1 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h1><p>事务是一个最小的不可分割的单元，事务能够保证一个业务的完整性</p><p>多条sql语句<strong>要么同时成功，要么同时失败</strong>，这时就要用到事务，即TCL</p><h2 id="自动提交、手动提交和回滚"><a href="#自动提交、手动提交和回滚" class="headerlink" title="自动提交、手动提交和回滚"></a>自动提交、手动提交和回滚</h2><p>通过<code>ROLLBACK; </code>指令可以回滚，但需要<strong>关闭自动提交</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">#关闭一次，也等于开启事务<span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>#查看自动提交状态<span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@autocommit</span>;</code></pre></div><p>但如果在进行操作之后，执行<code>COMMIT; </code>则无法再进行回滚（持久化）</p><p><strong>同时delete可以回滚，而truncate不能回滚</strong></p><p><strong>SAVEPOINT设置保存点</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> autocommit<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<span class="hljs-keyword">START</span> TRANSACTION;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> account <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">25</span>;<span class="hljs-keyword">SAVEPOINT</span> a;#设置保存点<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> account <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">28</span>;<span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> a;#回滚到保存点</code></pre></div><h2 id="手动开启事务"><a href="#手动开启事务" class="headerlink" title="手动开启事务"></a>手动开启事务</h2><p>通过</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;或者<span class="hljs-keyword">START</span> TRANSACTION;</code></pre></div><p>可以手动开启事务</p><p><strong>插入数据前</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810204606.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200810204606.png" alt="img"></a></p><p><strong>插入数据后</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;老六&#x27;</span>, <span class="hljs-number">7</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;老七&#x27;</span>, <span class="hljs-number">9</span>);或者<span class="hljs-keyword">START</span> TRANSACTION;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;老六&#x27;</span>, <span class="hljs-number">7</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;老七&#x27;</span>, <span class="hljs-number">9</span>);</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810204849.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200810204849.png" alt="img"></a></p><p><strong>回滚后</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200810204930.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200810204930.png" alt="img"></a></p><p>即</p><blockquote><p>步骤1：开启事务<br>set autocommit=0;<br>start transaction;可选的<br>步骤2：编写事务中的sql语句(select insert update delete)<br>语句1;<br>语句2;<br>…</p><p>步骤3：结束事务<br>commit;提交事务<br>rollback;回滚事务</p></blockquote><h2 id="四大特征-ACID"><a href="#四大特征-ACID" class="headerlink" title="四大特征 ACID"></a>四大特征 ACID</h2><ul><li>原子性：事务是最小的单位，<strong>不可再分</strong>，要么都执行要么都不执行</li><li>一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态</li><li>隔离性：一个事务的执行不受其他事务的干扰</li><li>持久性：事物<strong>一旦结束</strong>（commit），就<strong>不可返回</strong>（rollback）</li></ul><p><strong>隔离性</strong></p><ul><li>事务的隔离级别<ul><li>读未提交 read uncommitted</li><li>读已提交 read committed</li><li>可以重复读 repeatable read</li><li>串行化 serializable</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200811132934.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200811132934.png" alt="img"></a></p><ul><li>事务的并发问题<ul><li>脏读：事务A读取了事务B更新的数据，然后<strong>B回滚操作</strong>，那么<strong>A读取到的数据是脏数据</strong></li><li>不可重复读：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了<strong>更新并提交</strong>，<strong>导致事务A多次读取同一数据时，结果不一致</strong></li><li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读</li></ul></li></ul><p><strong>总结</strong>：不可重复读的和幻读很容易混淆，<strong>不可重复读侧重于修改，幻读侧重于新增或删除</strong></p><p> 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p><ul><li>查看数据库的隔离级别</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql">版本 <span class="hljs-number">5.</span>x<span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@global</span>.tx_isolation;版本 <span class="hljs-number">8.0</span><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@global</span>.transaction_isolation;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200811132716.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200811132716.png" alt="img"></a></p><ul><li>修改数据库的隔离级别</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read committed;</code></pre></div><h1 id="六、MySQL逻辑架构"><a href="#六、MySQL逻辑架构" class="headerlink" title="六、MySQL逻辑架构"></a>六、MySQL逻辑架构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200813170808.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200813170808.png" alt="img"></a></p><h2 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h2><p>最上层是一些客服端和连接服务，包括socket通信和大多数基于客服端/服务端工具实现的类似于tcp/ip的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案，在该层上引入了线程池的概念，为通过认证安全接入的客服端提供线程，同样在该层上可以实现基于SSL的安全的连接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</p><h2 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h2><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析以及优化部分内置函数的执行，所有跨存储引擎的功能也在这一层实现，如过程、函数等，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询的顺序是否利用索引，最后生成相应的执行操作</p><table><thead><tr><th>Management Serveices &amp; Utilities</th><th>系统管理和控制工具</th></tr></thead><tbody><tr><td>SQL Interface</td><td>SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface</td></tr><tr><td>Parser</td><td>解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析</td></tr><tr><td>Optimizer</td><td>查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。</td></tr><tr><td>Cache 和 Buffer</td><td>查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存， 权限缓存等</td></tr></tbody></table><h2 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h2><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有功能不同</p><table><thead><tr><th>对比项</th><th>MylSAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>[表锁](# 表锁)（不适合高并发）</td><td>[行锁](# 行锁)（适合高并发操作）</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引，还缓存真实数据。对内存要求较高</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr></tbody></table><h2 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h2><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互</p><h1 id="七、性能与JOIN"><a href="#七、性能与JOIN" class="headerlink" title="七、性能与JOIN"></a>七、性能与JOIN</h1><h2 id="性能下降原因"><a href="#性能下降原因" class="headerlink" title="性能下降原因"></a>性能下降原因</h2><p><strong>索引失效</strong></p><p><strong>单值索引</strong></p><p>创建语句</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_表名_字段名 <span class="hljs-keyword">ON</span> 表名(字段名);</code></pre></div><p><strong>复合索引</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_表名_字段名<span class="hljs-number">1</span>字段名<span class="hljs-number">2.</span>.. <span class="hljs-keyword">ON</span> 表名(字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span> ...);</code></pre></div><p><strong>关联太多JOIN</strong></p><p>内连接、外连接的表不要过多</p><p><strong>服务器调优及参数设置</strong></p><h2 id="SQL执行加载顺序"><a href="#SQL执行加载顺序" class="headerlink" title="SQL执行加载顺序"></a>SQL执行加载顺序</h2><p><strong>手写顺序</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112248.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814112248.png" alt="img"></a></p><p>随着 Mysql 版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而<strong>动态调整执行顺序</strong></p><p>下面是经常出现的查询顺序：</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112330.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814112330.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814112343.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814112343.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814191644.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814191644.png" alt="img"></a></p><h2 id="7种JOIN"><a href="#7种JOIN" class="headerlink" title="7种JOIN"></a>7种JOIN</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814150926.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814150926.png" alt="img"></a></p><p><strong>建表语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_dept` (`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,   `deptName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,   `address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (`id`)) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_emp` (`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,   `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,   `age` <span class="hljs-type">INT</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,   `deptId` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,   `empno` <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,   <span class="hljs-keyword">PRIMARY</span> KEY (`id`), KEY `idx_dept_id` (`deptId`)#<span class="hljs-keyword">CONSTRAINT</span> `fk_dept_id` <span class="hljs-keyword">FOREIGN</span> KEY (`deptId`) <span class="hljs-keyword">REFERENCES</span> `t_dept` (`id`)) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;华山&#x27;</span>,<span class="hljs-string">&#x27;华山&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;丐帮&#x27;</span>,<span class="hljs-string">&#x27;洛阳&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;峨眉&#x27;</span>,<span class="hljs-string">&#x27;峨眉山&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;武当&#x27;</span>,<span class="hljs-string">&#x27;武当山&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;明教&#x27;</span>,<span class="hljs-string">&#x27;光明顶&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;少林&#x27;</span>,<span class="hljs-string">&#x27;少林寺&#x27;</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;风清扬&#x27;</span>,<span class="hljs-number">90</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100001</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;岳不群&#x27;</span>,<span class="hljs-number">50</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100002</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;令狐冲&#x27;</span>,<span class="hljs-number">24</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100003</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;洪七公&#x27;</span>,<span class="hljs-number">70</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100004</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;乔峰&#x27;</span>,<span class="hljs-number">35</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100005</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;灭绝师太&#x27;</span>,<span class="hljs-number">70</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100006</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;周芷若&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100007</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;张三丰&#x27;</span>,<span class="hljs-number">100</span>,<span class="hljs-number">4</span>,<span class="hljs-number">100008</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;张无忌&#x27;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">5</span>,<span class="hljs-number">100009</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;韦小宝&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">100010</span>);</code></pre></div><p><strong>JOIN查询</strong></p><ul><li>笛卡尔积</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_dept, t_emp;</code></pre></div><p>t_dept共20条记录，t_emp共6条记录。两表共同查询后共120条记录</p><ul><li>内连接</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId <span class="hljs-operator">=</span> b.id;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153140.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814153140.png" alt="img"></a></p><ul><li>左外连接</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId <span class="hljs-operator">=</span> b.id;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153254.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814153254.png" alt="img"></a></p><ul><li>右外连接</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId <span class="hljs-operator">=</span> b.id;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153413.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814153413.png" alt="img"></a></p><ul><li>左外连接<strong>取左表的独有部分</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153909.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814153909.png" alt="img"></a></p><ul><li>右外连接<strong>取右表的独有部分</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814153844.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814153844.png" alt="img"></a></p><p><strong>注意</strong>：判断字段是否为NULL时，<strong>不能使用’=’</strong></p><p>因为<code>= NULL</code> 的结果不会报错，但是<strong>结果永远为false</strong>。所以必须使用<code>IS NULL </code>来进行判空</p><ul><li>全外连接</li></ul><p>MySQL不支持全外连接，要查询两个表的全集，需要合并两个查询结果，所以要使用 <strong>UNION</strong> 关键字</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814154554.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814154554.png" alt="img"></a></p><ul><li>查询两表独有内容</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814155138.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814155138.png" alt="img"></a></p><h1 id="八、索引优化"><a href="#八、索引优化" class="headerlink" title="八、索引优化"></a>八、索引优化</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><ul><li><p>MySQL 官方对索引的定义为：<strong>索引（Index）是帮助 MySQL 高效获取数据的数据结构</strong>。可以得到索引的本质： <strong>索引是数据结构</strong>。</p><p>可以简单理解为：<strong>排好序的快速查找数据结构</strong></p></li><li><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814173647.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200814173647.png" alt="img"></a></p><ul><li>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用 二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录 </li><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</li></ul><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p><strong>优点</strong></p><ul><li><strong>提高数据检索的效率</strong>，降低数据库的IO成本</li><li>通过索引列对数据进行排序，<strong>降低数据排序的成本</strong>，降低了CPU的消耗</li></ul><p><strong>缺点</strong></p><ul><li>虽然索引大大提高了查询速度，同时却<strong>会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间的</strong></li></ul><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p><strong>基本语法</strong></p><ul><li><p>创建</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] INDEX [indexName] <span class="hljs-keyword">ON</span> table_name(<span class="hljs-keyword">column</span>);</code></pre></div></li><li><p>删除</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX [indexName] <span class="hljs-keyword">ON</span> table_name;</code></pre></div></li><li><p>查看</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> table_name;</code></pre></div></li></ul><p><strong>分类</strong></p><ul><li><p>单值索引</p><ul><li><p>定义：即一个索引只包含单个列，一个表可以有多个单列索引</p></li><li><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <span class="hljs-keyword">PRIMARY</span> KEY(id), KEY (customer_name) <span class="hljs-comment">--单值索引</span>);<span class="hljs-comment">--单独创建单值索引</span><span class="hljs-keyword">CREATE</span> INDEX idx_customer_name <span class="hljs-keyword">ON</span> customer(customer_name);</code></pre></div></li></ul></li><li><p>唯一索引</p><ul><li><p>定义：索引列的值必须唯一，但允许有空值</p></li><li><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <span class="hljs-keyword">PRIMARY</span> KEY(id), KEY (customer_name), <span class="hljs-comment">--单值索引</span><span class="hljs-keyword">UNIQUE</span> (customer_no) <span class="hljs-comment">--唯一索引</span>);<span class="hljs-comment">--单独创建唯一索引</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_customer_no <span class="hljs-keyword">ON</span> customer(customer_no);</code></pre></div></li></ul></li><li><p>主键索引</p><ul><li><p>定义：设定为主键后数据库会<strong>自动建立索引</strong>，innodb为聚簇索引</p></li><li><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <span class="hljs-keyword">PRIMARY</span> KEY(id) <span class="hljs-comment">--主键索引</span>);<span class="hljs-comment">--单独创建主键索引</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY customer(customer_no);<span class="hljs-comment">--删除主键索引</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<span class="hljs-comment">--修改建主键索引</span>必须先删除掉(<span class="hljs-keyword">drop</span>)原索引，再新建(<span class="hljs-keyword">add</span>)索引</code></pre></div></li></ul></li><li><p>复合索引</p><ul><li><p>定义：即一个索引包含多个列</p></li><li><p>语法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <span class="hljs-keyword">PRIMARY</span> KEY(id), KEY (customer_name), <span class="hljs-comment">--单值索引</span><span class="hljs-keyword">UNIQUE</span> (customer_no), <span class="hljs-comment">--唯一索引</span>KEY (customer_no,customer_name) <span class="hljs-comment">--复合索引</span>);<span class="hljs-comment">--单独创建复合索引</span><span class="hljs-keyword">CREATE</span> INDEX idx_no_name <span class="hljs-keyword">ON</span> customer(customer_no,customer_name);</code></pre></div></li></ul></li></ul><h2 id="MySQL的索引"><a href="#MySQL的索引" class="headerlink" title="MySQL的索引"></a>MySQL的索引</h2><p><strong>B树</strong></p><ul><li>B树的阶：节点的<strong>最多子节点个数</strong>。比如 2-3树的阶是3，2-3-4树的阶是4</li><li>B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li><li>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据</li><li>搜索<strong>有可能在非叶子结点结束</strong></li><li>其搜索性能等价于在关键字全集内做一次二分查找</li></ul><p><strong>B+树</strong></p><ul><li>B+树是B树的变体，也是一种多路搜索树</li><li>B+树的搜索与 B树也基本相同，区别是 B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li><li><strong>所有关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫<strong>稠密索引</strong>】），且链表中的关键字(数据)恰好是有序的</li><li><strong>不可能在非叶子结点命中</strong></li><li><strong>非叶子结点</strong>相当于是叶子结点的<strong>索引</strong>（稀疏索引），<strong>叶子结点</strong>相当于是存储（关键字）<strong>数据</strong>的数据层</li><li>更适合文件索引系统</li><li>B树和 B+树各有自己的应用场景，不能说 B+树完全比 B树好，反之亦然</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815153029.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200815153029.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815153043.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200815153043.png" alt="img"></a></p><p><strong>区别</strong></p><ul><li>B树的<strong>关键字和记录是放在一起的</strong>，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，<strong>记录只放在叶子节点中</strong></li><li>在B树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比B树多，树高比B树小，这样带来的好处是减少磁盘访问次数。尽管 B+树找到 一个记录所需的比较次数要比 B树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+树的性能可能还会好些，而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+树的缘故</li></ul><p><strong>为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><ul><li>B+树的磁盘读写代价更低<ul><li>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了</li></ul></li><li>B+树的查询效率更加稳定<ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</li></ul></li></ul><h2 id="MySQL中的B-树"><a href="#MySQL中的B-树" class="headerlink" title="MySQL中的B+树"></a>MySQL中的B+树</h2><p><strong>业的概念</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210510203700441.png" alt="image-20210510203700441"></p><p><strong>主键索引</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822173605.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200822173605.png" alt="img"></a></p><p>MySQL在创建表时，会根据主键来创建主键索引（如果没有主键，会用一个隐藏值来作为主键）。主键索引所构建的B+树，表中所有的记录都存放在了树的最后一层。<strong>且与一般的B+树不同的是：叶子节点间的指针是双向的</strong></p><p><strong>复合索引</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822185520.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200822185520.png" alt="img"></a></p><p>创建复合索引时，会将作为<strong>复合索引字段的值</strong>进行排序并放在B+树的最后一层中，同时还会将其<strong>对应的主键值</strong>放在其后。如：</p><table><thead><tr><th>a（主键）</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>1</td><td>1</td><td>a</td></tr></tbody></table><p>其中字段a为主键，字段bcd共同作为复合索引，此时存放在最后一层的数据就是：111（复合索引） 2（主键索引）</p><p>根据这个特点，可以看出复合索引具有以下使用方法</p><ul><li><p>最佳左前缀：使用复合索引的顺序必须和创建的<strong>顺序一致</strong></p></li><li><p>覆盖索引的同时，可以带上主键字段，如</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a, b, c, d <span class="hljs-keyword">FROM</span> t_emp;</code></pre></div><p>因为<strong>主键字段和复合索引一起存放在了复合索引说产生的B+树的最后一层</strong>。如果需要a字段，无需进行全表扫描</p></li><li><p>如果进行范围查找，可能会进行全表扫描，这取决于处在范围内记录的多少</p><ul><li><p><strong>记录多</strong>，从复合索引映射到主键索引的次数过多，成本过高，<strong>会直接进行全表扫描</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175336.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200822175336.png" alt="img"></a></p></li><li><p><strong>记录少</strong>，先<strong>使用复合索引</strong>，然后<strong>映射到全表</strong>中的对应记录上</p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">80</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175403.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200822175403.png" alt="img"></a></p></li><li><p>但是使用<strong>覆盖索引</strong>，无论记录多少，都会用到索引</p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> age, name <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175611.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200822175611.png" alt="img"></a></p></li><li><p>不带WHERE也可以通过复合索引查找到主键+复合索引的记录</p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> id, age, name, deptId <span class="hljs-keyword">FROM</span> t_emp ;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175746.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200822175746.png" alt="img"></a></p></li></ul></li></ul><h2 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h2><p><strong>适合索引的场景</strong></p><ul><li>主键自动建立唯一索引</li><li>频繁作为<strong>查询条件</strong>的字段应该创建索引 </li><li>查询中与其它表关联的字段，<strong>外键关系</strong>建立索引 </li><li>单键/组合索引的选择问题，<strong>组合索引性价比更高</strong></li><li>查询中<strong>排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度 </li><li>查询中<strong>统计</strong>或者<strong>分组</strong>字段</li></ul><p><strong>不适合索引的场景</strong></p><ul><li>表<strong>记录太少</strong>（有无索引差别不大）</li><li>经常<strong>增删改</strong>的表或者字段</li><li>Where 条件里用不到的字段不创建索引</li><li><strong>过滤性不好</strong>的不适合建索引（重复性较高，比如国籍、性别之类的字段）</li></ul><h1 id="九、Explain-性能分析"><a href="#九、Explain-性能分析" class="headerlink" title="九、Explain 性能分析"></a>九、Explain 性能分析</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>使用 <strong>EXPLAIN</strong> 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。<strong>分析</strong>你的查询语句或是表结构的<strong>性能瓶颈</strong></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--EXPLAIN + SQL语句，如：</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> person;</code></pre></div><p><strong>Explain 执行后返回的信息：</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815171636.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200815171636.png" alt="img"></a></p><h2 id="表头字段介绍"><a href="#表头字段介绍" class="headerlink" title="表头字段介绍"></a>表头字段介绍</h2><p><strong>准备工作</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (id));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t2(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (id));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t3(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (id));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t4(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (id));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t1_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t2(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t2_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t3(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t3_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t4(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t4_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));</code></pre></div><h3 id="id：表的读取顺序"><a href="#id：表的读取顺序" class="headerlink" title="id：表的读取顺序"></a><strong>id：表的读取顺序</strong></h3><p>id是select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><ul><li><p><strong>id相同</strong>：执行顺序为 <strong>从上至下执行</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1, t2, t3 <span class="hljs-keyword">WHERE</span> t1.id <span class="hljs-operator">=</span> t2.id <span class="hljs-keyword">AND</span> t2.id <span class="hljs-operator">=</span> t3.id;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815173157.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200815173157.png" alt="img"></a></p><p>查询时，表的加载<strong>顺序为t1, t2, t3</strong></p></li><li><p><strong>id不同</strong>：执行顺序为 <strong>id大的先执行</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> t2.id <span class="hljs-keyword">FROM</span> t2 <span class="hljs-keyword">WHERE</span> t2.id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> t1.id <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> t1.id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> t3.id <span class="hljs-keyword">FROM</span> t3));</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174216.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200815174216.png" alt="img"></a></p><p>查询时，表的加载<strong>顺序为t3, t1, t2</strong></p></li><li><p><strong>id相同又不同</strong>： 执行顺序为 </p><ul><li>id不同时，值较大的先执行</li><li>id相同时，从上至下执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> t2.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> t3.id    <span class="hljs-keyword">FROM</span> t3    <span class="hljs-keyword">WHERE</span> t3.content <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span>) s1, t2<span class="hljs-keyword">WHERE</span> s1.id <span class="hljs-operator">=</span> t2.id;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174740.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200815174740.png" alt="img"></a></p><p>查询时，表的<strong>加载顺序为t3, t2, 虚表dervied2</strong></p><ul><li>其中dervied<strong>2</strong> 的 2，为 id = 2</li></ul></li></ul><h3 id="select-type：查询操作类型"><a href="#select-type：查询操作类型" class="headerlink" title="select_type：查询操作类型"></a><strong>select_type：查询操作类型</strong></h3><p>select_type代表<strong>查询的类型</strong>，主要是用于区别<strong>普通查询、联合查询、子查询等</strong>的复杂查询</p><table><thead><tr><th>select_type 属性</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的 select 查询,查询中<strong>不包含子查询或者 UNION</strong></td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子部分，<strong>最外层</strong>查询则被标记为 Primary</td></tr><tr><td>DERIVED</td><td>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里</td></tr><tr><td>SUBQUERY</td><td>在SELECT或WHERE列表中包含了<strong>子查询</strong></td></tr><tr><td>DEPEDENT SUBQUERY</td><td>在SELECT或WHERE列表中包含了子查询,<strong>子查询基于外层</strong></td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td><strong>无法使用缓存</strong>的子查询</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表<strong>获取结果</strong>的SELECT</td></tr></tbody></table><ul><li><p>SUBQUERY 和 DEPEDENT SUBQUERY</p></li><li><p>都是 WHERE 后面的条件，SUBQUERY 是单个值（=），DEPEDENT SUBQUERY 是一组值（IN）</p></li><li><p>UNCACHEABLE SUBQUERY</p></li><li><p>当使用了**@@来引用系统变量**的时候，不会使用缓存</p></li><li><p>UNION 和 UNION RESULT </p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span>  t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span>  t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816135453.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816135453.png" alt="img"></a></p></li></ul><h3 id="table：表的来源"><a href="#table：表的来源" class="headerlink" title="table：表的来源"></a><strong>table：表的来源</strong></h3><p>table表示这个数据是基于哪张表的</p><h3 id="type：访问类型"><a href="#type：访问类型" class="headerlink" title="type：访问类型"></a><strong>type：访问类型</strong></h3><p>type 是查询的访问类型。<strong>是较为重要的一个指标</strong>，结果值从最好到最坏依次是：</p><div class="hljs code-wrapper"><pre><code class="hljs css">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; all--常见的顺序为system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</code></pre></div><p>一般来说，得保证查询<strong>至少达到 range 级别</strong>，最好能达到 ref</p><table><thead><tr><th>类型名</th><th>含义</th></tr></thead><tbody><tr><td>SYSTEM</td><td>表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也<strong>可以忽略不计</strong></td></tr><tr><td>CONST</td><td>表示<strong>通过索引一次就找到了</strong>,const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</td></tr><tr><td>EQ_REF</td><td>唯一性索引扫描，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>。常见于主键或唯一索引扫描</td></tr><tr><td>REF</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行， 然而，它<strong>可能会找到多个符合条件的行</strong>，所以他应该属于查找和扫描的混合体</td></tr><tr><td>RANGE</td><td>只检索给定<strong>范围</strong>的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现 了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而 结束语另一点，不用扫描全部索引</td></tr><tr><td>INDEX</td><td>出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组</td></tr><tr><td>ALL</td><td>Full Table Scan，将遍历全表以找到匹配的行</td></tr></tbody></table><ul><li><p>REF</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--其中deptId为索引，且用到了&#x27; = &#x27;</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165420.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816165420.png" alt="img"></a></p></li><li><p>RANGE</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--其中deptId为索引，用到了 BETWEEN...AND... , IN , &gt; , &lt; 等范围查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816213631.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816213631.png" alt="img"></a></p></li><li><p>INDEX</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--其中deptId为索引，查找了整张表时，用到了索引</span>EXPLAIN <span class="hljs-keyword">SELECT</span> deptId <span class="hljs-keyword">FROM</span> t_emp;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165651.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816165651.png" alt="img"></a></p></li><li><p>ALL</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--其中name为非索引</span>EXPLAIN <span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> t_emp;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165722.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816165722.png" alt="img"></a></p></li></ul><h3 id="possible-key：可能用到的索引"><a href="#possible-key：可能用到的索引" class="headerlink" title="possible_key：可能用到的索引"></a><strong>possible_key：可能用到的索引</strong></h3><p>显示<strong>可能</strong>应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但<strong>不一 定被查询实际使用</strong></p><h3 id="key：实际使用的索引"><a href="#key：实际使用的索引" class="headerlink" title="key：实际使用的索引"></a><strong>key：实际使用的索引</strong></h3><p><strong>实际使用的索引</strong>。如果为NULL，则没有使用索引</p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816172950.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816172950.png" alt="img"></a></p><p>MySQL推测可能用到主键索引和idx_dept_id索引，实际上用到的是主键索引</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h4><p>当查找的字段与建立的索引的匹配（查询的字段都是索引，但不需要全是索引）时，会发生覆盖索引。MySQL推测使用的索引为NULL，而实际上会使用索引</p><p>有以下两种解释</p><ul><li>select的数据列<strong>只用从索引中就能够取得</strong>，不必从数据表中读取，换句话说<strong>查询列要被所使用的索引覆盖</strong></li><li>索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引</li></ul><p>注意：要使用覆盖索引，则<strong>只取出需要的列</strong>（被令为索引），<strong>不要</strong>使用 SELECT *</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--其中id和deptId都为索引</span>EXPLAIN <span class="hljs-keyword">SELECT</span> id, deptId <span class="hljs-keyword">FROM</span> t_emp;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173253.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816173253.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173228.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816173228.png" alt="img"></a></p><h3 id="key-len：索引使用字节数"><a href="#key-len：索引使用字节数" class="headerlink" title="key_len：索引使用字节数"></a><strong>key_len：索引使用字节数</strong></h3><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len 字段能够帮你检查是否充分的利用上了索引</p><p><strong>ken_len 越长，说明索引使用的越充分</strong></p><h3 id="ref：显示被使用的索引的具体信息"><a href="#ref：显示被使用的索引的具体信息" class="headerlink" title="ref：显示被使用的索引的具体信息"></a><strong>ref：显示被使用的索引的具体信息</strong></h3><p>ref显示索引的哪一列被使用了，如果可能的话，可以是一个常数。哪些列或常量被用于查找索引列上的值</p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId <span class="hljs-operator">=</span> t_dept.id;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816194305.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816194305.png" alt="img"></a></p><p>ref中如果有const就代表在where条件中加上了<code>t_emp.xx = &#39;xxx&#39;</code>匹配了常量</p><h3 id="rows：被查询的行数"><a href="#rows：被查询的行数" class="headerlink" title="rows：被查询的行数"></a><strong>rows：被查询的行数</strong></h3><p>rows 列显示 MySQL 认为它执行查询时必须检查的行数。<strong>越少越好！</strong></p><p><strong>验证</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--先删除索引</span><span class="hljs-keyword">DROP</span> INDEX idx_dept_id <span class="hljs-keyword">ON</span> t_emp;<span class="hljs-comment">--查找</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId <span class="hljs-operator">=</span> t_dept.id;<span class="hljs-comment">--再创建索引</span><span class="hljs-keyword">CREATE</span> INDEX idx_dept_id <span class="hljs-keyword">ON</span> t_emp(deptId);<span class="hljs-comment">--查找</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId <span class="hljs-operator">=</span> t_dept.id;</code></pre></div><p><strong>结果如下</strong></p><ul><li><p>未使用索引时，一共需要查询26行</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195241.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816195241.png" alt="img"></a></p></li><li><p>使用索引后，一共需要查询6行</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195401.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816195401.png" alt="img"></a></p></li></ul><h3 id="Extra：额外重要信息"><a href="#Extra：额外重要信息" class="headerlink" title="Extra：额外重要信息"></a><strong>Extra：额外重要信息</strong></h3><p>其他的额外<strong>重要</strong>的信息</p><h4 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a><strong>Using filesort</strong></h4><ul><li>使用外部索引排序（未使用用户创建的索引）</li><li>说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引 完成的排序操作称为“文件排序”</li><li>出现 Using filesort <strong>说明SQL语句设计的不好</strong>，<strong>没有按照创建的索引进行排序</strong>，或者<strong>未按照索引指定的顺序进行排序</strong></li></ul><p><strong>演示</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--创建符合索引</span><span class="hljs-keyword">CREATE</span> INDEX idx_emp_empno_age <span class="hljs-keyword">ON</span> t_emp(empno, age);<span class="hljs-comment">--进行查询操作，通过 age 字段进行排序（未按照复合索引顺序进行排序查询）</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno <span class="hljs-operator">&gt;</span><span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<span class="hljs-comment">--进行查询操作，通过 empno 或者 empno + age 字段进行排序（按照复合索引顺序进行排序查询）</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno <span class="hljs-operator">&gt;</span><span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> empno;EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno <span class="hljs-operator">&gt;</span><span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> empno, age;</code></pre></div><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205145.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816205145.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205226.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816205226.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205112.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816205112.png" alt="img"></a></p><h4 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a><strong>Using temporary</strong></h4><ul><li>使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。<strong>常见于排序 order by 和分组查询 group by</strong></li><li>出现 Using temporary <strong>说明SQL语句设计的非常不好</strong>，可能是因为没有按照顺序使用复合索引</li></ul><p><strong>演示</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--进行查询操作， 通过 age 字段进行分组（未按照复合索引顺序进行排序查询）</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno <span class="hljs-operator">&gt;</span><span class="hljs-number">100002</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> age;<span class="hljs-comment">----进行查询操作，通过 empno 或者 empno + age 字段进行分组（按照复合索引顺序进行排序查询）</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno <span class="hljs-operator">&gt;</span><span class="hljs-number">100002</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> empno;EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno <span class="hljs-operator">&gt;</span><span class="hljs-number">100002</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> empno, age;</code></pre></div><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210843.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816210843.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210908.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816210908.png" alt="img"></a></p><p><strong>重要结论</strong></p><p>如果创建了<strong>复合索引</strong>，一定要<strong>按照复合索引的顺序来使用</strong>，否则会使得性能大幅下降。</p><p>filesort只能应用在单个表上，如果有多个表的数据需要排序，那么MySQL会先使用using temporary保存临时数据，然后再在临时表上使用filesort进行排序，最后输出结果。</p><h4 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a><strong>Using index</strong></h4><ul><li>Using index 代表表示相应的 select 操作中使用了<strong>覆盖索引</strong>(Covering Index)，详见[key：实际用到的索引——覆盖索引](# 覆盖索引)，避免访问了表的数据行，<strong>效率不错</strong>！ </li><li>如果同时出现 using where，表明<strong>索引被用来执行索引键值的查找</strong></li><li>如果没有同时出现 using where，表明<strong>索引只是用来读取数据</strong>而非利用索引执行查找。</li></ul><p><strong>演示</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--查询 age 字段，使用了WHERE</span>EXPLAIN <span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span><span class="hljs-number">100000</span>;<span class="hljs-comment">--查询 empno 和 age 字段，未使用WHERE</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno, age <span class="hljs-keyword">FROM</span> t_emp;<span class="hljs-comment">--查询 empno 和 name 字段 （name字段不是索引）</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno, name <span class="hljs-keyword">FROM</span> t_emp;</code></pre></div><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212055.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816212055.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212129.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816212129.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212243.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200816212243.png" alt="img"></a></p><h4 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h4><ul><li>表明使用了 where 过滤</li></ul><h4 id="Using-join-buffer"><a href="#Using-join-buffer" class="headerlink" title="Using join buffer"></a>Using join buffer</h4><ul><li>使用了连接缓存</li></ul><h4 id="impossible-where"><a href="#impossible-where" class="headerlink" title="impossible where"></a>impossible where</h4><ul><li>where 子句的值总是 false，不能用来获取任何元组</li></ul><h4 id="select-tables-optimized-away"><a href="#select-tables-optimized-away" class="headerlink" title="select tables optimized away"></a>select tables optimized away</h4><ul><li>在没有 GROUP BY 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操 作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li></ul><h1 id="十、单表查询优化"><a href="#十、单表查询优化" class="headerlink" title="十、单表查询优化"></a>十、单表查询优化</h1><h2 id="全值匹配我最爱"><a href="#全值匹配我最爱" class="headerlink" title="全值匹配我最爱"></a>全值匹配我最爱</h2><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--建立符合索引（age, deptId, name）</span><span class="hljs-keyword">CREATE</span> INDEX idx_emp_ade <span class="hljs-keyword">ON</span> t_emp(age, deptId, NAME);<span class="hljs-comment">--查找</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<span class="hljs-comment">--和上一条SQL语句中WHERE后字段的顺序不同，但是不影响查询结果</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164200.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817164200.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817164226.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164241.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817164241.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817164506.png" alt="img"></a></p><p>可以看到，<strong>复合索引都被用到了，并且SQL中查询字段的顺序，跟使用索引中字段的顺序，没有关系</strong>。优化器会在不影响 SQL 执行结果的前提下，自动地优化</p><p><strong>结论：全职匹配我最爱指的是，查询的字段按照顺序在索引中都可以匹配到</strong></p><h2 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a><strong>最佳左前缀法则</strong></h2><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--先删除之前创建的单值索引</span><span class="hljs-keyword">DROP</span> INDEX idx_dept_id <span class="hljs-keyword">ON</span> t_emp; <span class="hljs-comment">--查询，未按照最佳左前缀法则</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<span class="hljs-comment">--查询，部分按照最佳左前缀法则（age字段和复合索引匹配，但name没有）</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span>  age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<span class="hljs-comment">--查询，完全按照最佳左前缀法则</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164932.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817164932.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164948.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817164948.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817165100.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817165100.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817164226.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817164506.png" alt="img"></a></p><p>可以看到，查询<strong>字段与索引字段顺序的不同会导致，索引无法充分使用，甚至索引失效</strong></p><p><strong>原因</strong>：使用复合索引，需要<strong>遵循最佳左前缀法则</strong>，即如果索引了多列，要遵守最左前缀法则。指的是查询从索引的<strong>最左前列开始并且不跳过索引中的列</strong>，俗称中间兄弟不能断</p><p><strong>结论：过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong></p><h2 id="索引列上不计算"><a href="#索引列上不计算" class="headerlink" title="索引列上不计算"></a><strong>索引列上不计算</strong></h2><p>不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换），<strong>可能会导致索引失效而转向全表扫描</strong></p><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--直接查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<span class="hljs-comment">--使用MySQL函数查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(age,<span class="hljs-number">2</span>) <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170139.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817170139.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170522.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817170522.png" alt="img"></a></p><p>可以看出，当age字段使用了left函数以后，<strong>导致索引完全失效</strong></p><p><strong>结论：等号左边无计算</strong></p><h2 id="范围之后全失效"><a href="#范围之后全失效" class="headerlink" title="范围之后全失效"></a>范围之后全失效</h2><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--范围查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<span class="hljs-comment">--未使用范围查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171833.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817171833.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817172159.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817172159.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171903.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817171903.png" alt="img"></a></p><p>可以看出，当对age字段使用范围查询后，使得范围后面的索引失效了</p><p><strong>建议：</strong>将可能做范围查询的字段的索引顺序<strong>放在最后</strong></p><p><strong>结论：使用范围查询后，如果范围内的记录过多，会导致索引失效</strong>，因为从自定义索引映射到主键索引需要耗费太多的时间，反而不如全表扫描来得快</p><h2 id="覆盖索引多使用"><a href="#覆盖索引多使用" class="headerlink" title="覆盖索引多使用"></a>覆盖索引多使用</h2><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--查询所有字段</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">--查询索引字段</span>EXPLAIN <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> t_dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173338.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817173338.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173314.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817173314.png" alt="img"></a></p><p><strong>结论：使用覆盖索引（Using index）会提高检索效率</strong></p><h2 id="使用不等会失效"><a href="#使用不等会失效" class="headerlink" title="使用不等会失效"></a>使用不等会失效</h2><p>在使用<strong>不等于(!= 或者&lt;&gt;)时</strong>，有时会无法使用索引会导致全表扫描</p><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--SQL语句中有不等于</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">!=</span> <span class="hljs-number">90</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">90</span>;<span class="hljs-comment">--SQL语句中没有不等于</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180448.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817180448.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180505.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817180505.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180521.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817180521.png" alt="img"></a></p><p><strong>结论：尽量不要使用不等于</strong></p><h2 id="使用NULL值要小心"><a href="#使用NULL值要小心" class="headerlink" title="使用NULL值要小心"></a>使用NULL值要小心</h2><p>在使用</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>或者<span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span></code></pre></div><p>时，可能会导致索引失效</p><p>但是如果<strong>允许字段为空</strong>，则</p><ul><li>IS NULL 不会导致索引失效</li><li>IS NOT NULL 会导致索引失效</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181044.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817181044.png" alt="img"></a></p><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181116.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817181116.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181137.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817181137.png" alt="img"></a></p><h2 id="模糊查询加右边"><a href="#模糊查询加右边" class="headerlink" title="模糊查询加右边"></a>模糊查询加右边</h2><p>要使用模糊查询时，<strong>百分号最好加在右边，而且进行模糊查询的字段必须是单值索引</strong></p><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--创建单值索引</span><span class="hljs-keyword">CREATE</span> INDEX idx_emp_name <span class="hljs-keyword">ON</span> t_emp(NAME);<span class="hljs-comment">--进行模糊查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风&#x27;</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;风%&#x27;</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风%&#x27;</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817183416.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183401.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817183401.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817183416.png" alt="img"></a></p><p>可以看出，对索引使用模糊查询时，<strong>只有当百分号在右边，索引为单值索引且模糊查询语句在最右边时，索引才会生效</strong></p><p>其他情况均失效了</p><p><strong>但是</strong>有时必须使用其他类型的模糊查询，这时就需要用<strong>覆盖索引</strong>来解决索引失效的问题</p><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风&#x27;</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;风%&#x27;</span>;EXPLAIN <span class="hljs-keyword">SELECT</span> NAME <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风%&#x27;</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817183741.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183801.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817183801.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817183741.png" alt="img"></a></p><p><strong>结论：对索引进行模糊查询时，最好在右边加百分号。必须在左边或左右加百分号时，需要用到覆盖索引来提升查询效率</strong></p><h2 id="字符串加单引号"><a href="#字符串加单引号" class="headerlink" title="字符串加单引号"></a>字符串加单引号</h2><p>当字段为字符串时，查询时必须带上单引号。否则<strong>会发生自动的类型转换</strong>，从而发生全表扫描</p><p><strong>用于查询的表</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817203952.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817203952.png" alt="img"></a></p><p><strong>其中card_id字段为varchar类型，且设置了单值索引</strong></p><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--使用了单引号</span>EXPLAIN <span class="hljs-keyword">SELECT</span> card_id <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">WHERE</span> card_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<span class="hljs-comment">--未使用单引号，发生自动类型转换</span>EXPLAIN <span class="hljs-keyword">SELECT</span> card_id <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">WHERE</span> card_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204047.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817204047.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204027.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817204027.png" alt="img"></a></p><h2 id="尽量不用or查询"><a href="#尽量不用or查询" class="headerlink" title="尽量不用or查询"></a><strong>尽量不用or查询</strong></h2><p>如果使用or，可能导致索引失效。所以要减少or的使用，可以<strong>使用 union all 或者 union 来替代：</strong></p><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--使用or进行查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">OR</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204307.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200817204307.png" alt="img"></a></p><h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>全职匹配我最爱，最左前缀要遵守</p><p>带头大哥不能死，中间兄弟不能断</p><p>索引列上少计算，范围之后全失效</p><p>LIKE 百分写最右，覆盖索引不写</p><p>不等空值还有 OR，索引影响要注意</p><p>VARCHAR 引号不可丢，SQL 优化有诀窍</p><h1 id="十一、关联查询优化"><a href="#十一、关联查询优化" class="headerlink" title="十一、关联查询优化"></a>十一、关联查询优化</h1><p><strong>建表语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `class` (`id` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `card` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (`id`));<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `book` (`bookid` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `card` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (`bookid`));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));</code></pre></div><h2 id="LEFT-JOIN优化"><a href="#LEFT-JOIN优化" class="headerlink" title="LEFT JOIN优化"></a>LEFT JOIN优化</h2><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--未建立索引时的左外连接查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;<span class="hljs-comment">--左表（class）建立索引</span><span class="hljs-keyword">CREATE</span> INDEX idx_class_card <span class="hljs-keyword">ON</span> class(card);<span class="hljs-comment">--再次执行查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;<span class="hljs-comment">--去掉左表索引</span><span class="hljs-keyword">DROP</span> INDEX idx_class_card <span class="hljs-keyword">ON</span> class;<span class="hljs-comment">--右表建立索引</span><span class="hljs-keyword">CREATE</span> INDEX idx_book_card <span class="hljs-keyword">ON</span> book(card);<span class="hljs-comment">--再次执行查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170458.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200818170458.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170402.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200818170402.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170547.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200818170547.png" alt="img"></a></p><p><strong>结论</strong></p><ul><li>在优化关联查询时，只有在<strong>被驱动表上建立索引才有效</strong></li><li>left join 时，左侧的为驱动表，<strong>右侧为被驱动表</strong></li></ul><h2 id="INNER-JOIN优化"><a href="#INNER-JOIN优化" class="headerlink" title="INNER JOIN优化"></a>INNER JOIN优化</h2><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--查询操作，目前索引在book表的card上，class表和book表的位置不会改变查询结果</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> class <span class="hljs-keyword">ON</span> book.card <span class="hljs-operator">=</span> class.card;<span class="hljs-comment">--删除book表中的几条记录</span><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">WHERE</span> bookid<span class="hljs-operator">&lt;</span><span class="hljs-number">10</span>;<span class="hljs-comment">--再次查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;<span class="hljs-comment">--删除book表card字段索引，给class表的card字段添加索引</span><span class="hljs-keyword">DROP</span> INDEX idx_book_card <span class="hljs-keyword">ON</span> book;<span class="hljs-keyword">CREATE</span> INDEX idx_class_card <span class="hljs-keyword">ON</span> class(card);<span class="hljs-comment">--再次查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171341.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200818171341.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171538.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200818171538.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171625.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200818171625.png" alt="img"></a></p><p><strong>结论</strong>：inner join 时，<strong>mysql 会把小结果集的表选为驱动表</strong>（小表驱动大表）</p><p><strong>所以最好把索引建立在大表（数据较多的表）上</strong></p><h2 id="RIGHT-JOIN优化"><a href="#RIGHT-JOIN优化" class="headerlink" title="RIGHT JOIN优化"></a>RIGHT JOIN优化</h2><p>优化类型和LEFT JOIN类似，只不过<strong>被驱动表变成了左表</strong></p><h2 id="IN与EXISTS"><a href="#IN与EXISTS" class="headerlink" title="IN与EXISTS"></a>IN与EXISTS</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210510115846960.png" alt="image-20210510115846960"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210510120010710.png" alt="image-20210510120010710"></p><h1 id="十二、排序分组优化"><a href="#十二、排序分组优化" class="headerlink" title="十二、排序分组优化"></a>十二、排序分组优化</h1><p>在查询中难免会对查询结果进行排序操作。进行排序操作时要<strong>避免出现 Using filesort</strong>，应使用索引给排序带来的方便</p><p><strong>索引信息</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819160428.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819160428.png" alt="img"></a></p><h2 id="ORDER-BY-优化"><a href="#ORDER-BY-优化" class="headerlink" title="ORDER BY 优化"></a>ORDER BY 优化</h2><p>以下查询都是在<strong>索引覆盖</strong>的条件下进行的</p><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--不满足索引覆盖时进行排序查询</span>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId;<span class="hljs-comment">--按照复合索引顺序进行排序</span>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId;EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId, name;<span class="hljs-comment">--不按照复合索引顺序进行排序（无 age 字段），发生Using filesort</span>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, name;<span class="hljs-comment">--不按照复合索引顺序进行排序（索引顺序打乱），发生Using filesort</span>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, name, age;<span class="hljs-comment">--排序时部分(age)升序，部分(deptId)降序，发生Using filesort</span>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span>, deptId <span class="hljs-keyword">DESC</span>;<span class="hljs-comment">--排序时都为降序</span>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span>, deptId <span class="hljs-keyword">DESC</span>;<span class="hljs-comment">--排序时，在前面的字段为常量时（非范围）</span>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, name;EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId<span class="hljs-operator">&gt;</span><span class="hljs-number">10000</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, name;</code></pre></div><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162506.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819162506.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819162240.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819162240.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819162240.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162314.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819162314.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200907210532.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200907210532.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162429.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819162429.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162901.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819162901.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164020.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819164020.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164317.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819164317.png" alt="img"></a></p><p><strong>结论</strong>：</p><p>要想在排序时使用索引，避免 Using filesort，首先需要发生<strong>索引覆盖</strong>，其次</p><ul><li>ORDER BY 后面字段的顺序要和复合索引的<strong>顺序完全一致</strong></li><li>ORDER BY 后面的索引必须按照顺序出现，<strong>排在后面的可以不出现</strong></li><li>要进行升序或者降序时，<strong>字段的排序顺序必须一致</strong>。不能一部分升序，一部分降序，可以都升序或者都降序</li><li>如果复合索引前面的<strong>字段作为常量</strong>出现在过滤条件中，<strong>排序字段可以为紧跟其后的字段</strong></li></ul><h2 id="MySQL的排序算法"><a href="#MySQL的排序算法" class="headerlink" title="MySQL的排序算法"></a>MySQL的排序算法</h2><p>当发生 Using filesort 时，MySQL会根据自己的算法对查询结果进行排序</p><ul><li>双路排序<ul><li>MySQL 4.1 之前是使用双路排序,字面意思就是<strong>两次扫描磁盘</strong>，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段</li><li>简单来说，<strong>取一批数据，要对磁盘进行了两次扫描</strong>，众所周知，I\O 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序</li></ul></li><li>单路排序<ul><li>从磁盘读取查询需要的所有列，按照 order by 列<strong>在 buffer 对它们进行排序</strong>，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO,但是它会使用更多的空间， 因为它把每一行都保存在内存中了</li><li><strong>存在的问题</strong>：在 sort_buffer 中，方法 B 比方法 A 要多占用很多空间，因为方法 B 是把所有字段都取出, 所以有可能<strong>取出的数据的总大小超出了 sort_buffer 的容量</strong>，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多路合并），排完再取取 sort_buffer 容量大小，再排……从而多次 I/O。也就是<strong>本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失</strong></li></ul></li><li>优化Using filesort<ul><li>增大 sort_butter_size 参数的设置<ul><li>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对<strong>每个进程的 1M-8M 之间调整</strong></li></ul></li><li>增大 max_length_for_sort_data 参数的设置<ul><li>mysql 使用单路排序的前提是<strong>排序的字段大小要小于 max_length_for_sort_data</strong></li><li>提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大， 明显症状是高的磁盘 I/O 活动和低的处理器使用率。（1024-8192 之间调整）</li></ul></li><li>减少 select 后面的查询的字段<ul><li>查询的字段减少了，缓冲里就能容纳更多的内容了，<strong>间接增大了sort_buffer_size</strong></li></ul></li></ul></li></ul><p><strong>总结</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164341.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200819164341.png" alt="img"></a></p><h2 id="GROUP-BY-优化"><a href="#GROUP-BY-优化" class="headerlink" title="GROUP BY 优化"></a>GROUP BY 优化</h2><p>优化方式和 ORDER BY 类似，参考ORDER BY 的优化方式即可</p><h1 id="十三、截取查询分析"><a href="#十三、截取查询分析" class="headerlink" title="十三、截取查询分析"></a>十三、截取查询分析</h1><h2 id="慢日志查询"><a href="#慢日志查询" class="headerlink" title="慢日志查询"></a>慢日志查询</h2><p><strong>概念</strong></p><ul><li>MySQL的慢查询日志是MySQL提供的一种日志记录，<strong>它用来记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过<strong>long_query_time</strong>值的SQL，则会被记录到慢查询日志中</li><li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句</li><li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能 收集超过5秒的sql，结合之前explain进行全面分析</li></ul><p><strong>使用</strong></p><p>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们<strong>手动</strong>来设置这个参数</p><p>如果不是调优需要的话，<strong>一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。 慢查询日志支持将日志记录写入文件</p><table><thead><tr><th>SQL 语句</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>SHOW VARIABLES LIKE ‘%slow_query_log%’</td><td>查看慢查询日志是否开启</td><td>默认情况下 slow_query_log 的值为 OFF</td></tr><tr><td>set global slow_query_log=1</td><td>开启慢查询日志</td><td></td></tr><tr><td>SHOW VARIABLES LIKE ‘long_query_time%’</td><td>查看慢查询设定阈值</td><td>单位：秒</td></tr><tr><td>set long_query_time=1</td><td>设定慢查询阈值</td><td>单位：秒</td></tr></tbody></table><p>运行查询时间长的 sql，<strong>可以打开慢查询日志查看</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210510150321742.png" alt="image-20210510150321742"></p><h2 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h2><p><strong>建表语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--dept 部门表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `dept` (`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `deptName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, ceo <span class="hljs-type">INT</span> <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (`id`)) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<span class="hljs-comment">--emp 员工表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `emp` (`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `empno` <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `age` <span class="hljs-type">INT</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, `deptId` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (`id`)#<span class="hljs-keyword">CONSTRAINT</span> `fk_dept_id` <span class="hljs-keyword">FOREIGN</span> KEY (`deptId`) <span class="hljs-keyword">REFERENCES</span> `t_dept` (`id`)) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;</code></pre></div><p><strong>设置参数</strong></p><p>在执行创建函数之前，首先请保证 log_bin_trust_function_creators 参数为 1，即 on 开启状态。 否则会报错</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--查询</span><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;log_bin_trust_function_creators&#x27;</span>;<span class="hljs-comment">--设置</span><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> log_bin_trust_function_creators<span class="hljs-operator">=</span><span class="hljs-number">1</span>;</code></pre></div><h2 id="编写随机函数"><a href="#编写随机函数" class="headerlink" title="编写随机函数"></a>编写随机函数</h2><p><strong>随机产生字符串</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--DELIMITER 是用于改变结束的标志的，一般以分号结尾，但这里改为了以 $$ 结尾</span>DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_string(n <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>)<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> chars_str <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;<span class="hljs-keyword">DECLARE</span> return_str <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;WHILE i <span class="hljs-operator">&lt;</span> n DO<span class="hljs-keyword">SET</span> return_str <span class="hljs-operator">=</span>CONCAT(return_str,<span class="hljs-built_in">SUBSTRING</span>(chars_str,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">52</span>),<span class="hljs-number">1</span>));<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">END</span> WHILE;<span class="hljs-keyword">RETURN</span> return_str;<span class="hljs-keyword">END</span> $$</code></pre></div><p>如果要<strong>删除函数</strong>，则执行：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> rand_string;</code></pre></div><p><strong>随机产生部门编号</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_num (from_num <span class="hljs-type">INT</span> ,to_num <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> <span class="hljs-built_in">FLOOR</span>(from_num <span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span>(to_num <span class="hljs-operator">-</span>from_num<span class="hljs-operator">+</span><span class="hljs-number">1</span>)) ;<span class="hljs-keyword">RETURN</span> i;<span class="hljs-keyword">END</span>$$</code></pre></div><p>如果要<strong>删除函数</strong>，则执行：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">function</span> rand_num;</code></pre></div><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p><strong>创建往 emp 表中插入数据的存储过程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> insert_emp( <span class="hljs-keyword">START</span> <span class="hljs-type">INT</span> , max_num <span class="hljs-type">INT</span> )<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;#<span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span><span class="hljs-number">0</span> 把 autocommit 设置成 <span class="hljs-number">0</span><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;REPEAT<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (empno, NAME ,age ,deptid ) <span class="hljs-keyword">VALUES</span> ((<span class="hljs-keyword">START</span><span class="hljs-operator">+</span>i) ,rand_string(<span class="hljs-number">6</span>) , rand_num(<span class="hljs-number">30</span>,<span class="hljs-number">50</span>),rand_num(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>));UNTIL i <span class="hljs-operator">=</span> max_num<span class="hljs-keyword">END</span> REPEAT;<span class="hljs-keyword">COMMIT</span>;<span class="hljs-keyword">END</span>$$<span class="hljs-comment">--删除</span><span class="hljs-comment">-- DELIMITER ;</span><span class="hljs-comment">-- drop PROCEDURE insert_emp; </span></code></pre></div><p><strong>创建往 dept 表中插入数据的存储过程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--执行存储过程，往 dept 表添加随机数据</span>DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> `insert_dept`( max_num <span class="hljs-type">INT</span> )<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;REPEAT<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept ( deptname,address,ceo ) <span class="hljs-keyword">VALUES</span> (rand_string(<span class="hljs-number">8</span>),rand_string(<span class="hljs-number">10</span>),rand_num(<span class="hljs-number">1</span>,<span class="hljs-number">500000</span>));UNTIL i <span class="hljs-operator">=</span> max_num<span class="hljs-keyword">END</span> REPEAT;<span class="hljs-keyword">COMMIT</span>;<span class="hljs-keyword">END</span>$$<span class="hljs-comment">--删除</span><span class="hljs-comment">-- DELIMITER ;</span><span class="hljs-comment">-- drop PROCEDURE insert_dept; </span></code></pre></div><h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><p><strong>添加数据到部门表</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--执行存储过程，往 dept 表添加 1 万条数据</span>DELIMITER ;<span class="hljs-keyword">CALL</span> insert_dept(<span class="hljs-number">10000</span>);</code></pre></div><p><strong>添加数据到员工表</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--执行存储过程，往 emp 表添加 50 万条数据</span>DELIMITER ;<span class="hljs-keyword">CALL</span> insert_emp(<span class="hljs-number">100000</span>,<span class="hljs-number">500000</span>);</code></pre></div><h2 id="批量删除某个表上的所有索引"><a href="#批量删除某个表上的所有索引" class="headerlink" title="批量删除某个表上的所有索引"></a>批量删除某个表上的所有索引</h2><p><strong>删除索引的存储过程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql">DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> `proc_drop_index`(dbname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),tablename <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>))<span class="hljs-keyword">BEGIN</span><span class="hljs-keyword">DECLARE</span> done <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">DECLARE</span> ct <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">DECLARE</span> _index <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">DECLARE</span> _cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> index_name <span class="hljs-keyword">FROM</span> information_schema.STATISTICS <span class="hljs-keyword">WHERE</span>table_schema<span class="hljs-operator">=</span>dbname <span class="hljs-keyword">AND</span> table_name<span class="hljs-operator">=</span>tablename <span class="hljs-keyword">AND</span> seq_in_index<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> index_name <span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;PRIMARY&#x27;</span> ;<span class="hljs-keyword">DECLARE</span> CONTINUE HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">set</span> done<span class="hljs-operator">=</span><span class="hljs-number">2</span> ;<span class="hljs-keyword">OPEN</span> _cur;<span class="hljs-keyword">FETCH</span> _cur <span class="hljs-keyword">INTO</span> _index;WHILE _index<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;&#x27;</span> DO<span class="hljs-keyword">SET</span> <span class="hljs-variable">@str</span> <span class="hljs-operator">=</span> CONCAT(&quot;drop index &quot;,_index,&quot; on &quot;,tablename );<span class="hljs-keyword">PREPARE</span> sql_str <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@str</span> ;<span class="hljs-keyword">EXECUTE</span> sql_str;<span class="hljs-keyword">DEALLOCATE</span> <span class="hljs-keyword">PREPARE</span> sql_str;<span class="hljs-keyword">SET</span> _index<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-keyword">FETCH</span> _cur <span class="hljs-keyword">INTO</span> _index;<span class="hljs-keyword">END</span> WHILE;<span class="hljs-keyword">CLOSE</span> _cur;<span class="hljs-keyword">END</span>$$</code></pre></div><p><strong>执行存储过程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;);</code></pre></div><h1 id="十四、Profiles分析"><a href="#十四、Profiles分析" class="headerlink" title="十四、Profiles分析"></a>十四、Profiles分析</h1><p>查看是否开启</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;profiling&#x27;</span>;</code></pre></div><p>开启</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> profiling <span class="hljs-operator">=</span> <span class="hljs-keyword">ON</span> ;</code></pre></div><p>查看结果</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> PROFILES ;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210510153815959.png" alt="image-20210510153815959"></p><p>查看具体语句的分析</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> PROFILE cpu,block io <span class="hljs-keyword">FOR</span> QUERY id;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210510153834309.png" alt="image-20210510153834309"></p><p>出现以下结果危险</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210510153359372.png" alt="image-20210510153359372"></p><h1 id="十五、MySQL锁机制"><a href="#十五、MySQL锁机制" class="headerlink" title="十五、MySQL锁机制"></a>十五、MySQL锁机制</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p><strong>[MylSAM](# 引擎层 )引擎使用表锁，并且不支持事务</strong></p><p><strong>SQL语句</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--展示表是否加锁</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> TABLES;<span class="hljs-comment">--加锁 read (读锁) write (写锁)</span>LOCK <span class="hljs-keyword">TABLE</span> table1 read(write), table2 read(write)...<span class="hljs-comment">--全部解锁</span>UNLOCK TABLES;</code></pre></div><h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><ul><li>主机A给表加上<strong>表锁（读锁）</strong>以后<ul><li>主机A和其他主机都可以读取<strong>该表</strong>的信息</li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中所有表的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，<strong>会修改失败</strong></li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给dept表加锁并查询状态</p><div class="hljs code-wrapper"><pre><code class="hljs sql">LOCK <span class="hljs-keyword">TABLE</span> dept READ;<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> TABLES;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151441.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820151441.png" alt="img"></a></p></li></ul><p><strong>读取</strong></p><ul><li><p>两个客户端分别读取dept表的信息，都能读出来</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div></li><li><p>客户端A（加锁端）A<strong>读取其他表</strong>信息，<strong>读取失败</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820152614.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820152614.png" alt="img"></a></p></li><li><p>其他客户端读取度其他表信息，读取成功</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820152714.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820152714.png" alt="img"></a></p></li></ul><p><strong>修改</strong></p><ul><li><p>客户端A对表中内容进行修改，<strong>修改失败</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151654.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820151654.png" alt="img"></a></p></li><li><p>客户端B对表中内容进行修改，进入阻塞状态</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151737.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820151737.png" alt="img"></a></p><ul><li><p>从客户端A解锁后，客户端B修改成功</p><div class="hljs code-wrapper"><pre><code class="hljs sql">UNLOCK TABLES;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820151818.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820151818.png" alt="img"></a></p></li></ul><h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><p>主机A给表加上<strong>表锁（写锁）</strong>以后</p><ul><li>主机A可以读取该表信息，但<strong>其他主机读取时，会进入阻塞状态，直到锁被释放</strong></li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中<strong>除该表以外所有表</strong>的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，修改成功</li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给dept表加上写锁并查看</p><div class="hljs code-wrapper"><pre><code class="hljs sql">LOCK <span class="hljs-keyword">TABLE</span> dept WRITE;<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> TABLES;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153259.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820153259.png" alt="img"></a></p></li></ul><p><strong>读取</strong></p><ul><li><p>客户端A查询该表内容，查询成功；读取其他表，读取失败</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> dept;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153403.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820153403.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153437.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820153437.png" alt="img"></a></p><ul><li><p>其他表读取该表信息，进入阻塞状态</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> dept;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153517.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820153517.png" alt="img"></a></p></li><li><p>释放后，读取成功</p><div class="hljs code-wrapper"><pre><code class="hljs sql">UNLOCK TABLES;</code></pre></div></li></ul><p><strong>修改</strong></p><ul><li><p>客户端A修改<strong>该表</strong>内容，修改成功</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153637.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820153637.png" alt="img"></a></p></li><li><p>客户端A修改<strong>其他表</strong>内容，修改失败</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820153710.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820153710.png" alt="img"></a></p></li><li><p>其他客户端修改<strong>该表</strong>内容，进入阻塞状态</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;</code></pre></div></li></ul><p><strong>总结</strong></p><p><strong>读锁不会阻塞读，只会阻塞写。但是写锁会阻塞读和写。</strong></p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p><strong>InnoDB使用行锁，并且支持事务</strong>，事务相关可参考 <a href="#%E4%BA%94%E3%80%81%E4%BA%8B%E5%8A%A1"><strong>MySQL基础事务</strong></a></p><p><strong>特点</strong></p><p>如果两个客户端<strong>对同一条记录进行修改</strong></p><ul><li>客户端A修改后，未提交（未commit），此时客户端B修改，则会阻塞</li><li>客户端A修改后，提交后，客户端B再修改，则不会阻塞</li></ul><p>如果两个客户端分别<strong>对不同的记录进行修改</strong>，则不会被阻塞</p><p><strong>修改同一条记录</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--关闭自动提交</span><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">--客户端A、B查询id=2的记录</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端A进行修改操作（将年龄改为了80），但未提交</span>UPDATE t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">80</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端A进行查询</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端B进行查询</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端B进行修改（客户端A未提交）</span>UPDATE t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端A提交</span><span class="hljs-keyword">COMMIT</span>;<span class="hljs-comment">--客户端B提交</span><span class="hljs-keyword">COMMIT</span>;</code></pre></div><p><strong>对应结果</strong></p><p>客户端A查询结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820163718.png" alt="img"></a></p><p>客户端B查询结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820163718.png" alt="img"></a></p><p>客户端A修改后A查询</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163847.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820163847.png" alt="img"></a></p><p>客户端A修改后B查询</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820163718.png" alt="img"></a></p><p>客户端A修改，未提交，此时B进行修改，<strong>被阻塞</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163957.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820163957.png" alt="img"></a></p><p>客户端A提交后，B修改成功</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820164036.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820164036.png" alt="img"></a></p><p><strong>修改不同记录</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--客户端A对id=2的年龄进行修改</span>UPDATE t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">--客户端B对id=3的年龄进行修改</span>UPDATE t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<span class="hljs-comment">--客户端A，B分别提交</span><span class="hljs-keyword">COMMIT</span>;<span class="hljs-keyword">COMMIT</span>;</code></pre></div><p>因为InnoDB使用行锁，对于不同行的操作，不会出现阻塞现象</p><p><strong>索引失效</strong></p><p>索引失效，<strong>行锁变表锁</strong></p><p>当<strong>索引失效</strong>后，即使多个客户端操作的不是同一条记录，<strong>如果未提交，其他客户端也会进入阻塞状态</strong></p><p>所以要<strong>避免索引失效</strong></p><h2 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h2><p><strong>概念</strong></p><p>当我们用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁</p><p>对于键值<strong>在条件范围内但并不存在的记录</strong>，叫做<strong>“间隙(GAP)<strong>” ，</strong>InnoDB也会对这个“间隙”加锁</strong>，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p><p><strong>危害</strong></p><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p><p><strong>演示</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--查询表记录，此处没有id=2的记录</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp;<span class="hljs-comment">--客户端A进行范围查询，但是范围内没有id=2的记录</span>UPDATE t_emp <span class="hljs-keyword">SET</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">&gt;</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">6</span>;<span class="hljs-comment">--客户端B进行插入数据，插入一条id=2的记录</span><span class="hljs-keyword">INSERT</span> t_emp <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;岳不群&#x27;</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100002</span>); <span class="hljs-comment">--客户端A提交</span><span class="hljs-keyword">COMMIT</span>;<span class="hljs-comment">--客户端B提交</span><span class="hljs-keyword">COMMIT</span>;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170126.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820170126.png" alt="img"></a></p><p><strong>客户端B进入阻塞状态</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170617.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820170617.png" alt="img"></a></p><p>提交后，插入成功</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170654.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200820170654.png" alt="img"></a></p><p><strong>结论</strong>：可以看到表中本来<strong>没有id=2的记录</strong>，但是在客户端A进行<strong>范围修改</strong>时，客户端B对<strong>在范围内但不存在的数据进行插入时，客户端B进入了阻塞状态</strong></p><p><strong>查看行锁的争夺情况</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;innodb_row_lock%&#x27;</span>;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210510163712985.png" alt="image-20210510163712985"></p><ul><li>1表示正在等待锁定的数量</li><li>2表示等待总时长</li><li>3表示等待平均时长</li><li>5表示系统启动后到现在总共等待的次数</li></ul><h2 id="锁住指定的一行"><a href="#锁住指定的一行" class="headerlink" title="锁住指定的一行"></a><strong>锁住指定的一行</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<span class="hljs-comment">--锁住指定的一行，如果进行更新操作就是 ... FOR UPDATE，删除操作就是 ... FOR DELETE 以此类推</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> UPDATE;<span class="hljs-comment">--进行修改操作</span>UPDATE t_emp <span class="hljs-keyword">SET</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风车车&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">--提交</span><span class="hljs-keyword">COMMIT</span>;</code></pre></div><p>如果当某一行被锁住后，其他客户端对改行进行操作，会被<strong>阻塞</strong></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Innodb存储引擎由于实现了<strong>行级锁定</strong>，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些， 但是在整体<strong>并发处理能力方面要远远优于MyISAM的表级锁定的</strong>。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。<br>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们<strong>使用不当的时候</strong>，可能会让Innodb的整体性能表现不仅不能比MylSAM高，甚至可能会更差。</p><h1 id="十六、复制"><a href="#十六、复制" class="headerlink" title="十六、复制"></a>十六、复制</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/12.mysql%E4%B8%AD%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84.jpg" alt="12.mysql中主从复制架构"></p><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改<strong>写入二进制日志</strong>（Binary log）中。</li><li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并<strong>写入从服务器的中继日志</strong>（Relay log）。</li><li><strong>SQL 线程</strong> ：负责<strong>读取中继日志</strong>，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133613.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200822133613.png" alt="img"></a></p><p><strong>在Linux下实施</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 0.架构规划</span><span class="hljs-code">192.168.202.201    master  主节点</span><span class="hljs-code">192.168.202.202    slave   从节点</span><span class="hljs-code"></span><span class="hljs-code"># 1.修改mysql的配置文件</span><span class="hljs-code">  vim /etc/my.cnf</span><span class="hljs-code"></span><span class="hljs-code"># 2.分别在配置文件中加入如下配置</span><span class="hljs-code">mysql(master):</span><span class="hljs-code">server-id=1</span><span class="hljs-code">log-bin=mysql-bin</span><span class="hljs-code">log-slave-updates</span><span class="hljs-code">slave-skip-errors=all</span><span class="hljs-code"></span><span class="hljs-code">msyql(slave):</span><span class="hljs-code">server-id=2</span><span class="hljs-code">log-bin=mysql-bin</span><span class="hljs-code">log-slave-updates</span><span class="hljs-code">slave-skip-errors=all</span><span class="hljs-code"></span><span class="hljs-code">注意:两个机器的server-id不能一致</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191013201349444.png" alt="image-20191013201349444"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 3.重启mysql服务</span><span class="hljs-code">systemctl restart mysqld</span><span class="hljs-code"></span><span class="hljs-code"># 4.登录mysql执行如下命令检测配置是否生效</span><span class="hljs-code">SHOW VARIABLES like &#x27;server_id&#x27;;</span></code></pre></div><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191013201523812.png" alt="image-20191013201523812"  /><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 5.登录master节点执行如下命令</span><span class="hljs-code">show master status;</span><span class="hljs-code">从图中可以发现从120行后同步</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191013203543728.png" alt="image-20191013203543728"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 6.登录slave节点执行如下命令:</span><span class="hljs-code">change master to </span><span class="hljs-code">master_host=&#x27;192.168.202.201&#x27;,</span><span class="hljs-code">master_user=&#x27;root&#x27;,</span><span class="hljs-code">master_password=&#x27;root&#x27;,</span><span class="hljs-code">master_log_file=&#x27;mysql-bin.000001&#x27;,</span><span class="hljs-code">master_log_pos=120;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 7.开启slave节点</span><span class="hljs-code">start slave; </span><span class="hljs-code">stop  slave;</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191013204413766.png" alt="image-20191013204413766"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 8.查看从节点状态</span><span class="hljs-code">show slave status\G;</span><span class="hljs-code"></span><span class="hljs-code">************************** 1. row ***************************</span><span class="hljs-code">               Slave_IO_State: Waiting for master to send event</span><span class="hljs-code">                  Master_Host: 10.15.0.9</span><span class="hljs-code">                  Master_User: root</span><span class="hljs-code">                  Master_Port: 3306</span><span class="hljs-code">                Connect_Retry: 60</span><span class="hljs-code">              Master_Log_File: mysql-bin.000001</span><span class="hljs-code">          Read_Master_Log_Pos: 120</span><span class="hljs-code">               Relay_Log_File: mysqld-relay-bin.000002</span><span class="hljs-code">                Relay_Log_Pos: 283</span><span class="hljs-code">        Relay_Master_Log_File: mysql-bin.000001</span><span class="hljs-code">             Slave_IO_Running: Yes</span><span class="hljs-code">            Slave_SQL_Running: Yes</span><span class="hljs-code">   </span><span class="hljs-code">    注意:</span><span class="hljs-code">    1.出现 Slave_IO_Running: Yes`和 Slave_SQL_Running: Yes 说明成功</span><span class="hljs-code">    2.如果在搭建过程出现错误,可以查看查看错误日志文件 cat /var/log/mysqld.log</span><span class="hljs-code"># 9.通过客户端工具进行测试</span><span class="hljs-code">自行选择客户端，在master节点新建，可以发现slave节点也会同步</span><span class="hljs-code"># 10.关闭主从复制(在从节点执行)</span><span class="hljs-code">stop slave;</span></code></pre></div><ul><li>注意:如果出现<code>Slave I/O: Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work. Error_code: 1593</code>错误</li><li>关闭<code>systemctl stop mysqld</code>后执行如下命令<code>rm -rf /var/lib/mysql/auto.cnf</code>删除这个文件,之所以出现会出现这样的问题，是因为我的从库主机是克隆的主库所在的主机，所以<code>auto.cnf</code>文件中保存的UUID会出现重复.</li></ul><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p><strong>主服务器处理写操作</strong>以及实时性要求比较高的读操作，而<strong>从服务器处理读操作</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13.mysql%E4%B8%AD%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84-0377396.jpg" alt="13.mysql中读写分离架构"></p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度<strong>缓解了锁的争用</strong></li><li><strong>从服务器</strong>可以使用 <a href="#%E5%BC%95%E6%93%8E%E5%B1%82">MyISAM</a>，提升查询性能以及节约系统开销</li><li>增加冗余，提高可用性</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133739.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20200822133739.png" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java开发网络相关知识</title>
    <link href="/2021/07/25/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/07/25/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Web相关"><a href="#Web相关" class="headerlink" title="Web相关"></a>Web相关</h1><blockquote><p>本文整合了Java工程师所需要用到的Web开发相关的基础知识，供参考</p></blockquote><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、mac地址、ip地址"><a href="#1、mac地址、ip地址" class="headerlink" title="1、mac地址、ip地址"></a>1、mac地址、ip地址</h2><p>终端输入<code>ifconfig en0</code>可以查看</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqbxj10qtj30yq07kwh0.jpg" alt="image-20210420171424350"></p><p>其中ether指的就是mac地址、inet 地址就是ip。</p><p>mac地址也叫物理地址和局域网地址，主要用于确认网上设备的地址，类似于身份证号，具有唯一标识，每一个网卡制作完成之后就带有一个mac地址，永远都不会改变。 </p><p>ip地址，类似于你的现住址，是标记你在网络中的具体位置，一个网卡的ip地址是可以改变的。</p><h2 id="2、计算机之间是怎么连接的"><a href="#2、计算机之间是怎么连接的" class="headerlink" title="2、计算机之间是怎么连接的"></a>2、计算机之间是怎么连接的</h2><h4 id="2-1-双绞线"><a href="#2-1-双绞线" class="headerlink" title="2.1 双绞线"></a>2.1 双绞线</h4><p>如果只是两台计算机，我能就可以使用双绞线（网线）连载一起，就能互相发送消息，组成一个小网络。</p><h4 id="2-2-集线器"><a href="#2-2-集线器" class="headerlink" title="2.2 集线器"></a>2.2 集线器</h4><p>如果有多台计算机，可以使用hub，叫做集线器，一个电脑发送信息到集线器，集线器负责广播到其他的计算机。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqbz4v0z8j30ii09m756.jpg" alt="image-20210420171958113"></p><h4 id="2-3-交换机"><a href="#2-3-交换机" class="headerlink" title="2.3 交换机"></a>2.3 交换机</h4><p>由于集线器的问题，我们经常需要发送信息到特定的计算机而不是广播，所以一个新的设备就出现了叫做交换机（switch）。</p><p>交换机可以记录每一个设备的弟子和接口的对应关系。</p><p>思考问题，交换机要将内容发送给指定的计算机，那么内部一定维护了一张表，记录了哪个电脑链接了我的哪个口。<strong>交换机只能识别MAC地址。MAC地址是物理地址，ip地址交换机并不感兴趣</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqbzu54a6j30w80a2n09.jpg" alt="image-20210420172038615"></p><p>思考一个问题：</p><p>交换机啊是怎么知道这个表的：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqc0drv32j310o0hs0z9.jpg" alt="image-20210420172110207"></p><p>找不到就全员广播，交换机效率比较高，而且可以进行桥接。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqc102pvlj30zy0fkdj6.jpg" alt="image-20210420172144325"></p><h4 id="2-4-路由器"><a href="#2-4-路由器" class="headerlink" title="2.4 路由器"></a>2.4 路由器</h4><p>思考：使用交换机可以建立一个超大型的网络吗？</p><p>一般的交换机的地址表也就能存个几千个地址，当网络内的设备多起来以后，只要交换机找不到对应设备就会广播，地址表如果满了，新地址还会覆盖就地址就会导致重新寻找效率比较低。所以有引入了一个设备叫路由器，谁也听过的一个设备，一般家里都有。</p><p>注意：路由器不是猫，猫是调制解调器，调制解调器的作用是将进来的光信号转化为电信号</p><p><strong>于是提出了以下的设计</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc1wbgstj30zs0eoq7l.jpg" alt="image-20210420172236973"></p><p>这里就有了网络的概念了。以上的几种，哪怕是交换机的桥接也没有设计ip地址这个概念，都是基于mac地址进行数据传输。这里有了网络这个抽象概念之后ip地址就应用而生了，IP地址只要是用来表示计算机的网络位置，他处于哪一个网络。IP地址和子网掩码共同帮助我们定位一个计算机在网络中的位置。</p><p>ip地址和子网掩码其实是个32位的二进制数字</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc2h9o9kj310m0b6tcy.jpg" alt="image-20210420172310601"></p><p>此时发送信息就会再包一个消息的头部</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc2usjtbj311604emym.jpg" alt="image-20210420172332366"></p><p>家用的路由器，有个wan口，有好几个lan口，wan口用来来接互联网端，lan用来连接家庭设备，这连个口都有一个网卡，一个网卡属于互联网网络，ip可能是10.25.23.65，另一个属于内部网络比如192.168.0.1。内部网络和外部互联网的数据转发由路由器内部实现。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc3hbvt0j310e0ds40v.jpg" alt="image-20210420172408830"></p><p>路由器内有路由表。 </p><p>网络内传输，有了网关的概念了。 ip不能直接进行传输，应为网络内的交换机不支持ip地址，所以通信要转化为mac地址，根据ip查找mac 地址。 </p><p>非常重要的arp协议，要进行广播，问一问哪个mac地址的ip是192.168.0.5，他收到就会回应</p><p>来一个栗子，192.168.100.100 发送信息到 192.168.200.101</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc44vadvj310e0f0adl.jpg" alt="image-20210420172446386"></p><p>第一步： 192.168.100.100 -&gt; 192.168.200.101</p><p><strong>利用地址解析协议（ARP）协议对应IP地址到MAC地址，因为交换机只认识MAC地址，同时在传输过程中MAC地址会一直变化，如下图所示，头部会变</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421153534811.png" alt="image-20210421153534811"></p><p>添加一条路由</p><div class="hljs code-wrapper"><pre><code class="hljs shell">route add -host 192.168.110.202 gw 192.168.120.202 route del -host 192.168.110.202 gw 192.168.120.202</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs shell">tcpdump -i eth1 host 192.168.1.123 -w /tmp/xxx.cap</code></pre></div><p>ICMP（InternetControlMessageProtocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421104754669.png" alt="image-20210421104754669"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421105345780.png" alt="image-20210421105345780"></p><h4 id="2-5-NAT协议"><a href="#2-5-NAT协议" class="headerlink" title="2.5 NAT协议"></a>2.5 NAT协议</h4><p>每台设备都分配一个ip当然能够实现网络的建立，但是事实上我们只有数量有限的IP地址，能给我们用的大概只有40亿左右，于是一般的做法是家里只有一个ip地址，所有的设备通过路由器连接。连接在内网。那么问题来了，你的手机的地址是192.168.0.10，别人家的也可能是一样的百度怎么区分呀？</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc6j041yj30ym0i8q6i.jpg" alt="image-20210420172704178"></p><p>这个叫NAT协议 NAT（Network Address Translation，网络地址转换）。</p><p>现在家里的路由器都是带有交换功能的，能使用的IP地址 25.68亿 共有40多亿</p><h2 id="3、ip地址的分类"><a href="#3、ip地址的分类" class="headerlink" title="3、ip地址的分类"></a>3、ip地址的分类</h2><p>1、A类IP地址 </p><p>一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从 1.0.0.0 到126.0.0.0。可用的A类网络有126个，每个网络能容纳1亿多个主机。</p><p>2、B类IP地址 </p><p>一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范 围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。</p><p>3、C类IP地址 </p><p>一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从 192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。</p><p>4、D类地址 </p><p>用于多点广播（Multicast）。 D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算 机，它标识共享同一协议的一组计算机。224.0.0.0到239.255.255.255用于多点广播 。</p><p>5、E类IP地址 </p><p>以“11110”开始，为将来使用保留。240.0.0.0到255.255.255.254，255.255.255.255用于广播地址，全零 （“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播 地址。</p><p><strong>IP私有地址：</strong></p><p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：</p><p>A类地址：10.0.0.0～10.255.255.255 </p><p>B类地址：172.16.0.0～172.31.255.255 </p><p><strong>C类地址</strong>：192.168.0.0～192.168.255.255 </p><p>A类地址的第一组数字为1～126。注意，数字0和127不作为A类地址，数字127保留给内部回送函数，而数字0则表示该地址是本地宿主机，不能传送。</p><p>B类地址的第一组数字为128～191。</p><p>C类地址的第一组数字为192～223。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc8i8b99j30s60rsgt7.jpg" alt="image-20210420172857859"></p><h2 id="4、域名DNS"><a href="#4、域名DNS" class="headerlink" title="4、域名DNS"></a>4、域名DNS</h2><p>你真的能记住每个网站的ip地址吗？ 那我们输入的<a href="http://www.github.com是什么是域名,我们可以去阿里云等云服务提供商购买域名./">www.github.com是什么是域名，我们可以去阿里云等云服务提供商购买域名。</a></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc9n9n09j30wg0cqafi.jpg" alt="image-20210420173003852"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqca0gsvij30x40magna.jpg" alt="image-20210420173025265"></p><p>域名是需要解析的，指向一个ip地址</p><p>为了让你容易记忆引入了域名的概念，你不需要记忆，有人帮您记录</p><p><strong>DNS解析</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqcb18w1ij30yy0fg78b.jpg" alt="image-20210420173112302"></p><h4 id="4-1、国内的dns"><a href="#4-1、国内的dns" class="headerlink" title="4.1、国内的dns"></a>4.1、国内的dns</h4><p><strong>第一名 114DNS：</strong>★★★★★ </p><p>114DNS开启DNS高可靠服务时代的大幕。114DNS开始同时为公众提供高速、稳定、可信的DNS递归解析服务；为网站提供强大抗攻击能力的权威智能DNS解析服务；为ISP提供可靠的DNS灾备及外包服务，作为国内用户量最大的老牌DNS，访问速度快，各地区设有节点，负载各运营商用户，DNS防劫持能力，自然也是名列前茅。 </p><p>DNS 服务器 IP 地址：</p><p>首选：114.114.114.114</p><p>备选：114.114.114.115 </p><p>2017公共DNS服务器地址评估—DNS推荐 </p><p><strong>第二名 DNSPod DNS：</strong>★★★★★</p><p>DNSPod创始于2006年3月，是中国最大的第三方域名服务商，全球排名第四位。DNSPod是国内最早提 供免费智能DNS产品的网站,致力于为各类网站提供高质量的电信、网通、教育网双线或者三线智能DNS 免费解析，作为114DNS竞争对手之一，无论是访问速度，还是各地区节点覆盖率以及防劫持能力都是 顶级的。 </p><p>DNS 服务器 IP 地址： </p><p>首选：119.29.29.29 </p><p>备选：182.254.116.116 </p><p>2017公共DNS服务器地址评估—DNS推荐 </p><p><strong>第三名 阿里 DNS：</strong>★★★★★ </p><p>阿里公共DNS是阿里巴巴集团推出的DNS递归解析系统，作为国内最大的互联网基础服务提供商，阿里 巴巴在继承多年优秀技术的基础上，通过提供性能优异的公共DNS服务，为广大互联网用户提供最可靠 的面向互联网用户提供“快速”、“稳定”、“智能”的免费DNS递归解析服务。 </p><p>DNS 服务器 IP 地址：</p><p>首选：223.5.5.5 </p><p>备选：223.6.6.6 </p><p>2017公共DNS服务器地址评估—DNS推荐</p><h4 id="4-2、域名的分类"><a href="#4-2、域名的分类" class="headerlink" title="4.2、域名的分类"></a>4.2、域名的分类</h4><p><strong>语种分类</strong></p><p>英文域名、中文域名、日文域名、韩文域名等等。</p><p>现在我们常见的就是英文域名。</p><p>英文域名：baidu.com</p><p>中文域名：百度.com 、百度.中国、baidu.中国</p><p>其它语言域名同上。</p><p><strong>地区分类</strong></p><p>中国、美国、英国、日本等等。</p><p>在国内我们常用的就是.cn域名，.cn是中国大陆的国家一级域名。另外还 有.com.cn、.net.cn、.org.cn等等。</p><p>国内不同省市也有自己的顶级域名，例如内蒙古的顶级域名就是：.nm.cn。</p><p>美国国家顶级域名是.us 、日本的是.jp、香港的是.hk。</p><p><strong>机构分类</strong></p><p>.com 商业性的机构或公司 </p><p>.org 非盈利的组织、团体 apache.org </p><p>.gov 政府部门 <a href="http://www.shanxi.gov.cn/">http://www.shanxi.gov.cn/</a> </p><p>.net 从事Internet相关的的机构或公司 </p><p>域名虽然有很多分类，但是我们平时在使用的时候，并没有过多的遵循这个原则。比如.com的也有 很多作为个人网站、.net很多也用来做了公司网站。</p><h4 id="4-3、层级分类"><a href="#4-3、层级分类" class="headerlink" title="4.3、层级分类"></a>4.3、层级分类</h4><p><strong>顶级域名（一级域名）</strong></p><p> baidu.com baidu.cn</p><p><strong>二级域名</strong></p><p><a href="http://www.baidu.com/">www.baidu.com</a>  jingyan.baidu.com</p><p><strong>三级域名</strong></p><p>wangshangyingxiao.club.1688.com    hhz.bbs.53hui.com</p><h1 id="二、网络七层协议"><a href="#二、网络七层协议" class="headerlink" title="二、网络七层协议"></a>二、网络七层协议</h1><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqcgu0vbmj310i0jmwif.jpg" alt="image-20210420173658725"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqch8ru04j311e0fsgqx.jpg" alt="image-20210420173722089"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqchtkslkj31100haamx.jpg" alt="image-20210420173742375"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210609162902357.png" alt="image-20210609162902357"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210609163017056.png" alt="image-20210609163017056"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210609163330263.png" alt="image-20210609163330263"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611114939511.png" alt="image-20210611114939511"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611115531956.png" alt="image-20210611115531956"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611115715297.png" alt="image-20210611115715297"></p><h2 id="1、Socket"><a href="#1、Socket" class="headerlink" title="1、Socket"></a>1、Socket</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210610185953431.png" alt="image-20210610185953431"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210610191338814.png" alt="image-20210610191338814"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210610191651004.png" alt="image-20210610191651004"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611102845612.png" alt="image-20210611102845612"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611111622941.png" alt="image-20210611111622941"></p><h2 id="2、C-S-amp-B-S"><a href="#2、C-S-amp-B-S" class="headerlink" title="2、C/S &amp; B/S"></a>2、C/S &amp; B/S</h2><ul><li>CS和BS含义： <strong>CS即Client/Server(客户机/服务器)结构</strong>。C/S结构在技术上很成熟，它的主要特点是<code>交互性强、具有安全的存取模式、网络通信量低、响应速度快、利于处理大量数据</code>。但是该结构的程序是<code>针对性开发，变更不够灵活，维护和管理的难度较大</code>。通常只局限于小型局域网，不利于扩展。并且，由于该结构的每台客户机都需要安装相应的客户端程序，分布功能弱且兼容性差，不能实现快速部署安装和配置，因此缺少通用性，具有较大的局限性。要求具有一定专业水准的技术人员去完成。  <strong>BS即Browser/Server(浏览器/服务器)结构</strong>，就是只安装维护一个服务器(Server)，而客户端采用浏览器(Browse)运行软件。B/S结构应用程序相对于传统的C/S结构应用程序是一个非常大的进步。B/S结构的主要特点是<code>分布性强、维护方便、开发简单且共享性强、总体拥有成本低</code>。但<a href="https://cloud.tencent.com/solution/data_protection?from=10680">数据安全</a>性问题、对服务器要求过高、数据传输速度慢、软件的个性化特点明显降低，这些缺点是有目共睹的，难以实现传统模式下的特殊功能要求。例如：通过浏览器进行大量的数据输入或进行报表的应答、专用性打印输出都比较困难和不便。此外，实现复杂的应用构造有较大的困难。</li><li>区别： <ul><li>1、开发维护成本 <strong>cs开发维护成本高于bs</strong>。因为采用cs结构时，对于不同的客户端要开发不同的程序，而且软件安装调试和升级都需要在所有客户机上进行。 bs只需要将服务器上的软件版本升级，然后从新登录就可以了。</li><li>2、客户端负载 <strong>cs客户端负载大</strong>。cs客户端不仅负责和用户的交互，收集用户信息，而且还需要通过网络向服务器发出请求。 bs把事务处理逻辑部分交给了服务器，客户端只是负责显示。</li><li>3、安全性 <strong>cs安全性高</strong>。cs适用于专人使用的系统，可以通过严格的管理派发软件。 bs使用人数多，不固定，安全性低。</li><li>4、作用范围 Client/Server是建立在<strong>局域网</strong>的基础上的。Browser/Server是建立在<strong>广域网</strong>的基础上的。</li></ul></li></ul><h2 id="3、可靠数据传输的原理"><a href="#3、可靠数据传输的原理" class="headerlink" title="3、可靠数据传输的原理"></a>3、可靠数据传输的原理</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611154205977.png" alt="image-20210611154205977"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611154251038.png" alt="image-20210611154251038"></p><p><strong>rdt具有不同的情况，见PDF第三章第七页</strong></p><h1 id="三、TCP-UDP-HTTP协议"><a href="#三、TCP-UDP-HTTP协议" class="headerlink" title="三、TCP/UDP/HTTP协议"></a>三、TCP/UDP/HTTP协议</h1><h2 id="1、tcp协议"><a href="#1、tcp协议" class="headerlink" title="1、tcp协议"></a>1、tcp协议</h2><p>传输依靠什么进行控制</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqcikuhu8j30ym0jwq64.jpg" alt="image-20210420173839440"></p><blockquote><p>源端口和目的端口字段</p></blockquote><ul><li>TCP源端口（Source Port）：源计算机上的应用程序的端口号，占 16 位。 </li><li>TCP目的端口（Destination Port）：目标计算机的应用程序端口号，占 16 位。</li></ul><blockquote><p>序列号字段</p></blockquote><p>CP序列号（SequenceNumber）：占32位。它表示本报文段所发送数据的第一个字节的编号。在TCP连接中，所传送的字节流的每一个字节都会按顺序编号。当SYN标记不为1时，这是当前数据分段第一个字母的序列号；如果SYN的值是1时，这个字段的值就是初始序列值（ISN），用于对序列号进行同步。这时，第一个字节的序列号比这个字段的值大1，也就是ISN加1。</p><blockquote><p>确认号字段</p></blockquote><p>TCP 确认号（Acknowledgment Number，ACK Number）：占 32 位。它表示接收方期望收到发送方 下一个报文段的第一个字节数据的编号。其值是接收计算机即将接收到的下一个序列号，也就是下一个 接收到的字节的序列号加1。</p><blockquote><p>数据偏移字段</p></blockquote><p>TCP 首部长度（Header Length）：数据偏移是指数据段中的“数据”部分起始处距离 TCP 数据段起始处 的字节偏移量，占 4 位。其实这里的“数据偏移”也是在确定 TCP 数据段头部分的长度，告诉接收端的应 用程序，数据从何处开始。</p><blockquote><p>保留字段</p></blockquote><p>保留（Reserved）：占 4 位。为 TCP 将来的发展预留空间，目前必须全部为 0。</p><blockquote><p>标志位字段</p></blockquote><ul><li>CWR（CongestionWindowReduce）：拥塞窗口减少标志，用来表明它接收到了设置ECE标志的TCP包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率。</li><li>ECE（ECNEcho）：用来在TCP三次握手时表明一个TCP端是具备ECN功能的。在数据传输过程中，它也用来表明接收到的TCP包的IP头部的ECN被设置为11，即网络线路拥堵。</li><li>URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。 </li><li>ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字 段才有效。TCP 规定，连接建立后，ACK 必须为 1。 </li><li>PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即 把数据提交给上层，而不是缓存起来。 </li><li>RST：表示是否重置连接。如果RST=1，说明TCP连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。</li><li>SYN：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的 报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接 或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。 </li><li>FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。</li></ul><blockquote><p>窗口大小字段</p></blockquote><p>窗口大小（Window Size）：占 16 位。它表示从 Ack Number 开始还可以接收多少字节的数据量，也 表示当前接收端的接收窗口还有多少剩余空间。该字段可以用于 TCP 的流量控制。</p><blockquote><p>TCP 校验和字段</p></blockquote><p>校验位（TCPChecksum）：占16位。它用于确认传输的数据是否有损坏。发送端基于数据内容校验生成一个数值，接收端根据接收的数据校验生成一个值。两个值必须相同，才能证明数据是有效的。如果两个值不同，则丢掉这个数据包。Checksum是根据伪头+TCP头+TCP数据三部分进行计算的。</p><blockquote><p>紧急指针字段</p></blockquote><p>紧急指针（Urgent Pointer）：仅当前面的 URG 控制位为 1 时才有意义。它指出本数据段中为紧急数据 的字节数，占 16 位。当所有紧急数据处理完后，TCP 就会告诉应用程序恢复到正常操作。即使当前窗 口大小为 0，也是可以发送紧急数据的，因为紧急数据无须缓存。</p><blockquote><p>可选项字段</p></blockquote><p>选项（Option）：长度不定，但长度必须是 32bits 的整数倍。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210615205125038.png" alt="image-20210615205125038"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210616101803429.png" alt="image-20210616101803429"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210616103716046.png" alt="image-20210616103716046"></p><h2 id="2、握手"><a href="#2、握手" class="headerlink" title="2、握手"></a>2、握手</h2><p>SYN–标志位</p><p>Seq–随机序列号</p><p>ACK–应答报文</p><p>ack–确认序列号（ack=x+1）</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqcmapkprj30pm0lk0w1.jpg" alt="image-20210420174213945"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqcmotnfjj31fy03w40t.jpg" alt="image-20210420174236651"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqcn921bej31by0hutgs.jpg" alt="image-20210420174308237"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210615212011080.png" alt="image-20210615212011080"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210615212132528.png" alt="image-20210615212132528"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210615213000278.png" alt="image-20210615213000278"></p><p><strong>具体的见PDF第三章26页</strong></p><p>在数据发送的过程中，利用滑动窗口进行数据的发送</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210422104504154.png" alt="image-20210422104504154"></p><h2 id="3、udp协议"><a href="#3、udp协议" class="headerlink" title="3、udp协议"></a>3、udp协议</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4r871ksj319y0u0qen.jpg" alt="image-20210421095544693"></p><p>讲解一下： </p><p>*UDP头部很简单，包括源端口，目的端口，UDP总长度，校验和，各占16位/2字节，共8字节。 </p><p>*源端口：长度16位，指定发送方所使用的端口号，若不需要对方回发消息，则可全置为0。 </p><p>*目的端口：长度16位，指定接收方所使用的端口号。 </p><p>*UDP总长度：长度16位，指定了UDP数据报的总长度。 </p><p>*校验和：长度16位，用于UDP的差错检测，防止UDP报文出错，同时伪首部参与计算，避免UDP用户 数据报传送到错误的目的地。UDP的首部，数据部分，伪首部都会参与检验和的计算，各字段是按照16 比特为单位进行计算的，因此数据部分是要保证是16比特的倍数，不够用0填充。</p><blockquote><p>tcp与udp的区别</p></blockquote><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210422105701215.png" alt="image-20210422105701215"></p><h2 id="4、http协议"><a href="#4、http协议" class="headerlink" title="4、http协议"></a>4、http协议</h2><h3 id="1、HTTP协议简介"><a href="#1、HTTP协议简介" class="headerlink" title="1、HTTP协议简介"></a>1、HTTP协议简介</h3><p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和 超媒体信息系统的<strong>应用层协议</strong>。HTTP是万维网的数据通信的基础。</p><p>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万 维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定 义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</p><p>2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将 HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。</p><h3 id="2、HTTP协议概述"><a href="#2、HTTP协议概述" class="headerlink" title="2、HTTP协议概述"></a>2、HTTP协议概述</h3><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。</p><p>通过使用网页浏览器或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为 80）。</p><p>我们称这个客户端为用户代理程序（user agent）。</p><p>应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。</p><p>通常，由HTTP客户端发起一个请求，创<strong>建一个到服务器指定端口（默认是80端口,https是443）的连接</strong>。HTTP服务器则<strong>在那个端口监听客户端的请求</strong>。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><h3 id="3、HTTP工作原理"><a href="#3、HTTP工作原理" class="headerlink" title="3、HTTP工作原理"></a>3、HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户 端。HTTP协议采用了<strong>请求/响应模型</strong>。客户端向服务器发送一个请求报文，请求报文包含请求的方法、 URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、 成功或者错误代码、服务器信息、响应头部和响应数据。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210610193946860.png" alt="image-20210610193946860"></p><p>在端口号为80的本地建立一个守护socket，当任意一个请求来的时候，再建立一个socket，但守护socket一直存在。</p><p><strong>以下是 HTTP 请求/响应的步骤：</strong></p><ol><li><p>1.客户端连接到Web服务器浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址，一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如， <a href="http://www.luffycity.com/">http://www.luffycity.com</a></p></li><li><p>发送HTTP请求 通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由<strong>请求行、请求头部、空行和请求数据</strong>4部分组成。</p></li><li><p>服务器接受请求并返回HTTP响应 Web服务器<strong>解析请求，定位请求资源</strong>。服务器将资源复本写到TCP套接字，由客户端读取。一个响 应由<strong>状态行、响应头部、空行和响应数据</strong>4部分组成。</p></li><li><p>释放连接TCP连接 若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若 connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析HTML内容</p><p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应 头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据 HTML的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4uenbidj31b60f4133.jpg" alt="image-20210421095847308"></p><p><strong>http协议是基于TCP/IP协议之上的应用层协议</strong></p><p> <strong>基于 请求-响应 的模式</strong> </p><p>HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开 始建立通信的,服务器端在没有 接收到请求之前不会发送响应，<strong>服务端不能主动说话</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4v1bp61j31em0i8gxu.jpg" alt="image-20210421095923805"></p><p><strong>无状态</strong> </p><p>HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态 进行保存。也就是说在HTTP这个 级别,协议对于<strong>发送过的请求或响应都不做持久化处理</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4vk81ccj31b80mugz6.jpg" alt="image-20210421095953726"></p><p>使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能,于是<strong>引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管理状态了</strong>。</p><p><strong>无连接</strong></p><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是<strong>现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在</strong>，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210610194254771.png" alt="image-20210610194254771"></p><blockquote><p>来个总结 http 是一种基于请求和响应的无状态、无连接的协议</p></blockquote><p><strong>简单的HTTP通信代码（基于TCP）</strong></p><p>客户端</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Socket socket = <span class="hljs-keyword">new</span> Socket();        socket.connect(<span class="hljs-keyword">new</span> InetSocketAddress(InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>),<span class="hljs-number">4000</span>));        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);        String msg = scanner.next();        OutputStream outputStream = socket.getOutputStream();        outputStream.write(msg.getBytes());        outputStream.flush();        outputStream.close();        socket.close();    &#125;&#125;</code></pre></div><p>服务器</p><p>多线程并发模式采用一个连接一个线程的方式，优点是确实一定程度上提高了服务器的吞吐量，因为之前的请求在<code>read</code>读阻塞后不会影响到后续的请求，由于它们在不同的线程中，而且一个线程只能对应一个套接字<code>socket</code>，每一个套接字<code>socket</code>都是阻塞的，所以一个线程中只能处理一个套接字。就算<code>accept</code>多个<code>socket</code>，如果前一个<code>socket</code>被阻塞其后的<code>socket</code>是无法被执行到的</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//创建服务器</span>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket();        <span class="hljs-comment">//绑定端口</span>        server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">4000</span>));        System.out.println(<span class="hljs-string">&quot;服务器已启动，监听4000端口&quot;</span>);        <span class="hljs-comment">//进行监听</span>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            Socket accept = server.accept();          <span class="hljs-comment">//利用多线程通信</span>            <span class="hljs-keyword">new</span> MsgHandler(accept).start();        &#125;    &#125;&#125;<span class="hljs-comment">//多线程处理，如果是多个客户端连接，端口号不一样，IP相同</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;    Socket accept = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MsgHandler</span><span class="hljs-params">(Socket accept)</span> </span>&#123;        <span class="hljs-keyword">this</span>.accept = accept;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        InputStream inputStream = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//拿到数据进行读取</span>            inputStream = accept.getInputStream();            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            <span class="hljs-keyword">int</span> len;            <span class="hljs-keyword">while</span> ((len = inputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;                System.out.println(<span class="hljs-keyword">new</span> String(buf, <span class="hljs-number">0</span>, len));            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span>&#123;            <span class="hljs-keyword">if</span>(inputStream != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">try</span> &#123;                    inputStream.close();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="4、HTTP请求格式-请求协议"><a href="#4、HTTP请求格式-请求协议" class="headerlink" title="4、HTTP请求格式(请求协议)"></a>4、HTTP请求格式(请求协议)</h3><p>其实就是个字符串：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4x9w0jyj315y0jejww.jpg" alt="image-20210421100133351"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4xhmgr9j31ga0skthf.jpg" alt="image-20210421100146022"></p><p>请求头里面的内容举个例子：这个length表示请求体里面的数据长度，其他的请求头里面的这些键值对，陆续我们会讲的，大概知道一下就可以了，其中有一个user-agent，算是需要你记住的吧，就是告诉你的服务端，我是用什么给你发送的请求，是个啥客户端。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4y12qdmj30qm0feq5q.jpg" alt="image-20210421100214644"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4y7jdv4j31iu0ji48d.jpg" alt="image-20210421100226816"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4yfz6suj31ki0tik7p.jpg" alt="image-20210421100240863"></p><p>看一个爬虫的例子，爬京东的时候没问题，但是爬抽屉的时候必须带着user-agent，因为 抽屉对user-agent做了判断，来判断你是不是一个正常的请求，算是反扒机制的一种</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4ywttdaj31hq0kwk2f.jpg" alt="image-20210421100307753"></p><p>打开我们保存的demo.html文件，然后通过浏览器打开看看就能看到页面效果。</p><p>写上面这些内容的意思是让你知道有这么个请求头的存在，有些是有意义的，请求头我们 还可以自己定义，就在requests模块里面那个headers={}，这个字典里面加就行</p><h3 id="5、HTTP请求方法"><a href="#5、HTTP请求方法" class="headerlink" title="5、HTTP请求方法"></a>5、HTTP请求方法</h3><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p><ul><li>GET</li></ul><p>向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，常用语查询数据的请求。</p><ul><li>POST</li></ul><p>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。常用于对数据的增删改操作。</p><blockquote><p>请求方式: get与post请求（通过form表单我们自己写写看）</p></blockquote><ul><li>GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲）POST方法是把提交的数据放在HTTP包的请求体中</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制</li><li>GET与POST请求在服务端获取请求数据方式不同，就是我们自己在服务端取请求数据的时候的方式不同了</li></ul><h3 id="6、URL"><a href="#6、URL" class="headerlink" title="6、URL"></a>6、URL</h3><p>超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：</p><ul><li>传送协议</li><li>层级URL标记符号(为[//],固定不变) </li><li>访问资源需要的凭证信息（可省略） </li><li>服务器（通常为域名，有时为IP地址） </li><li>端口号（以数字方式表示，若为HTTP的默认值“:80”可省略） </li><li>路径（以“/”字符区别路径中的每一个目录名称） </li><li>查询（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数 据，通常以UTF8的URL编码，避开字符冲突的问题） </li><li>片段，以“#”字符为起点</li></ul><div class="hljs code-wrapper"><pre><code class="hljs markdown">以http://www.xinzhi.com:80/news/index.html?id=250&amp;page=1 为例, 其中：http，是协议； www.xinzhi.com，是服务器； 80，是服务器上的默认网络端口号，默认不显示； /news/index.html，是路径（URI：直接定位到对应的资源）； ?id=250&amp;page=1，是查询条件。 大多数网页浏览器不要求用户输入网页中“[http://”的部分，因为绝大多数网页内容是超文本传输协议文件。 “80”是超文本传输协议文件的常用默认端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分</code></pre></div><p>Java中的三板斧</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">while</span> ((len = inputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;  System.out.println(<span class="hljs-keyword">new</span> String(buf, <span class="hljs-number">0</span>, len));&#125;</code></pre></div><h3 id="7、请求中常见的ContentType"><a href="#7、请求中常见的ContentType" class="headerlink" title="7、请求中常见的ContentType"></a>7、请求中常见的ContentType</h3><p>就是告诉服务器，我给你发了个参数，参数是什么类型，你应该怎么接受，怎么解析</p><blockquote><p>application/x-www-form-urlencoded </p></blockquote><p>这应该是最常见的POST提交数据的方式了。浏览器的原生form表单，如果不设置enctype属性，那么最终就会以application/x-www-form-urlencoded方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）</p><p>格式 ： name=’lisi’&amp;age=13</p><blockquote><p>application/json </p></blockquote><p>application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p><p>格式： {“name”:”lisi”,”age”:13} </p><blockquote><p>multipart/form-data </p></blockquote><p>这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这 个值。直接来看一个请求示例：</p><h3 id="8、HTTP响应格式（响应协议）"><a href="#8、HTTP响应格式（响应协议）" class="headerlink" title="8、HTTP响应格式（响应协议）"></a>8、HTTP响应格式（响应协议）</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr548wtogj315y0h87c0.jpg" alt="image-20210421100814365"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr54gqhucj31aw0u0k1u.jpg" alt="image-20210421100827723"></p><h3 id="9、HTTP状态码"><a href="#9、HTTP状态码" class="headerlink" title="9、HTTP状态码"></a>9、HTTP状态码</h3><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态 的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型：</p><ul><li>1xx消息——请求已被服务器接收，继续处理 </li><li>2xx成功——请求已成功被服务器接收、理解、并接受 </li><li>3xx重定向——需要后续操作才能完成这一请求 </li><li>4xx请求错误——请求含有词法错误或者无法被执行，客户端 </li><li>5xx服务器错误——服务器在处理某个正确请求时发生错误，500</li></ul><p>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍 然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr55eremqj31fu0han86.jpg" alt="image-20210421100922367"></p><p><strong>状态码（Status Codes）</strong></p><table><thead><tr><th>2xx：成功</th><th>3xx：重定向</th><th>4xx：客户端错误</th><th>5xx：服务器错误</th></tr></thead><tbody><tr><td>200 成功</td><td>301 永久重定向</td><td>400 错误请求</td><td>500 服务器错误</td></tr><tr><td>201 创建</td><td>304 资源未修改</td><td>401 未授权</td><td>501 尚未实施</td></tr><tr><td></td><td></td><td>410 已删除</td><td>502 网关错误</td></tr><tr><td></td><td></td><td>403 禁止访问</td><td>503 服务不可用</td></tr><tr><td></td><td></td><td>404 未找到</td><td>504 网关超时</td></tr><tr><td></td><td></td><td>405 请求方法不对</td><td>505 HTTP版本不支持</td></tr></tbody></table><h3 id="10、响应中常见的contentType"><a href="#10、响应中常见的contentType" class="headerlink" title="10、响应中常见的contentType"></a>10、响应中常见的contentType</h3><p><code>text/html </code></p><p>告诉浏览器，我给你返回的是html，请渲染</p><p><code>application/json</code></p><p>告诉浏览器，我给你返回的是json数据 ，一般会让js去处理</p><p><strong>常见的contenttype对照表</strong></p><p><a href="https://tool.oschina.net/commons/">https://tool.oschina.net/commons/</a></p><h3 id="11、一些常见的响应头"><a href="#11、一些常见的响应头" class="headerlink" title="11、一些常见的响应头"></a>11、一些常见的响应头</h3><p>常见的请求头对照表</p><p><a href="http://tools.jb51.net/table/http_header">http://tools.jb51.net/table/http_header</a></p><div class="hljs code-wrapper"><pre><code class="hljs css">Server: Apache-Coyote/<span class="hljs-number">1.1</span>：服务器的版本信息； Content-Type: text/html;charset=UTF-8：响应体使用的编码为UTF-8； <span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">724</span>：响应体为<span class="hljs-number">724</span>字节； Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/hello：响应给客户端的Cookie； Date: Wed, 25 Sep 2012 04:15:03 GMT：响应的时间，这可能会有8小时的时区差；Last-Modified：最后的修改时间； If-Modified-Since：把上次请求的index<span class="hljs-selector-class">.html</span>的最后修改时间还给服务器；//告诉浏览器不要缓存： Expires: -<span class="hljs-number">1</span>； Cache-Control: no-cache； Pragma: no-cache； **自动刷新**响应头，浏览器会在<span class="hljs-number">3</span>秒之后请求http://www.itcast.cn： Refresh: 3;url=http://www.itcast.cn</code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr5bf2wnrj31160u048m.jpg" alt="image-20210421101507448"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr5bqh57jj30yw0jcdii.jpg" alt="image-20210421101526912"></p><h1 id="四、Tomcat"><a href="#四、Tomcat" class="headerlink" title="四、Tomcat"></a>四、Tomcat</h1><p>Web 应⽤服务器：Tomcat、Jboos、Weblogic、Jetty</p><h2 id="tomcat目录"><a href="#tomcat目录" class="headerlink" title="tomcat目录"></a><strong>tomcat目录</strong></h2><ul><li>bin：存放各个平台下启动和停⽌ Tomcat 服务的脚本⽂件</li><li>conf：存放各种 Tomcat 服务器的配置⽂件</li><li>lib：存放Tomcat服务器所需要的 jar</li><li>logs：存放Tomcar服务运⾏的⽇志 </li><li>temp：Tomcat 运⾏时的临时⽂件</li><li>webapps：专门用来存放部署的Web工程</li><li>work：是 Tomcat 工作时的目录，用来存放 Tomcat运行时jsp翻译为Servlet的源码，和Session钝化的目录</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421100828862-9181885.png" alt="image-20210421100828862"></p><h2 id="Http工作原理"><a href="#Http工作原理" class="headerlink" title="Http工作原理"></a><strong>Http工作原理</strong></h2><p>HTTP协议是浏览器与服务器之间的数据传送协议。作为应用层协议，HTTP是基于TCP/IP协议来传递数 据的（HTML文件、图片、查询结果等），HTTP协议不涉及数据包（Packet）传输，主要规定了客户端 和服务器之间的通信格式。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423205515478.png" alt="image-20210423205515478"></p><p><strong>Http服务器请求处理</strong></p><p>浏览器发给服务端的是一个HTTP格式的请求，HTTP服务器收到这个请求后，需要调用服务端程序来处 理，所谓的服务端程序就是你写的Java类，一般来说不同的请求需要由不同的Java类来处理。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423205608522.png" alt="image-20210423205608522"></p><ul><li>图1 ， 表示HTTP服务器直接调用具体业务类，它们是紧耦合的</li><li>图2，HTTP服务器不直接调用业务类，而是把请求交给容器来处理，容器通过Servlet接口调用业务 类。因此Servlet接口和Servlet容器的出现，达到了HTTP服务器与业务类解耦的目的。而Servlet接口和 Servlet容器这一整套规范叫作Servlet规范。Tomcat按照Servlet规范的要求实现了Servlet容器，同时它 们也具有HTTP服务器的功能。作为Java程序员，如果我们要实现新的业务功能，只需要实现一个Servlet，并把它注册到Tomcat（Servlet容器）中，剩下的事情就由Tomcat帮我们处理了</li></ul><h2 id="Servlet容器工作流程"><a href="#Servlet容器工作流程" class="headerlink" title="Servlet容器工作流程"></a><strong>Servlet容器工作流程</strong></h2><p>为了解耦，HTTP服务器不直接调用Servlet，而是把请求交给Servlet容器来处理</p><p>当客户请求某个资源时，HTTP服务器会用一个ServletRequest对象把客户的请求信息封装起来，然后 调用Servlet容器的service方法，Servlet容器拿到请求后，根据请求的URL和Servlet的映射关系，找到 相应的Servlet，如果Servlet还没有被加载，就用反射机制创建这个Servlet，并调用Servlet的init方法来 完成初始化，接着调用Servlet的service方法来处理请求，把ServletResponse对象返回给HTTP服务 器，HTTP服务器会把响应发送给客户端</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423205747804.png" alt="image-20210423205747804"></p><h2 id="Tomcat整体架构"><a href="#Tomcat整体架构" class="headerlink" title="Tomcat整体架构"></a>Tomcat整体架构</h2><p>我们知道如果要设计一个系统，首先是要了解需求，我们已经了解了Tomcat要实现两个核心功能：</p><p>1） 处理Socket连接，负责网络字节流与Request和Response对象的转化。 </p><p>2） 加载和管理Servlet，以及具体处理Request请求。</p><p>因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。连接器负责对外交流，容器负责内部处理</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423205846503.png" alt="image-20210423205846503"></p><h2 id="Tomcat-服务器配置"><a href="#Tomcat-服务器配置" class="headerlink" title="Tomcat 服务器配置"></a>Tomcat 服务器配置</h2><p>Tomcat 服务器的配置主要集中于 tomcat/conf 下的 catalina.policy、catalina.properties、 context.xml、server.xml、tomcat-users.xml、web.xml 文件</p><p><strong>server.xml</strong></p><p>server.xml 是tomcat 服务器的核心配置文件，包含了Tomcat的 Servlet 容器（Catalina）的所有配 置。由于配置的属性特别多，我们在这里主要讲解其中的一部分重要配置。</p><blockquote><p>Server</p></blockquote><p>Server是server.xml的根元素，用于创建一个Server实例，默认使用的实现类是 org.apache.catalina.core.StandardServer</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8005&quot;</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">&quot;SHUTDOWN&quot;</span>&gt;</span>... <span class="hljs-tag">&lt;/<span class="hljs-name">Server</span>&gt;</span></code></pre></div><p>port : Tomcat 监听的关闭服务器的端口 </p><p>shutdown： 关闭服务器的指令字符串</p><blockquote><p>Connector</p></blockquote><p>Connector 用于创建链接器实例。默认情况下，server.xml 配置了两个链接器，一个支持HTTP协议， 一个支持AJP协议。因此大多数情况下，我们并不需要新增链接器配置，只是根据需要对已有链接器进 行优化。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><span class="hljs-tag"></span><span class="hljs-tag"><span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre></div><p>属性说明：</p><p>1）port：端口号，Connector用于创建服务端Socket并进行监听，以等待客户端请求链接。如果该属性设置为0，Tomcat将会随机选择一个可用的端口号给当前Connector使用</p><p>2） protocol ： 当前Connector 支持的访问协议。 默认为 HTTP/1.1 。</p><p> 3） connectionTimeOut : Connector 接收链接后的等待超时时间， 单位为毫秒。 -1 表示不超时</p><p> 4） URIEncoding : 用于指定编码URI的字符编码， Tomcat8.x版本默认的编码为 UTF-8 。 </p><p>完整的配置如下：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span></span><span class="hljs-tag"></span><span class="hljs-tag"><span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">executor</span>=<span class="hljs-string">&quot;tomcatThreadPool&quot;</span> <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">&quot;1000&quot;</span></span><span class="hljs-tag"></span><span class="hljs-tag"><span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">acceptCount</span>=<span class="hljs-string">&quot;1000&quot;</span></span><span class="hljs-tag"></span><span class="hljs-tag"><span class="hljs-attr">maxConnections</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span> <span class="hljs-attr">compression</span>=<span class="hljs-string">&quot;on&quot;</span> <span class="hljs-attr">compressionMinSize</span>=<span class="hljs-string">&quot;2048&quot;</span> <span class="hljs-attr">disableUploadTimeout</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span></span><span class="hljs-tag"></span><span class="hljs-tag"><span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span></code></pre></div><h2 id="Tomcat配置负载均衡"><a href="#Tomcat配置负载均衡" class="headerlink" title="Tomcat配置负载均衡"></a>Tomcat配置负载均衡</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16.%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%9B%86%E7%BE%A4.jpg" alt="16.负载均衡集群"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 0.准备多个tomcat</span><span class="hljs-code"> tar -zxvf apache-tomcat-8.5.46.tar.gz #解压缩一个新的tomcat安装包</span><span class="hljs-code"> mv apache-tomcat-8.5.46 tomcat1  #将名称改为tomcat1</span><span class="hljs-code"> cp -r tomcat1/ tomcat2 #复制一份</span><span class="hljs-code"> cp -r tomcat1/ tomcat3                #复制一份</span><span class="hljs-code"></span><span class="hljs-code"># 1.此时当前目录中有三个服务器,如下:</span><span class="hljs-code">[root@localhost ~]# ls -l</span><span class="hljs-code">总用量 12248</span><span class="hljs-code">-rwxrwxrwx. 1 root root  11623939 10月 13 12:25 apache-tomcat-8.5.46.tar.gz</span><span class="hljs-code">drwxr-xr-x. 9 root root       220 10月 14 21:28 tomcat1</span><span class="hljs-code">drwxr-xr-x. 9 root root       220 10月 14 21:38 tomcat2</span><span class="hljs-code">drwxr-xr-x. 9 root root       220 10月 14 21:38 tomcat3</span></code></pre></div><p><strong>配置三个tomcat的端口号</strong></p><p>分别修改端口，http协议端口，AJP协议端口</p><div class="hljs code-wrapper"><pre><code class="hljs xml"># 2.修改tomcat1端口号:(伪分布式)vim tomcat1/conf/server.xml,命令修改如下内容:a.<span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8001&quot;</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">&quot;SHUTDOWN&quot;</span>&gt;</span>   ---关闭端口b.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8888&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">---http</span>协议端口</span><span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span>c.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;10010&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;AJP/1.3&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span> ---AJP协议端口</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"># 3.修改tomcat2端口号:(伪分布式)vim tomcat2/conf/server.xml,命令修改如下内容:  a.<span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8002&quot;</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">&quot;SHUTDOWN&quot;</span>&gt;</span>b.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8889&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span>   c.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;10011&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;AJP/1.3&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"># 4.修改tomcat3端口号:(伪分布式)vim tomcat2/conf/server.xml,命令修改如下内容:  a.<span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8003&quot;</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">&quot;SHUTDOWN&quot;</span>&gt;</span>b.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8890&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span>   c.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;10012&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;AJP/1.3&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 5.将多个tomcat启动:</span><span class="hljs-code">tomcat1/bin/startup.sh </span><span class="hljs-code">tomcat2/bin/startup.sh </span><span class="hljs-code">tomcat3/bin/startup.sh</span><span class="hljs-code">    </span><span class="hljs-code"># 6.查看tomcat是否启动成功</span><span class="hljs-code">ps -aux|grep tomcat</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191014215035543.png" alt="image-20191014215035543"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 7.在windows中分别访问tomcat,都看到主页代表启动成功:</span><span class="hljs-code"></span><span class="hljs-code">http://10.15.0.8:8888/</span><span class="hljs-code">http://10.15.0.8:8889/</span><span class="hljs-code">http://10.15.0.8:8890/</span><span class="hljs-code"></span><span class="hljs-code">注意:这步一定要关闭网路防火墙</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 8.将多个tomcat配置到nginx的配置文件中:</span><span class="hljs-code">vim /conf/nginx.conf</span><span class="hljs-code"></span><span class="hljs-code">## 在server标签上加入如下配置:</span><span class="hljs-code">    upstream tomcat-servers &#123;</span><span class="hljs-code">      server 10.15.0.8:8888;</span><span class="hljs-code">      server 10.15.0.8:8889;</span><span class="hljs-code">      server 10.15.0.8:8890;</span><span class="hljs-code">    &#125;</span><span class="hljs-code">## 将配置文件中 location /替换为如下配置:</span><span class="hljs-code">location / &#123;</span><span class="hljs-code"> proxy_pass http://tomcat-servers;</span><span class="hljs-code"> proxy_redirect    off;</span><span class="hljs-code"> proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="hljs-code"> proxy_set_header X-Real-IP $remote_addr;</span><span class="hljs-code"> proxy_set_header Host $http_host;</span><span class="hljs-code"> proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><span class="hljs-code">   &#125;</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191014215825240.png" alt="image-20191014215825240"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 9.进入nginx安装目录sbin目录加载配置文件的形式启动nginx</span><span class="hljs-code">./nginx -c /usr/nginx/conf/nginx.conf</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 10.访问nginx,看到其中一个tomcat画面:</span><span class="hljs-code">http://10.15.0.8/ </span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191014220145379.png" alt="image-20191014220145379"></p><p><strong>Nginx负载均衡策略</strong></p><blockquote><p>默认策略：每个请求会按时间顺序逐一分配到不同的后端服务器</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 以下配置都在vim /conf/nginx.conf中</span><span class="hljs-section"># weight 权重</span><span class="hljs-code">说明: weight参数用于指定轮询几率，weight的默认值为1,；weight的数值与访问比率成正比 </span><span class="hljs-code">    upstream tomcat-servers &#123;</span><span class="hljs-code">        server localhost:8888   weight=2;  </span><span class="hljs-code">        server localhost:8889;  </span><span class="hljs-code">        server localhost:8890   backup;  </span><span class="hljs-code">    &#125;</span><span class="hljs-code">注意：1.权重越高分配到需要处理的请求越多。2.此策略可以与least_conn和ip_hash结合使用主要用于后端服务器性能不均</span><span class="hljs-code"></span><span class="hljs-code"># ip_hash </span><span class="hljs-code">　说明:指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题。</span><span class="hljs-code">　upstream tomcat-servers &#123;</span><span class="hljs-code">        ip_hash;    #保证每个访客固定访问一个后端服务器</span><span class="hljs-code">        ......</span><span class="hljs-code">    &#125;</span><span class="hljs-code"># least_conn</span><span class="hljs-code">说明: 把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。</span><span class="hljs-code">upstream tomcat-servers&#123;</span><span class="hljs-code">        least_conn;    #把请求转发给连接数较少的后端服务器</span><span class="hljs-code">    &#125;</span></code></pre></div><h2 id="Session共享"><a href="#Session共享" class="headerlink" title="Session共享"></a><strong>Session共享</strong></h2><p><strong>Memcached Session Manager</strong></p><blockquote><p>Memcached Session Manager基于memcache缓存的session共享.即使用cacheDB存取session信息，应用服务器接受新请求将session信息保存在cache DB中，当应用服务器发生故障时，调度器会遍历寻找可用节点，分发请求，当应用服务器发现session不在本机内存时，则去cacheDB中查找，如果找到则复制到本机，这样实现session共享和高可用。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.安装memcached</span>yum install -y memcached<span class="hljs-section"># 2.启动memcached（port:11211）</span>memcached -p 11211 -vvv -u root<span class="hljs-section"># 3.tomcat安装的lib目录中放入与memcache整合jar包</span><span class="hljs-code">cp *.jar tomcat1/lib</span><span class="hljs-code">cp *.jar tomcat2/lib</span><span class="hljs-code">cp *.jar tomcat3/lib</span><span class="hljs-code"></span><span class="hljs-code"># 4.配置tomcat目录中conf目录中context.xml(所有tomcat均需要配置)</span><span class="hljs-code">&lt;Context&gt;</span><span class="hljs-code"> &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;</span><span class="hljs-code">        memcachedNodes=&quot;n1:10.15.0.8:11211,n2:....&quot; --对应name:msm的ip:port，可以加多台做分布式</span><span class="hljs-code">        sticky=&quot;false&quot;  </span><span class="hljs-code">    sessionBackupAsync=&quot;false&quot;  </span><span class="hljs-code">        requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot;        transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot;</span><span class="hljs-code">        /&gt;</span><span class="hljs-code">&lt;/Context&gt;</span><span class="hljs-code"></span><span class="hljs-code"># 5.然后启动tomcat和nginx并放入测试项目进行测试</span></code></pre></div><p><strong>Redis</strong></p><blockquote><p>同样利用tomcat与nginx搭建，但是利用Redis集群进行管理，redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据</p></blockquote><h1 id="五、Nginx"><a href="#五、Nginx" class="headerlink" title="五、Nginx"></a>五、Nginx</h1><p><code>Nginx</code> 是一个高性能的 <code>HTTP</code> 和反向代理 <code>web</code> 服务器，同时也提供了 <code>IMAP/POP3/SMTP</code> 服务。</p><p><code>Nginx</code> 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 <code>Rambler.ru</code> 站点开发的，第一个公开版本 <code>0.1.0</code> 发布于 <code>2004</code>年 <code>10</code> 月 <code>4</code> 日。</p><p><code>Nginx</code> 特点是占有内存少，并发能力强。</p><p>事实上 <code>nginx</code> 的并发能力确实在同类型的网页服务器中表现较好，一般来说，如果我们在项目中引入了 <code>Nginx</code> ，我们的项目架构可能是这样：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/15-1.png" alt="img"></p><p>在这样的架构中 ， <code>Nginx</code> 所代表的角色叫做负载均衡服务器或者反向代理服务器，所有请求首先到达 <code>Nginx</code> 上，再由 <code>Nginx</code> 根据提前配置好的转发规则，将客户端发来的请求转发到某一个 <code>Tomcat</code> 上去。</p><p>那么这里涉及到两个概念：</p><ul><li>负载均衡服务器</li></ul><p>就是进行请求转发，降低某一个服务器的压力。负载均衡策略很多，也有很多层，对于一些大型网站基本上从 <code>DNS</code>就开始负载均衡，负载均衡有硬件和软件之分，各自代表分别是 <code>F5</code> 和 <code>Nginx</code> （目前 <code>Nginx</code> 已经被 <code>F5</code> 收购），早些年，也可以使用 <code>Apache</code> 来做负载均衡，但是效率不如 <code>Nginx</code> ，所以现在主流方案是 <code>Nginx</code> 。</p><ul><li>反向代理服务器：</li></ul><p>另一个概念是反向代理服务器，得先说正向代理，看下面一张图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/15-2.png" alt="img"></p><p>在这个过程中，Google 并不知道真正访问它的客户端是谁，它只知道这个中间服务器在访问它。因此，这里的代理，实际上是中间服务器代理了客户端，这种代理叫做正向代理。</p><p>那么什么是反向代理呢？看下面一张图：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/15-3.png" alt="img"></p><p>在这个过程中，10086 这个号码相当于是一个代理，真正提供服务的，是话务员，但是对于客户来说，他不关心到底是哪一个话务员提供的服务，他只需要记得 10086 这个号码就行了。</p><p>所有的请求打到 10086 上，再由 10086 将请求转发给某一个话务员去处理。因此，在这里，10086 就相当于是一个代理，只不过它代理的是话务员而不是客户端，这种代理称之为反向代理。</p><h2 id="Nginx-的优势"><a href="#Nginx-的优势" class="headerlink" title="Nginx 的优势"></a>Nginx 的优势</h2><p>在 Java 开发中，Nginx 有着非常广泛的使用，随便举几点：</p><ul><li>使用 Nginx 做静态资源服务器：Java 中的资源可以分为动态和静态，动态需要经过 Tomcat 解析之后，才能返回给浏览器，例如 JSP 页面、Freemarker 页面、控制器返回的 JSON 数据等，都算作动态资源，动态资源经过了 Tomcat 处理，速度必然降低。对于静态资源，例如图片、HTML、JS、CSS 等资源，这种资源可以不必经过 Tomcat 解析，当客户端请求这些资源时，之间将资源返回给客户端就行了。此时，可以使用 Nginx 搭建静态资源服务器，将静态资源直接返回给客户端。</li><li>使用 Nginx 做负载均衡服务器，无论是使用 Dubbo 还是 Spirng Cloud ，除了使用各自自带的负载均衡策略之外，也都可以使用 Nginx 做负载均衡服务器。</li><li>支持高并发、内存消耗少、成本低廉、配置简单、运行稳定等。</li></ul><h1 id="六、Servlet"><a href="#六、Servlet" class="headerlink" title="六、Servlet"></a>六、Servlet</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><ul><li>Servlet 是 JavaEE 规范之一。规范就是接口</li><li>Servlet 就 JavaWeb 三大组件之一。三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器</li><li>Servlet 是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端</li></ul><p><strong>功能</strong></p><ul><li>接受请求</li><li>处理请求</li><li>完成相应</li></ul><h2 id="Servlet加载时机"><a href="#Servlet加载时机" class="headerlink" title="Servlet加载时机"></a>Servlet加载时机</h2><p>在默认情况下，当Web客户第一次请求访问某个Servlet时，Web容器会创建这个Servlet的实例。</p><p>当设置了web.xml中的子元素后，Servlet容器在启动Web应用时，将按照指定顺序创建并初始化这个 Servlet。设置的数值大于0即可。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.langsin.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></code></pre></div><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>先看与Servlet生命周期有关的三个方法：init(), service(), destroy(). Servlet生命周期可被定义为从创建 直到毁灭的整个过程。以下是三个方法分别对应的Servlet过程：</p><ul><li>执行 Servlet 构造器方法</li><li>执行 init 初始化方法<ul><li>第一、二步，是在第一次访问的时候创建 Servlet 程序会调用</li></ul></li><li>执行 service 方法<ul><li>第三步，每次访问都会调用</li></ul></li><li>执行 destroy 销毁方法<ul><li>第四步，在 web 工程停止的时候调用</li></ul></li></ul><h2 id="手动实现-Servlet-程序"><a href="#手动实现-Servlet-程序" class="headerlink" title="手动实现 Servlet 程序"></a>手动实现 Servlet 程序</h2><ul><li>编写一个类去实现 Servlet 接口</li><li>实现 service 方法，处理请求，并响应数据</li><li>到 web.xml 中去配置 servlet 程序的访问地址<ul><li>浏览器不能直接访问 Servlet ⽂件，只能通过映射的⽅式来间接访问 Servlet，映射需要开发者⼿动配置，有两种配置⽅式</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * service 方法是专门用来处理请求和响应的</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> servletRequest</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> servletResponse</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">    */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">        ServletException, IOException </span>&#123;        System.out.println(<span class="hljs-string">&quot;Hello Servlet 被访问了&quot;</span>);        &#125;&#125;</code></pre></div><p><strong>基于 XML ⽂件的配置⽅式:</strong></p><p><code>Web.xml</code></p><div class="hljs code-wrapper"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--全类名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.southwind.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-comment">&lt;!--  mapping标签给servlet程序配置访问地址--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-comment">&lt;!--    告诉服务器，我当前配置的地址给那个servlet程序使用--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-comment">&lt;!--    访问地址--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/demo2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p><strong>基于注解的⽅式</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/demo2&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>&#123; &#125;</code></pre></div><p><strong>url 地址到 Servlet 程序的访问</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423170521391.png" alt="image-20210423170521391"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423170614051.png" alt="image-20210423170614051"></p><p><strong>通过继承 HttpServlet 实现 Servlet 程序</strong></p><p>一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。 </p><ul><li>编写一个类去继承 HttpServlet 类 </li><li>根据业务需要重写 doGet 或 doPost 方法 </li><li>到 web.xml 中的配置 Servlet 程序的访问地址</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * doGet（）在 get 请求的时候调用</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">    */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;HelloServlet2 的 doGet 方法&quot;</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * doPost（）在 post 请求的时候调用</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">    */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;    System.out.println(<span class="hljs-string">&quot;HelloServlet2 的 doPost 方法&quot;</span>);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.atguigu.servlet.HelloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><p><strong>Servlet 类的继承体系</strong></p><p><code>Servlet ---&gt; GenericServlet ---〉HttpServlet</code></p><p>HTTP 请求有很多种类型，常⽤的有四种： </p><ul><li><p>GET 读取 </p></li><li><p>POST 保存 </p></li><li><p>PUT 修改</p></li><li><p>DELETE 删除</p></li></ul><p>GenericServlet 实现 Servlet 接⼝，同时为它的⼦类屏蔽了不常⽤的⽅法，⼦类只需要重写 service⽅法即可。</p><p>HttpServlet 继承 GenericServlet，根据请求类型进⾏分发处理，GET 进⼊ doGET ⽅法，POST 进⼊ doPOST ⽅法。 开发者⾃定义的 Servlet 类只需要继承 HttpServlet 即可，重新 doGET 和 doPOST。</p><h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><ul><li>ServletConfig类从类名上来看，就知道是Servlet程序的配置信息类</li><li>Servlet 程序和 ServletConfig 对象都是由Tomcat负责创建，我们负责使用</li><li>Servlet 程序默认是第一次访问的时候创建，ServletConfig是每个Servlet 程序创建时，就创建一个对应的ServletConfig对象</li></ul><p><strong>ServletConfig 类的三大作用</strong></p><p>1、可以获取 Servlet 程序的别名 servlet-name 的值<br>2、获取Servlet 初始化参数 init-param<br>3、获取 ServletContext 对象</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-comment">&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-comment">&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.atguigu.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-comment">&lt;!--init-param 是初始化参数--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-comment">&lt;!--是参数名--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-comment">&lt;!--是参数值--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-comment">&lt;!--init-param 是初始化参数--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-comment">&lt;!--是参数名--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-comment">&lt;!--是参数值--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-comment">&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-comment">&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        url-pattern 标签配置访问地址 &lt;br/&gt;</span><span class="hljs-comment">        / 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径 &lt;br/&gt;</span><span class="hljs-comment">        /hello 表示地址为：http://ip:port/工程路径/hello &lt;br/&gt;</span><span class="hljs-comment">        --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></code></pre></div><p><strong>ServletConfig 各个方法</strong></p><p><code>getServletName()</code> 返回 Servlet的别名<br><code>getInitParameter(String key)</code> 获取init参数的值（web.xml）<br><code>getInitParameterNames()</code> 返回所有的 initParamter的name值，⼀般⽤作遍历初始化参数<br><code>getServletContext()</code> 返回 ServletContext 对象，它是 Servlet 的上下⽂，整个 Servlet 的管理者</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;    System.out.println(<span class="hljs-string">&quot;2 init 初始化方法&quot;</span>);    <span class="hljs-comment">// 1、可以获取 Servlet 程序的别名 servlet-name 的值</span>    System.out.println(<span class="hljs-string">&quot;HelloServlet 程序的别名是:&quot;</span> + servletConfig.getServletName());    <span class="hljs-comment">// 2、获取初始化参数 init-param</span>    System.out.println(<span class="hljs-string">&quot;初始化参数 username 的值是;&quot;</span> + servletConfig.getInitParameter(<span class="hljs-string">&quot;username&quot;</span>));    System.out.println(<span class="hljs-string">&quot;初始化参数 url 的值是;&quot;</span> + servletConfig.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>));    <span class="hljs-comment">// 3、获取 ServletContext 对象</span>    System.out.println(servletConfig.getServletContext());&#125;</code></pre></div><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p><strong>什么是 ServletContext?</strong></p><p>1、ServletContext 是一个接口，它表示 Servlet 上下文对象<br>2、一个 web 工程，只有一个 ServletContext 对象实例<br>3、ServletContext 对象是一个域对象<br>4、ServletContext 是在 web 工程部署启动的时候创建，<strong>在 web 工程停止的时候销毁</strong></p><p><strong>什么是域对象?</strong><br>域对象，是可以像Map一样存取数据的对象，叫域对象</p><p>这里的域指的是存取数据的操作范围，整个 web工程</p><div class="hljs code-wrapper"><pre><code class="hljs css"> 存数据   取数据       删除数据Map  put()   get()  remove()域对象 setAttribute() getAttribute() removeAttribute();</code></pre></div><p><strong>ServletContext对象的作用</strong></p><p>1、获取 web.xml 中配置的上下文参数 context-param<br>2、获取当前的工程路径，格式: /工程路径<br>3、获取工程部署后在服务器硬盘上的绝对路径<br>4、像 Map 一样存取数据</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">ServletException, IOException </span>&#123;    <span class="hljs-comment">// 1、获取 web.xml 中配置的上下文参数 context-param</span>    ServletContext context = getServletConfig().getServletContext();    String username = context.getInitParameter(<span class="hljs-string">&quot;username&quot;</span>);    System.out.println(<span class="hljs-string">&quot;context-param 参数 username 的值是:&quot;</span> + username);    System.out.println(<span class="hljs-string">&quot;context-param 参数 password 的值是:&quot;</span> +    context.getInitParameter(<span class="hljs-string">&quot;password&quot;</span>));    <span class="hljs-comment">// 2、获取当前的工程路径，格式: /工程路径</span>  System.out.println( <span class="hljs-string">&quot;当前工程路径:&quot;</span> + context.getContextPath() );    <span class="hljs-comment">// 3、获取工程部署后在服务器硬盘上的绝对路径</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">    * / 斜杠被服务器解析地址为:http://ip:port/工程名/ 映射到 IDEA 代码的 web 目录&lt;br/&gt;</span><span class="hljs-comment">    */</span>    System.out.println(<span class="hljs-string">&quot;工程部署的路径是:&quot;</span> + context.getRealPath(<span class="hljs-string">&quot;/&quot;</span>));    System.out.println(<span class="hljs-string">&quot;工程下 css 目录的绝对路径是:&quot;</span> + context.getRealPath(<span class="hljs-string">&quot;/css&quot;</span>));    System.out.println(<span class="hljs-string">&quot;工程下 imgs 目录 1.jpg 的绝对路径是:&quot;</span> + context.getRealPath(<span class="hljs-string">&quot;/imgs/1.jpg&quot;</span>));&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml">!--context-param 是上下文参数(它属于整个 web 工程)--&gt;<span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>context<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><span class="hljs-comment">&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>password<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre></div><p>ServletContext 像 Map 一样存取数据：</p><p>ContextServlet1 代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextServlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">        ServletException, IOException </span>&#123;        <span class="hljs-comment">// 获取 ServletContext 对象</span>        ServletContext context = getServletContext();        System.out.println(context);        System.out.println(<span class="hljs-string">&quot;保存之前: Context1 获取 key1 的值是:&quot;</span>+ context.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>));        context.setAttribute(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);        System.out.println(<span class="hljs-string">&quot;Context1 中获取域数据 key1 的值是:&quot;</span>+ context.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>));    &#125;&#125;</code></pre></div><p>ContextServlet2 代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException,</span><span class="hljs-function">IOException </span>&#123;    ServletContext context = getServletContext();System.out.println(context);    System.out.println(<span class="hljs-string">&quot;Context2 中获取域数据 key1 的值是:&quot;</span>+ context.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>));&#125;</code></pre></div><p><strong>ServletConfig 和 ServletContext 的区别：</strong></p><p>ServletConfig 作⽤于某个 Servlet 实例，每个 Servlet 都有对应的 ServletConfig，ServletContext 作⽤于整个 Web 应⽤，⼀个 Web 应⽤对应⼀个 ServletContext，多个 Servlet 实例对应⼀个ServletContext</p><p><strong>⼀个是局部对象，⼀个是全局对象</strong></p><h2 id="HTTP-协议回顾"><a href="#HTTP-协议回顾" class="headerlink" title="HTTP 协议回顾"></a><strong>HTTP 协议回顾</strong></h2><p><a href="#3%E3%80%81http%E5%8D%8F%E8%AE%AE">什么是 HTTP 协议</a></p><ul><li>协议是指双方，或多方，相互约定好，大家都需要遵守的规则，叫协议</li><li>所谓 HTTP 协议，就是指，客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫 HTTP 协议</li><li>HTTP 协议中的数据又叫报文</li></ul><p><strong>请求的 HTTP 协议格式</strong></p><ul><li>客户端给服务器发送数据叫请求 </li><li>服务器给客户端回传数据叫响应</li><li>请求又分为 GET 请求，和 POST 请求两种</li></ul><p><strong>GET 请求</strong></p><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">1</span>、请求行    (<span class="hljs-number">1</span>) 请求的方式 <span class="hljs-selector-tag">GET</span>    (<span class="hljs-number">2</span>) 请求的资源路径<span class="hljs-selector-attr">[+?+请求参数]</span>    (<span class="hljs-number">3</span>) 请求的协议的版本号 <span class="hljs-selector-tag">HTTP</span>/<span class="hljs-selector-tag">1</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-tag">2</span>、请求头<span class="hljs-selector-tag">key</span> : <span class="hljs-selector-tag">value</span> 组成不同的键值对，表示不同的含义。</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421104718675-9168959.png" alt="image-20210421104718675"></p><p> <strong>POST 请求</strong></p><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">1</span>、请求行    (<span class="hljs-number">1</span>) 请求的方式 <span class="hljs-selector-tag">POST</span>     (<span class="hljs-number">2</span>) 请求的资源路径<span class="hljs-selector-attr">[+?+请求参数]</span>     (<span class="hljs-number">3</span>) 请求的协议的版本号 <span class="hljs-selector-tag">HTTP</span>/<span class="hljs-selector-tag">1</span><span class="hljs-selector-class">.1</span> <span class="hljs-selector-tag">2</span>、请求头 <span class="hljs-selector-tag">key</span> : <span class="hljs-selector-tag">value</span> 不同的请求头，有不同的含义 空行<span class="hljs-selector-tag">3</span>、请求体就是发送给服务器的数据</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421104938669-9168959.png" alt="image-20210421104938669"></p><p> <strong>常用请求头的说明</strong></p><p><code>Accept</code> 表示客户端可以接收的数据类型<br><code>Accpet-Languege</code> 表示客户端可以接收的语言类型<br><code>User-Agent</code> 表示客户端浏览器的信息<br><code>Host</code> 表示请求时的服务器 ip 和端口号</p><p><strong>区分GET和POST请求</strong></p><p><strong>GET</strong></p><ul><li>from标签 method=get</li><li>a标签</li><li>link标签引入css</li><li>Script标签引入js文件</li><li>img标签引入图片</li><li>iframe引入html页面</li><li>在浏览器地址栏输入地址后翘回车</li></ul><p><strong>POST</strong></p><ul><li>from标签 method=post</li></ul><p><strong>响应的 HTTP 协议格式</strong></p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>、响应行    (<span class="hljs-number">1</span>) 响应的协议和版本号    (<span class="hljs-number">2</span>) 响应状态码    (<span class="hljs-number">3</span>) 响应状态描述符<span class="hljs-number">2</span>、响应头  key : value 不同的响应头，有其不同含义空行<span class="hljs-number">3</span>、响应体就是回传给客户端的数据</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421105124947-9168959.png" alt="image-20210421105124947"></p><p><strong>常用的响应码说明</strong></p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">200 </span>表示请求成功<span class="hljs-symbol">302 </span>表示请求重定向<span class="hljs-symbol">404 </span>表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误）<span class="hljs-symbol">500 </span>表示服务器已经收到请求，但是服务器内部错误（代码错误）</code></pre></div><p><strong>MIME 类型说明</strong></p><ul><li>MIME 是 HTTP 协议中数据类型</li><li>MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型/小类型”，并与某一种文件的扩展名相对应</li></ul><p>常见的 MIME 类型</p><table><thead><tr><th align="center">文件</th><th align="center">MIME 类型</th></tr></thead><tbody><tr><td align="center">超文本标记语言文本</td><td align="center">text/html</td></tr><tr><td align="center">普通文本</td><td align="center">text/plain</td></tr><tr><td align="center">TAR 文件</td><td align="center">application/x-tar</td></tr><tr><td align="center">GIF 图形</td><td align="center">image/gif</td></tr></tbody></table><h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a><strong>HttpServletRequest</strong></h2><p><strong>HttpServletRequest 类的作用</strong></p><ul><li>每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中</li><li>然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的信息</li></ul><p><strong>HttpServletRequest 类的常用方法</strong></p><p> <code>getRequestURI()</code> 获取请求的资源路径<br> <code>getRequestURL() </code>获取请求的统一资源定位符（绝对路径）<br> <code>getRemoteHost() </code>获取客户端的ip地址<br> <code>getHeader()</code> 获取请求头<br> <code>getParameter()</code>获取请求的参数<br> <code>getParameterValues()</code>获取请求的参数（多个值的时候使用）<br> <code> setAttribute(key, value)</code> 设置域数据<br> <code>getAttribute(key)</code>获取域数据<br> <code> getRequestDispatcher()</code> 获取请求转发对<br> <code>getMethod()</code> 获取请求的方式GET或POST</p><p>常用 API 示例代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestAPIServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span><span class="hljs-function">    IOException </span>&#123;        <span class="hljs-comment">// i.getRequestURI() 获取请求的资源路径</span>        System.out.println(<span class="hljs-string">&quot;URI =&gt; &quot;</span> + req.getRequestURI());        <span class="hljs-comment">// ii.getRequestURL() 获取请求的统一资源定位符（绝对路径）</span>        System.out.println(<span class="hljs-string">&quot;URL =&gt; &quot;</span> + req.getRequestURL());      <span class="hljs-comment">// iii.getRemoteHost() 获取客户端的 ip 地址</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">        * 在 IDEA 中，使用 localhost 访问时，得到的客户端 ip 地址是 ===&gt;&gt;&gt; 127.0.0.1&lt;br/&gt;</span><span class="hljs-comment">        * 在 IDEA 中，使用 127.0.0.1 访问时，得到的客户端 ip 地址是 ===&gt;&gt;&gt; 127.0.0.1&lt;br/&gt;</span><span class="hljs-comment">        * 在 IDEA 中，使用 真实 ip 访问时，得到的客户端 ip 地址是 ===&gt;&gt;&gt; 真实的客户端 ip 地址&lt;br/&gt;</span><span class="hljs-comment">        */</span>        System.out.println(<span class="hljs-string">&quot;客户端 ip 地址 =&gt; &quot;</span> + req.getRemoteHost());        <span class="hljs-comment">// iv.getHeader() 获取请求头</span>        System.out.println(<span class="hljs-string">&quot;请求头 User-Agent ==&gt;&gt; &quot;</span> + req.getHeader(<span class="hljs-string">&quot;User-Agent&quot;</span>));        <span class="hljs-comment">// vii.getMethod() 获取请求的方式 GET 或 POST</span>        System.out.println( <span class="hljs-string">&quot;请求的方式 ==&gt;&gt; &quot;</span> + req.getMethod() );    &#125;&#125;</code></pre></div><p><strong>如何获取请求参数</strong></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://localhost:8080/07_servlet/parameterServlet&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span>        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>        兴趣爱好：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cpp&quot;</span>&gt;</span>C++        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span>Java        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>Java 代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParameterServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span><span class="hljs-function">    IOException </span>&#123;      <span class="hljs-comment">//设置编码</span>     req.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);        <span class="hljs-comment">// 获取请求参数</span>        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);        String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);        String[] hobby = req.getParameterValues(<span class="hljs-string">&quot;hobby&quot;</span>);        System.out.println(<span class="hljs-string">&quot;用户名：&quot;</span> + username);        System.out.println(<span class="hljs-string">&quot;密码：&quot;</span> + password);        System.out.println(<span class="hljs-string">&quot;兴趣爱好：&quot;</span> + Arrays.asList(hobby));    &#125;&#125;</code></pre></div><p><strong>请求转发</strong></p><p>什么是请求的转发? </p><blockquote><p>请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发。</p></blockquote><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421111014356-9168959.png" alt="image-20210421111014356"></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Servlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span><span class="hljs-function">    IOException </span>&#123;        <span class="hljs-comment">// 获取请求的参数（办事的材料）查看</span>        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);        System.out.println(<span class="hljs-string">&quot;在 Servlet1（柜台 1）中查看参数（材料）：&quot;</span> + username);        <span class="hljs-comment">// 给材料 盖一个章，并传递到 Servlet2（柜台 2）去查看</span>        req.setAttribute(<span class="hljs-string">&quot;key1&quot;</span>,<span class="hljs-string">&quot;柜台 1 的章&quot;</span>);        <span class="hljs-comment">// 问路：Servlet2（柜台 2）怎么走</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">        * 请求转发必须要以斜杠打头，/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到 IDEA 代码的 web 目录</span><span class="hljs-comment">        &lt;br/&gt;</span><span class="hljs-comment">        *</span><span class="hljs-comment">        */</span>        RequestDispatcher requestDispatcher = req.getRequestDispatcher(<span class="hljs-string">&quot;/servlet2&quot;</span>);        <span class="hljs-comment">// 走向 Sevlet2（柜台 2）</span>        requestDispatcher.forward(req,resp);    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Servlet2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span><span class="hljs-function">    IOException </span>&#123;        <span class="hljs-comment">// 获取请求的参数（办事的材料）查看</span>        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);        System.out.println(<span class="hljs-string">&quot;在 Servlet2（柜台 2）中查看参数（材料）：&quot;</span> + username);        <span class="hljs-comment">// 查看柜台1是否有盖章</span>        Object key1 = req.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>);        System.out.println(<span class="hljs-string">&quot;柜台 1 是否有章：&quot;</span> + key1);        <span class="hljs-comment">// 处理自己的业务</span>        System.out.println(<span class="hljs-string">&quot;Servlet2 处理自己的业务 &quot;</span>);&#125;&#125;</code></pre></div><p><strong>base标签</strong></p><p>比如这里设置</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://localhost:8080/07_servlet/a/b/c.html&quot;</span>&gt;</span>或者<span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://localhost:8080/07_servlet/a/b/&quot;</span>&gt;</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424201046209.png" alt="image-20210424201046209"></p><p><strong>Web 中的相对路径和绝对路径</strong></p><p>在 javaWeb 中， 路径分为相对路径和绝对路径两种：</p><ul><li>相对路径是：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">.          </span>表示当前目录<span class="hljs-bullet">..         </span>表示上一级目录资源名     表示当前目录/资源名</code></pre></div><p>绝对路径： <code>http://ip:port/工程路径/资源路径</code> </p><p>在实际开发中， 路径都使用绝对路径， 而不简单的使用相对路径,具体而言, 绝对路径的表示方式有:</p><ul><li>绝对路径</li><li>base+相对</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// i.getRequestURI() 获取请求的资源路径</span>System.out.println(<span class="hljs-string">&quot;URI =&gt; &quot;</span> + req.getRequestURI());<span class="hljs-comment">// ii.getRequestURL() 获取请求的统一资源定位符（绝对路径）</span>System.out.println(<span class="hljs-string">&quot;URL =&gt; &quot;</span> + req.getRequestURL());<span class="hljs-comment">//动态获取当前项目的路径(磁盘上的真实路径)</span>ServletContext context=getServletContext();response.sendRedirect(context.getContextPath()+<span class="hljs-string">&quot;/pages/a.html&quot;</span>)</code></pre></div><p><strong>web 中 / 斜杠的不同意义</strong></p><p>在 web 中 / 斜杠 是一种绝对路径</p><p>/ 斜杠 如果被浏览器解析，得到的地址是：<a href="http://ip:port/">http://ip:port/</a></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>斜杠<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><p>/ 斜杠 如果被服务器解析，得到的地址是：<a href="http://ip:port/工程路径">http://ip:port/工程路径</a></p><ul><li><url-pattern>/servlet1</url-pattern></li><li>servletContext.getRealPath(“/”);</li><li>request.getRequestDispatcher(“/”);</li></ul><p><strong>特殊情况</strong>：</p><p>response.sendRediect(“/”); 把斜杠发送给浏览器解析。得到 <a href="http://ip:port/">http://ip:port/</a></p><p><strong>中文乱码问题</strong></p><p><strong>get请求：</strong></p><p>使用Servlet处理get请求时，如果get请求的参数中有中文，直接接收会是乱码，这个时候需要使用类似下面的语句来处理乱码:</p><div class="hljs code-wrapper"><pre><code class="hljs java">String name = request.getParameter(<span class="hljs-string">&quot;name&quot;</span>);System.out.prinlnt(name); <span class="hljs-comment">// 乱码</span><span class="hljs-comment">// 处理乱码</span>name = <span class="hljs-keyword">new</span> String(name.getBytes(<span class="hljs-string">&quot;ISO8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);System.out.println(name);<span class="hljs-comment">// 乱码问题解决</span></code></pre></div><p>每次中文都要处理，比较麻烦，可以使用过滤器，使用类似下面的代码处理乱码问题:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getParameter</span><span class="hljs-params">(String name)</span> </span>&#123;    String value = <span class="hljs-keyword">super</span>.getParameter(name);    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    String method = request.getMethod();    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;get&quot;</span>.equalsIgnoreCase(method)) &#123;        <span class="hljs-keyword">try</span> &#123;            value = <span class="hljs-keyword">new</span> String(value.getBytes(<span class="hljs-string">&quot;ISO8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-keyword">return</span> value;&#125;</code></pre></div><p>为什么我们需要将ISO8859-1转为UTF-8？为什么接收到的参数是ISO8859-1这种编码方式的？<br>其实很简单，只是个配置问题：<br>在tomcat安装目录下的conf/server.xml中，有如下的配置：</p><p>URIEncoding该配置决定了使用get请求通过浏览器地址栏访问tomcat时的编码方式，默认的编码方式使ISO8859-1:</p><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">URIEncoding:This specifies <span class="hljs-keyword">the</span> <span class="hljs-keyword">character</span> encoding used <span class="hljs-built_in">to</span> decode <span class="hljs-keyword">the</span> URI <span class="hljs-keyword">bytes</span>, <span class="hljs-keyword">after</span> %xx decoding <span class="hljs-keyword">the</span> <span class="hljs-built_in">URL</span>. If <span class="hljs-keyword">not</span> specified, ISO-``<span class="hljs-number">8859</span>``-``<span class="hljs-number">1</span>` `will be used.</code></pre></div><p>可以这样配置，则上述代码中，就不需要再从ISO8859-1转为UTF-8了：</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span></code></pre></div><p>值得注意的是，从tomcat8.0开始，URIEncoding默认值不再是ISO8859-1，而变成了UTF-8 ，那么也就意味着，从tomcat8.0开始，get请求中的中文参数，不需要特殊处理了</p><p><strong>post请求：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span><span class="hljs-function">IOException </span>&#123;    <span class="hljs-comment">// 设置请求体的字符集为 UTF-8，从而解决 post 请求的中文乱码问题</span>    req.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);    System.out.println(<span class="hljs-string">&quot;-------------doPost------------&quot;</span>);    <span class="hljs-comment">// 获取请求参数</span>    String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);    String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);    String[] hobby = req.getParameterValues(<span class="hljs-string">&quot;hobby&quot;</span>);    System.out.println(<span class="hljs-string">&quot;用户名：&quot;</span> + username);    System.out.println(<span class="hljs-string">&quot;密码：&quot;</span> + password);    System.out.println(<span class="hljs-string">&quot;兴趣爱好：&quot;</span> + Arrays.asList(hobby));&#125;</code></pre></div><h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><p><strong>HttpServletResponse 类的作用</strong> </p><ul><li>HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息</li><li>我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置</li></ul><p><strong>两个输出流的说明</strong></p><ul><li><p>字节流 getOutputStream(); 常用于下载（传递二进制数据） </p></li><li><p>字符流 getWriter(); 常用于回传字符串（常用）</p></li><li><p>两个流同时只能使用一个，使用了字节流，就不能再使用字符流，反之亦然，否则就会报错</p></li></ul><p><strong>响应的乱码解决</strong></p><p>解决响应中文乱码方案一（不推荐使用）：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 设置服务器字符集为 UTF-8</span>resp.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">// 通过响应头，设置浏览器也使用 UTF-8 字符集</span>resp.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html; charset=UTF-8);</span></code></pre></div><p>解决响应中文乱码方案二（推荐）：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 它会同时设置服务器和客户端都使用 UTF-8 字符集，还设置了响应头</span><span class="hljs-comment">// 此方法一定要在获取流对象之前调用才有效</span>resp.setContentType(<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);</code></pre></div><p><strong>请求重定向</strong></p><p>请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求 重定向（因为之前的地址可能已经被废弃）。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421113301751-9168959.png" alt="image-20210421113301751"></p><p>请求重定向的第一种方案：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 设置响应状态码 302 ，表示重定向，（已搬迁）</span>resp.setStatus(<span class="hljs-number">302</span>);<span class="hljs-comment">// 设置响应头，说明 新的地址在哪里</span>resp.setHeader(<span class="hljs-string">&quot;Location&quot;</span>, <span class="hljs-string">&quot;http://localhost:8080&quot;</span>);</code></pre></div><p>请求重定向的第二种方案（推荐使用）：</p><div class="hljs code-wrapper"><pre><code class="hljs java">resp.sendRedirect(<span class="hljs-string">&quot;http://localhost:8080&quot;</span>);</code></pre></div><h2 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h2><p>文件的上传和下载，是非常常见的功能。很多的系统中，或者软件中都经常使用文件的上传和下载。 比如：QQ 头像，就使用了上传。 邮箱中也有附件的上传和下载功能。 OA 系统中审批有附件材料的上传</p><p><strong>文件的上传介绍</strong></p><p>1、要有一个 form 标签，<code>method=post </code>请求 </p><p>2、form 标签的 encType 属性值必须为<code>multipart/form-data</code>值 </p><p>3、在 form 标签中使用<code>input type=file</code>添加上传的文件 </p><p>4、编写服务器代码（Servlet 程序）接收，处理上传的数据</p><p><code>encType=multipart/form-data</code>表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼接，然后以二进制流的形式发送给服务器</p><p><strong>HTTP 协议的说明</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424203534339.png" alt="image-20210424203534339"></p><p><strong>commons-fileupload.jar常用API</strong></p><p><code>commons-fileupload.jar</code> 需要依赖 <code>commons-io.jar</code> 这个包，所以两个包我们都要引入</p><p>第一步，就是需要导入两个 jar 包：</p><ul><li><p>commons-fileupload-1.2.1.jar</p></li><li><p>commons-io-1.4.jar</p></li></ul><p><code>commons-fileupload.jar</code> 和 <code>commons-io.jar</code> 包中，我们常用的类有哪些？</p><ul><li><code>ServletFileUpload</code> 类，用于解析上传的数据</li><li><code>FileItem</code>类，表示每一个表单项</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//判断当前上传的数据格式是否是多段的格式</span><span class="hljs-keyword">boolean</span> ServletFileUpload.isMultipartContent(HttpServletRequest request);<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;FileItem&gt; <span class="hljs-title">parseRequest</span><span class="hljs-params">(HttpServletRequest request)</span><span class="hljs-comment">//解析上传的数据</span></span><span class="hljs-function"><span class="hljs-comment">//判断当前这个表单项，是否是普通的表单项。还是上传的文件类型</span></span><span class="hljs-function"><span class="hljs-comment">//true 表示普通类型的表单项 false 表示上传的文件类型</span></span><span class="hljs-function"><span class="hljs-keyword">boolean</span> FileItem.<span class="hljs-title">isFormField</span><span class="hljs-params">()</span></span><span class="hljs-function">String FileItem.<span class="hljs-title">getFieldName</span><span class="hljs-params">()</span><span class="hljs-comment">//获取表单项的 name 属性值</span></span><span class="hljs-function">String FileItem.<span class="hljs-title">getString</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前表单项的值。</span></span><span class="hljs-function">String FileItem.<span class="hljs-title">getName</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取上传的文件名</span><span class="hljs-keyword">void</span> FileItem.write( file ); <span class="hljs-comment">//将上传的文件写到参数 file 所指向硬盘位置</span></code></pre></div><p><strong>fileupload 类库的使用</strong></p><p>上传文件的表单</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://192.168.31.74:8080/09_EL_JSTL/uploadServlet&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>头像：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;photo&quot;</span> &gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p>解析上传的数据的代码</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424204308913.png" alt="image-20210424204308913"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424204320995.png" alt="image-20210424204320995"></p><p><strong>文件下载</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424210255797.png" alt="image-20210424210255797"></p><p>下载的常用 API 说明</p><ul><li>response.getOutputStream(); </li><li>servletContext.getResourceAsStream(); </li><li>servletContext.getMimeType(); </li><li>response.setContentType();</li></ul><p><code>response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; fileName=1.jpg&quot;);</code></p><p>这个响应头告诉浏览器。这是需要下载的。而attachment表示附件，也就是下载的一个文件。fileName=后面，表示下载的文件名。</p><p>完成上面的两个步骤，下载文件是没问题了。但是如果我们要下载的文件是中文名的话。你会发现，下载无法正确显示出正确的中文名。</p><p>原因是在响应头中，不能包含有中文字符，只能包含 ASCII 码</p><p><strong>中文名乱码问题解决方案</strong></p><p>URLEncoder 解决 IE 和谷歌浏览器的附件中文名问题</p><p>如果客户端浏览器是 IE 浏览器 或者 是谷歌浏览器。我们需要使用 URLEncoder 类先对中文名进行 UTF-8 的编码 操作。 因为 IE 浏览器和谷歌浏览器收到含有编码后的字符串后会以 UTF-8 字符集进行解码显示。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 把中文名进行 UTF-8 编码操作。</span>String str = <span class="hljs-string">&quot;attachment; fileName=&quot;</span> + URLEncoder.encode(<span class="hljs-string">&quot;中文.jpg&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">// 然后把编码后的字符串设置到响应头中 </span>response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, str);</code></pre></div><p>如果是FireFox，需要Base64编码</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424211335676.png" alt="image-20210424211335676"></p><h1 id="七、Cookie-amp-Session"><a href="#七、Cookie-amp-Session" class="headerlink" title="七、Cookie&amp;Session"></a>七、Cookie&amp;Session</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>http是无状态的，他不保存状态，意思就是一个浏览器发的请求，随后就断开了，下一次发送请求就和 上一次无关了。</p><p>比如一个用户购买一个商品，第一次需要登录，如果再买一个时向服务器发送请求，服务器如果不知道是谁发的，那么他就得再登录一次，这显然是不合理的，于是就提出了cookie和session的概念。</p><p>cookie是记录在浏览器端的一个字符串，session是保存在服务器端的一个对象。他们两互相配合让服务器有了能识别客户端一些状态的能力，意思就是服务就就能知道这个客户端有没有登录等。cookie就相当于通行证，session就是门房，进去时需要从门房识别一个身份。</p><p><strong>创建时机</strong></p><ol><li><p>当浏览器向客户端发送请求时，服务器会为他创建一个session，同时相应会加一个头（SetCookie: jsessionid=ewrwerwer123）</p></li><li><p>浏览器得到相应就会在在自己这保存下这个字符串，以后访问这个网站的时候就会一直带着。</p></li><li><p>当下一个请求发起时，会带着这个cookie的信息，服务器通过查询id找的session，通过session内保存的信息，就能获得这个客户端的状态。</p></li></ol><p><strong>什么是 Cookie?</strong> </p><ul><li>Cookie 翻译过来是饼干的意思</li><li>Cookie 是服务器通知客户端保存键值对的一种技术 </li><li>客户端有了 Cookie 后，每次请求都发送给服务器</li><li>每个 Cookie 的大小不能超过 4kb</li></ul><p><strong>如何创建 Cookie</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210419220806656-9168959.png" alt="image-20210419220806656"></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createCookie</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span><span class="hljs-function">IOException </span>&#123;<span class="hljs-comment">//1 创建 Cookie 对象</span>Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-string">&quot;value4&quot;</span>);<span class="hljs-comment">//2 通知客户端保存 Cookie</span>resp.addCookie(cookie);<span class="hljs-comment">//1 创建 Cookie 对象</span>Cookie cookie1 = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;key5&quot;</span>, <span class="hljs-string">&quot;value5&quot;</span>);<span class="hljs-comment">//2 通知客户端保存 Cookie</span>resp.addCookie(cookie1);resp.getWriter().write(<span class="hljs-string">&quot;Cookie 创建成功&quot;</span>);&#125;</code></pre></div><p><strong>服务器如何获取 Cookie</strong></p><p>服务器获取客户端的 Cookie 只需要一行代码：req.getCookies():Cookie[]</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210419221025141-9168959.png" alt="image-20210419221025141"></p><p>Cookie 的工具类：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CookieUtils</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查找指定名称的Cookie对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookies</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cookie <span class="hljs-title">findCookie</span><span class="hljs-params">(String name , Cookie[] cookies)</span></span>&#123;        <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span> || cookies == <span class="hljs-keyword">null</span> || cookies.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;            <span class="hljs-keyword">if</span> (name.equals(cookie.getName())) &#123;                <span class="hljs-keyword">return</span> cookie;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p>Servlet 程序中的代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCookie</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        Cookie[] cookies = req.getCookies();        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;            <span class="hljs-comment">// getName方法返回Cookie的key（名）</span>            <span class="hljs-comment">// getValue方法返回Cookie的value值</span>            resp.getWriter().write(<span class="hljs-string">&quot;Cookie[&quot;</span> + cookie.getName() + <span class="hljs-string">&quot;=&quot;</span> + cookie.getValue() + <span class="hljs-string">&quot;] &lt;br/&gt;&quot;</span>);        &#125;        Cookie iWantCookie = CookieUtils.findCookie(<span class="hljs-string">&quot;key1&quot;</span>, cookies);<span class="hljs-comment">//        for (Cookie cookie : cookies) &#123;</span><span class="hljs-comment">//            if (&quot;key2&quot;.equals(cookie.getName())) &#123;</span><span class="hljs-comment">//                iWantCookie = cookie;</span><span class="hljs-comment">//                break;</span><span class="hljs-comment">//            &#125;</span><span class="hljs-comment">//        &#125;</span>        <span class="hljs-comment">// 如果不等于null，说明赋过值，也就是找到了需要的Cookie</span>        <span class="hljs-keyword">if</span> (iWantCookie != <span class="hljs-keyword">null</span>) &#123;            resp.getWriter().write(<span class="hljs-string">&quot;找到了需要的Cookie&quot;</span>);        &#125;    &#125;</code></pre></div><p><strong>Cookie 值的修改</strong></p><p>方案一： </p><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span>、先创建一个要修改的同名（指的就是 <span class="hljs-keyword">key</span>）的 Cookie 对象 <span class="hljs-number">2</span>、在构造器，同时赋于新的 Cookie 值。 <span class="hljs-number">3</span>、调用 response.addCookie( Cookie )</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;key1&quot;</span>,<span class="hljs-string">&quot;newValue1&quot;</span>);resp.addCookie(cookie);</code></pre></div><p>方案二： </p><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">1</span>、先查找到需要修改的 <span class="hljs-selector-tag">Cookie</span> 对象 <span class="hljs-selector-tag">2</span>、调用 <span class="hljs-selector-tag">setValue</span>()方法赋于新的 <span class="hljs-selector-tag">Cookie</span> 值。 <span class="hljs-selector-tag">3</span>、调用 <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.addCookie</span>()通知客户端保存修改</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">Cookie cookie = CookieUtils.findCookie(<span class="hljs-string">&quot;key2&quot;</span>, req.getCookies());       <span class="hljs-keyword">if</span> (cookie != <span class="hljs-keyword">null</span>) &#123;           cookie.setValue(<span class="hljs-string">&quot;newValue2&quot;</span>);           resp.addCookie(cookie);       &#125;</code></pre></div><p> <strong>Cookie 生命控制</strong></p><p>Cookie 的生命控制指的是如何管理 Cookie 什么时候被销毁（删除） </p><p><code>setMaxAge() </code></p><ul><li>正数，表示在指定的秒数后过期 </li><li>负数，表示浏览器一关，Cookie 就会被删除（默认值是-1）</li><li>零，表示马上删除 Cookie</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 设置存活1个小时的Cooie</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">life3600</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;       Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;life3600&quot;</span>, <span class="hljs-string">&quot;life3600&quot;</span>);       cookie.setMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">60</span>); <span class="hljs-comment">// 设置Cookie一小时之后被删除。无效</span>       resp.addCookie(cookie);       resp.getWriter().write(<span class="hljs-string">&quot;已经创建了一个存活一小时的Cookie&quot;</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 马上删除一个Cookie</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNow</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;       <span class="hljs-comment">// 先找到你要删除的Cookie对象</span>       Cookie cookie = CookieUtils.findCookie(<span class="hljs-string">&quot;key4&quot;</span>, req.getCookies());       <span class="hljs-keyword">if</span> (cookie != <span class="hljs-keyword">null</span>) &#123;           <span class="hljs-comment">// 调用setMaxAge(0);</span>           cookie.setMaxAge(<span class="hljs-number">0</span>); <span class="hljs-comment">// 表示马上删除，都不需要等待浏览器关闭</span>           <span class="hljs-comment">// 调用response.addCookie(cookie);</span>           resp.addCookie(cookie);           resp.getWriter().write(<span class="hljs-string">&quot;key4的Cookie已经被删除&quot;</span>);       &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 默认的会话级别的Cookie</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultLife</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;       Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;defalutLife&quot;</span>,<span class="hljs-string">&quot;defaultLife&quot;</span>);       cookie.setMaxAge(-<span class="hljs-number">1</span>);<span class="hljs-comment">//设置存活时间</span>       resp.addCookie(cookie);   &#125;</code></pre></div><p><strong>Cookie 有效路径 Path 的设置</strong></p><p>Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。 </p><p>path 属性是通过请求的地址来进行有效的过滤。</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">CookieA <span class="hljs-attribute">path</span>=/工程路径 CookieB <span class="hljs-attribute">path</span>=/工程路径/abc</code></pre></div><p>请求地址如下： <a href="http://ip:port/工程路径/a.html">http://ip:port/工程路径/a.html</a> </p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">CookieA</span> 发送 CookieB 不发送</code></pre></div><p> <a href="http://ip:port/工程路径/abc/a.html">http://ip:port/工程路径/abc/a.html</a> </p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">CookieA</span> 发送 CookieB 发送</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;path1&quot;</span>, <span class="hljs-string">&quot;path1&quot;</span>);    <span class="hljs-comment">// getContextPath() ===&gt;&gt;&gt;&gt;  得到工程路径</span>    cookie.setPath( req.getContextPath() + <span class="hljs-string">&quot;/abc&quot;</span> ); <span class="hljs-comment">// ===&gt;&gt;&gt;&gt;  /工程路径/abc</span>    resp.addCookie(cookie);    resp.getWriter().write(<span class="hljs-string">&quot;创建了一个带有Path路径的Cookie&quot;</span>);</code></pre></div><p> <strong>Cookie 练习—免输入用户名登录</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210419222822461-9168959.png" alt="image-20210419222822461"></p><p>login.jsp 页面</p><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;http://localhost:8080/13_cookie_session/loginServlet&quot;</span> method=<span class="hljs-string">&quot;get&quot;</span>&gt;用户名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;$&#123;cookie.username.value&#125;&quot;</span>&gt; &lt;br&gt;密码：&lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>&gt; &lt;br&gt;&lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;登录&quot;</span>&gt;&lt;/form&gt;</code></pre></div><p>LoginServlet </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;wzg168&quot;</span>.equals(username) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(password)) &#123;<span class="hljs-comment">//登录 成功</span>Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;username&quot;</span>, username);cookie.setMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>);<span class="hljs-comment">//当前 Cookie 一周内有效</span>resp.addCookie(cookie);System.out.println(<span class="hljs-string">&quot;登录 成功&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 登录 失败</span>System.out.println(<span class="hljs-string">&quot;登录 失败&quot;</span>);&#125;&#125;</code></pre></div><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p> <strong>什么是 Session 会话?</strong></p><p>1、Session 就一个接口（HttpSession）。 </p><p>2、Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。 </p><p>3、每个客户端都有自己的一个 Session 会话。 </p><p>4、Session 会话中，我们经常用来保存用户登录之后的信息。</p><p> <strong>如何创建 Session 和获取(id 号,是否为新)</strong></p><p>如何创建和获取 Session。它们的 API 是一样的。 request.getSession() </p><ul><li><p>第一次调用是：创建 Session 会话 </p></li><li><p>之后调用都是：获取前面创建好的 Session 会话对象 </p></li></ul><p>isNew(); 判断到底是不是刚创建出来的（新的） </p><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span> 表示刚创建 <span class="hljs-literal">false</span> 表示获取之前创建</code></pre></div><p>每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 是唯一的。 </p><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getId</span><span class="hljs-params">()</span></span> 得到 Session 的会话 id 值。</code></pre></div><p><strong>Session 域数据的存取</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 往 Session 中保存数据</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> req* <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;req.getSession().setAttribute(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);resp.getWriter().write(<span class="hljs-string">&quot;已经往 Session 中保存了数据&quot;</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 获取 Session 域中的数据</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAttribute</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;Object attribute = req.getSession().getAttribute(<span class="hljs-string">&quot;key1&quot;</span>);resp.getWriter().write(<span class="hljs-string">&quot;从 Session 中获取出 key1 的数据是：&quot;</span> + attribute);&#125;</code></pre></div><p> <strong>Session 生命周期控制</strong></p><p><code> public void setMaxInactiveInterval(int interval)</code> 设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。 </p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">值为正数的时候，设定 <span class="hljs-keyword">Session</span> 的超时时长。 负数表示永不超时（极少使用）</code></pre></div><p><code>public int getMaxInactiveInterval()</code> 获取 Session 的超时时间 </p><p><code>public void invalidate()</code>  让当前 Session 会话马上超时无效</p><p>Session 默认的超时时间长为 30 分钟</p><p>因为在 Tomcat 服务器的配置文件 web.xml中默认有以下的配置，它就表示配置了当前 Tomcat 服务器下所有的 Session 超时配置默认时长为：30 分钟。  </p><p>如果说。你希望你的 web 工程，默认的 Session 的超时时长为其他时长。你可以在你自己的 web.xml 配置文件中做 以上相同的配置。就可以修改你的 web 工程所有 Seession 的默认超时时长。</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--表示当前 web 工程。创建出来 的所有 Session 默认是 20 分钟 超时时长--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span></code></pre></div><p>Session 超时的概念介绍：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210420170135655-9168959.png" alt="image-20210420170135655"></p><p>示例代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">life3</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;<span class="hljs-comment">// 先获取 Session 对象</span>HttpSession session = req.getSession();<span class="hljs-comment">// 设置当前 Session3 秒后超时</span>session.setMaxInactiveInterval(<span class="hljs-number">3</span>);resp.getWriter().write(<span class="hljs-string">&quot;当前 Session 已经设置为 3 秒后超时&quot;</span>);&#125;</code></pre></div><p>Session 马上超时示例：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNow</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;<span class="hljs-comment">// 先获取 Session 对象</span>HttpSession session = req.getSession();<span class="hljs-comment">// 让 Session 会话马上超时</span>session.invalidate();resp.getWriter().write(<span class="hljs-string">&quot;Session 已经设置为超时（无效）&quot;</span>);&#125;</code></pre></div><p> <strong>浏览器和 Session 之间关联的技术内幕</strong></p><p>Session 技术，底层其实是基于 Cookie 技术来实现的。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210420170339207-9168959.png" alt="image-20210420170339207"></p><h1 id="八、Filter"><a href="#八、Filter" class="headerlink" title="八、Filter"></a>八、Filter</h1><h2 id="什么是过滤器"><a href="#什么是过滤器" class="headerlink" title="什么是过滤器"></a>什么是过滤器</h2><p>1、Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是：Servlet 程序、Listener 监听器、Filter 过滤器</p><p>2、Filter 过滤器它是 JavaEE 的规范。也就是接口 </p><p>3、Filter 过滤器它的作用是：拦截请求，过滤响应。</p><p><strong>拦截请求常见的应用场景有：</strong></p><p>1、权限检查 </p><p>2、日记操作 </p><p>3、事务管理</p><p><strong>Filter 的初体验</strong></p><p>要求：在你的 web 工程下，有一个 admin 目录。这个 admin 目录下的所有资源（html 页面、jpg 图片、jsp 文件、等等）都必 须是用户登录之后才允许访问。 </p><p>思考：根据之前我们学过内容。我们知道，用户登录之后都会把用户登录的信息保存到Session域中。所以要检查用户是否登录，可以判断Session中否包含有用户登录的信息</p><div class="hljs code-wrapper"><pre><code class="hljs java">Object user = session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<span class="hljs-comment">// 如果等于 null，说明还没有登录</span><span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;request.getRequestDispatcher(<span class="hljs-string">&quot;/login.jsp&quot;</span>).forward(request,response);<span class="hljs-keyword">return</span>;&#125;</code></pre></div><h2 id="Filter-的工作流程图"><a href="#Filter-的工作流程图" class="headerlink" title="Filter 的工作流程图"></a>Filter 的工作流程图</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210420171201652-9168959.png" alt="image-20210420171201652"></p><p>Filter 代码:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * doFilter 方法，专门用于拦截请求。可以做权限检查</span><span class="hljs-comment">    */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChainfilterChain)</span> <span class="hljs-keyword">throws</span> IOException,ServletException </span>&#123;   HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;    HttpSession session = httpServletRequest.getSession();    Object user = session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);    <span class="hljs-comment">// 如果等于 null，说明还没有登录</span>    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;    servletRequest.getRequestDispatcher(<span class="hljs-string">&quot;/login.jsp&quot;</span>).forward(servletRequest,servletResponse);    <span class="hljs-keyword">return</span>;    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 让程序继续往下访问用户的目标资源</span>    filterChain.doFilter(servletRequest,servletResponse);    &#125;    &#125;&#125;</code></pre></div><p>web.xml 中的配置：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--filter 标签用于配置一个 Filter 过滤器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-comment">&lt;!--给 filter 起一个别名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置 filter 的全类名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.atguigu.filter.AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-comment">&lt;!--filter-mapping 配置 Filter 过滤器的拦截路径--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-comment">&lt;!--filter-name 表示当前的拦截路径给哪个 filter 使用--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--url-pattern 配置拦截路径</span><span class="hljs-comment">    / 表示请求地址为：http://ip:port/工程路径/ 映射到 IDEA 的 web 目录</span><span class="hljs-comment">    /admin/* 表示请求地址为：http://ip:port/工程路径/admin/*</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/admin/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div><p>Filter 过滤器的使用步骤： </p><p>1、编写一个类去实现 Filter 接口 </p><p>2、实现过滤方法 doFilter() </p><p>3、到 web.xml 中去配置 Filter 的拦截路径</p><h2 id="Filter-的生命周期"><a href="#Filter-的生命周期" class="headerlink" title="Filter 的生命周期"></a><strong>Filter 的生命周期</strong></h2><p>Filter 的生命周期包含几个方法 </p><ul><li><p>构造器方法 </p></li><li><p>init 初始化方法 </p><ul><li>第 1，2 步，在 web 工程启动的时候执行（Filter 已经创建）</li></ul></li><li><p>doFilter 过滤方法 </p><ul><li>第 3 步，每次拦截到请求，就会执行</li></ul></li><li><p>destroy 销毁 </p><ul><li>第 4 步，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器）</li></ul></li></ul><h2 id="FilterConfig-类"><a href="#FilterConfig-类" class="headerlink" title="FilterConfig 类"></a><strong>FilterConfig 类</strong></h2><p>FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。 </p><p>Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。 </p><p>FilterConfig 类的作用是获取 filter 过滤器的配置内容 </p><ul><li>获取 Filter 的名称 filter-name 的内容</li><li>获取在 Filter 中配置的 init-param 初始化参数 </li><li>获取 ServletContext 对象</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;    System.out.println(<span class="hljs-string">&quot;2.Filter 的 init(FilterConfig filterConfig)初始化&quot;</span>);    <span class="hljs-comment">// 1、获取 Filter 的名称 filter-name 的内容</span>    System.out.println(<span class="hljs-string">&quot;filter-name 的值是：&quot;</span> + filterConfig.getFilterName());    <span class="hljs-comment">// 2、获取在 web.xml 中配置的 init-param 初始化参数</span>    System.out.println(<span class="hljs-string">&quot;初始化参数 username 的值是：&quot;</span> + filterConfig.getInitParameter(<span class="hljs-string">&quot;username&quot;</span>));    System.out.println(<span class="hljs-string">&quot;初始化参数 url 的值是：&quot;</span> + filterConfig.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>));    <span class="hljs-comment">// 3、获取 ServletContext 对象</span>    System.out.println(filterConfig.getServletContext());&#125;</code></pre></div><p>web.xml 配置</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--filter 标签用于配置一个 Filter 过滤器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-comment">&lt;!--给 filter 起一个别名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置 filter 的全类名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.atguigu.filter.AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost3306/test<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span></code></pre></div><h2 id="FilterChain-过滤器链"><a href="#FilterChain-过滤器链" class="headerlink" title="FilterChain 过滤器链"></a><strong>FilterChain 过滤器链</strong></h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210420172137716-9168959.png" alt="image-20210420172137716"></p><h2 id="Filter-的拦截路径"><a href="#Filter-的拦截路径" class="headerlink" title="Filter 的拦截路径"></a><strong>Filter 的拦截路径</strong></h2><p>精确匹配</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/target.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/target.jsp</code></pre></div><p>目录匹配</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/admin/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/admin/*</code></pre></div><p>后缀名匹配</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.html<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>以上配置的路径，表示请求地址必须以.html 结尾才会拦截到<span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>以上配置的路径，表示请求地址必须以.do 结尾才会拦截到<span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.action<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>以上配置的路径，表示请求地址必须以.action 结尾才会拦截到</code></pre></div><h2 id="使用-Filter和ThreadLocal组合管理事务"><a href="#使用-Filter和ThreadLocal组合管理事务" class="headerlink" title="使用 Filter和ThreadLocal组合管理事务"></a><strong>使用 Filter和ThreadLocal组合管理事务</strong></h2><p>使用 ThreadLocal 来确保所有 dao 操作都在同一个 Connection 连接对象中完成</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425220820180.png" alt="image-20210425220820180"></p><p><strong>JdbcUtils 工具类的修改</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221034230.png" alt="image-20210425221034230"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221121726.png" alt="image-20210425221121726"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221143361.png" alt="image-20210425221143361"></p><p><strong>修改 BaseDao</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221206385.png" alt="image-20210425221206385"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221232144.png" alt="image-20210425221232144"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221250908.png" alt="image-20210425221250908"></p><p><strong>使用 Filter 过滤器统一给所有的 Service 方法都加上 try-catch。来进行实现的管理</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221339475.png" alt="image-20210425221339475"></p><p><strong>Filter 类代码</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221416401.png" alt="image-20210425221416401"></p><p><strong>在 web.xml 中的配置</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221444049.png" alt="image-20210425221444049"></p><p><strong>记得把 BaseServlet 中的异常往外抛给 Filter 过滤器</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221511723.png" alt="image-20210425221511723"></p><p><strong>将所有异常都统一交给 Tomcat，让 Tomcat 展示友好的错误信息页面</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221540610.png" alt="image-20210425221540610"></p><h1 id="九、Listener"><a href="#九、Listener" class="headerlink" title="九、Listener"></a>九、Listener</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>监听器用于监听Web应用中某些对象的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理。当监听范围的对象的状态发生变化的时候，服务器自动调用监听器对象中的方法。常用于统计网站在线人数、系统加载时进行信息初始化、统计网站的访问量等等。</p><p>实现监听：</p><ol><li>创建类实现监听器接口</li><li><code>web.xml</code>文件中配置(注册）监听器<code>&lt;listener&gt; &lt;listener-class&gt;url&lt;/listener-class&gt;&lt;/listener&gt;</code> ，<code>Servlet3.0</code>后可以通过注解@WebListener 注册监听器</li></ol><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221742885.png" alt="image-20210425221742885"></p><p>web.xml 的加载顺序是：context- param -&gt; listener -&gt; filter -&gt; servlet</p><h2 id="Listener监听三个域对象创建与销毁"><a href="#Listener监听三个域对象创建与销毁" class="headerlink" title="Listener监听三个域对象创建与销毁"></a>Listener监听三个域对象创建与销毁</h2><p>监听<code>ServletContext</code>域对象的创建与销毁：实现<code>ServletContextListener</code>接口。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServletContextListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;初始化&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;销毁了&quot;</span>);&#125;&#125;</code></pre></div><p>监听<code>ServletRequest</code>域对象的创建与销毁：实现<code>ServletRequestListener</code>接口。</p><p><code>ServletRequest</code>域对象的生命周期：</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">创建：访问服务器任何资源都会发送请求<span class="hljs-params">(ServletRequest)</span>出现,访问<span class="hljs-string">.html</span>和<span class="hljs-string">.jsp</span>和<span class="hljs-string">.servlet</span>都会创建请求销毁：服务器已经对该次请求做出了响应</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServletRequestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletRequestListener</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestDestroyed</span><span class="hljs-params">(ServletRequestEvent arg0)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;ServletRequest销毁了&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestInitialized</span><span class="hljs-params">(ServletRequestEvent arg0)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;ServletRequest创建了&quot;</span>);&#125;&#125;</code></pre></div><p>监听<code>HttpSession</code>域对象的创建与销毁：实现<code>HttpSessionListener</code>接口：<br><code>HttpSession</code>域对象的生命周期：</p><div class="hljs code-wrapper"><pre><code class="hljs less">创建：只要调用了<span class="hljs-selector-tag">getSession</span>()方法就会创建，一次会话只会创建一次销毁：<span class="hljs-selector-tag">1</span>.超时(默认为<span class="hljs-number">30</span>分钟)<span class="hljs-selector-tag">2</span>.非正常关闭，销毁<span class="hljs-selector-tag">3</span>.正常关闭服务器(序列化)</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHttpSessionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent arg0)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;HttpSession创建了&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent arg0)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;HTTPSession销毁了&quot;</span>);&#125;&#125;</code></pre></div><h1 id="十、JSON"><a href="#十、JSON" class="headerlink" title="十、JSON"></a>十、JSON</h1><h2 id="什么是-JSON"><a href="#什么是-JSON" class="headerlink" title="什么是 JSON?"></a>什么是 JSON?</h2><p> JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 这样就使得 JSON 成为理想的数据交换格式。</p><p> json 是一种轻量级的数据交换格式。 </p><ul><li><p>轻量级指的是跟 xml 做比较</p></li><li><p>数据交换指的是客户端和服务器之间业务数据的传递格式</p></li></ul><h2 id="JSON-在-JavaScript-中的使用"><a href="#JSON-在-JavaScript-中的使用" class="headerlink" title="JSON 在 JavaScript 中的使用"></a>JSON 在 JavaScript 中的使用</h2><p><strong>json 的定义</strong></p><p>json 是由键值对组成，并且由花括号（大括号）包围。每个键由引号引起来，键和值之间使用冒号进行分隔， 多组键值对之间进行逗号进行分隔。</p><p>json 定义示例：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> jsonObj = &#123;    <span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-number">12</span>,    <span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;abc&quot;</span>,    <span class="hljs-string">&quot;key3&quot;</span>:<span class="hljs-literal">true</span>,    <span class="hljs-string">&quot;key4&quot;</span>:[<span class="hljs-number">11</span>,<span class="hljs-string">&quot;arr&quot;</span>,<span class="hljs-literal">false</span>],    <span class="hljs-string">&quot;key5&quot;</span>:&#123;        <span class="hljs-string">&quot;key5_1&quot;</span> : <span class="hljs-number">551</span>,        <span class="hljs-string">&quot;key5_2&quot;</span> : <span class="hljs-string">&quot;key5_2_value&quot;</span>&#125;,    <span class="hljs-string">&quot;key6&quot;</span>:[&#123;        <span class="hljs-string">&quot;key6_1_1&quot;</span>:<span class="hljs-number">6611</span>,        <span class="hljs-string">&quot;key6_1_2&quot;</span>:<span class="hljs-string">&quot;key6_1_2_value&quot;</span>&#125;,&#123;        <span class="hljs-string">&quot;key6_2_1&quot;</span>:<span class="hljs-number">6621</span>,        <span class="hljs-string">&quot;key6_2_2&quot;</span>:<span class="hljs-string">&quot;key6_2_2_value&quot;</span>    &#125;]&#125;;</code></pre></div><p><strong>json的访问</strong></p><p>json 本身是一个对象。 </p><p>json 中的 key 我们可以理解为是对象中的一个属性。 </p><p>json 中的 key 访问就跟访问对象的属性一样： json 对象.key </p><p>json访问示例：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">alert(<span class="hljs-keyword">typeof</span>(jsonObj));<span class="hljs-comment">// object json 就是一个对象</span>alert(jsonObj.key1); <span class="hljs-comment">//12</span>alert(jsonObj.key2); <span class="hljs-comment">// abc</span>alert(jsonObj.key3); <span class="hljs-comment">// true</span>alert(jsonObj.key4);<span class="hljs-comment">// 得到数组[11,&quot;arr&quot;,false]</span><span class="hljs-comment">// json 中 数组值的遍历</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; jsonObj.key4.length; i++) &#123;alert(jsonObj.key4[i]);&#125;alert(jsonObj.key5.key5_1);<span class="hljs-comment">//551</span>alert(jsonObj.key5.key5_2);<span class="hljs-comment">//key5_2_value</span>alert( jsonObj.key6 );<span class="hljs-comment">// 得到 json 数组</span><span class="hljs-comment">// 取出来每一个元素都是 json 对象</span><span class="hljs-keyword">var</span> jsonItem = jsonObj.key6[<span class="hljs-number">0</span>];<span class="hljs-comment">// alert( jsonItem.key6_1_1 ); //6611</span>alert( jsonItem.key6_1_2 ); <span class="hljs-comment">//key6_1_2_value</span></code></pre></div><h2 id="json-的两个常用方法"><a href="#json-的两个常用方法" class="headerlink" title="json 的两个常用方法"></a><strong>json 的两个常用方法</strong></h2><ul><li><p>JSON.stringify() 把 json 对象转换成为 json 字符串</p></li><li><p>JSON.parse() 把 json 字符串转换成为 json 对象</p></li></ul><p><strong>json 的存在有两种形式。</strong></p><ul><li><p> 一种是：对象的形式存在，我们叫它 json 对象。 </p></li><li><p>一种是：字符串的形式存在，我们叫它 json 字符串。</p></li><li><p> 一般我们要操作 json 中的数据的时候，需要 json 对象的格式。</p></li><li><p>一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串。</p></li></ul><h2 id="JSON-在-java-中的使用"><a href="#JSON-在-java-中的使用" class="headerlink" title="JSON 在 java 中的使用"></a><strong>JSON 在 java 中的使用</strong></h2><p>jackson fastjson Gson </p><p><strong>JSON介绍</strong></p><p><strong>Java–&gt;json</strong></p><p>将一个类以json字符串的形式输出：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将一个类以json字符串的形式输出</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-comment">//使用Jackson的ObjectMapper</span>        ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();        User user = <span class="hljs-keyword">new</span> User();        user.setMoney(<span class="hljs-number">1000</span>);        user.setUsername(<span class="hljs-string">&quot;张三&quot;</span>);        user.setPassword(<span class="hljs-string">&quot;123&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            System.out.println(mapper.writeValueAsString(user));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre></div><p>以json字符串输出一个List集合：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();    List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;User&gt;();    User u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">1000</span>);    list.add(u);    u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;456&quot;</span>, <span class="hljs-number">2000</span>);    list.add(u);    u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-string">&quot;789&quot;</span>, <span class="hljs-number">3000</span>);    list.add(u);    u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;赵六&quot;</span>, <span class="hljs-string">&quot;555&quot;</span>, <span class="hljs-number">4000</span>);    list.add(u);    <span class="hljs-keyword">try</span> &#123;        System.out.println(mapper.writeValueAsString(list));    &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;        <span class="hljs-comment">// TODO Auto-generated catch block</span>        e.printStackTrace();    &#125;&#125;</code></pre></div><p>将一个Map以json字符串的形式输出：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();    map.put(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);    map.put(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);    <span class="hljs-keyword">try</span> &#123;        System.out.println(mapper.writeValueAsString(map));    &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><p><strong>Json–&gt;java</strong></p><p>json字符串转为javaBean</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;    String str = <span class="hljs-string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;三国演义\&quot;,\&quot;price\&quot;:20,\&quot;author\&quot;:\&quot;罗贯中\&quot;,\&quot;detail\&quot;:&#123;\&quot;pressTime\&quot;:\&quot;2001-01-01\&quot;,\&quot;storyTime\&quot;:\&quot;196-05-06\&quot;&#125;,\&quot;attribute\&quot;:&#123;\&quot;category\&quot;:\&quot;小说\&quot;,\&quot;edition\&quot;:\&quot;9\&quot;&#125;&#125;&quot;</span>;    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();    <span class="hljs-keyword">try</span> &#123;        Book book = mapper.readValue(str, Book.class);        System.out.println(book.getAuthor()+<span class="hljs-string">&quot;,&quot;</span>+book.getAttribute().getCategory());    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><p>json字符串转为List</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//json--&gt;List</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;        String str = <span class="hljs-string">&quot;[&#123;\&quot;username\&quot;:\&quot;张三\&quot;,\&quot;password\&quot;:\&quot;123\&quot;,\&quot;money\&quot;:1000&#125;,&#123;\&quot;username\&quot;:\&quot;李四\&quot;,\&quot;password\&quot;:\&quot;456\&quot;,\&quot;money\&quot;:2000&#125;,&#123;\&quot;username\&quot;:\&quot;王五\&quot;,\&quot;password\&quot;:\&quot;789\&quot;,\&quot;money\&quot;:3000&#125;,&#123;\&quot;username\&quot;:\&quot;赵六\&quot;,\&quot;password\&quot;:\&quot;555\&quot;,\&quot;money\&quot;:4000&#125;]&quot;</span>;        ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();        <span class="hljs-keyword">try</span> &#123;            List&lt;User&gt; us = mapper.readValue(str, <span class="hljs-keyword">new</span> TypeReference&lt;ArrayList&lt;User&gt;&gt;() &#123;&#125;);            <span class="hljs-keyword">for</span> (User user : us) &#123;                System.out.println(user.getUsername()+<span class="hljs-string">&quot;,&quot;</span>+user.getMoney());            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre></div><p>json字符串转为Map：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//json--&gt;map</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;    String str = <span class="hljs-string">&quot;&#123;\&quot;password\&quot;:\&quot;888888\&quot;,\&quot;username\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();    <span class="hljs-keyword">try</span> &#123;        Map&lt;String, String&gt; map = mapper.readValue(str, <span class="hljs-keyword">new</span> TypeReference&lt;Map&lt;String, String&gt;&gt;() &#123;&#125;);        <span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;            System.out.println(key+<span class="hljs-string">&quot;,&quot;</span>+map.get(key));        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><h1 id="十一、Ajax"><a href="#十一、Ajax" class="headerlink" title="十一、Ajax"></a>十一、Ajax</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>AJAX即“Asynchronous Javascript And XML”(异步JavaScript和XML)，是指一种创建交互式网页应用的网页开发技术</p><ul><li><strong>ajax 是一种浏览器通过 js 异步发起请求，局部更新页面的技术</strong></li><li>ajax 请求的局部更新，浏览器地址栏不会发生变化 局部更新不会舍弃原来页面的内容</li></ul><p><strong>传统请求和异步请求</strong></p><ul><li>基于超级链接 地址栏 form表单 地址栏 location.href 发起的请求全部是传统请求<br>  特点: 请求之后,刷新整张页面<br>  缺点: 由于刷新了整张页面,用户操作被中断,造成大量网络流量的极大浪费。</li><li>基于ajax发起的请求都是异步请求<br>  特点: 多个请求并行发生,请求之间互不影响,请求之后页面不动,刷新页面的局部</li></ul><p><strong>传统网站中存在的问题</strong></p><ul><li>网速慢的情况下，页面加载时间长，用户只能等待</li><li>表单提交后，如果一项内容不合格，需要重新填写所有表单内容</li><li>页面跳转，重新加载页面，造成资源浪费，增加用户等待时间</li></ul><p><strong>Ajax 的应用场景</strong></p><ul><li>页面上拉加载更多数据</li><li>列表数据无刷新分页</li><li>表单项离开焦点数据验证</li><li>搜索框提示文字下拉列表</li></ul><p><strong>Ajax 运行原理</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210426102426443.png" alt="image-20210426102426443"></p><p><strong>核心对象</strong></p><p><code>XMLHttpRequest </code>对象是一个javascript对象，存在着浏览器差异。简称xhr对象</p><h2 id="Ajax入门"><a href="#Ajax入门" class="headerlink" title="Ajax入门"></a><strong>Ajax入门</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"><span class="hljs-comment">// 1.创建ajax对象</span></span><span class="javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><span class="javascript"><span class="hljs-comment">// 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求</span></span><span class="javascript"><span class="hljs-comment">// 1)请求方式 2)请求地址</span></span><span class="javascript">xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:3000/first&#x27;</span>);</span><span class="javascript"><span class="hljs-comment">// 3.发送请求</span></span>xhr.send();<span class="javascript"><span class="hljs-comment">// 4.获取服务器端响应到客户端的数据</span></span><span class="javascript">xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript"><span class="hljs-built_in">console</span>.log(xhr.responseText)</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="Ajax-状态码"><a href="#Ajax-状态码" class="headerlink" title="Ajax 状态码"></a><strong>Ajax 状态码</strong></h2><p>在创建ajax对象，配置ajax对象，发送请求，以及接收完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。</p><blockquote><p>0：请求未初始化(还没有调用open())<br>1：请求已经建立，但是还没有发送(还没有调用send())<br>2：请求已经发送<br>3：请求正在处理中，通常响应中已经有部分数据可以用了<br>4：响应已经完成，可以获取并使用服务器的响应了<br>xhr.readyState // 获取Ajax状态码</p></blockquote><h2 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a><strong>onreadystatechange 事件</strong></h2><p>当 Ajax 状态码发生变化时将自动触发该事件。<br>在事件处理函数中可以获取 Ajax 状态码并对其进行判断，当状态码为 4 时就可以通过 xhr.responseText 获取服务器端的响应数据了。</p><p>不推荐,因为这种方式会由于状态码的变化被触发多次,效率低.推荐使用onload这种方式.唯一不足就是不兼容低版本IE浏览器</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210426104807866.png" alt="image-20210426104807866"></p><h2 id="原生-ajax-请求的示例"><a href="#原生-ajax-请求的示例" class="headerlink" title="原生 ajax 请求的示例"></a><strong>原生 ajax 请求的示例</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;!DOCTYPE html PUBLIC <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=<span class="hljs-string">&quot;pragma&quot;</span> content=<span class="hljs-string">&quot;no-cache&quot;</span> /&gt;    &lt;meta http-equiv=<span class="hljs-string">&quot;cache-control&quot;</span> content=<span class="hljs-string">&quot;no-cache&quot;</span> /&gt;    &lt;meta http-equiv=<span class="hljs-string">&quot;Expires&quot;</span> content=<span class="hljs-string">&quot;0&quot;</span> /&gt;    &lt;meta http-equiv=<span class="hljs-string">&quot;Content-Type&quot;</span> content=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<span class="hljs-comment">// 在这里使用 javaScript 语言发起 Ajax 请求，访问服务器 AjaxServlet 中 javaScriptAjax</span><span class="hljs-function">function <span class="hljs-title">ajaxRequest</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">// 1、我们首先要创建 XMLHttpRequest</span>            <span class="hljs-keyword">var</span> xmlhttprequest = <span class="hljs-keyword">new</span> XMLHttpRequest();            <span class="hljs-comment">// 2、调用 open 方法设置请求参数</span>      xmlhttprequest.open(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet?action=javaScriptAjax&quot;</span>,<span class="hljs-keyword">true</span>)            <span class="hljs-comment">// 4、在 send 方法前绑定 onreadystatechange 事件，处理请求完成后的操作。</span>            xmlhttprequest.onreadystatechange = function()&#123;                <span class="hljs-keyword">if</span> (xmlhttprequest.readyState == <span class="hljs-number">4</span> &amp;&amp; xmlhttprequest.status == <span class="hljs-number">200</span>) &#123;                    <span class="hljs-keyword">var</span> jsonObj = JSON.parse(xmlhttprequest.responseText);                    <span class="hljs-comment">// 把响应的数据显示在页面上</span>                    document.getElementById(<span class="hljs-string">&quot;div01&quot;</span>).innerHTML = <span class="hljs-string">&quot;编号：&quot;</span> + jsonObj.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> +jsonObj.name;                &#125;            &#125;            <span class="hljs-comment">// 3、调用 send 方法发送请求</span>            xmlhttprequest.send();&#125;    &lt;/script&gt;   &lt;/head&gt;    &lt;body&gt;    &lt;button onclick=&quot;ajaxRequest()&quot;&gt;ajax request&lt;/button&gt;    &lt;div id=<span class="hljs-string">&quot;div01&quot;</span>&gt;    &lt;/div&gt;    &lt;/body&gt;   &lt;/html&gt;</code></pre></div><h2 id="发送GET方式请求"><a href="#发送GET方式请求" class="headerlink" title="发送GET方式请求"></a><strong>发送GET方式请求</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 创建xhr对象</span><span class="hljs-keyword">var</span> xhr ; <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.XMLHttpRequest)&#123;xhr = <span class="hljs-keyword">new</span> XMLHttpRequest(); &#125;<span class="hljs-keyword">else</span>&#123;xhr = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>); &#125;<span class="hljs-comment">//2.发送请求,并传递参数</span>xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/ajax_day2/test?name=zhangsan&quot;</span>);xhr.send();<span class="hljs-comment">//3.处理响应</span>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-keyword">if</span>(xhr.readyState==<span class="hljs-number">4</span> &amp;&amp; xhr.status==<span class="hljs-number">200</span>)&#123;     <span class="hljs-built_in">console</span>.log(xhr.responseText); &#125;&#125;</code></pre></div><h2 id="发送POST方式请求"><a href="#发送POST方式请求" class="headerlink" title="发送POST方式请求"></a><strong>发送POST方式请求</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 创建xhr对象</span><span class="hljs-keyword">var</span> xhr; <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.XMLHttpRequest)&#123;xhr = <span class="hljs-keyword">new</span> XMLHttpRequest(); &#125;<span class="hljs-keyword">else</span>&#123;xhr = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>); &#125;<span class="hljs-comment">//2.发送请求,并传递参数</span>xhr.open(<span class="hljs-string">&quot;POST&quot;</span>,<span class="hljs-string">&quot;/ajax_day2/test&quot;</span>);xhr.setRequestHeader(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>); xhr.send(<span class="hljs-string">&quot;name=zhangsan&quot;</span>);<span class="hljs-comment">//3.处理响应</span>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">if</span>(xhr.readyState==<span class="hljs-number">4</span> &amp;&amp; xhr.status==<span class="hljs-number">200</span>)&#123; <span class="hljs-built_in">console</span>.log(xhr.reponseText);&#125; &#125;</code></pre></div><h2 id="Ajax的数据交换机制"><a href="#Ajax的数据交换机制" class="headerlink" title="Ajax的数据交换机制"></a><strong>Ajax的数据交换机制</strong></h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210426110333170.png" alt="image-20210426110333170"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210426110704108.png" alt="image-20210426110704108"></p><h2 id="Ajax函数封装"><a href="#Ajax函数封装" class="headerlink" title="Ajax函数封装"></a><strong>Ajax函数封装</strong></h2><p>问题：发送一次请求代码过多，发送多次请求代码冗余且重复<br>解决方案：将请求代码封装到函数中，发请求时调用函数即可</p><p>利用回调函数</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210426112409636.png" alt="image-20210426112409636"></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span> (<span class="hljs-params">options</span>) </span>&#123;</span><span class="javascript"><span class="hljs-comment">// 存储的是默认值</span></span><span class="javascript"><span class="hljs-keyword">var</span> defaults = &#123;</span><span class="javascript">type: <span class="hljs-string">&#x27;get&#x27;</span>,</span><span class="javascript">url: <span class="hljs-string">&#x27;&#x27;</span>,</span>data: &#123;&#125;,header: &#123;<span class="javascript"><span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span></span>&#125;,<span class="javascript">success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,</span><span class="javascript">error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;</span>&#125;;<span class="javascript"><span class="hljs-comment">// 使用options对象中的属性覆盖defaults对象中的属性</span></span><span class="javascript"><span class="hljs-built_in">Object</span>.assign(defaults, options); <span class="hljs-comment">//options会覆盖defaults原有的属性</span></span><span class="javascript"><span class="hljs-comment">// 创建ajax对象</span></span><span class="javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><span class="javascript"><span class="hljs-comment">// 拼接请求参数的变量</span></span><span class="javascript"><span class="hljs-keyword">var</span> params = <span class="hljs-string">&#x27;&#x27;</span>;</span><span class="javascript"><span class="hljs-comment">// 循环用户传递进来的对象格式参数</span></span><span class="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> defaults.data) &#123;</span><span class="javascript"><span class="hljs-comment">// 将参数转换为字符串格式</span></span><span class="javascript">params += attr + <span class="hljs-string">&#x27;=&#x27;</span> + defaults.data[attr] + <span class="hljs-string">&#x27;&amp;&#x27;</span>;</span>&#125;<span class="javascript"><span class="hljs-comment">// 将参数最后面的&amp;截取掉 </span></span><span class="javascript"><span class="hljs-comment">// 将截取的结果重新赋值给params变量</span></span>params = params.substr(0, params.length - 1);<span class="javascript"><span class="hljs-comment">// 判断请求方式</span></span><span class="javascript"><span class="hljs-keyword">if</span> (defaults.type == <span class="hljs-string">&#x27;get&#x27;</span>) &#123;</span><span class="javascript">defaults.url = defaults.url + <span class="hljs-string">&#x27;?&#x27;</span> + params;</span>&#125;/*&#123;<span class="javascript">name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,</span>age: 20&#125;name=zhangsan&amp;age=20 */<span class="javascript"><span class="hljs-comment">// 配置ajax对象</span></span>xhr.open(defaults.type, defaults.url);<span class="javascript"><span class="hljs-comment">// 如果请求方式为post</span></span><span class="javascript"><span class="hljs-keyword">if</span> (defaults.type == <span class="hljs-string">&#x27;post&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 用户希望的向服务器端``传递的请求参数的类型</span></span><span class="javascript"><span class="hljs-keyword">var</span> contentType = defaults.header[<span class="hljs-string">&#x27;Content-Type&#x27;</span>]</span><span class="javascript"><span class="hljs-comment">// 设置请求参数格式的类型</span></span><span class="javascript">xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, contentType);</span><span class="javascript"><span class="hljs-comment">// 判断用户希望的请求参数格式的类型</span></span><span class="javascript"><span class="hljs-comment">// 如果类型为json</span></span><span class="javascript"><span class="hljs-keyword">if</span> (contentType == <span class="hljs-string">&#x27;application/json&#x27;</span>) &#123;</span><span class="javascript"><span class="hljs-comment">// 向服务器端传递json数据格式的参数</span></span><span class="javascript">xhr.send(<span class="hljs-built_in">JSON</span>.stringify(defaults.data))</span><span class="javascript">&#125;<span class="hljs-keyword">else</span> &#123;</span><span class="javascript"><span class="hljs-comment">// 向服务器端传递普通类型的请求参数</span></span>xhr.send(params);&#125;<span class="javascript">&#125;<span class="hljs-keyword">else</span> &#123;</span><span class="javascript"><span class="hljs-comment">// 发送请求</span></span>xhr.send();&#125;<span class="javascript"><span class="hljs-comment">// 监听xhr对象下面的onload事件</span></span><span class="javascript"><span class="hljs-comment">// 当xhr对象接收完响应数据后触发</span></span><span class="javascript">xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript"><span class="hljs-comment">// xhr.getResponseHeader()</span></span><span class="javascript"><span class="hljs-comment">// 获取响应头中的数据</span></span><span class="javascript"><span class="hljs-keyword">var</span> contentType = xhr.getResponseHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>);</span><span class="javascript"><span class="hljs-comment">// 服务器端返回的数据</span></span><span class="javascript"><span class="hljs-keyword">var</span> responseText = xhr.responseText;</span><span class="javascript"><span class="hljs-comment">// 如果响应类型中包含applicaition/json</span></span><span class="javascript"><span class="hljs-keyword">if</span> (contentType.includes(<span class="hljs-string">&#x27;application/json&#x27;</span>)) &#123;</span><span class="javascript"><span class="hljs-comment">// 将json字符串转换为json对象</span></span><span class="javascript">responseText = <span class="hljs-built_in">JSON</span>.parse(responseText)</span>&#125;<span class="javascript"><span class="hljs-comment">// 当http状态码等于200的时候</span></span>if (xhr.status == 200) &#123;<span class="javascript"><span class="hljs-comment">// 请求成功 调用处理成功情况的函数</span></span>defaults.success(responseText, xhr);<span class="javascript">&#125;<span class="hljs-keyword">else</span> &#123;</span><span class="javascript"><span class="hljs-comment">// 请求失败 调用处理失败情况的函数</span></span>defaults.error(responseText, xhr);&#125;&#125;&#125;        ajax(&#123;<span class="javascript">      type: <span class="hljs-string">&#x27;post&#x27;</span>,</span><span class="javascript">      url: <span class="hljs-string">&#x27;http://localhost:3000/responseData&#x27;</span>,</span><span class="javascript">      sucess:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is success&#x27;</span>);</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(data);</span>      &#125;    &#125;)    /*请求参数要考虑的问题1.请求参数位置的问题将请求参数传递到ajax函数内部, 在函数内部根据请求方式的不同将请求参数放置在不同的位置get 放在请求地址的后面post 放在send方法中2.请求参数格式的问题application/x-www-form-urlencoded参数名称=参数值&amp;参数名称=参数值name=zhangsan&amp;age=20application/json<span class="javascript">&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;</span>1.传递对象数据类型对于函数的调用者更加友好2.在函数内部对象数据类型转换为字符串数据类型更加方便*/<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="jQuery-中的-AJAX-请求"><a href="#jQuery-中的-AJAX-请求" class="headerlink" title="jQuery 中的 AJAX 请求"></a><strong>jQuery 中的 AJAX 请求</strong></h2><p><strong>ajax 方法</strong></p><ul><li>url 表示请求的地址</li><li>type 表示请求的类型 GET 或 POST 请求</li><li>data 表示发送给服务器的数据<ul><li>格式有两种：<div class="hljs code-wrapper"><pre><code>        一：name=value&amp;name=value          二：&#123;key:value&#125;</code></pre></div></li></ul></li></ul><p>success 请求成功，响应的回调函数</p><p><strong>dataType 响应的数据类型</strong></p><ul><li>text 表示纯文本</li><li>xml 表示 xml 数据</li><li>json 表示 json 对象</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#ajaxBtn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;$.ajax(&#123;url:<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;</span>,<span class="hljs-comment">// data:&quot;action=jQueryAjax&quot;,</span>data:&#123;<span class="hljs-attr">action</span>:<span class="hljs-string">&quot;jQueryAjax&quot;</span>&#125;,type:<span class="hljs-string">&quot;GET&quot;</span>,success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<span class="hljs-comment">// alert(&quot;服务器返回的数据是：&quot; + data);</span><span class="hljs-comment">// var jsonObj = JSON.parse(data);</span>$(<span class="hljs-string">&quot;#msg&quot;</span>).html(<span class="hljs-string">&quot;编号：&quot;</span> + data.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> + data.name);&#125;,dataType : <span class="hljs-string">&quot;json&quot;</span>&#125;);&#125;);</code></pre></div><p><code>$.get 方法</code>和<code>$.post 方法</code></p><ul><li>url 请求的 url 地址</li><li>data 发送的数据</li><li>callback 成功的回调函数</li><li>type 返回的数据类型</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ajax--get 请求</span>$(<span class="hljs-string">&quot;#getBtn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;$.get(<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;</span>,<span class="hljs-string">&quot;action=jQueryGet&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;$(<span class="hljs-string">&quot;#msg&quot;</span>).html(<span class="hljs-string">&quot; get 编号：&quot;</span> + data.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> + data.name);&#125;,<span class="hljs-string">&quot;json&quot;</span>);&#125;);<span class="hljs-comment">// ajax--post 请求</span>$(<span class="hljs-string">&quot;#postBtn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;$.post(<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;</span>,<span class="hljs-string">&quot;action=jQueryPost&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)</span><span class="hljs-function"></span>&#123;$(<span class="hljs-string">&quot;#msg&quot;</span>).html(<span class="hljs-string">&quot; post 编号：&quot;</span> + data.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> + data.name);&#125;,<span class="hljs-string">&quot;json&quot;</span>);&#125;);</code></pre></div><p><code>$.getJSON</code> 方法</p><ul><li>url 请求的 url 地址</li><li>data 发送给服务器的数据</li><li>callback 成功的回调函数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ajax--getJson 请求</span>$(<span class="hljs-string">&quot;#getJSONBtn&quot;</span>).click(function()&#123;$.getJSON(<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;</span>,<span class="hljs-string">&quot;action=jQueryGetJSON&quot;</span>,function(data) &#123;$(<span class="hljs-string">&quot;#msg&quot;</span>).html(<span class="hljs-string">&quot; getJSON 编号：&quot;</span> + data.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> + data.name);&#125;);&#125;);</code></pre></div><p>表单序列化 serialize() serialize()可以把表单中所有表单项的内容都获取到，并以 name=value&amp;name=value 的形式进行拼接。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ajax 请求</span>$(<span class="hljs-string">&quot;#submit&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">// 把参数序列化</span>$.getJSON(<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;</span>,<span class="hljs-string">&quot;action=jQuerySerialize&amp;&quot;</span> +$(<span class="hljs-string">&quot;#form01&quot;</span>).serialize(),<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;$(<span class="hljs-string">&quot;#msg&quot;</span>).html(<span class="hljs-string">&quot; Serialize 编号：&quot;</span> + data.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> + data.name);&#125;);&#125;);</code></pre></div><h1 id="十二、Axios"><a href="#十二、Axios" class="headerlink" title="十二、Axios"></a>十二、Axios</h1><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># axios的引言</span><span class="hljs-code">Axios 是一个  异步请求 技术</span><span class="hljs-code"></span><span class="hljs-code"># 异步请求</span><span class="hljs-code">基于XMLHttpRequest对象发起的请求都是异步请求</span><span class="hljs-code"></span><span class="hljs-code"># 异步请求特点</span><span class="hljs-code">请求之后页面不动,响应回来更新的是页面的局部,多个请求之间互不影响,并行执行</span><span class="hljs-code">ajax确实用来发送异步请求,ajax过气  </span><span class="hljs-code">系统架构 前后端分离架构系统 ---- 异步请求技术-----&gt; Vue 全家桶系列 前端技术端  Vue  淘汰了jQuery </span></code></pre></div><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h2 id="GET方式请求"><a href="#GET方式请求" class="headerlink" title="GET方式请求"></a>GET方式请求</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--引入axios的相关依赖--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">      <span class="hljs-comment">//get方式请求</span></span><span class="javascript">      axios.get(<span class="hljs-string">&#x27;http://localhost:8888/axios/findAll?username=zhangsan&amp;password=123&#x27;</span>)<span class="hljs-comment">//发送请求的url</span></span><span class="javascript">          .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>&#123;</span><span class="javascript">              <span class="hljs-built_in">console</span>.log(response.data);</span><span class="javascript">          &#125;)<span class="hljs-comment">//响应回来触发的回调函数</span></span><span class="javascript">          .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123; <span class="hljs-comment">//当请求出现错误时回调函数</span></span><span class="javascript">              <span class="hljs-built_in">console</span>.log(err);</span>          &#125;);  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h2 id="POST方式的请求"><a href="#POST方式的请求" class="headerlink" title="POST方式的请求"></a>POST方式的请求</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--引入axios的相关依赖--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">       <span class="hljs-comment">//post请求</span></span><span class="javascript">       axios.post(<span class="hljs-string">&#x27;http://localhost:8888/axios/save&#x27;</span>,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">23</span>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span><span class="javascript">           <span class="hljs-built_in">console</span>.log(response.data);</span><span class="javascript">       &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;</span><span class="javascript">           <span class="hljs-built_in">console</span>.log(err);</span>       &#125;);   <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p><strong>总结</strong></p><ol><li>axios在发送post方式的请求时传递的参数如果为对象类型,axios会自动将对象转为json格式的字符串使用 application/json的请求头向后端服务接口传递参数</li><li>axios的post请求传递参数的两种方式:</li><li>第一种使用字符串进行参数传递: “name=zhangsan&amp;age=23” 这种形式</li><li>第二种方式后端接口直接使用<code>@RequestBody</code>注解形式接收参数: </li><li>发送get跟post时，发送参数名称要跟接受参数名称保持一致（如果是对象的话，则跟对象属性的名称保持一致）</li></ol><h2 id="Axios的并发请求"><a href="#Axios的并发请求" class="headerlink" title="Axios的并发请求"></a>Axios的并发请求</h2><p>在同一时间发送多个不同的请求到后端服务,最后同一处理不同服务的响应结果</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--引入axios的相关依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-comment">//并发请求: 在同一时间发送多个不同的请求到后端服务,最后同一处理不同服务的响应结果</span></span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findAll</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">        <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">&quot;http://localhost:8888/axios/findAll?username=xiaochen&amp;password=123&quot;</span>);</span>    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">        <span class="hljs-keyword">return</span> axios.post(<span class="hljs-string">&#x27;h tp://localhost:8888/axios/save&#x27;</span>,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaosun&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">23</span>&#125;)</span>    &#125;<span class="javascript">    <span class="hljs-comment">//并行发送</span></span>    axios.all([findAll(),save()]).then(<span class="javascript">        axios.spread(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result1,result2</span>)</span>&#123;</span><span class="javascript">            <span class="hljs-built_in">console</span>.log(result1.data);</span><span class="javascript">            <span class="hljs-built_in">console</span>.log(result2.data);</span><span class="javascript">        &#125;)<span class="hljs-comment">//用来统一处理多个并发请求的执行结果</span></span><span class="javascript">    );<span class="hljs-comment">//all用来处理并发请求</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p><strong>总结</strong></p><ol><li>针对于并发请求需要用到<code>axios.all()</code>函数来完成并发请求的处理</li><li>针对于并发请求的结果汇总需要使用<code>axios.spread()</code>函数来统一汇总请求结果</li></ol><h2 id="Axios的高级使用配置对象"><a href="#Axios的高级使用配置对象" class="headerlink" title="Axios的高级使用配置对象"></a>Axios的高级使用配置对象</h2><p><strong>配置对象</strong></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;  <span class="hljs-comment">// `url` 是用于请求的服务器 URL</span>  url: <span class="hljs-string">&#x27;/user&#x27;</span>,  <span class="hljs-comment">// `method` 是创建请求时使用的方法</span>  method: <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-comment">// 默认是 get</span>  <span class="hljs-comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span>  <span class="hljs-comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span>  baseURL: <span class="hljs-string">&#x27;htt ps://some-domain.com/api/&#x27;</span>,  <span class="hljs-comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span>  <span class="hljs-comment">// 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span>  <span class="hljs-comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span>  transformRequest: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;    <span class="hljs-comment">// 对 data 进行任意转换处理</span>    <span class="hljs-keyword">return</span> data;  &#125;],  <span class="hljs-comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span>  transformResponse: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;    <span class="hljs-comment">// 对 data 进行任意转换处理</span>    <span class="hljs-keyword">return</span> data;  &#125;],  <span class="hljs-comment">// `headers` 是即将被发送的自定义请求头</span>  headers: &#123;<span class="hljs-string">&#x27;X-Requested-With&#x27;</span>: <span class="hljs-string">&#x27;XMLHttpRequest&#x27;</span>&#125;,  <span class="hljs-comment">// `params` 是即将与请求一起发送的 URL 参数</span>  <span class="hljs-comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span>  params: &#123;    ID: <span class="hljs-number">12345</span>  &#125;,  <span class="hljs-comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span>  <span class="hljs-comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>  paramsSerializer: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params</span>) </span>&#123;    <span class="hljs-keyword">return</span> Qs.stringify(params, &#123;<span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">&#x27;brackets&#x27;</span>&#125;)  &#125;,  <span class="hljs-comment">// `data` 是作为请求主体被发送的数据</span>  <span class="hljs-comment">// 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27;</span>  <span class="hljs-comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span>  <span class="hljs-comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>  <span class="hljs-comment">// - 浏览器专属：FormData, File, Blob</span>  <span class="hljs-comment">// - Node 专属： Stream</span>  data: &#123;    firstName: <span class="hljs-string">&#x27;Fred&#x27;</span>  &#125;,  <span class="hljs-comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span>  <span class="hljs-comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span>  timeout: <span class="hljs-number">1000</span>,  <span class="hljs-comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span>  withCredentials: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 默认的</span>  <span class="hljs-comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span>  <span class="hljs-comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span>  adapter: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>&#123;    <span class="hljs-comment">/* ... */</span>  &#125;,  <span class="hljs-comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span>  <span class="hljs-comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span>  auth: &#123;    username: <span class="hljs-string">&#x27;janedoe&#x27;</span>,    password: <span class="hljs-string">&#x27;s00pers3cret&#x27;</span>  &#125;,  <span class="hljs-comment">// `responseType` 表示服务器响应的数据类型，可以是 &#x27;arraybuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span>  responseType: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-comment">// 默认的</span>  <span class="hljs-comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span>  xsrfCookieName: <span class="hljs-string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span>  xsrfHeaderName: <span class="hljs-string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="hljs-comment">// 默认的</span>  <span class="hljs-comment">// `onUploadProgress` 允许为上传处理进度事件</span>  onUploadProgress: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>&#123;    <span class="hljs-comment">// 对原生进度事件的处理</span>  &#125;,  <span class="hljs-comment">// `onDownloadProgress` 允许为下载处理进度事件</span>  onDownloadProgress: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>&#123;    <span class="hljs-comment">// 对原生进度事件的处理</span>  &#125;,  <span class="hljs-comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span>  maxContentLength: <span class="hljs-number">2000</span>,  <span class="hljs-comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span>  validateStatus: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) </span>&#123;    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-comment">// 默认的</span>  &#125;,  <span class="hljs-comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span>  <span class="hljs-comment">// 如果设置为0，将不会 follow 任何重定向</span>  maxRedirects: <span class="hljs-number">5</span>, <span class="hljs-comment">// 默认的</span>  <span class="hljs-comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span>  <span class="hljs-comment">// `keepAlive` 默认没有启用</span>  httpAgent: <span class="hljs-keyword">new</span> http.Agent(&#123; <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> &#125;),  httpsAgent: <span class="hljs-keyword">new</span> https.Agent(&#123; <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> &#125;),  <span class="hljs-comment">// &#x27;proxy&#x27; 定义代理服务器的主机名称和端口</span>  <span class="hljs-comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span>  <span class="hljs-comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span>  proxy: &#123;    host: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,    port: <span class="hljs-number">9000</span>,    auth: : &#123;      username: <span class="hljs-string">&#x27;mikeymike&#x27;</span>,      password: <span class="hljs-string">&#x27;rapunz3l&#x27;</span>    &#125;  &#125;,  <span class="hljs-comment">// `cancelToken` 指定用于取消请求的 cancel token</span>  <span class="hljs-comment">// （查看后面的 Cancellation 这节了解更多）</span>  cancelToken: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cancel</span>) </span>&#123;  &#125;)&#125;</code></pre></div><p><strong>使用配置对象形式发送请求</strong></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"> <span class="hljs-keyword">var</span> instance = axios.create(&#123;   method:<span class="hljs-string">&quot;GET&quot;</span>,   baseURL:<span class="hljs-string">&quot;http://localhost:8888&quot;</span>,   data:&#123;  <span class="hljs-comment">//作为请求体发送的数据,只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27;</span>   &#125; &#125;);instance.get(<span class="hljs-string">&quot;/axios/findAll?username=zhangsan&quot;</span>);</code></pre></div><p><strong>Axios的Restful风格的API</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># Axios的API总结</span>  axios.request(config)  axios.get(url[, config])  axios.delete(url[, config])  axios.head(url[, config])  axios.post(url[, data[, config]])  axios.put(url[, data[, config]])  axios.patch(url[, data[, config]])<span class="hljs-section"># NOTE:</span><span class="hljs-code">在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java开发所需的Linux环境配置</title>
    <link href="/2021/07/16/Linux/"/>
    <url>/2021/07/16/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux环境配置"><a href="#Linux环境配置" class="headerlink" title="Linux环境配置"></a>Linux环境配置</h1><blockquote><p>本文主要讲解在Linux环境下的Java开发环境搭建，包含各种常用软件的安装步骤以及基础的Linux知识</p></blockquote><h1 id="安装Centos"><a href="#安装Centos" class="headerlink" title="安装Centos"></a>安装Centos</h1><p>因为开发中只需用得到命令行操作，所以只需要安装Minimal版本</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506161400598.png" alt="image-20210506161400598"></p><p>进行配置</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506162907224.png" alt="image-20210506162907224"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506163217156.png" alt="image-20210506163217156"></p><p>安装完成后重启即可</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506164209130.png" alt="image-20210506164209130"></p><p>重启后来到登录界面，输入账号密码即可登录</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506164333914.png" alt="image-20210506164333914"></p><h1 id="Linux基础知识"><a href="#Linux基础知识" class="headerlink" title="Linux基础知识"></a>Linux基础知识</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506164621687.png" alt="image-20210506164621687"></p><ul><li>bin  (binaries)存放二进制可执行文件                                                                                                    [重点]</li><li>sbin  (super user binaries)存放二进制可执行文件，只有root才能访问</li><li>etc (etcetera)存放系统配置文件                                                                                                                [重点]</li><li>usr  (unix shared resources)用于存放共享的系统资源                                                                  [重点]</li><li>home 存放用户文件的根目录                                                                                                                    [重点]</li><li>root  超级用户目录                                                                                                                                         [重点]</li><li>dev (devices)用于存放设备文件</li><li>lib  (library)存放跟文件系统中的程序运行所需要的共享库及内核模块</li><li>mnt  (mount)系统管理员安装临时文件系统的安装点</li><li>boot 存放用于系统引导时使用的各种文件</li><li>tmp  (temporary)用于存放各种临时文件                                                                                             [重点]</li><li>var  (variable)用于存放运行时需要改变数据的文件</li></ul><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><blockquote><p>注意:在linux中命令严格区分大小写</p></blockquote><h3 id="显示文件和目录列表-list"><a href="#显示文件和目录列表-list" class="headerlink" title="显示文件和目录列表    (list)"></a>显示文件和目录列表    (list)</h3><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">ls 常用参数:</span>  -l (long) 长格式显示文件和目录信息-a (all) 显示所有文件和目录(包含隐藏文件和目录)-R         递归显示指定目录下的文件清单，即会显示指定目录分支内各子目录中的文件清单。</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3.ls%20-l%E9%95%BF%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.png" alt="3.ls -l长格式说明"></p><h3 id="操作文件命令-重点"><a href="#操作文件命令-重点" class="headerlink" title="操作文件命令[重点]"></a>操作文件命令[重点]</h3><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 0.cd 用来切换目录</span><span class="hljs-meta">#</span><span class="bash"> 1.pwd 显示当前工作目录（<span class="hljs-built_in">print</span> working directory）</span><span class="hljs-meta">#</span><span class="bash"> 2.touch 创建空文件</span> <span class="hljs-meta">#</span><span class="bash"> 3.mkdir 创建目录（make directoriy）</span>-p 父目录不存在情况下先生成父目录 （parents）            <span class="hljs-meta">#</span><span class="bash"> 4.cp 复制文件或目录（copy）</span>      cp  文件名    目录   复制文件到指定目录中      cp  -r 目录名    目录   复制指定目录到指定目录中-r 递归处理，将指定目录下的文件与子目录一并拷贝（recursive）     <span class="hljs-meta">#</span><span class="bash"> 5.mv 移动文件或目录、文件或目录改名（move）</span>mv 文件名    新文件名      文件改名mv 文件名    目录名     文件移动mv 目录名    不存在目录名  目录改名         mv 目录名  已存在目录名  目录移动<span class="hljs-meta">#</span><span class="bash"> 6.rm 删除文件（remove）</span>-r 同时删除该目录下的所有文件（recursive）-f 强制删除文件或目录（force）<span class="hljs-meta">#</span><span class="bash"> 7.rmdir 删除空目录（remove directoriy）</span><span class="hljs-meta">#</span><span class="bash"> 8.cat 显示文本文件内容 （catenate） 用来展示少量内容</span><span class="hljs-meta">#</span><span class="bash"> 9.more、less 分页显示文本文件内容   退出用q退出</span><span class="hljs-meta">#</span><span class="bash"> 10.head、tail查看文本中开头或结尾部分的内容</span>head  -n  5  a.log 查看a.log文件的前5行<span class="hljs-meta">#</span><span class="bash"> 11.tail  -f  b.log 循环读取（fellow）</span><span class="hljs-meta">#</span><span class="bash"> 12.echo 输出命令</span>echo   I love baby说明:用来向屏幕输出一句话echo I Love baby  &gt;&gt;  aa.txt说明:将这段内容输入到文件中<span class="hljs-meta">#</span><span class="bash"> 13.查看文件</span>find -name xxxwhereis xx显示xx的位置which xx显示xx的完整路径</code></pre></div><h3 id="查看相关命令"><a href="#查看相关命令" class="headerlink" title="查看相关命令"></a>查看相关命令</h3><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.ip addr 查看IP地址</span>ip a  简化写法<span class="hljs-meta">#</span><span class="bash"> 2.ping 测试网络连通性</span>ping 192.168.0.1<span class="hljs-meta">#</span><span class="bash"> 3.查看Linux中网络系统状态信息</span>netstat<span class="hljs-meta">#</span><span class="bash"> 4.显示内存的使用情况</span>free<span class="hljs-meta">#</span><span class="bash"> 5.显示磁盘的相关信息</span>df<span class="hljs-meta">#</span><span class="bash"> 6.</span></code></pre></div><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><div class="hljs code-wrapper"><pre><code class="hljs shell"> -c 建立一个压缩文件的参数指令（create）-x 解开一个压缩文件的参数指令（extract）-z 是否需要用 gzip 压缩  -v 压缩的过程中显示文件（verbose）-f 使用档名，在 f 之后要立即接档名（file）`通常组合使用:`tar -cvf aaa.tar file1.txt file2.txt 将file1和2打包成aaa.tartar -zcvf aaa.tar.gz file1.txt file2.txt 将file1和2打包成aaa.tar并压缩tar -zxvf aaa.tar.gz file1.txt file2.txt 将aaa.tar.gz解压</code></pre></div><h3 id="systemctl-服务命令"><a href="#systemctl-服务命令" class="headerlink" title="systemctl 服务命令"></a>systemctl 服务命令</h3><div class="hljs code-wrapper"><pre><code class="hljs shell"> systemctl status|start|stop|restart 服务名  mysqld firewalld(防火墙) network(网络)systemctl status 服务名          说明:查看某个服务的运行状态systemctl start 服务名 说明:启动某个服务systemctl restart 服务名 说明:重启某个服务systemctl stop 服务名 说明:停止某个服务</code></pre></div><h3 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h3><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.ps 询在当前控制台上运行的进程</span>ps  -aux   说明:查询系统中所有运行的进程，包括后台进程，其中参数a是所有进程，参数x包括不占用控制台的进程，参数u显示用户。ps  -ef 说明:查询系统中所有运行的进程，包括后台进程，而且可以显示出每个进程的父进程号。    ps -aux|grep 进程/服务名/关键字/tomcat  [重点]    <span class="hljs-meta">#</span><span class="bash"> 2.top命令  动态显示系统进程</span><span class="hljs-meta">#</span><span class="bash"> 3.kill 杀死进程</span>kill  3029 说明：上述命令中3029是进程号；一般在执行kill命令之前，先用ps或pstree来查询一下将要被杀掉的进程的进程号。 kill  -9  3029 说明:强制终止3029号进程的运行，其中参数-9代表强制的意思,实际上kill命令是向该进程发送信号，该进程接到信号后决定是否停止运行，有些守护进程必须要收到参数9才终止运行。</code></pre></div><h3 id="vi命令"><a href="#vi命令" class="headerlink" title="vi命令"></a>vi命令</h3><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506185857940.png" alt="image-20210506185857940"></p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 常用命令:</span>i在光标前插入 I在光标当前行开始插入 a在光标后插入 A在光标当前行末尾插入 o在光标当前行的下一行插入新行 O在光标当前行的上一行插入新行 ----------------重点--------------------------- :set nu显示行号 :set nonu取消行号 :set paste  粘贴文本 dd 快速删除当前行 gg到文本的第一行 G到文本的最后一行 :n到文本的第n行 ------------------重点------------------------- uundo,取消上一步操作 Ctrl + rredo,返回到undo之前  -------------------重点------------------------ Shift+ zz保存退出，与“:wq”作用相同:q退出不保存:q!强制退出不保存:wq保存退出:wq!强制保存退出</code></pre></div><h3 id="软件相关命令"><a href="#软件相关命令" class="headerlink" title="软件相关命令"></a>软件相关命令</h3><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> rpm 命令</span>  常用参数:      i：安装应用程序（install）      e：卸载应用程序（erase）      vh：显示安装进度；（verbose   hash）       U：升级软件包；（update）       qa: 显示所有已安装软件包（query all）例子：rmp  -ivh  gcc-c++-4.4.7-3.el6.x86_64.rpm安装 rpm -ivh  xxxx.rpm    rpm -evh  xxxx.rpm    rpm -Uvh  xxx.rpm    rpm -qa     <span class="hljs-meta">#</span><span class="bash"> yum 命令</span>`使用YUM命令必须连接外部网络`    例子：    yum  install  gcc-c++    yum  remove   gcc-c++    yum  update   gcc-c++        yum install|remove|update  依赖名称</code></pre></div><h3 id="用户和组相关命令"><a href="#用户和组相关命令" class="headerlink" title="用户和组相关命令"></a>用户和组相关命令</h3><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.查看当前用户：whoami</span><span class="hljs-meta">#</span><span class="bash"> 2.查看登录用户：who</span>-m或am I只显示运行who命令的用户名、登录终端和登录时间-q或--count只显示用户的登录账号和登录用户的数量<span class="hljs-meta">#</span><span class="bash"> 3.退出用户:<span class="hljs-built_in">exit</span></span><span class="hljs-meta">#</span><span class="bash"> 4.添加、删除组账号：groupadd、groupdel</span><span class="hljs-meta">#</span><span class="bash"> 5.添加用户账号：useradd</span>-g指定组名称  说明:如果创建用户的时候，不指定组名，那么系统会自动创建一个和用户名一样的组名。<span class="hljs-meta">#</span><span class="bash"> 6.设置用户密码：passwd　[用户名]</span><span class="hljs-meta">#</span><span class="bash"> 7.su 切换用户</span>su  root</code></pre></div><h3 id="权限相关命令"><a href="#权限相关命令" class="headerlink" title="权限相关命令"></a>权限相关命令</h3><blockquote><p>Linux文件有三种典型的权限，<code>即r读权限、w写权限和x执行权限</code>。在长格式输出中在文件类型的后面有9列权限位，实际上这是针对不同用户而设定的。<code>r=4，w=2，x=1</code></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> chmod</span>   all = user + group + other   chmod  u+rwx,g+rwx,o+rwx   文件名字母法：chmod u/g/o/a +/-/= rwx 文件    [ u/g/o/a ]含义    uuser 表示该文件的所有者    ggroup 表示与该文件的所有者属于同一组( group )者，即用户组    oother 表示其他以外的人    aall 表示这三者皆是    [ +-= ]含义    +增加权限    -撤销权限    =设定权限    rwx含义    rread 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容。    wwrite 表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新的文件。    xexcute 表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录。      数字法:   4读 2写  1执行      chmod 777 文件名</code></pre></div><h1 id="CRT配置"><a href="#CRT配置" class="headerlink" title="CRT配置"></a>CRT配置</h1><p><strong>设置linux获取ip地址 (编辑网络配置文件)</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506194238775.png" alt="image-20210506194238775"></p><p><strong>修改ens33配置文件:</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">BOOTPROTO=dhcpONBOOT=yes</code></pre></div><p><strong>重启启动网路服务加载修改配置生效</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">systemctl restart network</code></pre></div><p><strong>查看ip地址</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">ip addr</code></pre></div><p><strong>此时ip已经获取</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506194647423-0301639.png" alt="image-20210506194647423"></p><p><strong>测试外部网络连通(保证宿主机可以上网前提)</strong></p><div class="hljs code-wrapper"><pre><code>    ping www.baidu.com</code></pre></div><p><strong>使用CRT工具连接即可</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506202557475.png" alt="image-20210506202557475"></p><h1 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h1><p>为了方便使用，在开始配置之前，利用命令<code>yum install vim</code>安装vim</p><p><strong>同样重要的功能，快照</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506210740915.png" alt="image-20210506210740915"></p><p>能记录当前虚拟机的状态，以便恢复到记录的时刻防止意外发生</p><p>然后利用FTP工具上传JDK安装包到Linux中</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506203930036.png" alt="image-20210506203930036"></p><p>安装到<code>usr</code>目录下</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506204006667.png" alt="image-20210506204006667"></p><p>在解压后到jdk的<code>bin</code>目录下查看java版本</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506204318398.png" alt="image-20210506204318398"></p><p>配置环境变量</p><div class="hljs code-wrapper"><pre><code class="hljs shell">vim /etc/profile<span class="hljs-meta">#</span><span class="bash">在文件末尾加入如下配置</span>export JAVA_HOME=/usr/jdk1.8.0_202export PATH=$PATH:$JAVA_HOME/bin<span class="hljs-meta">#</span><span class="bash"> 加载配置生效</span>source /etc/profile    加载配置生效reboot                 重启系统<span class="hljs-meta">#</span><span class="bash">注意: 以上两个选项选择任意一个即可<span class="hljs-built_in">source</span>可以不用重启立即生效,某些情况下<span class="hljs-built_in">source</span>无法生效时,可以使用重启试试</span></code></pre></div><p>此时配置成功</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506205050362.png" alt="image-20210506205050362"></p><p>也可以使用<code>rpm</code>命令安装</p><div class="hljs code-wrapper"><pre><code class="hljs shell">rpm -ivh jdk-8u202-linux-x64.rpm <span class="hljs-meta">#</span><span class="bash">然后搜索rpm的安装位置</span>whereis java<span class="hljs-meta">#</span><span class="bash">或者</span>find / -name &quot;java&quot;<span class="hljs-meta">#</span><span class="bash">默认在/usr/java/下</span></code></pre></div><p>然后同理于上面tar安装的步骤，配置环境后即可</p><h1 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h1><p><strong>准备工作</strong></p><p>同理上传到<code>usr</code>目录下并解压</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506211109844.png" alt="image-20210506211109844"></p><p><strong>启动tomcat</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">./bin/startup.sh</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506211749770.png" alt="image-20210506211749770"></p><p><strong>查看Tomcat是否启动</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506212029242.png" alt="image-20210506212029242"></p><p>使用<code>ps</code>或者<code>jps</code>两个命令都可以查看</p><p><strong>关闭网络防火墙</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> systemctl stop firewalld   关闭网络防火墙</span><span class="hljs-meta">$</span><span class="bash"> systemctl <span class="hljs-built_in">disable</span> firewalld  关闭开机自启动(永久关闭)</span></code></pre></div><p><strong>访问tomcat</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">http://172.16.211.4:8080</code></pre></div><p>在<code>/conf/server.xml</code>下可以修改端口号</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506212608053.png" alt="image-20210506212608053"></p><p><strong>显示tomcat实时控制台信息（）</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">进入tomcat的logs目录中使用tail -f catalina.out 命令实时查看控制台信息</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210506212757867.png" alt="image-20210506212757867"></p><p><strong>关闭tomcat</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">在tomcat的bin目录下面使用 ./shutdown.sh</code></pre></div><p>此刻Tomcat已经在Linux部署完毕，来测试一下在Linux部署SpringBoot</p><p>需要注意以jsp作为模板时候的问题，但不推荐以jps作为模板使用</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/11.%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%ADjar%E5%8C%85%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2springboot.png" alt="11.在linux系统中jar包方式部署springboot"></p><h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1><p><strong>准备工作</strong></p><ul><li>卸载mariadb，否则安装mysql会出现冲突</li><li>执行命令<code>rpm -qa | grep mariadb</code></li><li>列出所有被安装的mariadb rpm 包；</li><li>执行命令<code>rpm -e --nodeps mariadb-libs-5.5.xx-x.el7.x86_64</code>卸载</li></ul><p><strong>开始安装</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.添加官方的yum源创建并编辑mysql-community.repo文件</span><span class="hljs-code">vi /etc/yum.repos.d/mysql-community.repo</span><span class="hljs-code"># 2.粘贴以下内容到源文件中</span><span class="hljs-code">[mysql56-community]</span><span class="hljs-code">    name=MySQL 5.6 Community Server</span><span class="hljs-code">    baseurl=http://repo.mysql.com/yum/mysql-5.6 -community/el/7/$basearch/</span><span class="hljs-code">    enabled=1</span><span class="hljs-code">    gpgcheck=0</span><span class="hljs-code">    gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><span class="hljs-code">    </span><span class="hljs-code">   #注意:如果需要安装mysql5.7只需要将baseurl修改即可 </span><span class="hljs-code">    baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/</span><span class="hljs-code"></span><span class="hljs-code"># 3.安装mysql</span><span class="hljs-code">sudo yum install -y mysql-community-server</span></code></pre></div><p><strong>启动与登录</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.启动mysql数据库</span>systemctl start mysqld<span class="hljs-section"># 2.修改mysql数据库密码</span>mysqladmin -u root -p password 回车 输入原始密码 在输入新的密码<span class="hljs-section">#注意:5.7之前版本安装完成之后没有密码,mysql5.7之后的版本的初始密码是随机生成的，放在了 /var/log/mysqld.log</span><span class="hljs-section">#使用命令 grep ‘temporary password’ /var/log/mysqld.log 读出来即可</span><span class="hljs-section"># 5.7开始mysql不支持简单密码，使用Root!123</span><span class="hljs-section"># 3.登录mysql</span>mysql -u root -p</code></pre></div><p><strong>目录</strong></p><p>数据库文件的存放路径在<code>/var/lib/mysql</code></p><p>5.7版本的配置文件在<code>/usr/etc/my.cnf</code></p><p>相关命令目录在<code>/usr/bin</code></p><p><strong>配置文件</strong></p><p>在<code>my.cnf</code>下添加</p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 修改字符集</span>[mysqld]character-set-server=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8</code></pre></div><p>重启mysql，可以发现</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210508172907727.png" alt="image-20210508172907727"></p><p><strong>开启远程访问</strong></p><p>开启授权，让所有机器都可访问，在配置主从机的时候同样适用</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210507160110862.png" alt="image-20210507160110862"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210507160339587.png" alt="image-20210507160339587"></p><p><strong>已经连接成功</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210507160436771.png" alt="image-20210507160436771"></p><h1 id="安装MyCat"><a href="#安装MyCat" class="headerlink" title="安装MyCat"></a>安装MyCat</h1><blockquote><p>实现读写分离的中间件，也是MySQL常用的软件</p></blockquote><p><strong>准备工作</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.下载mycat</span><span class="hljs-code">http://dl.mycat.io/1.6-RELEASE/Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz</span><span class="hljs-code"></span><span class="hljs-code"># 2.解压mycat</span><span class="hljs-code">tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191014225929256.png" alt="image-20191014225929256"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 3.查看解压之后目录]</span><span class="hljs-code">[root@localhost mycat]# ls</span><span class="hljs-code">总用量 12</span><span class="hljs-code">drwxr-xr-x. 2 root root  190 10月 14 22:58 bin</span><span class="hljs-code">drwxrwxrwx. 2 root root    6 3月   1 2016 catlet</span><span class="hljs-code">drwxrwxrwx. 4 root root 4096 10月 14 22:58 conf</span><span class="hljs-code">drwxr-xr-x. 2 root root 4096 10月 14 22:58 lib</span><span class="hljs-code">drwxrwxrwx. 2 root root    6 10月 28 2016 logs</span><span class="hljs-code">-rwxrwxrwx. 1 root root  217 10月 28 2016 version.txt</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191014230002014.png" alt="image-20191014230002014"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 4.移动到/usr目录</span><span class="hljs-code">mv mycat/ /usr/</span><span class="hljs-code"></span><span class="hljs-code"># 5.配置mycat中conf下的配置schema.xml</span><span class="hljs-code">先删除原有的内容，加入以下配置</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--定义MyCat的逻辑库  dataNode表示映射的真实节点--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test_schema&quot;</span> <span class="hljs-attr">checkSQLschema</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">sqlMaxLimit</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;testNode&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span> <span class="hljs-comment">&lt;!--定义MyCat的数据节点 name与dataNode一致，dataHost映射真实主机，database映射真实的库--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;testNode&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;dtHost&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;test&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!--定义数据主机 name和dataHost一致   --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dtHost&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;1&quot;</span>     <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span> <span class="hljs-attr">switchType</span>=<span class="hljs-string">&quot;-1&quot;</span>     <span class="hljs-attr">slaveThreshold</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!--心跳配置   --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user()<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span>                <span class="hljs-comment">&lt;!--写节点--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostM1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;192.168.28.128:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span><span class="hljs-attr">password</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>                 <span class="hljs-comment">&lt;!--从节点--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">readHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;hostS1&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;192.168.28.129:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 6.配置登陆mycat的权限server.xml</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">system</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 这里配置的都是一些系统属性，可以自己查看mycat文档--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultSqlParser&quot;</span>&gt;</span>druidparser<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-comment">&lt;!--5.xx必须是utf-8，8.xx为utf8mb4   --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;charset&quot;</span>&gt;</span>utf8<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">system</span>&gt;</span><span class="hljs-comment">&lt;!--配置用户信息--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-comment">&lt;!--指定可以操作的逻辑库--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;schemas&quot;</span>&gt;</span>test_schema<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 7.在bin目录下启动mycat</span><span class="hljs-code"> ./mycat console</span><span class="hljs-code"></span><span class="hljs-code"># 8.查看日志</span><span class="hljs-code">tail -f ../logs/mycat.log</span><span class="hljs-code"></span><span class="hljs-code"># 9.数据库连接配置,测试</span></code></pre></div><h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 下载Nginx</span>   wget http://nginx.org/download/nginx-1.17.0.tar.gz<span class="hljs-section"># 然后解压下载的目录，进入解压目录中，在编译安装之前，需要安装两个依赖：</span><span class="hljs-code"> yum -y install pcre-devel</span><span class="hljs-code"> yum -y install openssl openssl-devel</span><span class="hljs-code"></span><span class="hljs-code"># 然后开始编译安装：</span><span class="hljs-code">./configure</span><span class="hljs-code">make</span><span class="hljs-code">make install</span><span class="hljs-code"></span><span class="hljs-code"># 装好之后，默认安装位置在:</span><span class="hljs-code">/usr/local/nginx/sbin/nginx</span><span class="hljs-code"></span><span class="hljs-code"># 启动nginx,进入nginx安装目录的sbin目录中执行:</span><span class="hljs-code">./nginx</span><span class="hljs-code">ps -aux|grep nginx</span><span class="hljs-code"></span><span class="hljs-code"># 浏览器访问,可以看到nginx欢迎页面:</span><span class="hljs-code">http://172.16.211.4:80/</span><span class="hljs-code">注意:关闭网络防火墙</span><span class="hljs-code"></span><span class="hljs-code"># 关闭nginx,进入nginx安装目录的sbin目录中执行:</span><span class="hljs-code">./nginx -s stop</span><span class="hljs-code"></span><span class="hljs-code"># 1nginx配置文件在nginx安装目录的conf目录中:</span><span class="hljs-code">[root@localhost conf]# ls -l</span><span class="hljs-code">总用量 60</span><span class="hljs-code">-rw-r--r--. 1 root root 2656 10月 14 21:17 nginx.conf</span><span class="hljs-code">.......</span><span class="hljs-code">注意:nginx.conf为nginx的配置文件,可以在nginx.conf修改nginx默认配置</span></code></pre></div><h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 0.准备环境</span><span class="hljs-bullet">-</span> vmware15.x+<span class="hljs-bullet">-</span> centos7.x+<span class="hljs-section"># 1.下载redis源码包</span><span class="hljs-bullet">-</span> https://redis.io/</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623121621195.png" alt="image-20200623121621195"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 2.下载完整源码包</span><span class="hljs-bullet">-</span> redis-4.0.10.tar.gz</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200623123918876.png" alt="image-20200623123918876"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 3.将下载redis资料包上传到Linux中</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210511115817995.png" alt="image-20210511115817995"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 4.解压缩文件</span>[root@localhost ~]# tar -zxvf redis-4.0.10.tar.gz[root@localhost ~]# ll</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210511115856761.png" alt="image-20210511115856761"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 5.安装gcc  </span><span class="hljs-bullet">-</span> yum install -y gcc<span class="hljs-section"># 6.进入解压缩目录执行如下命令</span><span class="hljs-bullet">-</span> make MALLOC=libc<span class="hljs-section"># 7.编译完成后执行如下命令</span><span class="hljs-bullet">-</span> make install PREFIX=/usr/redis<span class="hljs-section"># 8.进入/usr/redis目录启动redis服务 </span><span class="hljs-bullet">-</span> ./redis-server</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210511120413476.png" alt="image-20210511120413476"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 9.Redis服务端口默认是 6379</span><span class="hljs-section"># 10.进入bin目录执行客户端连接操作</span><span class="hljs-bullet">-</span>  ./redis-cli -h localhost -p 6379 <span class="hljs-bullet">-</span>  因为是本机，所以 ./redis-cli就可以连接</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210511120701317.png" alt="image-20210511120701317"></p><p>默认在安装redis后，安装目录没有任何配置文件，需要<strong>拷贝原码目录中的配置文件<code>redis.conf</code>到usr下的redis目录下</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210511121238577.png" alt="image-20210511121238577"></p><p>以加载配置文件的启动</p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> ./redis-server ../redis.conf</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 11.开启远程连接</span><span class="hljs-bullet">-</span>  vim redis.conf</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210512102805521.png" alt="image-20210512102805521"></p><p>重启后生效，连接成功</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210512103002519.png" alt="image-20210512103002519"></p><h1 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h1><p><strong>准备工作</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown">yum -y update<span class="hljs-section"># Erlang在默认的YUM存储库中不可用，因此您将需要安装EPEL存储库</span>yum -y install epel-releaseyum -y update<span class="hljs-section"># 安装Erlang</span>yum -y install erlang socat<span class="hljs-section"># 查看安装后Erlang的版本</span>erl -version</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210526115805077.png" alt="image-20210526115805077"></p><p><strong>正式安装</strong></p><p>上传文件至linux</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210526120554574.png" alt="image-20210526120554574"></p><div class="hljs code-wrapper"><pre><code class="hljs markdown">yum install rabbitmq-server-3.6.10-1.el7.noarch.rpm</code></pre></div><p><strong>使用命令</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 运行</span>systemctl start rabbitmq-server<span class="hljs-section"># 自启动</span>systemctl enable rabbitmq-server<span class="hljs-section"># 查看状态</span>systemctl status rabbitmq-server</code></pre></div><p><strong>用户相关</strong></p><p>默认账号密码都是guest</p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 查看用户</span>sudo rabbitmqctl list<span class="hljs-emphasis">_users</span><span class="hljs-emphasis"># 添加用户</span><span class="hljs-emphasis">rabbitmqctl add_</span>user username passwordrabbitmqctl set<span class="hljs-emphasis">_user_</span>tags username administrator<span class="hljs-section"># 赋予用户默认的全部操作权限</span>rabbitmqctl set<span class="hljs-emphasis">_permissions -p / username “.*” “.*” “.*”</span></code></pre></div><p><strong>开启web控制台</strong></p><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 启动RabbitMQ Web管理控制台</span>rabbitmq-plugins enable rabbitmq<span class="hljs-emphasis">_management</span><span class="hljs-emphasis"># 将RabbitMQ文件的所有权提供给RabbitMQ用户</span><span class="hljs-emphasis">chown -R rabbitmq:rabbitmq /var/lib/rabbitmq/</span><span class="hljs-emphasis"># url</span><span class="hljs-emphasis">http://Your_</span>Server<span class="hljs-emphasis">_IP:15672/</span></code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210526122044856.png" alt="image-20210526122044856"></p><p><strong>开启远程访问</strong></p><p>默认情况下，RabbitMQ的默认的<code>guest</code>用户只允许本机访问， 如果想让<code>guest</code>用户能够远程访问的话，只需要将配置文件中的<code>loopback_users</code>列表置为空即可</p><div class="hljs code-wrapper"><pre><code class="hljs markdown">cd /etc/rabbitmq/<span class="hljs-section"># 默认是没有配置文件的，需要自己创建</span>vim rabbitmq.config<span class="hljs-section"># 在文件中添加如下</span>[&#123;rabbit, [&#123;loopback<span class="hljs-emphasis">_users, []&#125;]&#125;]</span><span class="hljs-emphasis"># 重启服务即可</span></code></pre></div><h1 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h1><p><strong>主要分为两部分</strong></p><ul><li><strong>Tracker 安装</strong></li><li><strong>Storage 安装</strong></li></ul><h2 id="Tracker-安装"><a href="#Tracker-安装" class="headerlink" title="Tracker 安装"></a>Tracker 安装</h2><p>由于 FastDFS 采用 C 语言开发，所以在安装之前，如果没有 gcc 环境，需要先安装，安装命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">yum install gcc-c++</code></pre></div><p>再来看两个库，由于 <strong>FastDFS 依赖 libevent 库</strong>，安装命令如下：</p><div class="hljs code-wrapper"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> libevent</code></pre></div><p><strong>另一个库是 libfastcommon</strong>，这是 FastDFS 官方提供的，它包含了 FastDFS 运行所需要的一些基础库。</p><p>libfastcommon 下载地址：<a href="https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz">https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz</a></p><p>将下载好的 libfastcommon 拷贝至 /usr/local/ 目录下，然后依次执行如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> /usr/localtar -zxvf V1.<span class="hljs-number">0.43</span>.tar.gz<span class="hljs-keyword">cd</span> libfastcommon-<span class="hljs-number">1.0</span>.<span class="hljs-number">43</span>/./<span class="hljs-keyword">make</span>.<span class="hljs-keyword">sh</span>./<span class="hljs-keyword">make</span>.<span class="hljs-keyword">sh</span> install</code></pre></div><p><strong>接下来下载 Tracker</strong>，注意，由于 Tracker 和 Storage 是相同的安装包，所以下载一次即可</p><p>安装文件可以从 FastDFS 的 GitHub 仓库上下载，下载地址：<a href="https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz">https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz</a></p><p>下载成功后，将下载文件拷贝到 /usr/local 目录下，然后依次执行如下命令安装：</p><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> /usr/localtar -zxvf V6.<span class="hljs-number">06</span>.tar.gz<span class="hljs-keyword">cd</span> fastdfs-<span class="hljs-number">6.06</span>/./<span class="hljs-keyword">make</span>.<span class="hljs-keyword">sh</span>./<span class="hljs-keyword">make</span>.<span class="hljs-keyword">sh</span> install</code></pre></div><p>安装成功后，执行如下命令，将安装目录内 conf 目录下的配置文件拷贝到 /etc/fdfs 目录下：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">cd conf/cp .<span class="hljs-regexp">/* /</span>etc<span class="hljs-regexp">/fdfs/</span></code></pre></div><p><strong>接下来进入 /etc/fdfs/ 目录下进行配置</strong>：</p><p>打开 tracker.conf 文件：</p><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">vi</span> tracker.<span class="hljs-keyword">conf</span></code></pre></div><p>修改如下配置：</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210712152953238.png" alt="image-20210712152953238"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210712153240483.png" alt="image-20210712153240483"></p><p>接下来执行如下命令<strong>启动 Tracker：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/fdfs_trackerd /</span>etc<span class="hljs-regexp">/fdfs/</span>tracker.conf start</code></pre></div><p>如此之后，我们的 Tracker 就算安装成功了。</p><h2 id="Storage-安装"><a href="#Storage-安装" class="headerlink" title="Storage 安装"></a>Storage 安装</h2><p>Storage 安装也需要 libevent 和 libfastcommon，这两个库的安装参考上文</p><p>Storage 本身的安装，也和 Tracker 一致，执行命令也都一样，因为我这里将 Tracker 和 Storage 安装在同一台服务器上，所以不用再执行安装命令了（相当于安装 Tracker 时已经安装了 Storage 了）</p><p><strong>唯一要做的，就是进入到 /etc/fdfs 目录下，配置 Storage：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">vi</span> storage.<span class="hljs-keyword">conf</span></code></pre></div><p>这里一共配置三个地方，分别是 <strong>base_path、store_path0 以及 tracker_server</strong> ，<strong>base_path、store_path0</strong>地址相同，<strong>tracker_server</strong> 模板有两个地址，我们这里只有一个，配置完成后，记得注释掉另外一个不用的。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210712153654415.png" alt="image-20210712153654415"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210712153829253.png" alt="image-20210712153829253"></p><p>配置完成后，执行如下命令启动 Storage：</p><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/fdfs_storaged /</span>etc<span class="hljs-regexp">/fdfs/</span>storage.conf start</code></pre></div><p>这两个启动完成后，现在就可以做文件的上传了，但是一般如果是图片文件，<strong>我们还需要提供一个图片的访问功能，目前来说最佳方案当然是 Nginx</strong> ，所以我们这里连同 Nginx 一起配置好，再来做测试。</p><h2 id="fastdfs-nginx-module"><a href="#fastdfs-nginx-module" class="headerlink" title="fastdfs-nginx-module"></a>fastdfs-nginx-module</h2><p>图片上传我们一般使用 FastDFS，图片上传成功之后，接下来的图片访问我们一般采用 Nginx，Nginx安装已经完成，现在开始安装下载 fastdfs-nginx-module，下载地址：<a href="https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz">https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz</a></p><p>下载完成后，将下载的文件<strong>拷贝到 /usr/local</strong> 目录下。然后进入 /usr/local 目录，分别执行如下命令：</p><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /usr/local<span class="hljs-attribute">tar</span> -zxvf V<span class="hljs-number">1</span>.<span class="hljs-number">22</span>.tar.gz</code></pre></div><p>然后将 <code>/usr/local/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf</code> 文件拷贝到 <code>/etc/fdfs/</code> 目录下，并修改该文件的内容：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>fdfs/mod_fastdfs.conf</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210712155658437.png" alt="image-20210712155658437"></p><p>接下来，回到第一步下载的 nginx 安装文件的解压目录中，执行如下命令，重新配置编译安装：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/configure --add-module=/u</span>sr<span class="hljs-regexp">/local/</span>fastdfs-nginx-module-<span class="hljs-number">1.22</span>/srcmakemake install</code></pre></div><p>安装完成后，修改 nginx 的配置文件，如下：</p><div class="hljs code-wrapper"><pre><code class="hljs awk">vi <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>conf/nginx.conf</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210712163039593.png" alt="image-20210712163039593"></p><p>在这里配置 nginx 请求转发。</p><p>配置完成后，启动 nginx，看到如下日志，表示 nginx 启动成功：</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">ngx_http_fastdfs_set <span class="hljs-attribute">pid</span>=9908</code></pre></div><p><strong>疑问：fastdfs-nginx-module 有啥用</strong></p><p>到头来还是 nginx 本身直接找到了图片文件目录，fastdfs-nginx-module 到底有啥用？</p><p>前面我们说过，Storage 由很多组构成，每个组又是一个小的集群，在每一个组里边，数据会进行同步，但是如果数据还没同步，这个时候就有请求发来了，该怎么办？此时fastdfs-nginx-module 会帮助我们直接从源 Storage 上获取文件。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/07/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/07/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote><p>本笔记是根据王道考研所讲的操作系统所做的笔记，老师讲课风格诙谐幽默，值得一看</p></blockquote><h1 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h1><h2 id="1-操作系统的概念、特征、功能、目标"><a href="#1-操作系统的概念、特征、功能、目标" class="headerlink" title="1.操作系统的概念、特征、功能、目标"></a>1.操作系统的概念、特征、功能、目标</h2><blockquote><p>操作系统（ Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。计算机操作系统是随着计算机研究和应用的发展逐步形成并发展起来的，它是计算机系统中最基本的系统软件</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200401222215527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-1-操作系统的特征"><a href="#1-1-操作系统的特征" class="headerlink" title="1.1 操作系统的特征"></a>1.1 操作系统的特征</h3><blockquote><p>操作系统的基本特征包括并发、共享、虚拟和异步</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200528183517102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-1-1-并发-Concurrence"><a href="#1-1-1-并发-Concurrence" class="headerlink" title="1.1.1 并发(Concurrence)"></a>1.1.1 并发(Concurrence)</h4><p><code>并发是指两个或多个事件在同一时间间隔内发生</code>。在多道程序环境下，一段时间内宏观上有多道程序在同时执行，而在每一时刻，单处理机环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。操作系统的并发性是通过分时得以实现的。</p><p><strong>虽然现在CPU很多都是多核的,但是程序有可能很多,所以并发还是很重要.</strong></p><h4 id="1-1-2-共享-Sharing"><a href="#1-1-2-共享-Sharing" class="headerlink" title="1.1.2 共享(Sharing)"></a>1.1.2 共享(Sharing)</h4><p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可分为以下两种资源共享方式</p><ul><li><strong>互斥共享方式</strong> 系统中的某些资源，如打印机、磁带机，<code>虽然它们可以提供给多个进程使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程访问该资源</code>。为此，当进程A访问某资源时，必须先提出请求，如果此时该资源空闲，系统便可将之分配给进程A使用，此后若再有其他进程也要访问该资源时（只要A未用完）则必须等待。仅当进程A访问完并释放该资源后，才允许另一进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享</li><li><strong>同时共享方式</strong> 系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，<code>而在微观上，这些进程可能是交替地对该资源进行访问</code>，即“分时共享”,典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件. 要注意到，互斥共享，是因为一种资源在一段时间内（哪怕是一段很小的时间）只能满足一个请求，否则就会出现严重的问题（如打印机，第一行打印A文档的内容，第二行打印B文档的内容，你能想象是什么效果吗？）.而同时共享方式，通常要求，一个请求分几个时间片段间隔地完成的效果，与连续完成的效果相同</li></ul><p><strong>并发和共享是操作系统两个最基本的特征，这两者之间又是互为存在条件的：</strong></p><ul><li>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题</li><li>若系统不能对资源共享实施有效的管理，也必将影响到程序的并发执行，甚至根本无法并发执行</li></ul><h4 id="1-1-3-虚拟-Virtual"><a href="#1-1-3-虚拟-Virtual" class="headerlink" title="1.1.3 虚拟(Virtual)"></a>1.1.3 虚拟(Virtual)</h4><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。</p><p>在操作系统中利用了多种虚拟技术，分别用来实现<code>虚拟处理器、虚拟内存和虚拟外部设备</code>等。 在虚拟处理器技术中，是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU）在专门为它服务。利用多道程序设计技术，<code>把一个物理上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器</code> </p><p>类似地，<code>可以通过虚拟存储器技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上来扩充存储器的容量</code>。当然，这时用户所感觉到的内存容量是虚的。我们把用户所感觉到的存储器（实际是不存在的）称为虚拟存储器。</p><p>还可以通过虚拟设备技术，将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备，这样便可以使原来仅允许在一段时间内由一个用户访问的设备（即临界资源），变为在一段时间内允许多个用户同时访问的共享设备.因此，<code>操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器</code></p><p>把CPU抽象成进程，把磁盘抽象成文件，把内存抽象成地址空间</p><h4 id="1-1-4-异步-Asynchronism"><a href="#1-1-4-异步-Asynchronism" class="headerlink" title="1.1.4 异步(Asynchronism)"></a>1.1.4 异步(Asynchronism)</h4><p>在多道程序环境下，<code>允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停</code>，以不可预知的速度向前推进，这就是进程的异步性</p><h3 id="1-2-操作系统的目标和功能"><a href="#1-2-操作系统的目标和功能" class="headerlink" title="1.2 操作系统的目标和功能"></a>1.2 操作系统的目标和功能</h3><h4 id="1-2-1-操作系统作为计算机系统资源的管理者"><a href="#1-2-1-操作系统作为计算机系统资源的管理者" class="headerlink" title="1.2.1 操作系统作为计算机系统资源的管理者"></a>1.2.1 操作系统作为计算机系统资源的管理者</h4><p><img src="https://img-blog.csdnimg.cn/20200528180734868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>处理机管理<br>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。并发时在计算机内同时运行多个进程，所以，进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能<br>有：进程控制、进程同步、进程通信、死锁处理、处理机调度等。</li><li>存储器管理<br>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用以及提高内存的利用率，主要包括内存分配、地址映射、内存保护与共享和内存扩充等功能</li><li>文件管理<br>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</li><li>设备管理<br>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率.主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</li></ul><h4 id="1-2-2-操作系统作为用户与计算机硬件系统之间的接口"><a href="#1-2-2-操作系统作为用户与计算机硬件系统之间的接口" class="headerlink" title="1.2.2 操作系统作为用户与计算机硬件系统之间的接口"></a>1.2.2 操作系统作为用户与计算机硬件系统之间的接口</h4><p><img src="https://img-blog.csdnimg.cn/20200401223245841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200401223603928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>操作系统提供的接口主要分为两类<br>一类是<strong>命令接口</strong>，用户利用这些操作命令来组织和控制作业的执行；另一类是<strong>程序接口</strong>，编程人员可以使用它们来请求操作系统服务。</p><ul><li><p>命令接口<br>使用命令接口进行作业控制的主要方式有两种，<strong>即联机控制方式和脱机控制方式</strong>。按作业控制方式的不同，可以将命令接口分为联机命令接口和脱机命令接口。联机命令接口又称交互式命令接口，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入完一条命令，控制权就转入操作系统的命令解释程序，然后由命令解释程序对输入的命令解释并执行，完成指定的功能。之后，控制权又转回到控制台或终端，此时用户又可以输入下一条命令</p><ul><li><strong>脱机命令接口又称批处理命令接口</strong>，即适用于批处理系统，它由一组作业控制命令（或称作业控制语句）组成。脱机用户不能直接干预作业的运行，应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。当系统调度到该作业时，由系统中的命令解释程序.对作业说明书上的命令或作业控制语句逐条解释执行，从而间接地控制作业的运行.<br>联机命令接口可以理解为：“雇主”说一句话，“工人”做一件事，并做出反馈，这就强调了交互性。</li></ul></li><li><p>程序接口<br><strong>程序接口由一组系统调用命令</strong>（简称系统调用，也称广义指令）组成。用户通过在程序中使用这些系统调用命令来请求操作系统为其提供服务。用户在程序中可以直接使用这组系统调用命令向系统提出各种服务要求，如使用各种外部设备，进行有关磁盘文件的操作，申请分配和回收内存以及其他各种控制要求。操作系统不允许用户直接操作各种硬件资源，因此用户程序只能通过系统调用的方式来请求内核为其服务，间接地使用各种资源</p></li><li><p>GUI<br>图形用户界面（GUI）即图形接口，用户通过鼠标和键盘，在图形界面上单击或使用快捷键就能很方便地使用操作系统。有些系统提供了上述三种接口，但GUI最终是通过调用程序接口实现的，严格地说GUI图形接口不属于操作系统的一部分，但图形接口所调用的系统调用命令，属于操作系统的一部分</p></li></ul><h4 id="1-2-3-操作系统用做扩充机器"><a href="#1-2-3-操作系统用做扩充机器" class="headerlink" title="1.2.3 操作系统用做扩充机器"></a>1.2.3 操作系统用做扩充机器</h4><p>没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，它的外面是操作系统，由操作系统提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器，通常把<strong>覆盖了软件的机器称为扩充机器，又称之为虚拟机</strong></p><blockquote><p>单处理机系统中，可并行的是（D）. </p><p>I.进程与进程<br>Ⅱ.处理机与设备<br>Ⅲ.处理机与通道<br>Ⅳ.设备与设备 </p><p>A.I、Ⅱ、Ⅲ<br>B.I、Ⅱ、Ⅳ<br>C.I、Ⅲ、Ⅳ<br>D.Ⅱ、Ⅲ、Ⅳ</p></blockquote><p>在单处理机系统（不包含多核的情况）中，同一时刻只能有一个进程占用处理机，因此进程之间不能并行执行。通道是独立于CPU的控制输入输出的设备，两者可以并行，显然，处理器与设备是可以并行的，难道CPU和显示屏不能并行工作？设备与设备是可以并行的，难道显示屏与打印机不能并行工作？</p><h2 id="2-操作系统的发展与分类"><a href="#2-操作系统的发展与分类" class="headerlink" title="2. 操作系统的发展与分类"></a>2. 操作系统的发展与分类</h2><p><img src="https://img-blog.csdnimg.cn/20200402002639598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="hello"><br><img src="https://img-blog.csdnimg.cn/2020052914130223.png" alt="在这里插入图片描述"></p><h3 id="2-1-手工操作阶段（此阶段无操作系统）"><a href="#2-1-手工操作阶段（此阶段无操作系统）" class="headerlink" title="2.1 手工操作阶段（此阶段无操作系统）"></a>2.1 手工操作阶段（此阶段无操作系统）</h3><p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾（速度和资源利用）越来越大，必须寻求新的解决办法。</p><p>手工操作阶段有两个突出的缺点：</p><ul><li>用户独占全机。不会出现因资源已被其他用户占用而等待的现象，但资源利用率低</li><li>CPU等待手工操作，CPU的利用不充分</li></ul><p>唯一的解决办法就是用高速的机器代替相对较慢的手工操作来对作业进行控制</p><h3 id="2-2-批处理阶段（操作系统开始出现）"><a href="#2-2-批处理阶段（操作系统开始出现）" class="headerlink" title="2.2 批处理阶段（操作系统开始出现）"></a>2.2 批处理阶段（操作系统开始出现）</h3><p>为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，出现了批处理系统。它按发<br>展历程又分为<code>单道批处理系统、多道批处理系统</code>（多道程序设计技术出现以后）.</p><ul><li>单道批处理系统<br>系统对作业的处理是成批进行的，但内存中始终保持一道作业。该系统是在解决人机矛盾和CPU与I/O设备速率不匹配的矛盾中形成的。单道批处理系统的主要特征如下<ul><li>自动性。在顺利的情况下，在磁带上的一批作业能自动地逐个依次运行，而无需人工</li><li>顺序性。磁带上的各道作业是顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序，在正常情况下应完全相同，亦即先调入内存的作业先完成</li><li>单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行</li></ul></li></ul><p><strong>此时面临的问题是</strong></p><p>每次主机内存中仅存放一道作业，每当它运行期间（注意这里是“运行时”，并不是“完成后”）发出输入输出请求后，高速的CPU便处于等待低速的I/O完成状态.为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术.</p><ul><li><p>多道批处理系统<br><code>多道程序设计技术允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许们交替在CPU中运行</code>，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序</p><p>多道程序设计的特点有：多道、宏观上并行、微观上串行。</p><ul><li>多道：计算机内存中同时存放多道相互独立的程序。</li><li>宏观上并行：同时进入系统的多道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕。</li><li>微观上串行：内存中的多道程序轮流占有CPU，交替执行</li></ul></li></ul><p><strong>多道程序设计技术的实现需要解决下列问题</strong></p><ul><li>如何分配处理器</li><li>多道程序的内存分配问题</li><li>I/O设备如何分配</li><li>如何组织和存放大量的程序和数据，以便于用户使用和保证其安全性与一致性 </li></ul><p>优点是资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用：系统吞吐量大，CPU和其他资源保持“忙碌”状态。缺点是用户响应的时间较长。<code>不提供人机交互能力，用户既不能了解自己程序的运行情况，也不能控制计算机</code></p><h3 id="2-3-分时操作系统"><a href="#2-3-分时操作系统" class="headerlink" title="2.3 分时操作系统"></a>2.3 分时操作系统</h3><p>在操作系统中采用分时技术就形成了分时系统。所谓分时技术就是把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉好像是自己独占一台计算机.<br>分时操作系统是多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无需人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征，其主要特征如下：</p><ul><li>同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li><li>交互性。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</li><li>独立性。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样</li><li>及时性。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意</li></ul><p>虽然分时操作系统比较好地解决了人机交互问题，但是在一些应用场合，<code>需要系统能对外部的信息在规定的时间（比时间片的时间还短）内作出处理</code>（比如飞机订票系统或导弹制导系统）因此，实时系统应运而生</p><h3 id="2-4-实时操作系统"><a href="#2-4-实时操作系统" class="headerlink" title="2.4 实时操作系统"></a>2.4 实时操作系统</h3><p>为了能在某个时间限制内完成某些紧急任务而不需时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况：</p><ul><li>如果某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为硬实时系统。例如，飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成</li><li>如果能够接受偶尔违反时间规定，并且不会引起任何永久性的损害，则称为软实时系统，如飞机订票系统、银行管理系统</li></ul><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完接收的事件。实时操作系统的主要特点是及时性和可靠性。</p><h3 id="2-5-网络操作系统和分布式计算机系统"><a href="#2-5-网络操作系统和分布式计算机系统" class="headerlink" title="2.5 网络操作系统和分布式计算机系统"></a>2.5 网络操作系统和分布式计算机系统</h3><p>网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各个计算机之间的互相传送数据。网络操作系统最主要的特点是网络中各种资源的共享以及各台计算机之间的通信.</p><p>分布式计算机系统是由多台计算机组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息：系统中的每一台计算机都具有同等的地位，即没有主机也没有从机；每台计算机上的资源为所有用户共享；系统中的任意若干台计算机都可以构成一个子系统，并且还能重构；任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是：分布性和并行性。分布式操作系统与网络操作系统本质上的不同之处在于分布式操作系统中，若干台计算机相互协同完成同一任务。</p><h3 id="2-6-个人计算机操作系统"><a href="#2-6-个人计算机操作系统" class="headerlink" title="2.6 个人计算机操作系统"></a>2.6 个人计算机操作系统</h3><p>个人计算机操作系统是目前使用最广泛的操作系统，广泛应用于文字处理、电子表格、游戏等。常见的有 Windows、 Linux和 Macintosh等</p><h2 id="3-操作系统的运行机制跟体系结构"><a href="#3-操作系统的运行机制跟体系结构" class="headerlink" title="3. 操作系统的运行机制跟体系结构"></a>3. 操作系统的运行机制跟体系结构</h2><p><img src="https://img-blog.csdnimg.cn/20200706210933706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402092035655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210531175254267.png" alt="image-20210531175254267"></p><h3 id="3-1-操作系统的运行机制"><a href="#3-1-操作系统的运行机制" class="headerlink" title="3.1 操作系统的运行机制"></a>3.1 操作系统的运行机制</h3><p>计算机系统中，通常CPU执行两种不同性质的程序：<code>一种是操作系统内核程序；另一种是用户自编程序或系统外层的应用程序</code>。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”要执行一些特权指令，而“被管理程序”出于安全考虑不能执行这些指令。操作系统在具体实现上划分了用户态（目态）和核心态（管态），以严格区分两类程序.操作系统的各项功能分别被设置在不同的层次上。<code>一些与硬件关联较紧密的模块，诸如时钟管理、中断处理、设备驱动等处于最底层。其次是运行频率较高的程序，诸如进程管理、存储器管理和设备管理等</code>。这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。</p><p><code>内核是计算机上配置的底层软件，是计算机功能的延伸。不同系统对内核的定义稍有区别。大多数操作系统内核包括四个方面的内容</code></p><ul><li>时钟管理<br>在计算机的各种部件中，时钟是最关键的设备。时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现进程的切换。诸如，在分时操作系统中，采用时间片轮转调度的实现；在实时系统中，按截止时间控制运行的实现；在批处理系统中，通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面无不依赖于时钟。</li><li>中断机制<br>引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。<br>中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力</li><li>原语，按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。其特点是：<ul><li>它们处于操作系统的最底层，是最接近硬件的部分。</li><li>这些程序的运行具有原子性—其操作只能一气呵成（这主要是从系统的安全性和便于管理考虑的）</li><li>这些程序的运行时间都较短，而且调用频繁。</li></ul></li></ul><p>通常把具有这些特点的程序称为原语（ Atomic Operation）.定义原语的直接方法是关闭中断，让它的所有动作不可分割地进行完，再打开中断。</p><p><code>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可以定义为原语，使它们成为内核的组成部分</code></p><ul><li>系统控制的数据结构及处理<br>系统中用来登记状态信息的数据结构很多，比如作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下三种<br>1）进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块等<br>2）存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等<br>3）设备管理：缓冲区管理、设备分配和回收等<br>从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令</li></ul><h3 id="3-2-中断和异常"><a href="#3-2-中断和异常" class="headerlink" title="3.2 中断和异常"></a>3.2 中断和异常</h3><p><img src="https://img-blog.csdnimg.cn/20200706211009553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200402094023539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402094321685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402094734544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>中断（ Interruption），也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的I/O结束中断，表示设备输入输出处理已经完成，希望处理机能够向设备发下一个输入输出请求,同时让完成输入输出后的程序继续运行。<code>时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等</code>。这一类中断通常是与当前程序运行无关的事件，即它们与当前处理机运行的程序无关</p><p>异常（ Exception），也称内中断、例外或陷入（Trap），指源自CPU执行指令内部的事件，<br><code>如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页以及专门的陷入指令等引起的事件</code>。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一但出现应立即处理。</p><h3 id="3-3-系统调用"><a href="#3-3-系统调用" class="headerlink" title="3.3 系统调用"></a>3.3 系统调用</h3><p><img src="https://img-blog.csdnimg.cn/20200402100117545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200402100637106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402101046100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402102114944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706211048292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>所谓系统调用就是用户在程序中调用操作系统提供的一些子功能，系统调用可以被看做特殊的公共子程序</code>。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行I/O传输以及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十乃至上百条之多,这些系统调用按功能大致可分为如下几类</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能</li><li>文件管理。完成文件的读、写、创建及删除等功能</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能</li><li>进程通信。完成进程之间的消息传递或信号传递等功能</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li></ul><p>显然，<code>系统调用运行在系统的核心态。通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令</code>。系统调用命令是由操作系统提供的一个或多个子程序模块实现的。<br>下面列举一些由用户态转向核心态的例子：</p><p><img src="https://img-blog.csdnimg.cn/20200529111946326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-4-操作系统的体系结构"><a href="#3-4-操作系统的体系结构" class="headerlink" title="3.4 操作系统的体系结构"></a>3.4 操作系统的体系结构</h3><p><img src="https://img-blog.csdnimg.cn/2020040209232247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200708100758503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="二、进程同步和互斥"><a href="#二、进程同步和互斥" class="headerlink" title="二、进程同步和互斥"></a>二、进程同步和互斥</h1><p><img src="https://img-blog.csdnimg.cn/20200706161604234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706161654480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706161716690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706161813260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706161859429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706161933796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706171831433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706172629884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706174400154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706191129607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706180307698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706191956957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706193311914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706194954529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200531193752627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-1-进程的概念和特征"><a href="#1-1-进程的概念和特征" class="headerlink" title="1.1 进程的概念和特征"></a>1.1 进程的概念和特征</h3><p><img src="https://img-blog.csdnimg.cn/20200706161228279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h4><p>进程（Process）以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性）<code>为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块（ProcessControlBlock，PCB）</code>系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，<code>由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）</code>。<code>所谓创建进程，实质上是创建进程映像中的PCB：而撤销进程，实质上是撤销进程的PCB。</code></p><p><code>值得注意的是进程映像是静态的，进程则是动态的</code></p><p>从不同的角度，进程可以有不同的定义，比较典型的定义有：<br>1）进程是程序的一次<code>执行过程</code><br>2）进程是一个程序及其数据在处理机上顺序执行时<code>所发生的活动</code>。<br>3）进程是具有独立功能的程序在一个数据集合上<code>运行的过程</code>，它是系统进行资源分配和调度的一个独立单位。</p><p>在引入进程实体的概念后，我们可以把传统操作系统中的进程定义为：“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位这里的系统资源，指的是处理机、存储器和其他设备服务于某进程的“时间”，比如，把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，即“时间片”分配的独立单位，这就决定了，进程一定是一个动态的、过程性的概念。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601100224159.png" alt="image-20210601100224159"></p><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><p>进程是由多程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求</p><ul><li>动态性：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征</li><li>并发性：指多个进程实体，同存于内存中，能在一段时间内同时运行，<code>并发性是进程的重要特征，同时也是操作系统的重要特征</code>。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率</li><li>独立性：指<code>进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</code>。凡未建立PCB的程序都不能作为一个独立的单位参与运行。</li><li>异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制</li><li>结构性：每个进程都配置一个PCB对其进行描述。从结构上看，<code>进程实体是由程序段、数据段和进程控制段三部分组成的</code></li></ul><h3 id="1-2-进程的状态与转换"><a href="#1-2-进程的状态与转换" class="headerlink" title="1.2 进程的状态与转换"></a>1.2 进程的状态与转换</h3><p><img src="https://img-blog.csdnimg.cn/20200706161301448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020040220064459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>通常进程有以下五种状态，前三种是进程的基本状态<br>1）运行状态：进程正在处理机上运行。<code>在单处理机环境下，每一时刻最多只有一个进程处于运行状态</code>。</p><p>2）就绪状态：进程已处于准备运行的状态，<code>即进程获得了除处理机之外的一切所需资源,一旦得到处理机即可运行</code></p><p>3）阻塞状态，又称等待状态：<code>进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入输出完成。即使处理机空闲，该进程也不能运行</code>。</p><p>4）创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：<code>首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必需的资源：最后把该进程转入到就绪状态</code></p><p>5）结束状态：进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，<code>系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收等工作。</code></p><p><code>注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。</code><br><code>之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒</code>。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪状态的：而其他资源（如外设）的使用和分配或者某一事件的发生（如I/O操作的完成）对应的时间相对来说很长，进程转换到等待状态的次数也相对较少。这样来看，就绪状态和等待状态是进程生命周期中两个完全不同的状态，很显然需要加以区分。</p><h4 id="状态的转换"><a href="#状态的转换" class="headerlink" title="状态的转换"></a>状态的转换</h4><p>就绪状态→运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片）于是进程由就绪状态转换为运行状态</p><p>运行状态→就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。</p><p>运行状态→阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如IO操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式</p><p>阻塞状态→就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态<br>需要注意的是，一个进程从运行状态变成阻塞状态是一个主动的行为，而从阻塞状态变到就就绪状态是一个被动的行为，需要其他相关进程的协助</p><h3 id="1-3-进程控制"><a href="#1-3-进程控制" class="headerlink" title="1.3 进程控制"></a>1.3 进程控制</h3><p><img src="https://img-blog.csdnimg.cn/20200706161406983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有<code>创建新进程、撤销已有进程、实现进程状态转换等功能</code>。<code>在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</code><br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601103352347.png" alt="image-20210601103352347"></p><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程</p><p>在操作系统中，<code>终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建</code>。操作系统创建一个新进程的过程如下（创建原语）：</p><p>1）为新进程分配一个唯一的进程标识号，并申请一个空白的PCB（PCB是有限的）.若PCB申请失败则创建失败。</p><p>2）为进程分配资源，为新进程的程序和数据，以及用户栈分配必要的内存空间（在PCB中体现）.注意：这里如果资源不足（比如内存空间），并不是创建失败，而是处于“等待状态或称为“阻塞状态”，等待的是内存这个资源</p><p>3）初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等</p><p>4）如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601103626193.png" alt="image-20210601103626193"></p><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p>引起进程终止的事件主要有：正常结束，表示进程的任务已经完成和准备退出运行。异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止</p><p>操作系统终止进程的过程如下（撤销原语）</p><p>1）根据被终止进程的标识符，检索PCB，从中读出该进程的状态<br>2）若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程<br>3）若该进程还有子进程，则应将其所有子进程终止<br>4）将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。<br>5）将该PCB从所在队列（链表）中删除</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601103701471.png" alt="image-20210601103701471"></p><h4 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成数据尚未到达或无新工作可做等，则由系统自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。阻塞原语的执行过程是</p><p>1）找到将要被阻塞进程的标识号对应的PCB.<br>2）若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。<br>3）把该PCB插入到相应事件的等待队列中去<br>当被阻塞进程所期待的事件出现时，如它所启动的IO操作已完成或其所期待的数据已到达则由有关进程（比如，提供数据的进程）调用喚醒原语（Wakeup），将等待该事件的进程唤醒唤醒原语的执行过程是</p><p>1）在该事件的等待队列中找到相应进程的PCB<br>2）将其从等待队列中移出，并置其状态为就绪状态<br>3）把该PCB插入就绪队列中，等待调度程序调度</p><p>需要注意的是，Block原语和 Wakeup原语是一对作用刚好相反的原语，必须成对使用。 Block原语是由被阻塞进程自我调用实现的，而 Wakeup原语则是由一个与被唤醒进程相合作或被其他相关的进程调用实现的</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601103839486.png" alt="image-20210601103839486"></p><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>对于通常的进程，其创建、撤销以及要求由系统设备完成的IO操作都是利用系统调用而进入内核，再由内核中相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的进程切换是指处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化。进程切换的过程如下</p><p>1）保存处理机上下文，包括程序计数器和其他寄存器。<br>2）更新PCB信息<br>3）把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<br>4）选择另一个进程执行，并更新其PCB<br>5）更新内存管理的数据结构<br>6）恢复处理机上下文</p><p>注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。如果进程因中断或异常进入到核心态运行，执行完后又回到用户态刚被中断的程序运行则操作系统只需恢复进程进入内核时所保存的CPU现场，无需改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。</p><p>注意：“调度”和“切换”的区别，调度是指决定资源分配给哪个进程的行为，是一种决策行为切换是指实际分配的行为，是执行行为。一般来说，先有资源的调度，然后才有进程的切换</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601104024983.png" alt="image-20210601104024983"></p><h3 id="1-4-进程的组织"><a href="#1-4-进程的组织" class="headerlink" title="1.4 进程的组织"></a>1.4 进程的组织</h3><p>进程是操作系统的资源分配和独立运行的基本单位。它一般由以下三个部分组成</p><ul><li>进程控制块<br>进程创建时，操作系统就新建一个PCB结构，它之后就常驻内存，任一时刻可以存取，在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。当创建一个进程时，系统为该进程建立一个PCB：当进程执行时，系统通过其PCB了解进程的现行状态信息，以便对其进行控制和管理；当进程结束时，系统收回其PCB，该进程随之消亡。操作系统通过PCB表来管理和控制进程PCB主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。各部分的主要说明如下：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200531175224684.png" alt="在这里插入图片描述"></p><p>1）进程描述信息<br>进程标识符：标志各个进程，每个进程都有一个并且是唯一的标识号<br>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务</p><p>2）进程控制和管理信息进程当前状态：描述进程的状态信息，作为处理机分配调度的依据进程优先级：描述进程抢占处理机的优先级，优先级高的进程可以优先获得处理机。</p><p>3）资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况：所打开文件的列表和所使用的输入输出设备信息。</p><p>4）处理机相关信息，主要指处理机中各寄存器值，当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能再从断点继续执行在一个系统中，通常存在着许多进程，有的处于就绪状态，有的处于阻塞状态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来。目前常用的组织方式有链接方式和索引方式两种。链接方式将同一状态的PCB链接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。索引方式是将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB不同状态对应不同的索引表，如就绪索引表和阻塞索引表等</p><ul><li><p>程序段<br>程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可以被多个进程共享，就是说多个进程可以运行同一个程序</p></li><li><p>数据段<br>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200402194654392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402194758818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402194818323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-5-进程的通信"><a href="#1-5-进程的通信" class="headerlink" title="1.5 进程的通信"></a>1.5 进程的通信</h3><p><img src="https://img-blog.csdnimg.cn/20200706161449867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类:</p><h4 id="1-5-1-共享存储"><a href="#1-5-1-共享存储" class="headerlink" title="1.5.1 共享存储"></a>1.5.1 共享存储</h4><p><img src="https://img-blog.csdnimg.cn/20200531184114689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402205029332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_1,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-5-2-消息传递"><a href="#1-5-2-消息传递" class="headerlink" title="1.5.2 消息传递"></a>1.5.2 消息传递</h4><p><img src="https://img-blog.csdnimg.cn/2020053118444774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601105328555.png" alt="image-20210601105328555"></p><h4 id="1-5-3-管道通信"><a href="#1-5-3-管道通信" class="headerlink" title="1.5.3 管道通信"></a>1.5.3 管道通信</h4><p><img src="https://img-blog.csdnimg.cn/20200531184934335.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200531185020516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601105231233.png" alt="image-20210601105231233"></p><h3 id="1-6-线程概念和多线程模型"><a href="#1-6-线程概念和多线程模型" class="headerlink" title="1.6 线程概念和多线程模型"></a>1.6 线程概念和多线程模型</h3><p><img src="https://img-blog.csdnimg.cn/20200706161521969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-6-1-线程的基本概念"><a href="#1-6-1-线程的基本概念" class="headerlink" title="1.6.1 线程的基本概念"></a>1.6.1 线程的基本概念</h4><p>引入进程的目的，是为了更好地使多道程序并发执行，以提高资源利用率和系统吞吐量，增加并发程度；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。</p><p><code>线程是进程中的一个实体，是被系统独立调度和分派的基本单位</code>，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。<code>线程也有就绪、阻塞和运行三种基本状态</code>。</p><p>引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，<code>线程则作为处理机的分配单元。由于一个进程内部有多个线程，如果线程的切换发生在同一个进程内部，则只需要很少的时空开销</code></p><h4 id="1-6-2-线程与进程的比较"><a href="#1-6-2-线程与进程的比较" class="headerlink" title="1.6.2 线程与进程的比较"></a>1.6.2 线程与进程的比较</h4><ul><li>调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，<code>线程是独立调度的基本单位，进程是拥有资源的基本单位</code>。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>拥有资源。不论是传统操作系统还是设有线程的操作系统，<code>进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点必不可少的资源）</code>，但线程可以访问其隶属进程的系统资源。我们要知道，如果线程也是拥有资源的单位，那么，切换线程也需要较大的时空开销，线程这个概念的提出就没有意义了。</li><li>并发性。在引入线程的操作系统中，<code>不仅进程之间可以并发执行，而且多个线程之间也可以并发执行</code>，从而使操作系统具有更好的并发性，提高了系统的吞吐量。</li><li>系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、IO设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，<code>涉及当前执行进程CPU环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小</code>。此外，由于同一进程内的多个线程共享进程的地址空间，因此，这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预</li><li>地址空间和其他资源（如打开的文件）：进程的地址空间之间互相独立，同<code>一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见</code></li><li>通信方面：进程间通信（IPC）需要进程同步和互斥手段的辅助，以保证数据的一致性而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</li></ul><h4 id="1-6-3-线程的属性"><a href="#1-6-3-线程的属性" class="headerlink" title="1.6.3 线程的属性"></a>1.6.3 线程的属性</h4><p>在多线程操作系统中，把线程作为独立运行（或调度）的基本单位，此时的进程，已不再是个基本的可执行实体。但进程仍具有与执行相关的状态，所谓进程处于“执行”状态，实际上是指该进程中某线程正在执行。线程的主要属性如下</p><p>1）线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态<br>2）不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统为它们创建成不同的线程<br>3）同一进程中的各个线程共享该进程所拥有的资源<br>4）线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务则可缩短进程的处理时间。<br>5）一个线程被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历阻塞态就绪态和运行态等各种状态变化</p><p>为什么线程的提出有利于提高系统并发性？可以这样来理解：由于有了线程，线程切换时有可能会发生进程切换，也有可能不发生进程的切换，那么平均下来，每次切换所需要的开销就小了，因而，就能够让更多的线程参与并发，也不会影响到响应时间等问题了</p><h4 id="1-6-4-线程的实现方式"><a href="#1-6-4-线程的实现方式" class="headerlink" title="1.6.4 线程的实现方式"></a>1.6.4 线程的实现方式</h4><p>线程的实现可以分为两类：用户级线程（User-LevelThread，ULT）和内核级线程（Kernel-LevThread，KLT）.内核级线程又称为内核支持的线程。</p><p>在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。</p><ul><li>图（a）说明了用户级线程的实现方式在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。</li><li>图（b）说明了内核级线程的实现方式在一些系统中，使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。</li><li>图（c）说明了用户级与内核级的组合实现方式</li></ul><p><img src="https://img-blog.csdnimg.cn/20210103095251735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210103095317592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210103095348648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-6-5-多线程模型"><a href="#1-6-5-多线程模型" class="headerlink" title="1.6.5 多线程模型"></a>1.6.5 多线程模型</h4><p><img src="https://img-blog.csdnimg.cn/20210103095714208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210103095735307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021010309580711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式</p><p>1）多对一模型。将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（即透明）.优点：线程管理是在用户空间进行的，因而效率比较高。缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞：多个线程不能并行地运行在多处理机上。</p><p>2）一对一模型。将每个用户级线程映射到一个内核级线程。优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能</p><p>3）多对多模型。将n个用户级线程映射到m个内核级线程上，要求m≤n特点：在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长</p><h3 id="1-7-处理机调度的概念、层次"><a href="#1-7-处理机调度的概念、层次" class="headerlink" title="1.7 处理机调度的概念、层次"></a>1.7 处理机调度的概念、层次</h3><p><img src="https://img-blog.csdnimg.cn/20200602121604324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020040809253446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200408092917283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><p><img src="https://img-blog.csdnimg.cn/20210218200901411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><p><img src="https://img-blog.csdnimg.cn/20210218200945224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601114353166.png" alt="image-20210601114353166"></p><h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><p><img src="https://img-blog.csdnimg.cn/2021021820113736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h4><p>在多道程序系统中，进程的数量往往多于处理机的个数，进程争用处理机的情况就在所难免。<br>处理机调度是对处理机进行分配，就是从就绪队列中，按照一定的算法（公平、高效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行，处理机调度是多道程序操作系统的基础，它是操作系统设计的核心问题</p><h4 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h4><p>作业从提交开始直到完成，往往要经历以下三级调度<br>1）作业调度。又称高级调度，其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入输出设备等必要的资源，并建立相应的进程，以使它（们）获得竞争处理机的权利。简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次，多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。<br>2）中级调度。又称内存调度。引入中级调度是为了提高内存利用率和系统吞吐量。为此应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待<br>3）进程调度。又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次</p><h4 id="三级调度的联系"><a href="#三级调度的联系" class="headerlink" title="三级调度的联系"></a>三级调度的联系</h4><p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行状态，把CPU分配给它。<br>中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒<br>1）作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间<br>2）作业调度次数少，中级调度次数略多，进程调度频率最高。<br>3）进程调度是最基本的，不可或缺</p><p><img src="https://img-blog.csdnimg.cn/20200408092848537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-8-进程调度的时机、切换与过程、方式"><a href="#1-8-进程调度的时机、切换与过程、方式" class="headerlink" title="1.8 进程调度的时机、切换与过程、方式"></a>1.8 进程调度的时机、切换与过程、方式</h3><h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h4><p><img src="https://img-blog.csdnimg.cn/20210218201609623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218201741149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218201824662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>进程调度和切换程序是操作系统内核程序。当请求调度的事件发生后，才可能会运行进程调度程序，当调度了新的就绪进程后，才会去进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，在操作系统内核程序运行时，如果某时发生了引起进程调度的因素，并不一定能够马上进行调度与切换。</p><p><strong>现代操作系统中，不能进行进程的调度与切换的情况有以下几种情况</strong><br>1）在处理中断的过程中：中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。<br>2）进程在操作系统内核程序临界区中：进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。<br>3）其他需要完全屏蔽中断的原子操作过程中：如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。如果在上述过程中发生了引起调度的条件，并不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。</p><p><strong>应该进行进程调度与切换的情况有</strong>：</p><p>1）当发生引起调度条件，且当前进程无法继续运行下去时，可以马上进行调度与切换。如果操作系统只在这种情况下进行进程调度，就是非剥夺调度<br>2）当中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。如果操作系统支持这种情况下的运行调度程序，就实现了剥夺方式的调度。<br>进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的现场信息推入到当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p><h4 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h4><p><img src="https://img-blog.csdnimg.cn/20210218201922547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>所谓进程调度方式是指当某一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。通常有以下两种进程调度方式</p><p>1）非剥夺调度方式，又称非抢占方式。是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。<br>在非剥夺调度方式下，一旦把CPU分配给一个进程，那么该进程就会保持CPU直到终止或转换到等待状态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。<br>2）剥夺调度方式，又称抢占方式。是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。</p><p>采用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有：优先权、短进程优先和时间片原则等。</p><h4 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h4><p><img src="https://img-blog.csdnimg.cn/20210218202035404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-9-调度算法的评价指标"><a href="#1-9-调度算法的评价指标" class="headerlink" title="1.9 调度算法的评价指标"></a>1.9 调度算法的评价指标</h3><h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h4><p><img src="https://img-blog.csdnimg.cn/20210218202359315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h4><p><img src="https://img-blog.csdnimg.cn/20210218202449483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p><img src="https://img-blog.csdnimg.cn/20210218202534195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218202623484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt=" "></p><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4><p><img src="https://img-blog.csdnimg.cn/20210218202824852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法所具有的特性。为了比较处理机调度算法的性能，人们提出很多评价准则，下面介绍主要的几种<br>1）CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU保持“忙”状态，使这一资源利用率最高<br>2）系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。<br>3）周转时间。是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处理机上运行以及进行输入输出操作所花费时间的总和。<br>4）等待时间。是指进程处于等处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法的优劣，常常只需简单地考察等待时间。<br>5）响应时间。是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一</p><h3 id="1-10-FCFS、SJF、HRRN调度算法"><a href="#1-10-FCFS、SJF、HRRN调度算法" class="headerlink" title="1.10 FCFS、SJF、HRRN调度算法"></a>1.10 FCFS、SJF、HRRN调度算法</h3><p>在操作系统中存在多种调度算法，<code>其中有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用</code>。下面介绍几种常用的调度算法。</p><p><img src="https://img-blog.csdnimg.cn/20210218204030759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="先来先服务（FCFS）调度算法"><a href="#先来先服务（FCFS）调度算法" class="headerlink" title="先来先服务（FCFS）调度算法"></a>先来先服务（FCFS）调度算法</h4><p><img src="https://img-blog.csdnimg.cn/20210218203207451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218203231218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。</p><p>FCFS调度算法属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。FCFS调度算法的特点是算法简单，但效率低：对长作业比较有利，但对短作业不利（相对SJF和高响应比）：有利于CPU繁忙型作业，而不利于I/O繁忙型作业。</p><h4 id="短作业优先（SJF）调度算法"><a href="#短作业优先（SJF）调度算法" class="headerlink" title="短作业优先（SJF）调度算法"></a>短作业优先（SJF）调度算法</h4><p><img src="https://img-blog.csdnimg.cn/20210218203434618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218203616700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218203707934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先（SJF）调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先（SPF）调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</p><p>SJF调度算法也存在不容忽视的缺点：<br>1）该算法对长作业不利，SJF调度算法中长作业的周转时间会增加。更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些（即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”.后者是系统环形等待，前者是调度策略问题）.<br>2）该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。<br>3）由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。<br>注意，SJF调度算法的平均等待时间、平均周转时间最少</p><h4 id="高响应比优先调度算法HRRN"><a href="#高响应比优先调度算法HRRN" class="headerlink" title="高响应比优先调度算法HRRN"></a>高响应比优先调度算法HRRN</h4><p><img src="https://img-blog.csdnimg.cn/20210218203839373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218203900804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行</p><h3 id="1-11-时间片轮转、优先级、多级反馈队列"><a href="#1-11-时间片轮转、优先级、多级反馈队列" class="headerlink" title="1.11 时间片轮转、优先级、多级反馈队列"></a>1.11 时间片轮转、优先级、多级反馈队列</h3><p><img src="https://img-blog.csdnimg.cn/20210218205155253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h4><p><img src="https://img-blog.csdnimg.cn/20210218204419708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218204514230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms.在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。<br>在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。</p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p><img src="https://img-blog.csdnimg.cn/20210218204646593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218204718346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218204738133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p><img src="https://img-blog.csdnimg.cn/20210218204948784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218205035647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展，如图2-5所示。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间。</p><p>多级反馈队列调度算法的实现思想如下：<br>1）应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。</p><p>2）赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长1倍…第计+1级队列的时间片要比第i级队列的时间片长1倍。</p><p>3）当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列如此下去，当一个长进程从第1级队列依次降到第n级队列后，在第n级队列中便釆用时间片轮转的方式运行。</p><p>4）仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1（-1）级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时又有新进程进入优先级较高的队列（第1~（-1）中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。多级反馈队列的优势有以下几点。</p><p>1）终端型作业用户：短作业优先。<br>2）短批处理作业用户：周转时间较短<br>3）长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理</p><h3 id="1-12-进程同步、互斥"><a href="#1-12-进程同步、互斥" class="headerlink" title="1.12 进程同步、互斥"></a>1.12 进程同步、互斥</h3><p><img src="https://img-blog.csdnimg.cn/20200603000704755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>临界资源</strong><br>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等.此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源.<br>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。<br><strong>同步</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602105321250.png" alt="image-20210602105321250"></p><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作<br>例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A</p><p><strong>互斥</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602105226378.png" alt="image-20210602105226378"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602105446229.png" alt="image-20210602105446229"></p><p>互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源<br>例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时，系统已将打印机分配给进程B，则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。<br>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：<br>1）空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区<br>2）忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。<br>3）有限等待。对请求访问的进程，应保证能在有限时间内进入临界区<br>4)让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待</p><h4 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h4><p><img src="https://img-blog.csdnimg.cn/20210220212750798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210220212506232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220212543496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220212617407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220212710319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>软件实现方法</strong></p><ul><li>单标志法。</li><li>双标志法先检查</li><li>双标志法后检查。</li><li>Peterson’s Algorithm</li></ul><p><strong>硬件实现方法</strong></p><p>1）<code>中断屏蔽方法</code><br>当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单方法是禁止一切中断发生，或称之为屏蔽中断、关中断。因为CPU只在发生中断时引起进程切换，这样屏蔽中断就能保证当前运行进程将临界区代码顺利地执行完，从而保证了互斥的正确实现，然后再执行开中断。其典型模式<br>…<br>关中断；<br>临界区；<br>开中断；<br>…<br>这种方法限制了处理机交替执行程序的能力，因此执行的效率将会明显降低。对内核来说当它执行更新变量或列表的几条指令期间关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断之后不再开中断，则系统可能会因此终止。</p><p>2）<code>硬件指令方法</code></p><ul><li>TestAndSet指令</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602111641733.png" alt="image-20210602111641733"></p><ul><li>Swap指令</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602111656074.png" alt="image-20210602111656074"></p><h3 id="1-13-信号量"><a href="#1-13-信号量" class="headerlink" title="1.13 信号量*"></a>1.13 信号量*</h3><p><img src="https://img-blog.csdnimg.cn/20210220212940947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213023527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213143348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213209435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213417600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213503108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213534503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021022021355937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>信号量机构是一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准的原语wait(S)和 signal(S)来访问，也可以记为“P操作”和“V操作”.<br>原语是指完成某种功能且不被分割不被中断执行的操作序列，通常可由硬件来实现完成不被分割执行特性的功能。如前述的“ Test-and-Set”和“Swap”指令，就是由硬件实现的原子操作。<br>原语功能的不被中断执行特性在单处理机时可由软件通过屏蔽中断方法实现。<br>原语之所以不能被中断执行，是因为原语对变量的操作过程如果被打断，可能会去运行另个对同一变量的操作过程，从而出现临界段问题。如果能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。</p><ul><li>整型信号量 </li><li>记录型信号量</li><li>利用信号量实现同步</li><li>利用信号量实现进程互斥</li><li>利用信号量实现前驱关系</li></ul><h3 id="1-14-经典同步问题"><a href="#1-14-经典同步问题" class="headerlink" title="1.14 经典同步问题"></a>1.14 经典同步问题</h3><p>见PDF 223页</p><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>问题描述：一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待：只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者个消费者从中取出消息</p><h4 id="多生产者多消费者"><a href="#多生产者多消费者" class="headerlink" title="多生产者多消费者"></a>多生产者多消费者</h4><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>问题描述：有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作：②只允许一个写者往文件中写信息：③任一写者在完成写操作之前不允许其他读者或写者工作；④写者行写操作前，应让已有的读者和写者全部退出</p><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>问题描述：一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭.哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当晢学家饥饿的时候，才试图拿起左、右两根筷子（一根一根地拿起）.如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕筷子继续思考</p><h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><p>问题描述：假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉完成了，供应者就会放另外两种材料在桌上，这种过程一直重复（让三个抽烟者轮流地抽烟）</p><h3 id="1-15-管程"><a href="#1-15-管程" class="headerlink" title="1.15 管程"></a>1.15 管程</h3><p><img src="https://img-blog.csdnimg.cn/20210220214731921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1 管程的定义<br>系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略了它们的内部结构和实现细节。管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程.</p><p>2 管程的纽成<br>1）局部于管程的共享结构数据说明<br>2）对该数据结构进行操作的一组过程。<br>3）对局部于管程的共享数据设置初始值的语句</p><p>3 管程的基本特性<br>1）局部于管程的数据只能被局部于管程内的过程所访问<br>2）一个进程只有通过调用管程内的过程才能进入管程访问共享数据<br>3）每次仅允许一个进程在管程内执行某个内部过程。<br>由于管程是一个语言成分，所以管程的互斥访问完全由编译程序在编译时自动添加，无需程序员关注，而且保证正确.</p><p><strong>这里，我们再用生活化的语言介绍什么是管程。</strong><br>管程实质上是一个抽象类，这个抽象类有好几个成员变量，系统中任何设备都可以通过这几成员变量进行区分和描述：管程中还有对这些成员变量进行操作的一组成员函数，例如，对外设的操作中，会有read，write这一类函数。假如，进程P0要使用一台打印机，于是管程这个抽象类就会利用初始值语句对自身的几个成员变量赋初值（这个行为不需要程序员关注），特定的几个初值可以让管程表示成一台打印机，进程P0进入管程后，通过调用管程中的成员函数（即上面所说的过程）对这台打印机进行操作。每次进入这个管程的，只能是一个进程</p><h3 id="1-16-死锁"><a href="#1-16-死锁" class="headerlink" title="1.16 死锁"></a>1.16 死锁</h3><p><img src="https://img-blog.csdnimg.cn/20200603082933257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220214929860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021022021502281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220215048244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021022021511267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220215138752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>死锁的定义</strong><br>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题—死锁。所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进.在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入设备进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p><p><strong>死锁产生的原因</strong><br>（1）系统资源的竞争<br>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。<br>（2）进程推进顺序非法<br>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程P1P2分别保持了资源R1、R2，而进程Pl申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，结果也会使得这些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁.<br>（3）死锁产生的必要条件<br>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）.请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p><p><img src="https://img-blog.csdnimg.cn/20200603074928110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>资源分配图含圈而系统又不一定有死锁的原因是同类资源数大于1.但若系统中每类资源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。要注意区分不可剥夺条件与请求和保持条件，用一个简单的例子来说明：如果你手上拿着个苹果（即便你不打算吃），别人不能把你手上的苹果拿走，那就是不可剥夺条件；如果你左手拿着一个苹果，允许你右手再去拿一个苹果，那就是请求和保持条件。</p><h3 id="1-17-死锁的处理策略"><a href="#1-17-死锁的处理策略" class="headerlink" title="1.17 死锁的处理策略"></a>1.17 死锁的处理策略</h3><p>为使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一，或者允许死锁产生，但当死锁发生时能检测出死锁，并有能力实现恢复<br><strong>预防死锁</strong><br>设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个，以防止发生死锁<br><strong>避免死锁</strong><br>在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁<br><strong>死锁的检测及解除</strong><br>无需采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。<br>预防死锁和避免死锁都属于事先预防策略，但预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低：避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。</p><p><img src="https://img-blog.csdnimg.cn/20200603075414636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-17-1-死锁预防"><a href="#1-17-1-死锁预防" class="headerlink" title="1.17.1 死锁预防"></a>1.17.1 死锁预防</h4><p>防止死锁的发生只需破坏死锁产生的四个必要条件之一即可</p><p><strong>破坏互斥条件</strong><br>如果允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性</p><p><strong>破坏不剥夺条件</strong><br>当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放或者说是被剥夺了，或从而破坏了不可剥夺条件</p><p>该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量.这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源</p><p><strong>破坏请求和保持条件</strong><br>采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求这样就可以保证系统不会发生死锁</p><p>这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p><p><strong>破坏循环等待条件</strong><br>为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源.</p><p>这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加：尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费：此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦.</p><h4 id="1-17-2-死锁避免"><a href="#1-17-2-死锁避免" class="headerlink" title="1.17.2 死锁避免"></a>1.17.2 死锁避免</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210603162257147.png" alt="image-20210603162257147"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210603162451927.png" alt="image-20210603162451927"></p><p><strong>则可以引入银行家算法，见PDF 290页</strong></p><h4 id="1-17-3-死锁检测和解除"><a href="#1-17-3-死锁检测和解除" class="headerlink" title="1.17.3 死锁检测和解除"></a>1.17.3 死锁检测和解除</h4><p>前面介绍的死锁预防和避免算法，都是在为进程分配资源时施加限制条件或进行检测，若系统为进程分配资源时不采取任何措施，则应该提供死锁检测和解除的手段。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210603163502062.png" alt="image-20210603163502062"></p><p><strong>具体见PDF 299页</strong></p><h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><p><img src="https://img-blog.csdnimg.cn/20200711083859717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-1-内存管理的概念"><a href="#1-1-内存管理的概念" class="headerlink" title="1.1 内存管理的概念"></a>1.1 内存管理的概念</h2><p><img src="https://img-blog.csdnimg.cn/20200705083124193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200705083705203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>内存管理</strong>（ Memory Management）是操作系统设计中最重要和最复杂的内容之一。操作系统对内存的划分和动态分配，就是内存管理的概念<br>内存管理的功能有：<br>内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</p><p><strong>地址转换</strong>：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。</p><p>内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</p><p><strong>存储保护</strong>：保证各道作业在各自的存储空间内运行，互不干扰。<br>在进行具体的内存管理之前，需要了解进程运行的基本原理和要求。</p><p><strong>程序装入和链接</strong></p><p>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤</p><p><code>编译</code>：由编译程序将用户源代码编译成若干个目标模块<br><code>链接</code>：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块<br><code>装入</code>：由装入程序将装入模块装入内存运行。</p><p>程序的链接有以下三种方式</p><p><code>静态链接</code>：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。</p><p><code>装入时动态链接</code>：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式</p><p><img src="https://img-blog.csdnimg.cn/20200604130139117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>运行时动态链接</code>：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享</p><p>内存的装入模块在装入内存时，同样有以下三种方式：</p><p>1）<code>绝对装入</code>。在编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改<br>绝对装入方式只适用于单道程序环境。另外，程序中所使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。而通常情况下在程序中采用的是符号地址，编译或汇编时再转换为绝对地址。</p><p>2）<code>可重定位装入</code>。在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，所以又称为静态重定位，如图（a）所示。</p><p><img src="https://img-blog.csdnimg.cn/20200604130820626.png" alt="在这里插入图片描述"></p><p>静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。此外，作业一旦进入内存后，在整个运行期间不能在内存中移动，也不能再申请内存空间</p><p>动态运行时装入，也称为<code>动态重定位</code>，程序在内存中如果发生移动，就需要采用动态的装入方式。装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持，如图（b）所示<br>动态重定位的特点是可以将程序分配到不连续的存储区中：在程序运行之前可以只装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存：便于程序段的共享,可以向用户提供一个比存储空间大得多的地址空间</p><p><img src="https://img-blog.csdnimg.cn/20200604131137834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>逻辑地扯空间与物理地址空间</strong></p><p>编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址（或逻辑地址）.<br>链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间。用户程序和程序员只需知道逻辑地址而内存管理的具体机制则是完全透明的，它们只有系统编程人员才会涉及。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置.物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位</p><p><strong>内存保护</strong></p><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法</p><ul><li><p>在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界</p></li><li><p>通过采用重定位寄存器（或基址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值。每个逻辑地址值必须小于界地址寄存器；内存管理机构动态地将逻辑地址与界地址寄存器进行比较，如果未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如图3-3所示</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200604131837577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当CPU调度程序选择进程执行时，派遣程序会初始化重定位寄存器和界地址寄存器。每个逻辑地址都需要与这两个寄存器进行核对，以保证操作系统和其他用户程序及数据不被该进程的运行所影响.实现内存保护需要重定位寄存器和界地址寄存器，注意两者的区别。重定位寄存器是用来“加”的，逻辑地址加上重定位寄存器中的值就能得到物理地址;界地址寄存器是用来“比”的通过比较界地址寄存器中的值与重定位寄存器加上逻辑地址的值来判断是否越界</p><h2 id="1-2-覆盖与交换"><a href="#1-2-覆盖与交换" class="headerlink" title="1.2 覆盖与交换"></a>1.2 覆盖与交换</h2><p><img src="https://img-blog.csdnimg.cn/20200705085655673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法</p><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决</p><p><strong>覆盖的基本思想</strong>：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区.其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段.</p><p><strong>覆盖技术的特点</strong>是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆准区的段，不在覆盖区中的段会常驻内存</p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p><strong>交换（对换）的基本思想</strong>，把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出：把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。</p><p>例如，有一个CPU采用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。同时，CPU调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行.</p><p>有关交换需要注意以下几个问题<br>交换需要备份存储，通常是快速磁盘。它必须足够大，并且提供对这些内存映像的直接访问。为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间。转移时间与所交换的内存空间成正比.如果换出进程，必须确保该进程是完全处于空闲状态.交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。普通的交换使用不多，但交换策略的某些变种在许多系统中（如UNⅨ系统）仍发挥作用</p><p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史：而交换技术在现代操作系统中仍具有较强的生命力</p><h2 id="1-3-连续分配管理方式"><a href="#1-3-连续分配管理方式" class="headerlink" title="1.3 连续分配管理方式"></a>1.3 连续分配管理方式</h2><p><img src="https://img-blog.csdnimg.cn/20200705092720324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>连续分配方式，是指为一个用户程序分配一个连续的内存空间，比如说某用户需要1GB的内存空间，它就在内存空间中分配一块连续的1GB的空间给用户。它主要包括单一连续分配/固定分区分配和动态分区分</p><p><strong>单一连续分配</strong></p><p>内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分.用户区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。因为内存中永远只有一道程序，肯定不会因为访问越界而干扰其他程序。</p><p>这种方式的优点是简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低</p><p><strong>固定分区分配</strong></p><p>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中，选择适当大小的作业装入该分区，如此循环固定分区分配在划分分区时，有两种不同的方法，如图3-4所示</p><p><img src="https://img-blog.csdnimg.cn/20200604134943455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>分区大小相等</code>：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性</p><p><code>分区大小不等</code>：划分为含有多个较小的分区、适量的中等分区及少量的大分区。</p><p>为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配），如图3-5（a）所示。当有用户程序要装入时，便检索该表，以找到合适的分区给予分配并将其状态置为“已分配”,未找到合适分区则拒绝为该用户程序分配内存。存储空间的分配情况如图3-5（b）所示</p><p><strong>这种分区方式存在两个问题</strong>：一是程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间：二是主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部有空间浪费，这种现象称为内部碎片。</p><p>固定分区是可用于多道程序设计最简单的存储分配，无外部碎片，但不能实现多进程共享一个主存区，所以存储空间利用率低。固定分区分配很少用于现在通用的操作系统中，但在某些用于控制多个相同对象的控制系统中仍发挥着一定的作用。</p><p><img src="https://img-blog.csdnimg.cn/20200604135858857.png" alt="在这里插入图片描述"></p><h2 id="1-4-动态分区分配"><a href="#1-4-动态分区分配" class="headerlink" title="1.4 动态分区分配"></a>1.4 动态分区分配</h2><p><img src="https://img-blog.csdnimg.cn/2020070509353090.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>动态分区分配又称为可变分区分配</code>，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。</p><p><img src="https://img-blog.csdnimg.cn/2020060414101810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如图所示，系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。开始时装入前三个进程，在它们分别分配到所需空间后，内存只剩下4MB，进程4无法装入。在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4.由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。之后CPU又出现空闲，而主存无法容纳进程2，操作系统就换出进程1，换入进程2.</p><p>动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块。随着时间的推移，内存中会产生越来越多的碎片（图3-6中最后的4MB和中间的6MB，且随着进程的换入换出,很可能会出现更多更小的内存块），内存的利用率随之下降。这些小的内存块称为外部碎片，指在所有分区外的存储空间会变成越来越多的碎片，这与固定分区中的内部碎片正好相对。克服外部碎片可以通过紧凑（ Compaction）技术来解决，就是操作系统不时地对进程进行移动和整理</p><p>但是这需要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于 Windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑.<br>在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略，考虑以下几种算法</p><p>1）<code>首次适应（ First Fit）算法</code>：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区<br>2）<code>最佳适应（ Best Fit）算法</code>：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区<br>最坏适应（ Worst Fit）算法：又称最大适应（ Largest Fit）算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区<br>3）<code>邻近适应（ Next Fit）算法</code>：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找</p><p>在这几种方法中，首次适应算法不仅是最简单的，而且通常也是最好和最快的。在UNIX系统的最初版本中，就是使用首次适应算法为进程分配内存空间，其中使用数组的数据结构（而非链表）来实现。不过，首次适应算法会使得内存的低地址部分出现很多小的空闲分区,而每次分配查找时，都要经过这些分区，因此也增加了查找的开销</p><p>邻近适应算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间（因为在遍扫描中，内存前面部分使用后再释放时，不会参与分配），分裂成小碎片。它通常比首次适应算法的结果要差</p><p>最佳适应算法虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，它会产生最多的外部碎片</p><p>最坏适应算法与最佳适应算法相反，选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大的内存块，因此性能也非常差</p><p>Knuth和Shore分别就前三种方法对内存空间的利用情况做了模拟实验，结果表明首次适应算法可能比最佳适应法效果好，而它们两者一定比最大适应法效果好。另外注意，在算法实现时，分配操作中最佳适应法和最大适应法需要对可用块进行排序或遍历查找，而首次适应法和邻近适应法只需要简单查找：回收操作中，当回收的块与原来的空闲块相邻时（有三种相邻的情况，比较复杂），需要将这些块合并。在算法实现时，使用数组或链表进行管理。除了内存的利用率，这里的算法开销也是操作系统设计需要考虑的一个因素</p><p><img src="https://img-blog.csdnimg.cn/2020060414223979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-5-基本分页存储管理的基本概念"><a href="#1-5-基本分页存储管理的基本概念" class="headerlink" title="1.5 基本分页存储管理的基本概念"></a>1.5 基本分页存储管理的基本概念</h2><p><img src="https://img-blog.csdnimg.cn/20200705144615215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>非连续分配管理方式</strong></p><p>非连续分配允许一个程序分散地装入到不相邻的内存分区中。在连续分配管理方式中我们发现，即使内存有超过1GB的空闲空间，但如果没有连续的1GB的空间，需要1GB空间的作业仍然是无法运行的；但如果采用非连续分配管理方式，作业所要求的1GB内存空间可以分散地分配在内存的各个区域，当然，这也需要额外的空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续存储方式</p><p>非连续分配管理方式根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。下面介绍基本分页存储管理方式。</p><p><strong>基本分页存储管理方式</strong></p><p>固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低.我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。但它又有本质的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才生成主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平<br>均只产生半个块大小的内部碎片（也称页内碎片）.</p><p><img src="https://img-blog.csdnimg.cn/20200604144448210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604150239308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>*<img src="https://img-blog.csdnimg.cn/20200604150407527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="加粗样式"></p><h2 id="1-6-基本地址变换机构"><a href="#1-6-基本地址变换机构" class="headerlink" title="1.6 基本地址变换机构"></a>1.6 基本地址变换机构</h2><p><img src="https://img-blog.csdnimg.cn/20200705161226230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604152256836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604154934221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-7-具有快表的地址变换机构"><a href="#1-7-具有快表的地址变换机构" class="headerlink" title="1.7 具有快表的地址变换机构"></a>1.7 具有快表的地址变换机构</h2><p><img src="https://img-blog.csdnimg.cn/20200604155151158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604155409990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="加粗样式"><br><img src="https://img-blog.csdnimg.cn/20200705162805426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-8-两级页表"><a href="#1-8-两级页表" class="headerlink" title="1.8 两级页表"></a>1.8 两级页表</h2><p><img src="https://img-blog.csdnimg.cn/20200604155533303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604155611809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202007051653310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-9-基本分段存储管理方式"><a href="#1-9-基本分段存储管理方式" class="headerlink" title="1.9 基本分段存储管理方式"></a>1.9 基本分段存储管理方式</h2><p><img src="https://img-blog.csdnimg.cn/2020060416083722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604160902726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604161001886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200705171647698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-10-段页式管理方式"><a href="#1-10-段页式管理方式" class="headerlink" title="1.10 段页式管理方式"></a>1.10 段页式管理方式</h2><p><img src="https://img-blog.csdnimg.cn/20200604161136560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604161206254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200705175323749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-11-虚拟内存的基本概念"><a href="#1-11-虚拟内存的基本概念" class="headerlink" title="1.11 虚拟内存的基本概念"></a>1.11 虚拟内存的基本概念</h2><p><strong>传统存储管理方式的特征</strong></p><p>1）时间局部性<br>2）空间局部性</p><p><strong>虚拟存储器的定义和特征</strong></p><p>1）多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存<br>2）对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。<br>3）虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。</p><p><strong>虚拟内存技术的实现</strong></p><p>虚拟内存的实现有以下三种方式</p><p><code>请求分页存储管理 请求分段存储管理 请求段页式存储管理</code></p><p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面</p><ul><li>定容量的内存和外存</li><li>页表机制（或段表机制），作为主要的数据结构</li><li>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断</li><li>地址变换机构，逻辑地址到物理地址的变换</li></ul><p><img src="https://img-blog.csdnimg.cn/20200705182312176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-12-请求分页管理方式"><a href="#1-12-请求分页管理方式" class="headerlink" title="1.12 请求分页管理方式"></a>1.12 请求分页管理方式</h2><p><img src="https://img-blog.csdnimg.cn/20200705184734624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-13-页面置换算法（决定应该换入哪页换出哪页）"><a href="#1-13-页面置换算法（决定应该换入哪页换出哪页）" class="headerlink" title="1.13 页面置换算法（决定应该换入哪页换出哪页）"></a>1.13 页面置换算法（决定应该换入哪页换出哪页）</h2><p><img src="https://img-blog.csdnimg.cn/20200705195258840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200710184701146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200710184719340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200710184731447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200710184747935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-14-页面分配策略"><a href="#1-14-页面分配策略" class="headerlink" title="1.14 页面分配策略"></a>1.14 页面分配策略</h2><p><img src="https://img-blog.csdnimg.cn/20200705201739116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-15-抖动"><a href="#1-15-抖动" class="headerlink" title="1.15 抖动"></a>1.15 抖动</h2><p><img src="https://img-blog.csdnimg.cn/20210221101932861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-16-工作集"><a href="#1-16-工作集" class="headerlink" title="1.16 工作集"></a>1.16 工作集</h2><p><img src="https://img-blog.csdnimg.cn/20210221102019306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="四、文件管理"><a href="#四、文件管理" class="headerlink" title="四、文件管理"></a>四、文件管理</h1><h2 id="1-1-初识文件管理"><a href="#1-1-初识文件管理" class="headerlink" title="1.1 初识文件管理"></a>1.1 初识文件管理</h2><p><img src="https://img-blog.csdnimg.cn/20210221102430890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>文件</strong>（File）是操作系统中的一个重要概念。文件是以计算机硬盘为载体存储在计算机上的信息集合，文件可以是文本文档、图片、程序，等等。</p><p>1）数据项。数据项是文件系统中最低级的数据组织形式，可分为以下两种类型：<br>基本数据项：用于描述一个对象的某种属性的一个值，如姓名、日期或证件号等，是数据中可命名的最小逻辑数据单位，即原子数据<br>组合数据项：由多个基本数据项组成。<br>2）记录。记录是一组相关的数据项的集合，用于描述一个对象在某方面的属性，如一个考生报名记录包括考生姓名、出生日期、报考学校代号、身份证号等一系列域<br>3）文件。文件是指由创建者所定义的一组相关信息的集合，逻辑上可分为有结构文件和无结构文件两种。在有结构文件中，文件由一组相似记录组成，如报考某学校的所有考生的报考信息记录，又称记录式文件：而无结构文件则被看成是一个字符流，比如一个二进制文件或字符文件，又称流式文件.</p><p><strong>文件的属性</strong></p><p>文件有一定的属性，这根据系统的不同而有所不同，但是通常都包括如下属性。<br>①名称：文件名称唯一，以容易读取的形式保存<br>②标识符：标识文件系统内文件的唯一标签，通常为数字，它是对人不可读的一种内部名称。<br>③类型：被支持不同类型的文件系统所使用<br>④位置：指向设备和设备上文件的指针。<br>⑤大小：文件当前大小（用字节、字或块表示），也可包含文件允许的最大值。<br>⑥保护：对文件进行保护的访问控制信息<br>⑦时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息，用于保护、安全跟踪文件的使用.<br>所有文件的信息都保存在目录结构中，而目录结构也保存在外存上。文件信息当需要时再调入内存。通常，目录条目包括文件名称及其唯一标识符，而标识符定位其他属性的信息.</p><p><strong>文件的基本操作</strong></p><p>文件属于抽象数据类型。为了恰当地定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，它对文件进行创建、写、读、定位和截断。<br>①创建文件：创建文件有两个必要步骤，一是在文件系统中为文件找到空间：二是在目录中为新文件创建条目，该条目记录文件名称、在文件系统中的位置及其他可能信息<br>②写文件：为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容。对于给定文件名称，系统搜索目录以查找文件位置。系统必须为该文件维护一个写位置的指针。每当发生写操作，便更新写指针<br>③读文件：为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置。<br>同样，需要搜索目录以找到相关目录项，系统维护一个读位置的指针。每当发生读操作时，更新读指针。一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。由于读和写操作都使用同一指针，节省了空间也降低了系统复杂度。<br>④文件重定位（文件寻址）：按某条件搜索目录，将当前文件位置设为给定值，并且不会读写文件<br>⑤删除文件：先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间<br>⑥截断文件：允许文件所有属性不变，并删除文件内容，即将其长度设为0并释放其空间<br>这6个基本操作可以组合执行其他文件操作。例如，一个文件的复制，可以创建新文件、从旧文件读出并写入到新文件</p><p><strong>文件的打开与关闭</strong></p><h2 id="1-2-文件的逻辑结构"><a href="#1-2-文件的逻辑结构" class="headerlink" title="1.2 文件的逻辑结构"></a>1.2 文件的逻辑结构</h2><p><img src="https://img-blog.csdnimg.cn/20200704080830897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>按逻辑结构，文件有无结构文件和有结构文件两种类型：<br>1 无结构文件（流式文件）<br>2.有结构文件（记录式文件）<br>1）顺序文件<br>2）索引文件<br>3）索引顺序文件是顺序和索引两种组织形式的结合.<br>4）直接文件或散列文件（ Hash File）</p><h2 id="1-3-文件目录"><a href="#1-3-文件目录" class="headerlink" title="1.3 文件目录"></a>1.3 文件目录</h2><p><img src="https://img-blog.csdnimg.cn/20200704083545250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>文件控制块和索引结点</strong><br>1）文件控制块。文件控制块（FCB）是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”.FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。为了创建配一个FCB并存放在文件目录中，成为目录项</p><p><strong>FCB主要包含以下信息：</strong><br>基本信息，如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。<br>存取控制信息，如文件存取权限等<br>使用信息，如文件建立时间、修改时间等<br>2）索引结点</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><img src="https://img-blog.csdnimg.cn/20200610161755526.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610162141697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610162211853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610162700847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="4）无环图目录结构。"></p><p><img src="https://img-blog.csdnimg.cn/20200704114453333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-4-文件物理结构"><a href="#1-4-文件物理结构" class="headerlink" title="1.4 文件物理结构"></a>1.4 文件物理结构</h2><p><img src="https://img-blog.csdnimg.cn/20210221111739893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-4-1-链接分配"><a href="#1-4-1-链接分配" class="headerlink" title="1.4.1 链接分配"></a>1.4.1 链接分配</h3><p><img src="https://img-blog.csdnimg.cn/2021022111153759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-4-2-索引分配"><a href="#1-4-2-索引分配" class="headerlink" title="1.4.2 索引分配"></a>1.4.2 索引分配</h3><p><img src="https://img-blog.csdnimg.cn/20210221111647235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-5-文件存储空间管理"><a href="#1-5-文件存储空间管理" class="headerlink" title="1.5 文件存储空间管理"></a>1.5 文件存储空间管理</h2><p><img src="https://img-blog.csdnimg.cn/20200704123728867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-6-文件的基本操作"><a href="#1-6-文件的基本操作" class="headerlink" title="1.6 文件的基本操作"></a>1.6 文件的基本操作</h2><p><img src="https://img-blog.csdnimg.cn/20200704124644171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-7-文件共享"><a href="#1-7-文件共享" class="headerlink" title="1.7 文件共享"></a>1.7 文件共享</h2><p><img src="https://img-blog.csdnimg.cn/20200704125140509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-8-文件保护"><a href="#1-8-文件保护" class="headerlink" title="1.8 文件保护"></a>1.8 文件保护</h2><p><img src="https://img-blog.csdnimg.cn/20210221112629665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-9-文件系统层次结构"><a href="#1-9-文件系统层次结构" class="headerlink" title="1.9 文件系统层次结构"></a>1.9 文件系统层次结构</h2><p><img src="https://img-blog.csdnimg.cn/20200704130311622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200704130352457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610200728418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610200858608.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610200955594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="五、磁盘管理"><a href="#五、磁盘管理" class="headerlink" title="五、磁盘管理"></a>五、磁盘管理</h1><h2 id="1-1-磁盘的结构"><a href="#1-1-磁盘的结构" class="headerlink" title="1.1 磁盘的结构"></a>1.1 磁盘的结构</h2><p><img src="https://img-blog.csdnimg.cn/20200704130854420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-2-磁盘调度算法"><a href="#1-2-磁盘调度算法" class="headerlink" title="1.2 磁盘调度算法"></a>1.2 磁盘调度算法</h2><p><img src="https://img-blog.csdnimg.cn/20200704133834864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200704133927225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200704134016916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020070413410374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200704134142131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200704134254195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200704134413468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-3-减少磁盘延迟时间的方法"><a href="#1-3-减少磁盘延迟时间的方法" class="headerlink" title="1.3 减少磁盘延迟时间的方法"></a>1.3 减少磁盘延迟时间的方法</h2><p><img src="https://img-blog.csdnimg.cn/20200704135844178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-4-磁盘的管理"><a href="#1-4-磁盘的管理" class="headerlink" title="1.4 磁盘的管理"></a>1.4 磁盘的管理</h2><p><img src="https://img-blog.csdnimg.cn/20200704142108418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200610215752183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="六、设备管理"><a href="#六、设备管理" class="headerlink" title="六、设备管理"></a>六、设备管理</h1><h2 id="输入输出（I-O）管理"><a href="#输入输出（I-O）管理" class="headerlink" title="输入输出（I/O）管理"></a>输入输出（I/O）管理</h2><h3 id="1-I-O设备的概念和分类"><a href="#1-I-O设备的概念和分类" class="headerlink" title="1. I-O设备的概念和分类"></a>1. I-O设备的概念和分类</h3><p><img src="https://img-blog.csdnimg.cn/2020070315120126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>按使用特性可分为以下类型</strong><br>1）人机交互类外部设备：用于与计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换的。<br>2）存储设备：用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。<br>3）网络通信设备：用于与远程设备通信的设备，如各种网络接口、调制解调器等。其速度介于前两类设备之间。<br>除了上面最常见的分类方法，I/O设备还可以按以下方法分类</p><p><strong>按传输速率分类</strong><br>1）低速设备：传输速率仅为每秒几个到数百个字节的一类设备，如键盘、鼠标等。<br>2）中速设备：传输速率在每秒数千个字节至数万个字节的一类设备，如行式打印机、激光打印机等<br>3）高速设备：传输速率在数百个千字节至千兆字节的一类设备，如磁带机、磁盘机、光盘机等。</p><p><strong>按信息交换的单位分类</strong><br>1）块设备：由于信息的存取总是以数据块为单位的，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高，以及可寻址，即对它可随机地读/写任一块<br>2）字符设备：用于数据输入输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且在输入输出时常采用中断驱动方式。</p><h3 id="2-I-O控制器"><a href="#2-I-O控制器" class="headerlink" title="2. I-O控制器"></a>2. I-O控制器</h3><p><img src="https://img-blog.csdnimg.cn/20200703151309306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-I-O控制方式"><a href="#3-I-O控制方式" class="headerlink" title="3. I-O控制方式"></a>3. I-O控制方式</h3><p><img src="https://img-blog.csdnimg.cn/2020070315140685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>设备管理的主要任务之一是控制设备和内存或处理机之间的数据传送。外围设备和内存之间的输入输出控制方式有四种，下面分别介绍。</p><p><strong>程序直接控制方式</strong></p><p>如图5-1（a）所示，计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在IO控制器的数据寄存器中。在程序直接控制方式中，由于CPU的高速性和I/O设备的低速性，致使CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中，造成了CPU资源的极大浪费。在该方式中，CPU之所以要不断地测试I/O设备的状态，就是因为在CPU中没有采用中断机构，使I/O设备无法向CPU报告它已完成了一个字符的输入操作。</p><p><strong>中断驱动方式</strong></p><p>中断驱动方式的思想是，允许I/O设备主动打断CPU的运行并请求服务，从而“解放”CPU，使得其向I/O控制器发送读命令后可以继续做其他有用的工作。如图5-1（b）所示，我们从I/O控制器和CPU两个角度分别来看中断驱动方式的工作过程：</p><p>从I/O控制器的角度来看，I/O控制器从CPU接收一个读命令，然后从外围设备读数据，一旦数据读入到该I/O控制器的数据寄存器，便通过控制线给CPU发出一个中断信号，表示数据已准备好，然后等待CPU请求该数据。I/O控制器收到CPU发出的取数据请求后，将数据放到数据总线上，传到CPU的寄存器中。至此，本次I/O操作完成，I/O控制器又可开始下一次I/O操作。</p><p>从CPU的角度来看，CPU发出读命令，然后保存当前运行程序的上下文（现场，包括程序计数器及处理机寄存器），转去执行其他程序。在每个指令周期的末尾，CPU检查中断。当有来自I/O控制器的中断时，CPU保存当前正在运行程序的上下文，转去执行中断处理程序处理该中断。这时，CPU从I/O控制器读一个字的数据传送到寄存器，并存入主存。接着，CPU恢复发出I/O命令的程序（或其他程序）的上下文，然后继续运行。中断驱动方式比程序直接控制方式有效，但由于数据中的每个字在存储器与I/O控制器之间的传输都必须经过CPU，这就导致了中断驱动方式仍然会消耗较多的CPU时间。</p><p><strong>DMA方式</strong></p><p>在中断驱动方式中，I/O设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度还是受限，而DMA（直接存储器存取）方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底“解放”CPU.DMA方式的特点是<br>1）基本单位是数据块<br>2）所传送的数据，是从设备直接送入内存的，或者相反。<br>3）仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。</p><p><strong>通道控制方式</strong></p><p><img src="https://img-blog.csdnimg.cn/20200611002131137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-I-O软件层次结构"><a href="#4-I-O软件层次结构" class="headerlink" title="4. I-O软件层次结构"></a>4. I-O软件层次结构</h3><p><img src="https://img-blog.csdnimg.cn/20200703151513481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5-I-O核心子系统"><a href="#5-I-O核心子系统" class="headerlink" title="5. I-O核心子系统"></a>5. I-O核心子系统</h3><p><img src="https://img-blog.csdnimg.cn/20200703151554310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>由于I/O设备种类繁多，功能和传输速率差异巨大，需要多种方法来进行设备控制。这些方法共同组成了操作系统内核的I/O子系统，它将内核的其他方面从繁重的I/O设备管理中解放出来。I/O核心子系统提供的服务主要有：IO调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等</p><h3 id="6-假脱机技术"><a href="#6-假脱机技术" class="headerlink" title="6. 假脱机技术"></a>6. 假脱机技术</h3><p><img src="https://img-blog.csdnimg.cn/20200703151714594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>为了缓和CPU的高速性与I/O设备低速性之间的矛盾而引入了脱机输入/输出技术。该技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上；或者相反。 SPOOLing的意思是外部设备同时联机操作，又称为假脱机输入输出操作，是操作系统中采用的一项将独占设备改造成共享设备的技术。</p><p><strong>输入井和输出井</strong></p><p><img src="https://img-blog.csdnimg.cn/20200611082824989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>输入缓冲区和输出缓冲区</strong></p><p>在内存中开辟的两个缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备</p><p><strong>输入进程和输出进程</strong></p><p>输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井。当CPU需要输入数据时，直接将数据从输入井读入内存。输出进程模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备</p><h3 id="7-设备的分配与回收"><a href="#7-设备的分配与回收" class="headerlink" title="7. 设备的分配与回收"></a>7. 设备的分配与回收</h3><p><img src="https://img-blog.csdnimg.cn/20200703152532663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><p><strong>设备分配概述</strong></p><p>设备分配是指根据用户的I/O请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。从设备的特性来看，采用下述三种使用方式的设备分别称为独占设备、共享设备和虚拟设备。</p><p>1）独占式使用设备。指在申请设备时，如果设备空闲，就将其独占，不再允许其他进程申请使用，一直等到该设备被释放才允许其他进程申请使用。例如，打印机，在使用它打印时，只能独占式使用，否则在同一张纸上交替打印不同任务的内容，无法正常阅读。<br>2）分时式共享使用设备。独占式使用设备时，设备利用率很低，当设备没有独占使用的要求时，可以通过分时共享使用提高利用率。例如，对磁盘设备的I/O操作，各进程的每次I/O操作请求可以通过分时来交替进行。<br>3）以 SPOOLing方式使用外部设备。 SPOOLing（ Simultaneous Peripheral Operation On-Line)技术是在批处理操作系统时代引入的，即假脱机IO技术。这种技术用于对设备的操作，实质上就是对I/O操作进行批处理。 SPOOLing技术实质上是一种以空间换时间的技术，而我们熟悉的请求分页系统中的页面调度算法就刚好相反，是以时间换空间的技术。</p><p><strong>设备分配的数据结构</strong></p><p><strong>设备分配的策略</strong></p><p>1）设备分配原则：设备分配应根据设备特性、用户要求和系统配置情况。分配的总原则：既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。<br>2）设备分配方式：设备分配方式有静态分配和动态分配两种：<br>静态分配主要用于对独占设备的分配，它在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、控制器（如通道等）.一旦分配后，这些设备、控制器（和通道）就一直为该作业所占用，直到该作业被撤销。静态分配方式不会出现死锁，但设备的使用效率低。因此，静态分配方式并不符合分配的总原则。<br>动态分配是在进程执行过程中根据执行需要进行。当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按照事先规定的策略给进程分配所需要的设备、IO控制器，一旦用完之后，便立即释放。动态分配方式有利于提高设备的利用率，但如果分配算法使用不当，则有可能造成进程死锁。<br>3）设备分配算法：常用的动态设备分配算法有先请求先分配、优先级高者优先等。<br>对于独占设备，既可以采用动态分配方式也可以采用静态分配方式，往往采用静态分配方式，即在作业执行前，将作业所要用的这一类设备分配给它。共享设备可被多个进程所共享，一般采用动态分配方式，但在每个I/O传输的单位时间内只被一个进程所占有，通常采用先请求先分配和优先级高者优先的分配算法</p><p><strong>设备分配的安全性</strong></p><p>设备分配的安全性是指设备分配中应防止发生进程死锁。<br>1）安全分配方式：每当进程发出I/O请求后便进入阻塞状态，直到其I/O操作完成时才被唤醒。这样，一旦进程已经获得某种设备后便阻塞，不能再请求任何资源，而且在它阻塞时也不保持任何资源。优点是设备分配安全：缺点是CPU和I/O设备是串行工作的（对同一进程而言）<br>2）不安全分配方式：进程在发出I/O请求后继续运行，需要时又发出第二个、第三个I/O请求等。仅当进程所请求的设备已被另一进程占用时，才进入阻塞状态。优点是一个进程可同时操作多个设备，从而使进程推进迅速；缺点是这种设备分配有可能产生死锁。</p><p><strong>逻辑设备名到物理设备名的映射</strong></p><p>为了提高设备分配的灵活性和设备的利用率、方便实现I/O重定向，因此引入了设备独立性。设备独立性是指应用程序独立于具体使用的物理设备。<br>为了实现设备独立性，在应用程序中使用逻辑设备名来请求使用某类设备，在系统中设置张逻辑设备表（ Logical Unit Table，LUT），用于将逻辑设备名映射为物理设备名。LUT表项包括逻辑设备名、物理设备名和设备驱动程序入口地址；当进程用逻辑设备名来请求分配设备时，系统为它分配相应的物理设备，并在LUT中建立一个表项，以后进程再利用逻辑设备名请求IO操作时，系统通过查找LUT来寻找相应的物理设备和驱动程序。</p><p>在系统中可采取两种方式建立逻辑设备表<br>1）在整个系统中只设置一张LUT.这样，所有进程的设备分配情况都记录在这张表中，故不允许有相同的逻辑设备名，主要适用于单用户系统中。<br>2）为每个用户设置一张LUT.当用户登录时，系统便为该用户建立一个进程，同时也为之建立一张LUT，并将该表放入进程的PCB中。</p><h3 id="8-缓冲区管理"><a href="#8-缓冲区管理" class="headerlink" title="8. 缓冲区管理"></a>8. 缓冲区管理</h3><p><img src="https://img-blog.csdnimg.cn/20200703153108478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153304460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153345702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153438901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153706542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153803582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153927302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>磁盘高速缓存（ Disk Cache）</strong></p><p>操作系统中使用磁盘高速缓存技术来提高磁盘的I/O速度，对高速缓存复制的访问要比原始数据访问更为高效。例如，正在运行的进程的指令既存储在磁盘上，也存储在物理内存上，也被复制到CPU的二级和一级高速缓存中。<br>不过，磁盘高速缓存技术不同于通常意义下的介于CPU与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存在逻辑上属于磁盘，物理上则是驻留在内存中的盘块。<br>高速缓存在内存中分为两种形式：一种是在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定；另一种是把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I/O时共享。</p><p><strong>缓冲区（ Buffer）</strong><br>在设备管理子系统中，引入缓冲区的目的主要有：<br>1）缓和CPU与I/O设备间速度不匹配的矛盾。<br>2）减少对CPU的中断频率，放宽对CPU中断响应时间的限制<br>3）解决基本数据单元大小（即数据粒度）不匹配的问题。<br>4）提高CPU和I/O设备之间的并行性</p><p>其实现方法有：<br>1）采用硬件缓冲器，但由于成本太高，除一些关键部位外，一般不采用硬件缓冲器。<br>2）采用缓冲区（位于内存区域）.<br>缓冲区有一个特点，当缓冲区的数据非空的时候，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</p><p>根据系统设置缓冲器的个数，缓冲技术可以分为</p><p>1）单缓冲：在设备和处理机之间设置一个缓冲区。设备和处理机交换数据时，先把被交换<br>数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据。<br>2）双缓冲：根据单缓冲的特点，CPU在传送时间M内处于空闲状态，由此引入双缓冲。I/O设备输入数据时先装填到缓冲区1，在缓冲区1填满后才开始装填缓冲区2，与此同时处理机可<br>以从缓冲区1中取出数据放入用户进程处理，当缓冲区1中的数据处理完后，若缓冲区2已填满，则处理机又从缓冲区2中取出数据放入用户进程处理，而IO设备又可以装填缓冲区1.要注意，必须等缓冲区2充满才能让处理机从缓冲区2取出数据。双缓冲机制提高了处理机和输入设备的并行操作的程度3）循环缓冲：包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。</p><p>循环缓冲用于输入输出时，还需要有两个指针in和out对输入而言，首先要从设备接收数据到缓冲区中，in指针指向可以输入数据的第一个空缓冲区；当运行进程需要数据时，从循环缓冲区中取一个装满数据的缓冲区，并从此缓冲区中提取数据，out指针指向可以提取数据的第一个满缓冲区。输出则正好相反.</p><p>4）缓冲池：由多个系统公用的缓冲区组成，缓冲区按其使用状况可以形成三个队列：空缓冲队列、装满输入数据的缓冲队列（输入队列）和装满输出数据的缓冲队列（输出队列）.还应具有四种缓冲区：用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区及用于提取输出数据的工作缓冲区</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node-sass安装失败解决方案</title>
    <link href="/2021/07/08/node-sass%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/07/08/node-sass%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="node-sass安装失败解决方案"><a href="#node-sass安装失败解决方案" class="headerlink" title="node-sass安装失败解决方案"></a>node-sass安装失败解决方案</h1><p>在Github上看到一个用Vue写的<a href="https://github.com/is-liyiwei/vue-Chat-demo">仿造VX的聊天界面</a>，比较美观，想用在自己的项目中</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708171357360.png" alt="image-20210708171357360"></p><p>可惜<code>npm install</code>后意外发生了</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708171832501.png" alt="image-20210708171832501"></p><p>部署的时候报错<code>Module build failed: Error: Cannot find module &#39;node-sass&#39;</code></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708171504322.png" alt="image-20210708171504322"></p><p>很明显是node-sass包并没有安装成功，当我以为是外网的问题，重试使用淘宝镜像安装的时候</p><div class="hljs code-wrapper"><pre><code class="hljs shell">npm uninstall node-sass //使用淘宝镜像安装npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</code></pre></div><p>又报了其他模块无法解析的错误，很明显，还还是模块安装不完全的问题</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708172109790.png" alt="image-20210708172109790"></p><p>所以需要重新安装相关的模块</p><div class="hljs code-wrapper"><pre><code class="hljs shell">npm uninstall sass-loadernpm uninstall style-loadernpm install sass-loader@7.3.1 --save-dev　　　 //安装7.3.1版本的sassnpm install style-loader --save-dev // 安装style-loader</code></pre></div><p>发现这里又报了版本不对应的错误</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708172411081.png" alt="image-20210708172411081"></p><p>这才恍然大悟，<strong>淘宝镜像默认下载的是最新版本的包，所以需要在下载的时候指定版本</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">npm uninstall node-sass npm i node-sass@4.14.1 --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</code></pre></div><p>最终部署成功，成功解决</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708172544043.png" alt="image-20210708172544043"></p><p><strong>总结：</strong></p><p><strong>根据报错内容，一步一步的去信息解决问题是很重要的，一次报错不可怕，能仔细观察日记解决问题才是最重要的，希望下次引以为戒</strong></p>]]></content>
    
    
    <categories>
      
      <category>Bug解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JetBrains IDE Git操作报错解决方案</title>
    <link href="/2021/06/07/JetBrains%20IDE%20Git%E6%93%8D%E4%BD%9C%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/06/07/JetBrains%20IDE%20Git%E6%93%8D%E4%BD%9C%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="JetBrains-IDE-Git报错解决方案"><a href="#JetBrains-IDE-Git报错解决方案" class="headerlink" title="JetBrains IDE Git报错解决方案"></a>JetBrains IDE Git报错解决方案</h1><p>在使用<code>IDEA、WebStorm、PyCharm</code>的时候，在设置Github的时候</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607091401404.png" alt="image-20210607091401404"></p><p>或者在使用自带的版本管理插件进行Git操作的时候</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607091600563.png" alt="image-20210607091600563"></p><p>容易出现<code>invalid authentication data. connection reset</code>或者<code>LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 </code>之类的报错，试过网上许多解决方案，都没有一个统一的解答</p><h2 id="如果Ping不通"><a href="#如果Ping不通" class="headerlink" title="如果Ping不通"></a>如果Ping不通</h2><p>博主是使用了代理工具的，开始以为是网络的问题，但是<code>ping github.com</code>也能ping通，如果有ping不通的话，这里提供一个解决方案，利用域名解析器，看看github.com域名下映射的IP地址，这里可以去 <a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a> 上查看自己的映射地址</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607092335451.png" alt="image-20210607092335451"></p><p>填入到自己的Host文件配置中</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607092424140.png" alt="image-20210607092424140"></p><p><strong>基本就能解决Ping的问题</strong></p><h2 id="invalid-authentication-data-connection-reset"><a href="#invalid-authentication-data-connection-reset" class="headerlink" title="invalid authentication data. connection reset"></a>invalid authentication data. connection reset</h2><p>这是由于使用了代理工具但是在IDE并不能有效的识别，先设置</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607092615434.png" alt="image-20210607092615434"></p><p><strong>然后就可以发现添加账号成功</strong></p><h2 id="LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443"><a href="#LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443" class="headerlink" title="LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443"></a>LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</h2><p>这时候虽然能够配置上Github账号，但是在项目进行Push到github的时候会容易报这个错误，这是因为使用了代理工具，在<code>~</code>目录下使用<code>vim .gitconfig</code>目录对Git进行配置，最为关键的是添加如下配置</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607093139972.png" alt="image-20210607093139972"></p><p>进行如下配置后，Push成功</p><blockquote><p>不要一上来就进行这个配置，如果先配置了这个，会在设置Github的时候报错<code>invalid authentication data. connection reset</code>，先设置好Github账号后需要Push的时候再再上此配置行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Bug解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java NIO</title>
    <link href="/2021/05/13/NIO/"/>
    <url>/2021/05/13/NIO/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，<strong>可以替代标准的Java IO API</strong>。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持<strong>面向缓冲区的、基于通道的IO操作</strong>。NIO将以更加高效的方式进行文件的读写操作。</p><h1 id="二、IO与NIO的区别"><a href="#二、IO与NIO的区别" class="headerlink" title="二、IO与NIO的区别"></a>二、IO与NIO的区别</h1><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(NonBlocking IO)</td></tr><tr><td></td><td>选择器(Selectors)</td></tr></tbody></table><h2 id="面向流和缓冲区"><a href="#面向流和缓冲区" class="headerlink" title="面向流和缓冲区"></a>面向流和缓冲区</h2><p><strong>IO</strong></p><p>传统IO在传输数据时，根据输入输出的不同需要分别建立不同的链接，而且传输的数据是以流的形式在链接上进行传输的</p><p>就像自来水要通过水管将自来水厂和家连接起来一样</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109084453.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109084453.png" alt="img"></a></p><p><strong>NIO</strong></p><p>NIO在传输数据时，会在输入输出端之间建立<strong>通道</strong>，然后将数据放入到<strong>缓冲区</strong>中。缓冲区通过通道来传输数据</p><p>这里通道就像是铁路，能够连通两个地点。缓冲区就像是火车，能够真正地进行数据的传输</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222459918.png" alt="image-20210513222459918"></p><h1 id="三、通道与缓冲区"><a href="#三、通道与缓冲区" class="headerlink" title="三、通道与缓冲区"></a>三、通道与缓冲区</h1><p>Java NIO系统的核心在于：**通道(Channel)和缓冲区(Buffer)**。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理</p><p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p><h1 id="四、缓冲区-Buffer"><a href="#四、缓冲区-Buffer" class="headerlink" title="四、缓冲区(Buffer)"></a>四、缓冲区(Buffer)</h1><h2 id="1、缓冲区类型"><a href="#1、缓冲区类型" class="headerlink" title="1、缓冲区类型"></a>1、缓冲区类型</h2><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(<strong>boolean 除外</strong>) ，有以下Buffer 常用子类</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p><strong>各种类型的缓冲区中，都有一个对应类型的数组</strong>，如</p><p>ByteBuffer</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] hb;                  <span class="hljs-comment">// Non-null only for heap buffersCopy</span></code></pre></div><p>IntBuffer</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] hb;                  <span class="hljs-comment">// Non-null only for heap buffersCopy</span></code></pre></div><p><strong>他们的继承关系如下</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222534808.png" alt="image-20210513222534808"></p><h2 id="2、获取缓冲区"><a href="#2、获取缓冲区" class="headerlink" title="2、获取缓冲区"></a>2、获取缓冲区</h2><p>通过<strong>allocate方法</strong>可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法</p><p>例</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获取一个容量大小为1024字节的字节缓冲区</span>ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);</code></pre></div><h2 id="3、核心属性"><a href="#3、核心属性" class="headerlink" title="3、核心属性"></a>3、核心属性</h2><p>缓冲区的父类Buffer中有几个核心属性，如下</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mark = -<span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;</code></pre></div><ul><li>capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li>limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li>position：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li>mark：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h2 id="4、核心方法"><a href="#4、核心方法" class="headerlink" title="4、核心方法"></a>4、核心方法</h2><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222603127.png" alt="image-20210513222603127"></p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222630105.png" alt="image-20210513222630105"></p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222642585.png" alt="image-20210513222642585"></p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222657733.png" alt="image-20210513222657733"></p><h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h4><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222714944.png" alt="image-20210513222714944"></p><h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值</li></ul><h4 id="使用展示"><a href="#使用展示" class="headerlink" title="使用展示"></a>使用展示</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        System.out.println(<span class="hljs-string">&quot;放入前参数&quot;</span>);        System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());        System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());        System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());        System.out.println();        System.out.println(<span class="hljs-string">&quot;------put()------&quot;</span>);        System.out.println(<span class="hljs-string">&quot;放入3个数据&quot;</span>);        <span class="hljs-keyword">byte</span> bt = <span class="hljs-number">1</span>;        byteBuffer.put(bt);        byteBuffer.put(bt);        byteBuffer.put(bt);        System.out.println(<span class="hljs-string">&quot;放入后参数&quot;</span>);        System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());        System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());        System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());        System.out.println();        System.out.println(<span class="hljs-string">&quot;------flip()-get()------&quot;</span>);        System.out.println(<span class="hljs-string">&quot;读取一个数据&quot;</span>);        <span class="hljs-comment">// 切换模式</span>        byteBuffer.flip();        byteBuffer.get();        System.out.println(<span class="hljs-string">&quot;读取后参数&quot;</span>);        System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());        System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());        System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());        System.out.println();        System.out.println(<span class="hljs-string">&quot;------rewind()------&quot;</span>);        byteBuffer.rewind();        System.out.println(<span class="hljs-string">&quot;恢复后参数&quot;</span>);        System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());        System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());        System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());        System.out.println();        System.out.println(<span class="hljs-string">&quot;------clear()------&quot;</span>);        <span class="hljs-comment">// 清空缓冲区，这里只是恢复了各个属性的值，但是缓冲区里的数据依然存在</span>        <span class="hljs-comment">// 但是下次写入的时候会覆盖缓冲区中之前的数据</span>        byteBuffer.clear();        System.out.println(<span class="hljs-string">&quot;清空后参数&quot;</span>);        System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());        System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());        System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());        System.out.println();        System.out.println(<span class="hljs-string">&quot;清空后获得数据&quot;</span>);        System.out.println(byteBuffer.get());    &#125;&#125;</code></pre></div><p>打印结果</p><div class="hljs code-wrapper"><pre><code class="hljs java">放入前参数position <span class="hljs-number">0</span>limit <span class="hljs-number">1024</span>capacity <span class="hljs-number">1024</span>------put()------放入<span class="hljs-number">3</span>个数据放入后参数position <span class="hljs-number">3</span>limit <span class="hljs-number">1024</span>capacity <span class="hljs-number">1024</span>------flip()-get()------读取一个数据读取后参数position <span class="hljs-number">1</span>limit <span class="hljs-number">3</span>capacity <span class="hljs-number">1024</span>------rewind()------恢复后参数position <span class="hljs-number">0</span>limit <span class="hljs-number">3</span>capacity <span class="hljs-number">1024</span>------clear()------清空后参数position <span class="hljs-number">0</span>limit <span class="hljs-number">1024</span>capacity <span class="hljs-number">1024</span>清空后获得数据<span class="hljs-number">1</span></code></pre></div><h2 id="5、非直接缓冲区和直接缓冲区"><a href="#5、非直接缓冲区和直接缓冲区" class="headerlink" title="5、非直接缓冲区和直接缓冲区"></a>5、非直接缓冲区和直接缓冲区</h2><h4 id="非直接缓冲区"><a href="#非直接缓冲区" class="headerlink" title="非直接缓冲区"></a>非直接缓冲区</h4><p>通过<strong>allocate()<strong>方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM</strong>堆内存</strong>之中的。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-comment">// 在堆内存中开辟空间</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapByteBuffer(capacity, capacity);&#125;HeapByteBuffer(<span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> lim) &#123;        <span class="hljs-comment">// package-private</span>    <span class="hljs-comment">// new byte[cap] 创建数组，在堆内存中开辟空间</span>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, lim, cap, <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[cap], <span class="hljs-number">0</span>);    <span class="hljs-comment">/*</span><span class="hljs-comment">    hb = new byte[cap];</span><span class="hljs-comment">    offset = 0;</span><span class="hljs-comment">    */</span>&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222737771.png" alt="image-20210513222737771"></p><p>通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。<strong>都需要经过JVM和操作系统</strong>，数据在两个地址空间中传输时，会<strong>copy</strong>一份保存在对方的空间中。所以费直接缓冲区的读取效率较低</p><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p><strong>只有ByteBuffer可以获得直接缓冲区</strong>，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在<strong>物理内存</strong>之中的。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);&#125;DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;                   <span class="hljs-comment">// package-private</span>    ...    <span class="hljs-comment">// 申请物理内存</span>    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();    ...&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222756664.png" alt="image-20210513222756664"></p><p>直接缓冲区通过在操作系统和JVM之间创建<strong>物理内存映射文件</strong>加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中</p><h1 id="五、通道-Channel"><a href="#五、通道-Channel" class="headerlink" title="五、通道(Channel)"></a>五、通道(Channel)</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Channel由java.nio.channels 包定义的。Channel 表示<strong>IO 源与目标打开的连接</strong>。Channel 类似于传统的“流”。只不过<strong>Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互</strong></p><h2 id="2、图解"><a href="#2、图解" class="headerlink" title="2、图解"></a>2、图解</h2><p>应用程序进行读写操作调用函数时，<strong>底层调用的操作系统提供给用户的读写API</strong>，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，<strong>所有读写请求的指令都有CPU去执行</strong>，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222809288.png" alt="image-20210513222809288"></p><p>后来，<strong>DMA</strong>(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，<strong>DMA会向CPU请求，让DMA去处理这些IO操作</strong>，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。<strong>当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222817234.png" alt="image-20210513222817234"></p><p>于是便有了<strong>Channel(通道)<strong>，Channel相当于一个</strong>专门用于IO操作的独立处理器</strong>，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222824224.png" alt="image-20210513222824224"></p><h2 id="3、Java-Channel"><a href="#3、Java-Channel" class="headerlink" title="3、Java Channel"></a>3、Java Channel</h2><h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222909219.png" alt="image-20210513222909219"></p><ul><li>本地文件IO<ul><li>FileChannel</li></ul></li><li>网络IO<ul><li>SocketChanel、ServerSocketChannel：用于TCP传输</li><li>DatagramChannel：用于UDP传输</li></ul></li></ul><h4 id="获得通道的方法"><a href="#获得通道的方法" class="headerlink" title="获得通道的方法"></a>获得通道的方法</h4><p>获取通道的一种方式是对支持通道的<strong>对象调用getChannel() 方法</strong>。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 本地通道</span>      FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;&quot;</span>);      FileChannel channel1 = fileInputStream.getChannel();      FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;&quot;</span>);      FileChannel channel2 = fileOutputStream.getChannel();      <span class="hljs-comment">// 网络通道</span>      Socket socket = <span class="hljs-keyword">new</span> Socket();      SocketChannel channel3 = socket.getChannel();      ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();      ServerSocketChannel channel4 = serverSocket.getChannel();      DatagramSocket datagramSocket = <span class="hljs-keyword">new</span> DatagramSocket();      DatagramChannel channel5 = datagramSocket.getChannel();      <span class="hljs-comment">// 最后要关闭通道</span>   &#125;&#125;</code></pre></div><p><strong>也可以通过通道的静态方法open()来获取</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   FileChannel open = FileChannel.open(Paths.get(<span class="hljs-string">&quot;&quot;</span>));   SocketChannel open1 = SocketChannel.open();   ...&#125;</code></pre></div><p><strong>同时可以利用Files工具类的newByteChannel()方法来获取</strong></p><h4 id="getChannel-非直接缓冲区"><a href="#getChannel-非直接缓冲区" class="headerlink" title="getChannel()+非直接缓冲区"></a>getChannel()+非直接缓冲区</h4><ul><li>getChannel()获得通道</li><li>allocate()获得<strong>非直接缓冲区</strong></li></ul><p>通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      FileInputStream is = <span class="hljs-keyword">null</span>;      FileOutputStream os = <span class="hljs-keyword">null</span>;      <span class="hljs-comment">// 获得通道</span>      FileChannel inChannel = <span class="hljs-keyword">null</span>;      FileChannel outChannel = <span class="hljs-keyword">null</span>;      <span class="hljs-comment">// 利用 try-catch-finally 保证关闭</span>      <span class="hljs-keyword">try</span> &#123;         is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;</span>);         os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\2.jpg&quot;</span>);         <span class="hljs-comment">// 获得通道</span>         inChannel = is.getChannel();         outChannel = os.getChannel();         <span class="hljs-comment">// 获得缓冲区，用于在通道中传输数据</span>         ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);         <span class="hljs-comment">// 循环将字节数据放入到buffer中，然后写入磁盘中</span>         <span class="hljs-keyword">while</span> (inChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 切换模式</span>            byteBuffer.flip();            outChannel.write(byteBuffer);            byteBuffer.clear();         &#125;      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;         e.printStackTrace();      &#125; <span class="hljs-keyword">finally</span> &#123;         <span class="hljs-keyword">if</span> (inChannel != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               inChannel.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-keyword">if</span> (outChannel != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               outChannel.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               is.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-keyword">if</span> (os != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               os.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;      &#125;   &#125;&#125;</code></pre></div><p><strong>图片读取后，被写入到了指定位置</strong><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222934130.png" alt="image-20210513222934130"></p><h4 id="open-直接缓冲区"><a href="#open-直接缓冲区" class="headerlink" title="open()+直接缓冲区"></a>open()+直接缓冲区</h4><ul><li>通过open获得通道</li><li>通过FileChannel.map()获取直接缓冲区</li></ul><p>使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 通过open()方法来获得通道</span>      FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;</span>), StandardOpenOption.READ);      <span class="hljs-comment">// outChannel需要为 READ WRITE CREATE模式</span>      <span class="hljs-comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span>      <span class="hljs-comment">// CREATE是因为要创建新的文件</span>      FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\3.jpg&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);      <span class="hljs-comment">// 获得直接缓冲区</span>      MappedByteBuffer inMapBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, inChannel.size());      MappedByteBuffer outMapBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, inChannel.size());      <span class="hljs-comment">// 字节数组</span>      <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inMapBuf.limit()];      <span class="hljs-comment">// 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输</span>      inMapBuf.get(bytes);      outMapBuf.put(bytes);      <span class="hljs-comment">// 关闭缓冲区，这里没有用try-catch-finally</span>      inChannel.close();      outChannel.close();   &#125;&#125;</code></pre></div><p><strong>运行结果，图片被创建</strong><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222959909.png" alt="image-20210513222959909"></p><h4 id="通道间直接传输"><a href="#通道间直接传输" class="headerlink" title="通道间直接传输"></a>通道间直接传输</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelToChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   <span class="hljs-keyword">long</span> start = System.currentTimeMillis();   <span class="hljs-comment">// 通过open()方法来获得通道</span>   FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.mp4&quot;</span>), StandardOpenOption.READ);   <span class="hljs-comment">// outChannel需要为 READ WRITE CREATE模式</span>   <span class="hljs-comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span>   <span class="hljs-comment">// CREATE是因为要创建新的文件</span>   FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\4.mp4&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);   <span class="hljs-comment">// 通道间直接传输</span>   inChannel.transferTo(<span class="hljs-number">0</span>, inChannel.size(), outChannel);   <span class="hljs-comment">// 对应的还有transferFrom</span>   <span class="hljs-comment">// outChannel.transferFrom(inChannel, 0, inChannel.size());</span>   inChannel.close();   outChannel.close();&#125;</code></pre></div><h4 id="直接缓冲区VS非直接缓冲区"><a href="#直接缓冲区VS非直接缓冲区" class="headerlink" title="直接缓冲区VS非直接缓冲区"></a>直接缓冲区VS非直接缓冲区</h4><p><strong>效率</strong></p><p>读取一个MP4文件，通过二者花费时间的多少来判定执行的速度</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// getChannel() + 非直接缓冲区耗时</span><span class="hljs-number">708</span><span class="hljs-comment">// open() + 直接缓冲区耗时</span><span class="hljs-number">115</span><span class="hljs-comment">// channel transferTo channel耗时</span><span class="hljs-number">47</span></code></pre></div><p><strong>内存占用</strong></p><p>直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得计算机运行速度变慢</p><h2 id="4、分散和聚集"><a href="#4、分散和聚集" class="headerlink" title="4、分散和聚集"></a>4、分散和聚集</h2><h4 id="分散读取"><a href="#分散读取" class="headerlink" title="分散读取"></a>分散读取</h4><p>分散读取（Scattering Reads）是指<strong>从Channel 中读取的数据“分散”到多个Buffer 中</strong></p><p><strong>注意</strong>：按照缓冲区的<strong>顺序</strong>，从Channel 中读取的数据依次将 Buffer 填满</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223014213.png" alt="image-20210513223014213"></p><h4 id="聚集写入"><a href="#聚集写入" class="headerlink" title="聚集写入"></a>聚集写入</h4><p>聚集写入（Gathering Writes）是指将<strong>多个Buffer 中的数据“聚集”到Channel</strong></p><p>按照缓冲区的<strong>顺序</strong>，写入position 和limit 之间的数据到Channel </p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223022650.png" alt="image-20210513223022650"></p><p><strong>代码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划.txt&quot;</span>);      FileOutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划2.txt&quot;</span>);      FileChannel inChannel = is.getChannel();      FileChannel outChannel = os.getChannel();      <span class="hljs-comment">// 获得多个缓冲区，并且放入到缓冲区数组中</span>      ByteBuffer byteBuffer1 = ByteBuffer.allocate(<span class="hljs-number">50</span>);      ByteBuffer byteBuffer2 = ByteBuffer.allocate(<span class="hljs-number">1024</span>);      ByteBuffer[] byteBuffers = &#123;byteBuffer1, byteBuffer2&#125;;      <span class="hljs-comment">// 分散读取</span>      inChannel.read(byteBuffers);      byteBuffer1.flip();      byteBuffer2.flip();      <span class="hljs-comment">//打印结果</span>      System.out.println(<span class="hljs-keyword">new</span> String(byteBuffers[<span class="hljs-number">0</span>].array(),<span class="hljs-number">0</span>,byteBuffers[<span class="hljs-number">0</span>].limit()));      System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);      System.out.println(<span class="hljs-keyword">new</span> String(byteBuffers[<span class="hljs-number">1</span>].array(),<span class="hljs-number">0</span>,byteBuffers[<span class="hljs-number">1</span>].limit()));      <span class="hljs-comment">// 聚集写入</span>      outChannel.write(byteBuffers);   &#125;&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223043503.png" alt="image-20210513223043503"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223052049.png" alt="image-20210513223052049"></p><h1 id="六、非阻塞式网络通信"><a href="#六、非阻塞式网络通信" class="headerlink" title="六、非阻塞式网络通信"></a>六、非阻塞式网络通信</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>双11买的快递到了，快递小哥给你打电话说马上到，麻烦在门口等一下，方便签收快递</p><ul><li>若为<strong>阻塞式</strong>的，你到了小区门口以后，快递小哥还没到的期间，你什么事儿也做不了</li><li>若为<strong>非阻塞式</strong>的，快递小哥将快递放到门卫处，门卫给你发消息说快递到了，麻烦去取一下。当快递还没到的时候你可以做你自己的事儿</li></ul><h4 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h4><p>传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，<strong>该线程被阻塞</strong>，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p><p>因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以<strong>服务器端必须为每个客户端都提供一个独立的线程进行处理</strong>，当服务器端需要处理大量客户端时，<strong>性能急剧下降</strong></p><p>也就是说，服务器在等待IO准备就绪的期间，<strong>线程处于阻塞状态</strong>，若为单线程，等待期间CPU未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待IO准备就绪时，CPU可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223107153.png" alt="image-20210513223107153"></p><h4 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h4><p>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，<strong>若没有数据可用时，该线程可以进行其他任务</strong>。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以<strong>单独的线程可以管理多个输入和输出通道</strong></p><p>因此，NIO 可以让服务器端<strong>使用一个或有限几个线程来同时处理连接到服务器端的所有客户端</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223114797.png" alt="image-20210513223114797"></p><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><h4 id="阻塞式网络通信演示"><a href="#阻塞式网络通信演示" class="headerlink" title="阻塞式网络通信演示"></a>阻塞式网络通信演示</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 一、使用 NIO 完成网络通信的三个核心：</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 1. 通道（Channel）：负责连接</span><span class="hljs-comment"> *         </span><span class="hljs-comment"> *        java.nio.channels.Channel 接口：</span><span class="hljs-comment"> *             |--SelectableChannel</span><span class="hljs-comment"> *                 |--SocketChannel</span><span class="hljs-comment"> *                 |--ServerSocketChannel</span><span class="hljs-comment"> *                 |--DatagramChannel</span><span class="hljs-comment"> * </span><span class="hljs-comment"> *                 |--Pipe.SinkChannel</span><span class="hljs-comment"> *                 |--Pipe.SourceChannel</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 2. 缓冲区（Buffer）：负责数据的存取</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 3. 选择器（Selector）：是 SelectableChannel 的多路复用器。用于监控 SelectableChannel 的 IO 状况</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBlockingNIO</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-keyword">try</span> &#123;            server();         &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();         &#125;      &#125;);      Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-keyword">try</span> &#123;            client();         &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();         &#125;      &#125;);      thread1.start();      thread2.start();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 创建客户端通道</span>      SocketChannel socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">2022</span>));      <span class="hljs-comment">// 读取信息</span>      FileChannel fileChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\nio\\day3\\1.jpg&quot;</span>), StandardOpenOption.READ);      <span class="hljs-comment">// 创建缓冲区</span>      ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);      <span class="hljs-comment">// 写入数据</span>      <span class="hljs-keyword">while</span> (fileChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">//切换为读模式</span>         byteBuffer.flip();         socketChannel.write(byteBuffer);         byteBuffer.clear();      &#125;      fileChannel.close();      socketChannel.close();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 创建服务端通道</span>      ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();      FileChannel fileChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\nio\\day3\\2.jpg&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);      <span class="hljs-comment">// 绑定链接</span>      serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">2022</span>));      <span class="hljs-comment">// 获取客户端的通道</span>      SocketChannel socketChannel = serverSocketChannel.accept();      <span class="hljs-comment">// 创建缓冲区</span>      ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);      <span class="hljs-keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;         byteBuffer.flip();         fileChannel.write(byteBuffer);         byteBuffer.clear();      &#125;      socketChannel.close();      fileChannel.close();      serverSocketChannel.close();   &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBlockingNIO2</span> </span>&#123;    <span class="hljs-comment">//客户端</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        SocketChannel sChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9898</span>));        FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;1.jpg&quot;</span>), StandardOpenOption.READ);        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-keyword">while</span>(inChannel.read(buf) != -<span class="hljs-number">1</span>)&#123;            buf.flip();            sChannel.write(buf);            buf.clear();        &#125;        sChannel.shutdownOutput();        <span class="hljs-comment">//接收服务端的反馈</span>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>((len = sChannel.read(buf)) != -<span class="hljs-number">1</span>)&#123;            buf.flip();            System.out.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, len));            buf.clear();        &#125;        inChannel.close();        sChannel.close();    &#125;    <span class="hljs-comment">//服务端</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        ServerSocketChannel ssChannel = ServerSocketChannel.open();        FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;2.jpg&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);        ssChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9898</span>));        SocketChannel sChannel = ssChannel.accept();        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-keyword">while</span>(sChannel.read(buf) != -<span class="hljs-number">1</span>)&#123;            buf.flip();            <span class="hljs-comment">//保存到本地</span>            outChannel.write(buf);            buf.clear();        &#125;        <span class="hljs-comment">//发送反馈给客户端</span>        buf.put(<span class="hljs-string">&quot;服务端接收数据成功&quot;</span>.getBytes());        buf.flip();        sChannel.write(buf);        sChannel.close();        outChannel.close();        ssChannel.close();    &#125;&#125;</code></pre></div><h4 id="非阻塞式网络通信演示"><a href="#非阻塞式网络通信演示" class="headerlink" title="非阻塞式网络通信演示"></a>非阻塞式网络通信演示</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNonBlockingNIO2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;                server();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;);        Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;                client();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;);        thread1.start();        thread2.start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        SocketChannel socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">2020</span>));        <span class="hljs-comment">// 设置为非阻塞模式</span>        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;            String str = scanner.next();            byteBuffer.put(str.getBytes());            byteBuffer.flip();            socketChannel.write(byteBuffer);            byteBuffer.clear();        &#125;        byteBuffer.clear();        socketChannel.close();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//获取通道</span>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        <span class="hljs-comment">//切换为非阻塞</span>        serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//绑定链接</span>        serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">2020</span>));        <span class="hljs-comment">// 获得选择器</span>        Selector selector = Selector.open();        <span class="hljs-comment">// 将通道注册到选择器中，设定为接收操作</span>        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        <span class="hljs-comment">// 轮训接受</span>        <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();            <span class="hljs-comment">// 获得事件的key</span>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                <span class="hljs-comment">//获取准备就绪的事件</span>                SelectionKey key = iterator.next();                <span class="hljs-comment">//判断具体是什么事件准备就绪</span>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;                    <span class="hljs-comment">//若接受就绪，则获取客户端连接</span>                    SocketChannel socketChannel = serverSocketChannel.accept();                    socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);                    <span class="hljs-comment">//将该通道注册到选择器上</span>                    socketChannel.register(selector, SelectionKey.OP_READ);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;                    <span class="hljs-comment">// 从选择器中获取读就绪通道</span>                    SocketChannel socketChannel = (SocketChannel) key.channel();                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);                    <span class="hljs-keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;                        <span class="hljs-keyword">int</span> len = byteBuffer.limit();                        byteBuffer.flip();                        System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array(), <span class="hljs-number">0</span>, len));                        byteBuffer.clear();                    &#125;                    socketChannel.close();                &#125;                <span class="hljs-comment">//取消选择键</span>                iterator.remove();            &#125;        &#125;        serverSocketChannel.close();    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//演示DatagramChannel</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNonBlockingNIO2</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        DatagramChannel dc = DatagramChannel.open();        dc.configureBlocking(<span class="hljs-keyword">false</span>);        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span>(scan.hasNext())&#123;            String str = scan.next();            buf.put((<span class="hljs-keyword">new</span> Date().toString() + <span class="hljs-string">&quot;:\n&quot;</span> + str).getBytes());            buf.flip();            dc.send(buf, <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9898</span>));            buf.clear();        &#125;        dc.close();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        DatagramChannel dc = DatagramChannel.open();        dc.configureBlocking(<span class="hljs-keyword">false</span>);        dc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9898</span>));        Selector selector = Selector.open();        dc.register(selector, SelectionKey.OP_READ);        <span class="hljs-keyword">while</span>(selector.select() &gt; <span class="hljs-number">0</span>)&#123;            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();            <span class="hljs-keyword">while</span>(it.hasNext())&#123;                SelectionKey sk = it.next();                <span class="hljs-keyword">if</span>(sk.isReadable())&#123;                    ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);                    dc.receive(buf);                    buf.flip();                    System.out.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, buf.limit()));                    buf.clear();                &#125;            &#125;            it.remove();        &#125;    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPipe</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        <span class="hljs-comment">//1. 获取管道</span>        Pipe pipe = Pipe.open();        <span class="hljs-comment">//2. 将缓冲区中的数据写入管道</span>        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        Pipe.SinkChannel sinkChannel = pipe.sink();        buf.put(<span class="hljs-string">&quot;通过单向管道发送数据&quot;</span>.getBytes());        buf.flip();        sinkChannel.write(buf);        <span class="hljs-comment">//3. 读取缓冲区中的数据</span>        Pipe.SourceChannel sourceChannel = pipe.source();        buf.flip();        <span class="hljs-keyword">int</span> len = sourceChannel.read(buf);        System.out.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, len));        sourceChannel.close();        sinkChannel.close();    &#125;&#125;</code></pre></div><h5 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h5><p>选择器（Selector）是<strong>SelectableChannle</strong> 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。<strong>Selector 是非阻塞IO 的核心</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223137934.png" alt="image-20210513223137934"></p><p><strong>选择器的创建</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个选择器</span>Selector selector = Selector.open();</code></pre></div><p><strong>绑定选择器</strong></p><p>通过调用通道的register方法可以绑定选择器，register方法有两个参数</p><ul><li><p>Selector：即绑定哪个选择器</p></li><li><p>ops：监听事件类型。ops有4个值可以选择，为<strong>SelectionKey</strong>的静态属性</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223148530.png" alt="image-20210513223148530"></p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 让选择器监听一种状态</span>myChannel.register(selector, SelectionKey.OP_READ);<span class="hljs-comment">// 让选择器监听多种状态</span>myChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);</code></pre></div><p><strong>SelectionKey</strong></p><p><strong>表示SelectableChannel 和Selector 之间的注册关系</strong>。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程</title>
    <link href="/2021/05/07/JUC/"/>
    <url>/2021/05/07/JUC/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。 </li><li>一个线程就是一<strong>个指令流</strong>，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集进程拥有共享的资源，如内存空间等，供其内部的线程共享 <ul><li>进程间通信较为复杂，<strong>同一台计算机的进程通信称为 IPC</strong>（Inter-process communication） </li><li>不同计算机之间的<strong>进程通信，需要通过网络，并遵守共同的协议</strong>，例如 HTTP </li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量线程更轻量，<strong>线程上下文切换成本一般上要比进程上下文切换低</strong></li></ul><h4 id="进程和线程的切换"><a href="#进程和线程的切换" class="headerlink" title="进程和线程的切换"></a>进程和线程的切换</h4><p><strong>上下文切换</strong></p><p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态</strong>包括以下内容：</p><ul><li>通用目的寄存器</li><li>浮点寄存器</li><li>程序计数器</li><li>用户栈</li><li>状态寄存器</li><li>内核栈</li><li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li></ul><p><strong>进程切换和线程切换的主要区别</strong></p><p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p><p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p><p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p><p><strong>为什么TLB能加快访问速度</strong></p><p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p><h2 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h2><p><strong>并发是一个CPU在不同的时间去不同线程中执行指令</strong></p><p><strong>并行是多个CPU同时处理不同的线程</strong></p><p>引用 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力 </li><li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li></ul><h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><h4 id="应用之异步调用（案例1）"><a href="#应用之异步调用（案例1）" class="headerlink" title="应用之异步调用（案例1）"></a>应用之异步调用（案例1）</h4><p>以调用方角度来讲，如果</p><ul><li><strong>需要等待结果返回，才能继续运行就是同步</strong> </li><li><strong>不需要等待结果返回，就能继续运行就是异步</strong></li></ul><ol><li>设计<br>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</li><li>结论 </li></ol><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li><li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><p>结论 </p><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 </li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 <ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 </li></ul></li><li>IO 操作不占用 cpu，只是我们<strong>一般拷贝文件使用的是【阻塞 IO】</strong>，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，<strong>没能充分利用线程</strong>。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li></ol><h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="1、创建一个线程（非主线程）"><a href="#1、创建一个线程（非主线程）" class="headerlink" title="1、创建一个线程（非主线程）"></a>1、创建一个线程（非主线程）</h2><h3 id="方法一：通过继承dead创建线程"><a href="#方法一：通过继承dead创建线程" class="headerlink" title="方法一：通过继承dead创建线程"></a>方法一：通过继承dead创建线程</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread myThread = <span class="hljs-keyword">new</span> MyThread();        <span class="hljs-comment">// 启动线程</span>        myThread.start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;my thread running...&quot;</span>);    &#125;&#125;</code></pre></div><p>使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p><h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建线程任务</span>        Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>);            &#125;        &#125;;        <span class="hljs-comment">//将Runnable对象传给Thread</span>        Thread t = <span class="hljs-keyword">new</span> Thread(r);        <span class="hljs-comment">//启动线程</span>        t.start();    &#125;&#125;</code></pre></div><p>或者</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread2</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;         System.out.println(<span class="hljs-string">&quot;my runnable running...&quot;</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();      Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);      thread.start();   &#125;&#125;</code></pre></div><p>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</p><h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p><p>所以方法二中的代码可以被简化为</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建线程任务</span>        Runnable r = () -&gt; &#123;            <span class="hljs-comment">//直接写方法体即可</span>            System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>);            System.out.println(<span class="hljs-string">&quot;Hello Thread&quot;</span>);        &#125;;        <span class="hljs-comment">//将Runnable对象传给Thread</span>        Thread t = <span class="hljs-keyword">new</span> Thread(r);        <span class="hljs-comment">//启动线程</span>        t.start();    &#125;&#125;</code></pre></div><p>可以再Runnable上使用Alt+Enter(option+Enter)</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png" alt="img"></a></p><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起</li><li>方法2 是把线程和任务分开了 </li><li>用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        <span class="hljs-comment">//需要传入一个Callable对象</span>        FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">&quot;线程执行!&quot;</span>);                Thread.sleep(<span class="hljs-number">1000</span>);                <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;            &#125;        &#125;);        Thread r1 = <span class="hljs-keyword">new</span> Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);        r1.start();        <span class="hljs-comment">//获取线程中方法执行后的返回结果</span>        System.out.println(task.get());    &#125;&#125;</code></pre></div><p>或</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseFutureTask</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;      FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyCall());      Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);      thread.start();      <span class="hljs-comment">// 获得线程运行后的返回值</span>      System.out.println(futureTask.get());   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;   &#125;&#125;</code></pre></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。<strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p><h2 id="2、原理之线程运行"><a href="#2、原理之线程运行" class="headerlink" title="2、原理之线程运行"></a>2、原理之线程运行</h2><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p><ul><li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li><li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong>，栈帧里包含<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法返回地址</strong>、<strong>运行时常量池引用</strong>和<strong>锁记录</strong></li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能 </li></ul><h2 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h2><h3 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h3><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p><h3 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h4><ol><li><p>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p></li><li><p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<span class="hljs-comment">//休眠一分钟</span>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);</code></pre></div></li></ol><h4 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h4><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程 </li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 </p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">//设置为优先级最高 </span></code></pre></div></li></ul><h3 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h3><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p><div class="hljs code-wrapper"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread();<span class="hljs-comment">//等待thread线程执行结束</span>thread.join();<span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span>thread.join(<span class="hljs-number">1000</span>);</code></pre></div><h3 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。 </li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//用于查看打断标记，返回值被boolean类型</span>t1.isInterrupted();</code></pre></div><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;        <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre></div><h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png" alt="img"></a></p><p><strong>代码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();        monitor.start();        Thread.sleep(<span class="hljs-number">3500</span>);        monitor.stop();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;    Thread monitor;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 启动监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//开始不停的监控</span>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-comment">//判断当前线程是否被打断了</span>                    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);                        <span class="hljs-comment">//终止线程执行</span>                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//线程休眠</span>                        Thread.sleep(<span class="hljs-number">1000</span>);                        System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                        <span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span>                        Thread.currentThread().interrupt();                    &#125;                &#125;            &#125;        &#125;;        monitor.start();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *     用于停止监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//打断线程</span>        monitor.interrupt();    &#125;&#125;</code></pre></div><h3 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h3><ul><li>stop方法 停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）</li><li>suspend（暂停线程）/resume（恢复线程）方法</li></ul><h3 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h3><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将线程设置为守护线程, 默认为false</span>monitor.setDaemon(<span class="hljs-keyword">true</span>);</code></pre></div><p><strong>守护线程的应用</strong></p><ul><li>垃圾回收器线程就是一种守护线程 </li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul><h2 id="4、线程的状态"><a href="#4、线程的状态" class="headerlink" title="4、线程的状态"></a>4、线程的状态</h2><h3 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h3><p>这是从 <strong>操作系统</strong> 层面来描述的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png" alt="img"></a></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 </li><li>【运行状态】指获取了 CPU 时间片运行中的状态 <ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 </li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 </li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们 </li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h3 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png" alt="img"></a></p><ul><li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行） </li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。 </li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul><h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="1、共享带来的问题"><a href="#1、共享带来的问题" class="headerlink" title="1、共享带来的问题"></a>1、共享带来的问题</h2><h3 id="1-临界区-Critical-Section"><a href="#1-临界区-Critical-Section" class="headerlink" title="(1)临界区 Critical Section"></a>(1)临界区 Critical Section</h3><ul><li><p>一个程序运行多个线程本身是没有问题的</p></li><li><p>问题出在多个线程访问<strong>共享资源</strong></p></li><li><p><strong>多个线程读共享资源</strong>其实也没有问题 </p></li><li><p>在<strong>多个线程对共享资源读写操作</strong>时发生指令交错，就会出现问题 </p></li><li><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;       counter++; &#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;     counter--; &#125;</code></pre></div><h3 id="2-竞态条件-Race-Condition"><a href="#2-竞态条件-Race-Condition" class="headerlink" title="(2)竞态条件 Race Condition"></a><strong>(2)竞态条件 Race Condition</strong></h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="2、synchronized-解决方案"><a href="#2、synchronized-解决方案" class="headerlink" title="2、synchronized 解决方案"></a>2、synchronized 解决方案</h2><h3 id="1-解决手段"><a href="#1-解决手段" class="headerlink" title="(1)解决手段"></a>(1)解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock </li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h3 id="2-synchronized语法"><a href="#2-synchronized语法" class="headerlink" title="(2)synchronized语法"></a>(2)synchronized语法</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;    <span class="hljs-comment">//临界区</span>&#125;</code></pre></div><p>例：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//创建一个公共对象，作为对象锁的对象</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                    <span class="hljs-keyword">synchronized</span> (room) &#123;             counter++;                        &#125;               &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                     <span class="hljs-keyword">synchronized</span> (room) &#123;                        counter--;                      &#125;            &#125;     &#125;, <span class="hljs-string">&quot;t2&quot;</span>);    t1.start();        t2.start();     t1.join();       t2.join();        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter); &#125;</code></pre></div><h3 id="3-synchronized加在方法上"><a href="#3-synchronized加在方法上" class="headerlink" title="(3)synchronized加在方法上"></a>(3)synchronized加在方法上</h3><ul><li><p>加在<strong>成员方法</strong>上</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;    <span class="hljs-comment">//在方法上加上synchronized关键字</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">//等价于</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;        &#125;    &#125;&#125;</code></pre></div></li><li><p>加在<strong>静态方法</strong>上</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-comment">//在静态方法上加上synchronized关键字</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">//等价于</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span>(Demo.class) &#123;        &#125;    &#125;&#125;</code></pre></div></li></ul><h2 id="3、变量的线程安全分析"><a href="#3、变量的线程安全分析" class="headerlink" title="3、变量的线程安全分析"></a>3、变量的线程安全分析</h2><h4 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h4><ul><li>如果它们<strong>没有共享，则线程安全</strong></li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果<strong>只有读</strong>操作，则线程安全 </li><li>如果<strong>有读写</strong>操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h4 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h4><ul><li><p>局部变量是<strong>线程安全</strong>的</p></li><li><p>但<strong>局部变量引用的对象则未必</strong> （要看该对象是否被共享且被执行了读写操作）</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li><li><p><strong>局部变量是线程安全</strong>的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;  i++;&#125;</code></pre></div></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png" alt="img"></a></p><ul><li><p>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span> </span>&#123;    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            method2();            method3();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;        list.add(<span class="hljs-string">&quot;1&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;        list.remove(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png" alt="img"></a></p><ul><li><p>如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> </span>&#123;  <span class="hljs-comment">//final保证子类不对其有影响，保障线性安全</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-comment">//改为局部变量</span>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            method2(list);            method3(list);        &#125;    &#125;<span class="hljs-comment">//设为private为了保护有子类时能复写方法则不安全</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;        list.add(<span class="hljs-string">&quot;1&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;        System.out.println(<span class="hljs-number">1</span>);        list.remove(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png" alt="img"></a></p><p>从以上例子可以看出，使用<strong>private或者final</strong>提供<strong>安全</strong>的意义所在</p><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuﬀer </li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p><ul><li>它们的每个方法是原子的（都被加上了synchronized）</li><li>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png" alt="img"></a></p><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 </p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;       <span class="hljs-comment">//安全</span>       String S1  = <span class="hljs-string">&quot;...&quot;</span>;       <span class="hljs-comment">//安全</span>       <span class="hljs-keyword">final</span> String S2  = <span class="hljs-string">&quot;...&quot;</span>;       <span class="hljs-comment">//不安全</span>       Date D1 = <span class="hljs-keyword">new</span> Date();       <span class="hljs-comment">//不安全，因为Date不是String，内部属性会被修改</span>       <span class="hljs-keyword">final</span> Date D2 = <span class="hljs-keyword">new</span> Date();       <span class="hljs-comment">//不安全</span>       <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();       <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;           <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;           <span class="hljs-comment">//有可能多个代码来修改里面的值</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;               <span class="hljs-comment">// ...</span>               count++;           &#125;       &#125;  &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;    <span class="hljs-comment">//不安全，因为start会被修改</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">0L</span>;    <span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;       start = System.nanoTime();     &#125;    <span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> end = System.nanoTime();        System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start));    &#125;&#125;</code></pre></div><h2 id="4、Monitor（锁）概念"><a href="#4、Monitor（锁）概念" class="headerlink" title="4、Monitor（锁）概念"></a>4、Monitor（锁）概念</h2><h3 id="1-原理之Monitor"><a href="#1-原理之Monitor" class="headerlink" title="(1)原理之Monitor"></a>(1)原理之Monitor</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png" alt="img"></a></p><ul><li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p><ul><li><p>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</p></li><li><p>如果已经绑定，则会去查询该Monitor是否已经有了Owner</p><ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList，进入阻塞状态(blocked)</li></ul></li></ul></li><li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p></li><li><p><strong>注意</strong>：</p><ul><li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li><li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li></ul></li></ul><h2 id="5、Synchronized原理进阶"><a href="#5、Synchronized原理进阶" class="headerlink" title="5、Synchronized原理进阶"></a>5、Synchronized原理进阶</h2><h3 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h3><p>普通对象</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gph8nfmtlrj30ya086gmo.jpg" alt="image-20210412203347281"></p><p>数组对象</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gph8n1ce41j316w07yag2.jpg" alt="image-20210412203425689"></p><p>其中Klass可以找到类对象，有<strong>类型指针Object reference</strong>，Mac Word结构为</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png" alt="img"></a></p><h3 id="1-轻量级锁（用于优化Monitor这类的重量级锁）"><a href="#1-轻量级锁（用于优化Monitor这类的重量级锁）" class="headerlink" title="(1)轻量级锁（用于优化Monitor这类的重量级锁）"></a>(1)轻量级锁（用于优化Monitor这类的重量级锁）</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p><ul><li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的<strong>栈帧都会包含一个锁记录对象</strong>，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png" alt="img"></a></p></li><li><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png" alt="img"></a></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png" alt="img"></a></p><ul><li>如果cas失败，是自己执行了Synchronized锁重入，那么再添加一条Lock Record作为重入的计数</li></ul><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gph7zqfw55j30rw0hu7d2.jpg" alt="image-20210412201158273"  /><ul><li>当退出Synchronized代码块（解锁时）如果有取值为null的锁记录，表示<strong>有重入</strong>，这时<strong>重置锁记录</strong>，表示重入计数减一</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gph84y06q0j30qu0g4jy0.jpg" alt="image-20210412201704193"></p><ul><li>当退出Synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mac Word的值恢复给对象头<ul><li>成功则解锁成功</li><li>失败说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h3 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="(2)锁膨胀"></a>(2)锁膨胀</h3><ul><li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png" alt="img"></a></p><ul><li><p>此时便会给对象加上重量级锁（使用Monitor）</p><ul><li><p>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</p></li><li><p>并且该线程放入入EntryList中，并进入阻塞状态(blocked)</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png" alt="img"></a></p></li></ul></li><li><p>当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为Null，唤醒Entrylist中BLOCKED线程</p></li></ul><h3 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="(3)自旋优化"></a>(3)自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自选来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p><ul><li>第一种情况</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png" alt="img"></a></p><ul><li>第二种情况</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png" alt="img"></a></p><h3 id="4-偏向锁-用于优化轻量级锁重入"><a href="#4-偏向锁-用于优化轻量级锁重入" class="headerlink" title="(4)偏向锁(用于优化轻量级锁重入)"></a>(4)偏向锁(用于优化轻量级锁重入)</h3><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png" alt="img"></a></p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png" alt="img"></a></p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态，可用VM参数 -XX: BiasedLockingStartopDelay=0来禁用延迟</li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001，这时候它的hashcode、age都为0，第一次用到hashcode时才会赋值</li></ul><h4 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h4><p>以下几种情况会使对象的<strong>偏向锁失效</strong></p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h3 id="5-批量重偏向"><a href="#5-批量重偏向" class="headerlink" title="(5)批量重偏向"></a>(5)批量重偏向</h3><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>重偏向会重置Thread ID</li></ul></li><li>当<strong>撤销超过20次后</strong>（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，<strong>重新偏向至加锁线程</strong>。</li></ul><h3 id="6-批量撤销"><a href="#6-批量撤销" class="headerlink" title="(6)批量撤销"></a>(6)批量撤销</h3><p>当撤销偏向锁的阈值<strong>超过40以后</strong>，就会将<strong>整个类的对象都改为不可偏向的</strong></p><h2 id="6、Wait-Notify"><a href="#6、Wait-Notify" class="headerlink" title="6、Wait/Notify"></a>6、Wait/Notify</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="(1)原理"></a>(1)原理</h3><p> <a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png" alt="img"></a></p><ul><li><p>锁对象调用wait方法（obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</p></li><li><p>处于<strong>BLOCKED和WAITING状态的线程都为阻塞</strong>状态，CPU都不会分给他们时间片。但是有所区别：</p><ul><li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li></ul></li><li><p>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。</p></li></ul><p><strong>注：只有当对象被锁以后，才能调用wait和notify方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object LOCK = <span class="hljs-keyword">new</span> Object();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//只有在对象被锁住后才能调用wait方法</span>        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;            LOCK.wait();        &#125;    &#125;&#125;</code></pre></div><h3 id="2-Wait与Sleep的区别"><a href="#2-Wait与Sleep的区别" class="headerlink" title="(2)Wait与Sleep的区别"></a>(2)Wait与Sleep的区别</h3><p><strong>不同点</strong></p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li><strong>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</strong></li><li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li></ul><p><strong>相同点</strong></p><ul><li>阻塞状态都为<strong>TIMED_WAITING</strong></li></ul><h3 id="3-优雅地使用wait-notify"><a href="#3-优雅地使用wait-notify" class="headerlink" title="(3)优雅地使用wait/notify"></a>(3)优雅地使用wait/notify</h3><p><strong>什么时候适合使用wait</strong></p><ul><li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。</li></ul><p><strong>使用wait/notify需要注意什么</strong></p><ul><li>当有<strong>多个</strong>线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了<strong>notify</strong>方法，可能会造成<strong>虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用<strong>notifyAll</strong>方法，同时将wait方法置于while循环中判断，同样避免虚假唤醒。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (LOCK) &#123;    <span class="hljs-keyword">while</span>(<span class="hljs-comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span>        LOCK.wait();    &#125;    <span class="hljs-comment">//满足条件后再运行</span>&#125;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;    <span class="hljs-comment">//唤醒所有等待线程</span>    LOCK.notifyAll();&#125;</code></pre></div><h2 id="7、同步模式之保护性暂停"><a href="#7、同步模式之保护性暂停" class="headerlink" title="7、同步模式之保护性暂停"></a>7、同步模式之保护性暂停</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1)定义"></a>(1)定义</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png" alt="img"></a></p><h3 id="2-举例"><a href="#2-举例" class="headerlink" title="(2)举例"></a>(2)举例</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String hello = <span class="hljs-string">&quot;hello thread!&quot;</span>;        Guarded guarded = <span class="hljs-keyword">new</span> Guarded();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(<span class="hljs-string">&quot;想要得到结果&quot;</span>);            <span class="hljs-keyword">synchronized</span> (guarded) &#123;                System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span>+guarded.getResponse());            &#125;            System.out.println(<span class="hljs-string">&quot;得到结果&quot;</span>);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(<span class="hljs-string">&quot;设置结果&quot;</span>);            <span class="hljs-keyword">synchronized</span> (guarded) &#123;                guarded.setResponse(hello);            &#125;        &#125;).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Guarded</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 要返回的结果</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Object response;    <span class="hljs-comment">//优雅地使用wait/notify</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//如果返回结果为空就一直等待，避免虚假唤醒</span>        <span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">this</span>.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> response;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;        <span class="hljs-keyword">this</span>.response = response;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">//唤醒休眠的线程</span>            <span class="hljs-keyword">this</span>.notifyAll();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Guarded&#123;&quot;</span> +                <span class="hljs-string">&quot;response=&quot;</span> + response +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p><strong>带超时判断的暂停</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">//获取开始时间</span>            <span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis();            <span class="hljs-comment">//用于保存已经等待了的时间</span>            <span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//看经过的时间-开始时间是否超过了指定时间</span>                <span class="hljs-keyword">long</span> waitTime = time -passedTime;                <span class="hljs-keyword">if</span>(waitTime &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">try</span> &#123;                       <span class="hljs-comment">//等待剩余时间</span>                    <span class="hljs-keyword">this</span>.wait(waitTime);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-comment">//获取当前时间</span>                passedTime = System.currentTimeMillis()-currentTime                    &#125;        &#125;        <span class="hljs-keyword">return</span> response;    &#125;</code></pre></div><h3 id="3-join源码——使用保护性暂停模式"><a href="#3-join源码——使用保护性暂停模式" class="headerlink" title="(3)join源码——使用保护性暂停模式"></a>(3)join源码——使用保护性暂停模式</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> base = System.currentTimeMillis();        <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span> (isAlive()) &#123;                wait(<span class="hljs-number">0</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">while</span> (isAlive()) &#123;              <span class="hljs-comment">//同样的思想，用于join</span>                <span class="hljs-keyword">long</span> delay = millis - now;                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                wait(delay);                now = System.currentTimeMillis() - base;            &#125;        &#125;    &#125;</code></pre></div><h2 id="8、异步模式之生产者-消费者"><a href="#8、异步模式之生产者-消费者" class="headerlink" title="8、异步模式之生产者/消费者"></a>8、异步模式之生产者/消费者</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1)定义"></a>(1)定义</h3><ul><li>与前面的保护性暂停中的GuardObject不同，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj133103oj31bo0bmahb.jpg" alt="image-20210414094410348"></p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="(2)代码"></a>(2)代码</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test21&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMessageQueue</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MessageQueue queue = <span class="hljs-keyword">new</span> MessageQueue(<span class="hljs-number">2</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">int</span> id = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                queue.put(<span class="hljs-keyword">new</span> Message(id , <span class="hljs-string">&quot;值&quot;</span>+id));            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();        &#125;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;                sleep(<span class="hljs-number">1</span>);                Message message = queue.take();            &#125;        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();    &#125;&#125;<span class="hljs-comment">// 消息队列类 ， java 线程之间通信</span><span class="hljs-meta">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;    <span class="hljs-comment">// 消息的队列集合,双向队列</span>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-comment">// 队列容量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;        <span class="hljs-keyword">this</span>.capcity = capcity;    &#125;    <span class="hljs-comment">// 获取消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 检查队列是否为空</span>        <span class="hljs-keyword">synchronized</span> (list) &#123;            <span class="hljs-keyword">while</span>(list.isEmpty()) &#123;                <span class="hljs-keyword">try</span> &#123;                    log.debug(<span class="hljs-string">&quot;队列为空, 消费者线程等待&quot;</span>);                    list.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-comment">// 从队列头部获取消息并返回</span>            Message message = list.removeFirst();            log.debug(<span class="hljs-string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);            list.notifyAll();            <span class="hljs-keyword">return</span> message;        &#125;    &#125;    <span class="hljs-comment">// 存入消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Message message)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (list) &#123;            <span class="hljs-comment">// 检查对象是否已满</span>            <span class="hljs-keyword">while</span>(list.size() == capcity) &#123;                <span class="hljs-keyword">try</span> &#123;                    log.debug(<span class="hljs-string">&quot;队列已满, 生产者线程等待&quot;</span>);                    list.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-comment">// 将消息加入队列尾部</span>            list.addLast(message);            log.debug(<span class="hljs-string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);            list.notifyAll();        &#125;    &#125;&#125;<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> Object value;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, Object value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.value = value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, value=&quot;</span> + value +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><h2 id="9、park-unpark"><a href="#9、park-unpark" class="headerlink" title="9、park/unpark"></a>9、park/unpark</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1)基本使用"></a>(1)基本使用</h3><p><strong>park/unpark都是LockSupport类中的的方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//暂停线程运行</span>LockSupport.park;<span class="hljs-comment">//恢复线程运行</span>LockSupport.unpark(thread); <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            System.out.println(<span class="hljs-string">&quot;park&quot;</span>);            <span class="hljs-comment">//暂停线程运行</span>            LockSupport.park();            System.out.println(<span class="hljs-string">&quot;resume&quot;</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);        thread.start();        Thread.sleep(<span class="hljs-number">1000</span>);        System.out.println(<span class="hljs-string">&quot;unpark&quot;</span>);        <span class="hljs-comment">//恢复线程运行</span>        LockSupport.unpark(thread);    &#125;</code></pre></div><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h3><p><strong>与wait/notify的区别</strong></p><ul><li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li><li>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</li><li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li><li><strong>park不会释放锁</strong>，而wait会释放锁</li></ul><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="(3)原理"></a>(3)原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象**_counter, _cond,__mutex**组成</p><ul><li>先调用park再调用unpark时<ul><li><p>先调用park</p><ul><li>线程运行时，会将Park对象中的**_counter的值设为0**；</li><li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li><li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li></ul></li><li><p>然后调用unpark</p><ul><li><p>调用unpark方法后，会将counter的值设置为1</p></li><li><p>去唤醒阻塞队列cond中的线程</p></li><li><p>线程继续运行并将counter的值设为0</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png" alt="img"></a></p></li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png" alt="img"></a></p><ul><li>先调用unpark，再调用park<ul><li>调用unpark<ul><li>会将counter设置为1（运行时0）</li></ul></li><li>调用park方法<ul><li>查看counter是否为0</li><li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png" alt="img"></a></p><h2 id="10、线程中的状态转换"><a href="#10、线程中的状态转换" class="headerlink" title="10、线程中的状态转换"></a>10、线程中的状态转换</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png" alt="img"></a></p><h3 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h3><ul><li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE </li></ul><h3 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul><li><p>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</p></li><li><p>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时</p><ul><li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE </li><li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED </li></ul></li></ul></li></ul><h3 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h3><ul><li><p>当前线程</p><p>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</p><ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</p></li></ul><h3 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ul><h3 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ul><li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED </li></ul></li></ul><h3 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li><p>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p></li><li><p>注意是当前线程在t 线程对象的监视器上等待 </p></li><li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</p></li></ul><h3 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING </li><li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h3 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE –&gt; TIMED_WAITING </li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li></ul><h3 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h3><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED </li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然 BLOCKED </li></ul><h3 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p><h2 id="11、多把锁"><a href="#11、多把锁" class="headerlink" title="11、多把锁"></a>11、多把锁</h2><p><strong>将锁的粒度细分</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;    <span class="hljs-comment">//额外创建对象来作为锁</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();&#125;</code></pre></div><ul><li>好处，是可以增加并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><h2 id="12、活跃性"><a href="#12、活跃性" class="headerlink" title="12、活跃性"></a>12、活跃性</h2><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="(1)定义"></a>(1)定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p><h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：t1线程获得A对象锁，接下来想获取B对象的锁</p><p>​         t2线程获得B对象锁，接下来想获取A对象的锁 </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> Object A = <span class="hljs-keyword">new</span> Object();        <span class="hljs-keyword">final</span> Object B = <span class="hljs-keyword">new</span> Object();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">synchronized</span> (A) &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">2000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">synchronized</span> (B) &#123;                &#125;            &#125;        &#125;).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">synchronized</span> (B) &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">synchronized</span> (A) &#123;                &#125;            &#125;        &#125;).start();    &#125;</code></pre></div><h4 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h4><ul><li>互斥条件<ul><li>在一段时间内，一种资源只能被一个进程所使用</li></ul></li><li>请求和保持条件<ul><li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li></ul></li><li>不可抢占条件<ul><li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li></ul></li><li>循环等待条件<ul><li>发生死锁时，必然存在一个进程——资源的循环链。</li></ul></li></ul><h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul><li><p><code>jps+jstack ThreadID</code></p><ul><li>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID，使用<strong>jstack ThreadID</strong>可以查看线程状态。<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png" alt="img"></a></li></ul><div class="hljs code-wrapper"><pre><code class="hljs sh">❯ jps14196 RemoteMavenServer36694 NutstoreGUI14871 Launcher14872 TestDeadLock14121 14876 Jps❯ ❯ ❯ jstack 14872</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs smali">  - 打印的结果    ```java  //找到一个java级别的死锁  Found one Java-level deadlock:  =============================  <span class="hljs-string">&quot;Thread-1&quot;</span>:    waiting to lock<span class="hljs-built_in"> monitor </span>0x0000000017f40de8 (object 0x00000000d6188880, a java.lang.Object),    which is held by <span class="hljs-string">&quot;Thread-0&quot;</span>  <span class="hljs-string">&quot;Thread-0&quot;</span>:    waiting to lock<span class="hljs-built_in"> monitor </span>0x0000000017f43678 (object 0x00000000d6188890, a java.lang.Object),    which is held by <span class="hljs-string">&quot;Thread-1&quot;</span></code></pre></div></li><li><p>jconsole检测死锁</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png" alt="img"></a></p></li></ul><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png" alt="img"></a></p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png" alt="img"></a></p><h3 id="3-活锁"><a href="#3-活锁" class="headerlink" title="(3)活锁"></a>(3)活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h3 id="4-饥饿"><a href="#4-饥饿" class="headerlink" title="(4)饥饿"></a>(4)饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p><strong>在使用顺序加锁时，可能会出现饥饿现象</strong></p><h2 id="13、ReentrantLock"><a href="#13、ReentrantLock" class="headerlink" title="13、ReentrantLock"></a>13、ReentrantLock</h2><p><strong>和synchronized相比具有的的特点</strong></p><ul><li>可中断 </li><li>可以设置超时时间 </li><li>可以设置为公平锁 (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li></ul><p><strong>基本语法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取ReentrantLock对象</span><span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//加锁</span>lock.lock();<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//需要执行的代码</span>&#125;<span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">//释放锁</span>    lock.unlock();&#125;</code></pre></div><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//加锁，可打断锁</span>                lock.lockInterruptibly();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();                <span class="hljs-comment">//被打断，返回，不再向下执行</span>                <span class="hljs-keyword">return</span>;            &#125;<span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">//释放锁</span>                lock.unlock();            &#125;        &#125;);        lock.lock();        <span class="hljs-keyword">try</span> &#123;            t1.start();            Thread.sleep(<span class="hljs-number">1000</span>);            <span class="hljs-comment">//打断</span>            t1.interrupt();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;</code></pre></div><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>不设置等待时间</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-comment">//未设置等待时间，一旦获取失败，直接返回false</span>            <span class="hljs-keyword">if</span>(!lock.tryLock()) &#123;                System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);                <span class="hljs-comment">//获取失败，不再向下执行，返回</span>                <span class="hljs-keyword">return</span>;            &#125;            System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);            lock.unlock();        &#125;);        lock.lock();        <span class="hljs-keyword">try</span>&#123;            t1.start();            Thread.sleep(<span class="hljs-number">3000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;</code></pre></div><p>设置等待时间</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//判断获取锁是否成功，最多等待1秒</span>                <span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;                    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);                    <span class="hljs-comment">//获取失败，不再向下执行，直接返回</span>                    <span class="hljs-keyword">return</span>;                &#125;            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();                <span class="hljs-comment">//被打断，不再向下执行，直接返回</span>                <span class="hljs-keyword">return</span>;            &#125;            System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);            <span class="hljs-comment">//释放锁</span>            lock.unlock();        &#125;);        lock.lock();        <span class="hljs-keyword">try</span>&#123;            t1.start();            <span class="hljs-comment">//打断等待</span>            t1.interrupt();            Thread.sleep(<span class="hljs-number">3000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;</code></pre></div><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre></div><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比 </p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息 </li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li></ul><p>使用要点：</p><ul><li>await 前需要<strong>获得锁</strong></li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁 </li><li>竞争 lock 锁成功后，从 await 后继续执</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-comment">//获得条件变量</span>    Condition condition = lock.newCondition();    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        lock.lock();        <span class="hljs-keyword">try</span>&#123;            <span class="hljs-keyword">while</span>(!judge) &#123;                System.out.println(<span class="hljs-string">&quot;不满足条件，等待...&quot;</span>);                <span class="hljs-comment">//等待</span>                condition.await();            &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(<span class="hljs-string">&quot;执行完毕！&quot;</span>);            lock.unlock();        &#125;    &#125;).start();    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1</span>);            judge = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">//释放</span>            condition.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;).start();&#125;</code></pre></div><h4 id="通过Lock与AQS实现可重入锁"><a href="#通过Lock与AQS实现可重入锁" class="headerlink" title="通过Lock与AQS实现可重入锁"></a>通过Lock与AQS实现可重入锁</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;               setExclusiveOwnerThread(Thread.currentThread());               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;         &#125;         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == Thread.currentThread()) &#123;            <span class="hljs-keyword">int</span> state = getState();            compareAndSetState(state, state + <span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;         &#125;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;         <span class="hljs-keyword">if</span> (getState() &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();         &#125;         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();         &#125;         <span class="hljs-keyword">int</span> state = getState();         <span class="hljs-keyword">if</span> (state == <span class="hljs-number">1</span>) &#123;            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);            compareAndSetState(state, <span class="hljs-number">0</span>);         &#125; <span class="hljs-keyword">else</span> &#123;            compareAndSetState(state, state - <span class="hljs-number">1</span>);         &#125;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> getState() &gt;= <span class="hljs-number">1</span>;      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();      &#125;   &#125;   Sync sync = <span class="hljs-keyword">new</span> Sync();   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;      sync.acquire(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      sync.acquireInterruptibly(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, time);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;      sync.release(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> sync.newCondition();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException </span>&#123;      MyLock lock = <span class="hljs-keyword">new</span> MyLock();      Object syncLock = <span class="hljs-keyword">new</span> Object();      Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;               lock.lock();               <span class="hljs-keyword">try</span> &#123;                  lock.lock();                  <span class="hljs-keyword">try</span> &#123;                     num++;                  &#125; <span class="hljs-keyword">finally</span> &#123;                     lock.unlock();                  &#125;               &#125; <span class="hljs-keyword">finally</span> &#123;                  lock.unlock();               &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;               lock.unlock();            &#125;         &#125;      &#125;);      Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;               lock.lock();               <span class="hljs-keyword">try</span> &#123;                  lock.lock();                  <span class="hljs-keyword">try</span> &#123;                     num--;                  &#125; <span class="hljs-keyword">finally</span> &#123;                     lock.unlock();                  &#125;               &#125; <span class="hljs-keyword">finally</span> &#123;                  lock.unlock();               &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;               lock.unlock();            &#125;         &#125;      &#125;);      t1.start();      t2.start();      t1.join();      t2.join();      <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;   &#125;&#125;</code></pre></div><h2 id="14、同步模式之顺序控制"><a href="#14、同步模式之顺序控制" class="headerlink" title="14、同步模式之顺序控制"></a>14、同步模式之顺序控制</h2><h3 id="Wait-Notify版本"><a href="#Wait-Notify版本" class="headerlink" title="Wait/Notify版本"></a>Wait/Notify版本</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//判断先执行的内容是否执行完毕</span><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;            <span class="hljs-keyword">while</span> (!judge) &#123;                <span class="hljs-keyword">try</span> &#123;                    LOCK.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);        &#125;    &#125;).start();    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;            System.out.println(<span class="hljs-string">&quot;1&quot;</span>);            judge = <span class="hljs-keyword">true</span>;               <span class="hljs-comment">//执行完毕，唤醒所有等待线程</span>            LOCK.notifyAll();        &#125;    &#125;).start();&#125;</code></pre></div><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><h5 id="wait-notify版本"><a href="#wait-notify版本" class="headerlink" title="wait/notify版本"></a><strong>wait/notify版本</strong></h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test27&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test27</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        WaitNotify wn = <span class="hljs-keyword">new</span> WaitNotify(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            wn.print(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            wn.print(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            wn.print(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);        &#125;).start();    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出内容       等待标记     下一个标记</span><span class="hljs-comment">   a           1             2</span><span class="hljs-comment">   b           2             3</span><span class="hljs-comment">   c           3             1</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;    <span class="hljs-comment">// 打印               a           1             2</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> waitFlag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                <span class="hljs-keyword">while</span>(flag != waitFlag) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">this</span>.wait();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                System.out.print(str);                flag = nextFlag;                <span class="hljs-keyword">this</span>.notifyAll();            &#125;        &#125;    &#125;    <span class="hljs-comment">// 等待标记</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag; <span class="hljs-comment">// 2</span>    <span class="hljs-comment">// 循环次数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WaitNotify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">this</span>.flag = flag;        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;    &#125;&#125;</code></pre></div><h5 id="await-signal版本"><a href="#await-signal版本" class="headerlink" title="await/signal版本"></a>await/signal版本</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test30</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal(<span class="hljs-number">5</span>);        Condition a = awaitSignal.newCondition();        Condition b = awaitSignal.newCondition();        Condition c = awaitSignal.newCondition();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a, b);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b, c);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c, a);        &#125;).start();        Thread.sleep(<span class="hljs-number">1000</span>);        <span class="hljs-comment">//刚开始所有线程都在await，需要主线程唤醒a</span>        awaitSignal.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(<span class="hljs-string">&quot;开始...&quot;</span>);            a.signal();        &#125; <span class="hljs-keyword">finally</span> &#123;            awaitSignal.unlock();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AwaitSignal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;    &#125;    <span class="hljs-comment">//            参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            <span class="hljs-comment">//继承了ReentrantLock，可以直接Lock，相当于this.lock()</span>            lock();            <span class="hljs-keyword">try</span> &#123;                current.await();                System.out.print(str);                next.signal();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                unlock();            &#125;        &#125;    &#125;&#125;</code></pre></div><h5 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park/unpark"></a>park/unpark</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test31&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test31</span> </span>&#123;    <span class="hljs-keyword">static</span> Thread t1;    <span class="hljs-keyword">static</span> Thread t2;    <span class="hljs-keyword">static</span> Thread t3;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ParkUnpark pu = <span class="hljs-keyword">new</span> ParkUnpark(<span class="hljs-number">5</span>);        t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            pu.print(<span class="hljs-string">&quot;a&quot;</span>, t2);        &#125;);        t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            pu.print(<span class="hljs-string">&quot;b&quot;</span>, t3);        &#125;);        t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            pu.print(<span class="hljs-string">&quot;c&quot;</span>, t1);        &#125;);        t1.start();        t2.start();        t3.start();        <span class="hljs-comment">//主线程发起者</span>        LockSupport.unpark(t1);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnpark</span> </span>&#123;    <span class="hljs-comment">//park不需要记录当前，因为park会自己记录</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Thread next)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            LockSupport.park();            System.out.print(str);            LockSupport.unpark(next);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParkUnpark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;    &#125;&#125;</code></pre></div><h2 id="14、ThreadLocal"><a href="#14、ThreadLocal" class="headerlink" title="14、ThreadLocal"></a>14、ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么<strong>访问这个变量的每个线程都会有这个变量的一个本地副本</strong>。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而<strong>避免了线程安全</strong>问题</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalStudy</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 创建ThreadLocal变量</span>      ThreadLocal&lt;String&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();      ThreadLocal&lt;User&gt; userThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();      <span class="hljs-comment">// 创建两个线程，分别使用上面的两个ThreadLocal变量</span>      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-comment">// stringThreadLocal第一次赋值</span>         stringThreadLocal.set(<span class="hljs-string">&quot;thread1 stringThreadLocal first&quot;</span>);         <span class="hljs-comment">// stringThreadLocal第二次赋值</span>         stringThreadLocal.set(<span class="hljs-string">&quot;thread1 stringThreadLocal second&quot;</span>);         <span class="hljs-comment">// userThreadLocal赋值</span>         userThreadLocal.set(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Lucifer&quot;</span>, <span class="hljs-number">24</span>));         <span class="hljs-comment">// 取值</span>         System.out.println(stringThreadLocal.get());         System.out.println(userThreadLocal.get());          <span class="hljs-comment">// 移除</span>         userThreadLocal.remove();         System.out.println(userThreadLocal.get());      &#125;);      Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-comment">// stringThreadLocal第一次赋值</span>         stringThreadLocal.set(<span class="hljs-string">&quot;thread2 stringThreadLocal first&quot;</span>);         <span class="hljs-comment">// stringThreadLocal第二次赋值</span>         stringThreadLocal.set(<span class="hljs-string">&quot;thread2 stringThreadLocal second&quot;</span>);         <span class="hljs-comment">// userThreadLocal赋值</span>         userThreadLocal.set(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Melrose&quot;</span>, <span class="hljs-number">9</span>));         <span class="hljs-comment">// 取值</span>         System.out.println(stringThreadLocal.get());         System.out.println(userThreadLocal.get());      &#125;);      <span class="hljs-comment">// 启动线程</span>      thread1.start();      thread2.start();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;   String name;   <span class="hljs-keyword">int</span> age;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;      <span class="hljs-keyword">this</span>.age = age;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +            <span class="hljs-string">&quot;, age=&quot;</span> + age +            <span class="hljs-string">&#x27;&#125;&#x27;</span>;   &#125;&#125;</code></pre></div><p><strong>运行结果</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">thread1 stringThreadLocal secondthread2 stringThreadLocal secondUser&#123;name=&#x27;Lucifer&#x27;, age=24&#125;User&#123;name=&#x27;Melrose&#x27;, age=9&#125;null</code></pre></div><p>从运行结果可以看出</p><ul><li><strong>每个线程中的ThreadLocal变量是线程私有的</strong>，而不是共享的<ul><li>从线程1和线程2的打印结果可以看出</li></ul></li><li>ThreadLocal其实就相当于其泛型类型的一个变量，只不过是每个线程私有的<ul><li>stringThreadLocal被赋值了两次，保存的是最后一次赋值的结果</li></ul></li><li>ThreadLocal可以进行以下几个操作<ul><li>set 设置值</li><li>get 取出值</li><li>remove 移除值</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Thread中的threadLocals"><a href="#Thread中的threadLocals" class="headerlink" title="Thread中的threadLocals"></a>Thread中的threadLocals</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123; ... ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 放在后面说</span> ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>; ...&#125; <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;            <span class="hljs-keyword">super</span>(k);            value = v;        &#125;    &#125;</code></pre></div><p>可以看出Thread类中有一个threadLocals和一个inheritableThreadLocals，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的Hashmap。在默认情况下，每个线程中的这两个变量都为null。此处先讨论threadLocals，inheritableThreadLocals放在后面讨论</p><h4 id="ThreadLocal中的方法"><a href="#ThreadLocal中的方法" class="headerlink" title="ThreadLocal中的方法"></a><strong>ThreadLocal中的方法</strong></h4><p><strong>set方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;    <span class="hljs-comment">// 获取当前线程</span>    Thread t = Thread.currentThread();    <span class="hljs-comment">// 获得ThreadLocalMap对象 </span>    <span class="hljs-comment">// 这里的get会返回Thread类中的threadLocals</span>    ThreadLocalMap map = getMap(t);    <span class="hljs-comment">// 判断map是否已经创建，没创建就创建并放入值，创建了就直接放入</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// ThreadLocal自生的引用作为key，传入的值作为value</span>        map.set(<span class="hljs-keyword">this</span>, value);    <span class="hljs-keyword">else</span>        createMap(t, value);&#125;</code></pre></div><p><strong>如果未创建</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;    <span class="hljs-comment">// 创建的同时设置想放入的值</span>    <span class="hljs-comment">// hreadLocal自生的引用作为key，传入的值作为value</span>    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);&#125;</code></pre></div><p><strong>get方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 获取当前线程</span>    Thread t = Thread.currentThread();    <span class="hljs-comment">// 获取当前线程的threadLocals变量</span>    ThreadLocalMap map = getMap(t);    <span class="hljs-comment">// 判断threadLocals是否被初始化了</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 已经初始化则直接返回</span>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            T result = (T)e.value;            <span class="hljs-keyword">return</span> result;        &#125;    &#125;    <span class="hljs-comment">// 否则就创建threadLocals</span>    <span class="hljs-keyword">return</span> setInitialValue();&#125; <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">setInitialValue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 这个方法返回是null</span>    T value = initialValue();    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    <span class="hljs-comment">// 无论map创建与否，最终value的值都为null</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)        map.set(<span class="hljs-keyword">this</span>, value);    <span class="hljs-keyword">else</span>        createMap(t, value);    <span class="hljs-keyword">return</span> value;&#125;<span class="hljs-function">Cop otected T <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p><strong>remove方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    ThreadLocalMap m = getMap(Thread.currentThread());    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// 如果threadLocals已经被初始化，则移除</span>        m.remove(<span class="hljs-keyword">this</span>);&#125;</code></pre></div><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为HashMap，其中<strong>key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值</strong>。每个线程的本地变量存放在线程自己的内存变量threadLocals中</p><p>只有当前线程<strong>第一次调用ThreadLocal的set或者get方法时才会创建threadLocals</strong>（inheritableThreadLocals也是一样）。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</p><h2 id="15、InheritableThreadLocal"><a href="#15、InheritableThreadLocal" class="headerlink" title="15、InheritableThreadLocal"></a>15、InheritableThreadLocal</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>从ThreadLocal的源码可以看出，无论是set、get、还是remove，都是相对于当前线程操作的</p><div class="hljs code-wrapper"><pre><code class="hljs java">Thread.currentThread()</code></pre></div><p><strong>ThreadLocal无法从父线程传向子线程</strong>，<strong>InheritableThreadLocal它能够让父线程中ThreadLocal的值传给子线程。</strong></p><p>也就是从main所在的线程，传给thread1或thread2</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ThreadLocal&lt;String&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();      InheritableThreadLocal&lt;String&gt; stringInheritable = <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;&gt;();      <span class="hljs-comment">// 主线程赋对上面两个变量进行赋值</span>      stringThreadLocal.set(<span class="hljs-string">&quot;this is threadLocal&quot;</span>);      stringInheritable.set(<span class="hljs-string">&quot;this is inheritableThreadLocal&quot;</span>);      <span class="hljs-comment">// 创建线程</span>      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-comment">// 获得ThreadLocal中存放的值</span>         System.out.println(stringThreadLocal.get());         <span class="hljs-comment">// 获得InheritableThreadLocal存放的值</span>         System.out.println(stringInheritable.get());      &#125;);      thread1.start();   &#125;&#125;</code></pre></div><p><strong>运行结果</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">nullthis is inheritableThreadLocal</code></pre></div><p>可以看出InheritableThreadLocal的值成功从主线程传入了子线程，而ThreadLocal则没有</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritableThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">// 传入父线程中的一个值，然后直接返回</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">childValue</span><span class="hljs-params">(T parentValue)</span> </span>&#123;        <span class="hljs-keyword">return</span> parentValue;    &#125;      <span class="hljs-comment">// 返回传入线程的inheritableThreadLocals</span>    <span class="hljs-comment">// Thread中有一个inheritableThreadLocals变量</span>    <span class="hljs-comment">// ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span>    <span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;    &#125;     <span class="hljs-comment">// 创建一个inheritableThreadLocals</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);    &#125;&#125;</code></pre></div><p>由如上代码可知，InheritableThreadLocal继承了ThreadLocal，并重写了三个方法。InheritableThreadLocal重写了<strong>createMap方法</strong>，那么现在当第一次调用set方法时，创建的是当前线程的inheritableThreadLocals变量的实例而不再是threadLocals。当调用<strong>getMap方法</strong>获取当前线程内部的map变量时，获取的是inheritableThreadLocals而不再是threadLocals</p><h4 id="childValue-T-parentValue-方法的调用"><a href="#childValue-T-parentValue-方法的调用" class="headerlink" title="childValue(T parentValue)方法的调用"></a>childValue(T parentValue)方法的调用</h4><p>在主函数运行时，会调用Thread的默认构造函数（<strong>创建主线程</strong>，也就是父线程），所以我们先看看Thread的默认构造函数</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span> </span>&#123;    init(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);&#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span></span><span class="hljs-function"><span class="hljs-params">                  <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><span class="hljs-function"><span class="hljs-params">                  <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;       ...    <span class="hljs-comment">// 获得当前线程的，在这里是主线程</span>    Thread parent = currentThread();    ...    <span class="hljs-comment">// 如果父线程的inheritableThreadLocals存在</span>    <span class="hljs-comment">// 我们在主线程中调用set和get时，会创建inheritableThreadLocals</span>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// 设置子线程的inheritableThreadLocals</span>        <span class="hljs-keyword">this</span>.inheritableThreadLocals =            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);    <span class="hljs-comment">/* Stash the specified stack size in case the VM cares */</span>    <span class="hljs-keyword">this</span>.stackSize = stackSize;    <span class="hljs-comment">/* Set thread ID */</span>    tid = nextThreadID();&#125;<span class="hljs-function">Cop atic ThreadLocalMap <span class="hljs-title">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadLocalMap(parentMap);&#125;</code></pre></div><p>在createInheritedMap内部使用父线程的inheritableThreadLocals变量作为构造函数创建了一个新的ThreadLocalMap变量，然后赋值给了子线程的inheritableThreadLocals变量</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> </span>&#123;    Entry[] parentTable = parentMap.table;    <span class="hljs-keyword">int</span> len = parentTable.length;    setThreshold(len);    table = <span class="hljs-keyword">new</span> Entry[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;        Entry e = parentTable[j];        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();            <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 这里调用了 childValue 方法</span>                <span class="hljs-comment">// 该方法会返回parent的值</span>                Object value = key.childValue(e.value);                Entry c = <span class="hljs-keyword">new</span> Entry(key, value);                <span class="hljs-keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);                <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-keyword">null</span>)                    h = nextIndex(h, len);                table[h] = c;                size++;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>在该构造函数内部把父线程的inheritableThreadLocals成员变量的值复制到新的ThreadLocalMap对象中</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>InheritableThreadLocal类通过重写getMap和createMap，让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程在通过InheritableThreadLocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritableThreadLocals变量。</p><p><strong>当父线程创建子线程时，构造函数会把父线程中inheritableThreadLocals变量里面的本地变量复制一份保存到子线程的inheritableThreadLocals变量里面。</strong></p><h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="1、JAVA内存模型（JMM）"><a href="#1、JAVA内存模型（JMM）" class="headerlink" title="1、JAVA内存模型（JMM）"></a>1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。 </p><p><strong>JMM体现在以下几个方面</strong></p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h4><p><strong>退出不出的循环</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">while</span> (run) &#123;                <span class="hljs-comment">//如果run为真，则一直执行</span>            &#125;        &#125;).start();        Thread.sleep(<span class="hljs-number">1000</span>);        System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);        run = <span class="hljs-keyword">false</span>;    &#125;</code></pre></div><p><strong>为什么无法退出该循环</strong></p><ul><li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png" alt="img"></a></p><ul><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png" alt="img"></a></p><ul><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png" alt="img"></a></p><p><strong>解决方法</strong></p><ul><li>使用<strong>volatile</strong>易变关键字</li><li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//使用易变关键字</span><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        <span class="hljs-keyword">while</span> (run) &#123;            <span class="hljs-comment">//如果run为真，则一直执行</span>        &#125;    &#125;).start();    Thread.sleep(<span class="hljs-number">1000</span>);    System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);    run = <span class="hljs-keyword">false</span>;&#125;</code></pre></div><h4 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h4><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</p></li><li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p><ul><li>因为使用了<strong>synchronized</strong>关键字<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;        <span class="hljs-comment">//使用了synchronized关键字</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            print(x);            newLine();        &#125;    &#125;</code></pre></div></li></ul></li></ul><h4 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();        monitor.start();        Thread.sleep(<span class="hljs-number">3500</span>);        monitor.stop();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;    Thread monitor;    <span class="hljs-comment">//设置标记，用于判断是否被终止了</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 启动监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//开始不停的监控</span>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-keyword">if</span>(stop) &#123;                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                    System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//线程休眠</span>                        Thread.sleep(<span class="hljs-number">1000</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);                    &#125;                &#125;            &#125;        &#125;;        monitor.start();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *     用于停止监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//打断线程</span>        monitor.interrupt();        <span class="hljs-comment">//修改标记</span>        stop = <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h4 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h4><p><strong>定义</strong></p><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong></p><ul><li>用一个标记来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题<ul><li>加锁的代码块要尽量的小，以保证性能</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();        monitor.start();        monitor.start();        Thread.sleep(<span class="hljs-number">3500</span>);        monitor.stop();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;    Thread monitor;    <span class="hljs-comment">//设置标记，用于判断是否被终止了</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 启动监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">if</span> (starting) &#123;                <span class="hljs-comment">//已被启动，直接返回</span>                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">//启动监视器，改变标记</span>            starting = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//开始不停的监控</span>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-keyword">if</span>(stop) &#123;                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                    System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//线程休眠</span>                        Thread.sleep(<span class="hljs-number">1000</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);                    &#125;                &#125;            &#125;        &#125;;        monitor.start();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *     用于停止监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//打断线程</span>        monitor.interrupt();        stop = <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png" alt="img"></a></p><p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p><h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul><li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png" alt="img"></a></p><ul><li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></p></li><li><p>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子 </span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; System.out.println( a + b );<span class="hljs-comment">// 不能重排的例子 </span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> b = a - <span class="hljs-number">5</span>;</code></pre></div></li></ul><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级<strong>指令流水线</strong>，例如支持<strong>同时</strong>执行 <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地<strong>吞吐率</strong>。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png" alt="img"></a></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p><ul><li>禁止的是加volatile关键字变量之前的代码被重排序</li></ul><h2 id="4、内存屏障"><a href="#4、内存屏障" class="headerlink" title="4、内存屏障"></a>4、内存屏障</h2><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><ul><li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中 </li><li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后</strong>，对共享变量的读取，加载的是主存中新数据 </li></ul><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><ul><li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后 </li><li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li></ul><h2 id="5、volatile-原理"><a href="#5、volatile-原理" class="headerlink" title="5、volatile 原理"></a>5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障 </li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png" alt="img"></a></p></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png" alt="img"></a></p></li></ul><h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png" alt="img"></a></p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png" alt="img"></a></p><p><strong>但是不能解决指令交错问题</strong></p><ul><li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去 </li><li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li></ul><h3 id="double-checked-locking"><a href="#double-checked-locking" class="headerlink" title="double-checked locking"></a>double-checked locking</h3><p>以著名的 double-checked locking 单例模式为例</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span><span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;   <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-comment">// t1 </span>   INSTANCE = <span class="hljs-keyword">new</span> Singleton();   &#125;&#125;&#125;   <span class="hljs-keyword">return</span> INSTANCE;&#125;&#125;</code></pre></div><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li></ul><p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpjnh8hyzhj31ba0u0wjy.jpg" alt="image-20210414223856348"></p><p>其中</p><ul><li>17 表示创建对象，将对象引用入栈 // new Singleton</li><li>20 表示复制一份对象引用 // 引用地址</li><li>21 表示利用一个对象引用，调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpjnibyqsnj31j50u0n0r.jpg" alt="image-20210414224002739"></p><p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值 </p><p>这时 <strong>t1 还未完全将构造方法执行完毕</strong>，如果在构造方法中要执行很多初始化操作，那么 <strong>t2 拿到的是将是一个未初始化完毕的单例</strong> </p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><p><strong>如何解决：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;   <span class="hljs-comment">//解决重排序的问题</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">// t2 </span>         <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次 </span>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1 </span>          INSTANCE = <span class="hljs-keyword">new</span> Singleton();         &#125;&#125;&#125;     <span class="hljs-keyword">return</span> INSTANCE;&#125;&#125;</code></pre></div><p>字节码上看不出来 volatile 指令的效果</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span>0: getstatic  #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpk7c82cqxj31c00u0dpb.jpg" alt="image-20210415100608659"></p><p>如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证可见性和有序性</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpk7dys4gzj31gq0u0443.jpg" alt="image-20210415100749610"></p><h3 id="balking模式习题"><a href="#balking模式习题" class="headerlink" title="balking模式习题"></a>balking模式习题</h3><p>希望doInit方法仅被调用一次，下面实现有问题</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span></span>&#123;  <span class="hljs-comment">//volatile只能保证共享变量可见性，不能保证原子性</span>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> initialized = <span class="hljs-keyword">false</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//一次出现，volatile有序性也只能保证变量之前的读写屏障</span>    <span class="hljs-keyword">if</span>(initialized)&#123;      <span class="hljs-keyword">return</span>;    &#125;    doInit();    <span class="hljs-comment">//二次出现，线程1还没来得及赋值，线程2已经进入到了if判断</span>    initialized = <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span><span class="hljs-params">()</span></span>&#123;&#125;&#125;</code></pre></div><p>所以要用<strong>synchronized</strong>来保证以上的问题</p><h3 id="实现原理之Lock前缀"><a href="#实现原理之Lock前缀" class="headerlink" title="实现原理之Lock前缀"></a>实现原理之Lock前缀</h3><p>在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">instance</span> = new Singleton()<span class="hljs-comment">; </span></code></pre></div><p>对应的汇编代码是</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">...</span> lock addl <span class="hljs-string">...</span></code></pre></div><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，<strong>Lock前缀</strong>的指令在多核处理器下会引发了两件事</p><ul><li>Lock前缀指令会引起处理器缓存回写到内存<ul><li>Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是<strong>锁缓存</strong>，毕竟锁总线开销的比较大。使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong></li></ul></li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效<ul><li>在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能<strong>嗅探其他处理器访问系统内存和它们的内部缓存</strong>。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致</li></ul></li></ul><h2 id="6、final原理"><a href="#6、final原理" class="headerlink" title="6、final原理"></a>6、final原理</h2><p>理解了 volatile 原理，再对比 ﬁnal 的实现就比较简单了</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinal</span> </span>&#123;   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>; &#125;</code></pre></div><p>字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">0</span>: aload_0 1: invokespecial #1 <span class="hljs-number">4</span>: aload_0 <span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span> 7: putfield #2 &lt;-- 写屏障 <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span></code></pre></div><p>发现ﬁnal变量的赋值也会通过putﬁeld指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为0的情况</p><p><strong>final修饰的变量会有一个栈内存读取速度的优化</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">10</span>;<span class="hljs-comment">//直接从栈内存拿取</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkvwtaow5j30m605gtbi.jpg" alt="image-20210416001619162"></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">10</span>;<span class="hljs-comment">//从共享内存拿取，效率低，在堆中</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkvxy4mlpj30mg05cq6p.jpg" alt="image-20210416001725052"></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> B = Short.MAX_VALUE+<span class="hljs-number">1</span>;<span class="hljs-comment">//数值太大，此时从常量池中拿取</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkvzmusmoj30lw05ujuf.jpg" alt="image-20210416001902406"></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> B = Short.MAX_VALUE+<span class="hljs-number">1</span>;<span class="hljs-comment">//同理，从共享内存拿取，效率低，在堆中</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkw0d2xsyj30m60580w6.jpg" alt="image-20210416001944201"></p><h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="1、无锁解决线程安全问题"><a href="#1、无锁解决线程安全问题" class="headerlink" title="1、无锁解决线程安全问题"></a>1、无锁解决线程安全问题</h2><p>使用<strong>原子整数</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">AtomicInteger balance = <span class="hljs-keyword">new</span> AtomicInteger();</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">long</span> start = System.nanoTime();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                account.withdraw(<span class="hljs-number">10</span>);            &#125;));        &#125;        ts.forEach(Thread::start);        ts.forEach(t -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                t.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        <span class="hljs-keyword">long</span> end = System.nanoTime();        System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);    &#125;&#125;<span class="hljs-comment">//线程不安全的做法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer balance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;        <span class="hljs-keyword">this</span>.balance = balance;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;        balance -= amount;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Account.demo(<span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>));        Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));    &#125;&#125;<span class="hljs-comment">//线程安全的做法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-comment">//使用原子整数</span>    <span class="hljs-keyword">private</span> AtomicInteger balance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//得到原子整数的值</span>        <span class="hljs-keyword">return</span> balance.get();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">//获得修改前的值</span>            <span class="hljs-keyword">int</span> prev = balance.get();            <span class="hljs-comment">//获得修改后的值</span>            <span class="hljs-keyword">int</span> next = prev-amount;            <span class="hljs-comment">//比较并设值</span>            <span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="2、CAS与volatile"><a href="#2、CAS与volatile" class="headerlink" title="2、CAS与volatile"></a>2、CAS与volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><p>其中的<strong>关键是 compareAndSwap</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png" alt="img"></a></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul><li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li></ul></li></ul><p><strong>注意</strong></p><ul><li>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</li><li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。即一个线程对volatile变量的修改，对另一个线程可见。</p><p><strong>注意</strong></p><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">volatile</span> 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）</code></pre></div><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果 </p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png" alt="img"></a></p><p><strong>原因</strong></p><h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p><ul><li><p>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 </p></li><li><p>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 </p></li><li><p>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</p><ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 </li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="3、原子整数"><a href="#3、原子整数" class="headerlink" title="3、原子整数"></a>3、原子整数</h2><p>J.U.C 并发包提供了</p><ul><li>AtomicBoolean</li><li>AtomicInteger </li><li>AtomicLong</li></ul><p><strong>以 AtomicInteger 为例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement());</span><span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet());</span><span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet());</span><span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span>System.out.println(i.getAndDecrement());<span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0） </span>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0） </span>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><span class="hljs-keyword">final</span> System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));</code></pre></div><h2 id="4、原子引用"><a href="#4、原子引用" class="headerlink" title="4、原子引用"></a>4、原子引用</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;    <span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    </span><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccountImpl account)</span> </span>&#123;        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">long</span> start = System.nanoTime();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                account.withdraw(BigDecimal.TEN);            &#125;));        &#125;        ts.forEach(Thread::start);        ts.forEach(t -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                t.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        <span class="hljs-keyword">long</span> end = System.nanoTime();        System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;    <span class="hljs-comment">//原子引用，泛型类型为小数类型</span>    AtomicReference&lt;BigDecimal&gt; balance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountImpl</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;BigDecimal&gt;(balance);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> balance.get();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            BigDecimal pre = balance.get();            BigDecimal next = pre.subtract(amount);            <span class="hljs-keyword">if</span>(balance.compareAndSet(pre, next)) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountImpl(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>)));    &#125;&#125;</code></pre></div><h2 id="5、ABA问题"><a href="#5、ABA问题" class="headerlink" title="5、ABA问题"></a>5、ABA问题</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            String pre = str.get();            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                other();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">//把str中的A改为C</span>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C &quot;</span> + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>));        &#125;).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            System.out.println(<span class="hljs-string">&quot;change A-&gt;B &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>));        &#125;).start();        Thread.sleep(<span class="hljs-number">500</span>);        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            System.out.println(<span class="hljs-string">&quot;change B-&gt;A &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>));        &#125;).start();    &#125;&#125;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png" alt="img"></a></p><p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;    <span class="hljs-comment">//指定版本号</span>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            String pre = str.getReference();            <span class="hljs-comment">//获得版本号</span>            <span class="hljs-keyword">int</span> stamp = str.getStamp();            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                other();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C stamp &quot;</span> + stamp + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));        &#125;).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-keyword">int</span> stamp = str.getStamp();            System.out.println(<span class="hljs-string">&quot;change A-&gt;B stamp &quot;</span> + stamp + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));        &#125;).start();        Thread.sleep(<span class="hljs-number">500</span>);        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-keyword">int</span> stamp = str.getStamp();            System.out.println(<span class="hljs-string">&quot;change B-&gt;A stamp &quot;</span> + stamp +  str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));        &#125;).start();    &#125;&#125;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png" alt="img"></a></p><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;    <span class="hljs-comment">//指定版本号</span>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            String pre = str.getReference();            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                other();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C mark &quot;</span> +  str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));        &#125;).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;change A-&gt;A mark &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));        &#125;).start();    &#125;&#125;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png" alt="img"></a></p><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul><li><strong>AtomicStampedReference</strong> 需要我们传入<strong>整型变量</strong>作为版本号，来判定是否被更改过</li><li><strong>AtomicMarkableReference</strong>需要我们传入<strong>布尔变量</strong>作为标记，来判断是否被更改过</li></ul><h2 id="6、原子数组"><a href="#6、原子数组" class="headerlink" title="6、原子数组"></a>6、原子数组</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray </li><li>AtomicReferenceArray</li></ul><h3 id="lamba表达式的使用"><a href="#lamba表达式的使用" class="headerlink" title="lamba表达式的使用"></a>lamba表达式的使用</h3><ul><li><p>提供者</p></li><li><p>无参又返回</p></li><li><p>()-&gt;返回结果</p></li><li><p>方法</p><ul><li>有参有返回</li><li>(参数一…)-&gt;返回结果</li></ul></li><li><p>消费者</p><ul><li>有参无返回</li><li>(参数一…)-&gt;void</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkipn3olxj30u00usthn.jpg" alt="image-20210415163935411"></p><p>不安全的数组</p><div class="hljs code-wrapper"><pre><code class="hljs java">demo(   ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>],   (array)-&gt;array.length,   (array, index) -&gt; array[index]++,   array-&gt; System.out.println(Arrays.toString(array)) );<span class="hljs-comment">//[9870, 9862, 9774, 9697, 9683, 9678, 9679, 9668, 9680, 9698]</span></code></pre></div><p>安全的数组</p><div class="hljs code-wrapper"><pre><code class="hljs java">demo(   ()-&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),   (array) -&gt; array.length(),   (array, index) -&gt; array.getAndIncrement(index),   array -&gt; System.out.println(array) );<span class="hljs-comment">//[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span></code></pre></div><h2 id="7、原子更新器"><a href="#7、原子更新器" class="headerlink" title="7、原子更新器"></a>7、原子更新器</h2><ul><li>AtomicReferenceFieldUpdater // 域 字段 </li><li>AtomicIntegerFieldUpdater </li><li>AtomicLongFieldUpdate</li></ul><p>原子更新器用于帮助我们改变某个对象中的某个属性</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Student student = <span class="hljs-keyword">new</span> Student();      <span class="hljs-comment">// 获得原子更新器</span>      <span class="hljs-comment">// 泛型</span>      <span class="hljs-comment">// 参数1 持有属性的类 参数2 被更新的属性的类</span>      <span class="hljs-comment">// newUpdater中的参数：第三个为属性的名称</span>      AtomicReferenceFieldUpdater&lt;Student, String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);      <span class="hljs-comment">// 修改</span>      updater.compareAndSet(student, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;LLL&quot;</span>);      System.out.println(student);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-keyword">volatile</span> String name;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +            <span class="hljs-string">&#x27;&#125;&#x27;</span>;   &#125;&#125;</code></pre></div><h3 id="原子更新器初始化过程"><a href="#原子更新器初始化过程" class="headerlink" title="原子更新器初始化过程"></a>原子更新器初始化过程</h3><p>从上面的例子可以看出，原子更新器是通过newUpdater来获取实例的。其中传入了三个参数</p><ul><li>拥有属性的类的Class</li><li>属性的Class</li><li>属性的名称</li></ul><p>大概可以猜出来，<strong>初始化过程用到了反射</strong>，让我们看看源码来验证一下这个猜测。</p><h4 id="newUpdater方法"><a href="#newUpdater方法" class="headerlink" title="newUpdater方法"></a>newUpdater方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U,W&gt; <span class="hljs-function">AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="hljs-title">newUpdater</span><span class="hljs-params">(Class&lt;U&gt; tclass,</span></span><span class="hljs-function"><span class="hljs-params">                                                                Class&lt;W&gt; vclass,</span></span><span class="hljs-function"><span class="hljs-params">                                                                String fieldName)</span> </span>&#123;    <span class="hljs-comment">// 返回了一个AtomicReferenceFieldUpdaterImpl实例</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;        (tclass, vclass, fieldName, Reflection.getCallerClass());&#125;</code></pre></div><p>从newUpdater方法还并不能看出来具体的初始化过程</p><h4 id="内部实现类"><a href="#内部实现类" class="headerlink" title="内部实现类"></a>内部实现类</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png" alt="img"></a></p><p>AtomicReferenceFieldUpdater为抽象类，该类<strong>内部有一个自己的实现类AtomicReferenceFieldUpdaterImpl</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceFieldUpdaterImpl</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AtomicReferenceFieldUpdater</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">V</span>&gt; </span></code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png" alt="img"></a></p><p><strong>构造方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">AtomicReferenceFieldUpdaterImpl(<span class="hljs-keyword">final</span> Class&lt;T&gt; tclass,                                <span class="hljs-keyword">final</span> Class&lt;V&gt; vclass,                                <span class="hljs-keyword">final</span> String fieldName,                                <span class="hljs-keyword">final</span> Class&lt;?&gt; caller) &#123;    <span class="hljs-comment">// 用于保存要被修改的属性</span>    <span class="hljs-keyword">final</span> Field field;    <span class="hljs-comment">// 属性的Class</span>    <span class="hljs-keyword">final</span> Class&lt;?&gt; fieldClass;    <span class="hljs-comment">// field的修饰符</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> modifiers;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 反射获得属性</span>        field = AccessController.doPrivileged(            <span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> Field <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;                    <span class="hljs-comment">// tclass为传入的属性的Class，可以通过它来获得属性</span>                    <span class="hljs-keyword">return</span> tclass.getDeclaredField(fieldName);                &#125;            &#125;);        <span class="hljs-comment">// 获得属性的修饰符，主要用于判断</span>        <span class="hljs-comment">// 1、vclass 与 属性确切的类型是否匹配</span>        <span class="hljs-comment">// 2、是否为引用类型</span>        <span class="hljs-comment">// 3、被修改的属性是否加了volatile关键字</span>        modifiers = field.getModifiers();        sun.reflect.misc.ReflectUtil.ensureMemberAccess(            caller, tclass, <span class="hljs-keyword">null</span>, modifiers);        ClassLoader cl = tclass.getClassLoader();        ClassLoader ccl = caller.getClassLoader();        <span class="hljs-keyword">if</span> ((ccl != <span class="hljs-keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;            ((cl == <span class="hljs-keyword">null</span>) || !isAncestor(cl, ccl))) &#123;            sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);        &#125;        <span class="hljs-comment">// 获得属性类的Class</span>        fieldClass = field.getType();    &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(pae.getException());    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);    &#125;    <span class="hljs-keyword">if</span> (vclass != fieldClass)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassCastException();    <span class="hljs-keyword">if</span> (vclass.isPrimitive())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Must be reference type&quot;</span>);    <span class="hljs-keyword">if</span> (!Modifier.isVolatile(modifiers))        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Must be volatile type&quot;</span>);    <span class="hljs-comment">// Access to protected field members is restricted to receivers only</span>    <span class="hljs-comment">// of the accessing class, or one of its subclasses, and the</span>    <span class="hljs-comment">// accessing class must in turn be a subclass (or package sibling)</span>    <span class="hljs-comment">// of the protected member&#x27;s defining class.</span>    <span class="hljs-comment">// If the updater refers to a protected field of a declaring class</span>    <span class="hljs-comment">// outside the current package, the receiver argument will be</span>    <span class="hljs-comment">// narrowed to the type of the accessing class.</span>     <span class="hljs-comment">// 对类中的属性进行初始化</span>    <span class="hljs-keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;                   tclass.isAssignableFrom(caller) &amp;&amp;                   !isSamePackage(tclass, caller))                  ? caller : tclass;    <span class="hljs-keyword">this</span>.tclass = tclass;    <span class="hljs-keyword">this</span>.vclass = vclass;    <span class="hljs-comment">// 获得偏移量</span>    <span class="hljs-keyword">this</span>.offset = U.objectFieldOffset(field);&#125;</code></pre></div><p><strong>可以看出，原子引用更新器确实使用了反射</strong></p><h2 id="8、LongAdder原理"><a href="#8、LongAdder原理" class="headerlink" title="8、LongAdder原理"></a>8、LongAdder原理</h2><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p> <a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png" alt="img"></a></p><p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png" alt="img"></a></p><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png" alt="img"></a></p><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1] </li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p><p>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p><p><strong>@sun.misc.Contended 用来解决这个问题</strong>，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png" alt="img"></a></p><p><strong>累加主要调用以下方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;       Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;       <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;           <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;           <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||               (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||               !(uncontended = a.cas(v = a.value, v + x)))               longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);       &#125;   &#125;</code></pre></div><p><strong>累加流程图</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png" alt="img"></a></p><h2 id="9、Unsafe"><a href="#9、Unsafe" class="headerlink" title="9、Unsafe"></a>9、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetUnsafe</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;        <span class="hljs-comment">// 通过反射获得Unsafe对象</span>        Class unsafeClass = Unsafe.class;        <span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span>        Constructor constructor = unsafeClass.getDeclaredConstructor();        <span class="hljs-comment">// 设置为允许访问私有内容</span>        constructor.setAccessible(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">// 创建Unsafe对象</span>        Unsafe unsafe = (Unsafe) constructor.newInstance();        <span class="hljs-comment">// 创建Person对象</span>        Person person = <span class="hljs-keyword">new</span> Person();        <span class="hljs-comment">// 获得其属性 name 的偏移量</span>        Field field = Person.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);        <span class="hljs-keyword">long</span> offset = unsafe.objectFieldOffset(field);        <span class="hljs-comment">// 通过unsafe的CAS操作改变值</span>        unsafe.compareAndSwapObject(person, offset, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;OOOOh&quot;</span>);        System.out.println(person);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span>     <span class="hljs-keyword">volatile</span> String name;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p><strong>自定义AcomicData实现之前线程安全的原子整数Account实现</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpksjiq4abj30u00uh7cm.jpg" alt="image-20210415221945212"></p><p>Account 实现</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkskfabo3j30tg0eyacp.jpg" alt="image-20210415222036997"></p><h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h3 id="1、不可变"><a href="#1、不可变" class="headerlink" title="1、不可变"></a>1、不可变</h3><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p><h3 id="2、不可变设计"><a href="#2、不可变设计" class="headerlink" title="2、不可变设计"></a>2、不可变设计</h3><h4 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-comment">/** The value is used for character storage. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];    <span class="hljs-comment">/** Cache the hash code for the string */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span>   <span class="hljs-comment">//....</span>  &#125;&#125;</code></pre></div><p>**ﬁnal 的使用 **<br>发现该类、类中所有属性都是 <strong>ﬁnal</strong>的</p><ul><li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改 </li><li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，<strong>防止子类无意间破坏不可变性</strong></li></ul><p>**保护性拷贝 **</p><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);        &#125;        <span class="hljs-keyword">int</span> subLen = value.length - beginIndex;        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);        &#125;        <span class="hljs-comment">//返回的是一个新的对象</span>        <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);    &#125;</code></pre></div><p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        &#125;        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);            &#125;            <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;                <span class="hljs-keyword">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span>        <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);        &#125;        <span class="hljs-keyword">this</span>.value = Arrays. OfRange(value, offset, offset+count);    &#125;Cop</code></pre></div><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【<strong>保护性拷贝</strong>（defensive  ）】</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><blockquote><p>Flyweight pattern是一个通过与其他类似对象共享尽可能多的数据来最小化内存使用的对象</p></blockquote><h6 id="自己DIY一个"><a href="#自己DIY一个" class="headerlink" title="自己DIY一个"></a>自己DIY一个</h6><p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时 预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约 了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;<span class="hljs-comment">// 1. 连接池大小 </span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;<span class="hljs-comment">// 2. 连接对象数组 </span>  <span class="hljs-keyword">private</span> Connection[] connections;<span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙 </span>  <span class="hljs-keyword">private</span> AtomicIntegerArray states;<span class="hljs-comment">// 4. 构造方法初始化 </span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<span class="hljs-keyword">this</span>.poolSize = poolSize;     <span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];     <span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;       connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));     &#125;&#125;  <span class="hljs-comment">// 5. 借连接 </span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;           <span class="hljs-comment">// 获取空闲连接 </span>          <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;           log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);                 <span class="hljs-keyword">return</span> connections[i];             &#125;           &#125;&#125;     <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待 </span>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">try</span> &#123;           log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);           <span class="hljs-keyword">this</span>.wait();         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();         &#125;&#125;&#125;&#125;  <span class="hljs-comment">// 6. 归还连接 </span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;           <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;             states.set(i, <span class="hljs-number">0</span>);             <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;              log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);               <span class="hljs-keyword">this</span>.notifyAll();             &#125;             <span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span> </span>&#123;   <span class="hljs-comment">// 实现略 </span>&#125;</code></pre></div><p>使用连接池：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Pool pool = <span class="hljs-keyword">new</span> Pool(<span class="hljs-number">2</span>); <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;     Connection conn = pool.borrow();     <span class="hljs-keyword">try</span> &#123;       Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;       e.printStackTrace();     &#125;     pool.free(conn);   &#125;).start();&#125;</code></pre></div><p>以上实现没有考虑：</p><ul><li>连接的动态增长与收缩 </li><li>连接保活（可用性检测） </li><li>等待超时处理 </li><li>分布式 hash</li></ul><p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p><h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="1、自定义线程池"><a href="#1、自定义线程池" class="headerlink" title="1、自定义线程池"></a>1、自定义线程池</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png" alt="img"></a></p><ul><li>阻塞队列中维护了由主线程（或者其他线程）所产生的的任务</li><li>主线程类似于<strong>生产者</strong>，产生任务并放入阻塞队列中</li><li>线程池类似于<strong>消费者</strong>，得到阻塞队列中已有的任务并执行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ThreadPool threadPool = <span class="hljs-keyword">new</span> ThreadPool(<span class="hljs-number">2</span>,  TimeUnit.SECONDS, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;         threadPool.execute(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;               TimeUnit.SECONDS.sleep(<span class="hljs-number">10000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">&quot;任务正在执行!&quot;</span>);         &#125;);      &#125;   &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 自定义线程池</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 自定义阻塞队列</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; blockingQueue;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 核心线程数</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> coreSize;   <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 用于指定线程最大存活时间</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> TimeUnit timeUnit;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timeout;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 工作线程类</span><span class="hljs-comment">    * 内部封装了Thread类，并且添加了一些属性</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;      Runnable task;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable task)</span> </span>&#123;         System.out.println(<span class="hljs-string">&quot;初始化任务&quot;</span>);         <span class="hljs-keyword">this</span>.task = task;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-comment">// 如果有任务就执行</span>         <span class="hljs-comment">// 如果阻塞队列中有任务，就继续执行</span>         <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = blockingQueue.take()) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               System.out.println(<span class="hljs-string">&quot;执行任务&quot;</span>);               task.run();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;               e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;               <span class="hljs-comment">// 任务执行完毕，设为空</span>               System.out.println(<span class="hljs-string">&quot;任务执行完毕&quot;</span>);               task = <span class="hljs-keyword">null</span>;            &#125;         &#125;         <span class="hljs-comment">// 移除任务</span>         <span class="hljs-keyword">synchronized</span> (workers) &#123;            System.out.println(<span class="hljs-string">&quot;移除任务&quot;</span>);            workers.remove(<span class="hljs-keyword">this</span>);         &#125;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> coreSize, TimeUnit timeUnit, <span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> capacity)</span> </span>&#123;      <span class="hljs-keyword">this</span>.coreSize = coreSize;      <span class="hljs-keyword">this</span>.timeUnit = timeUnit;      blockingQueue = <span class="hljs-keyword">new</span> BlockingQueue&lt;&gt;(capacity);      <span class="hljs-keyword">this</span>.timeout = timeout;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;      <span class="hljs-keyword">synchronized</span> (workers) &#123;         <span class="hljs-comment">// 创建任务</span>         <span class="hljs-comment">// 池中还有空余线程时，可以运行任务</span>         <span class="hljs-comment">// 否则阻塞</span>         <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;            Worker worker = <span class="hljs-keyword">new</span> Worker(task);            workers.add(worker);            worker.start();         &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;线程池中线程已用完，请稍等&quot;</span>);            blockingQueue.put(task);         &#125;      &#125;   &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 阻塞队列</span><span class="hljs-comment"> * 用于存放主线程或其他线程产生的任务</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 阻塞队列</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span>  Deque&lt;T&gt; blockingQueue;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 阻塞队列容量</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 锁</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> ReentrantLock lock;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 条件队列</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> Condition fullQueue;   <span class="hljs-keyword">private</span> Condition emptyQueue;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;      blockingQueue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(capacity);      lock = <span class="hljs-keyword">new</span> ReentrantLock();      fullQueue = lock.newCondition();      emptyQueue = lock.newCondition();      <span class="hljs-keyword">this</span>.capacity = capacity;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 获取任务的方法</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">// 加锁</span>      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// 如果阻塞队列为空（没有任务），就一直等待</span>         <span class="hljs-keyword">while</span> (blockingQueue.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;               emptyQueue.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-comment">// 获取任务并唤醒生产者线程</span>         T task = blockingQueue.removeFirst();         fullQueue.signalAll();         <span class="hljs-keyword">return</span> task;      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">takeNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;      <span class="hljs-comment">// 转换等待时间</span>      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);         <span class="hljs-keyword">while</span> (blockingQueue.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// awaitNanos会返回剩下的等待时间</span>               nanos = emptyQueue.awaitNanos(nanos);               <span class="hljs-keyword">if</span> (nanos &lt; <span class="hljs-number">0</span>) &#123;                  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;               &#125;            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;         &#125;         T task = blockingQueue.removeFirst();         fullQueue.signalAll();         <span class="hljs-keyword">return</span> task;      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 放入任务的方法</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> task 放入阻塞队列的任务</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T task)</span> </span>&#123;      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">while</span> (blockingQueue.size() == capacity) &#123;            <span class="hljs-keyword">try</span> &#123;               System.out.println(<span class="hljs-string">&quot;阻塞队列已满&quot;</span>);               fullQueue.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;         &#125;         blockingQueue.add(task);         <span class="hljs-comment">// 唤醒等待的消费者</span>         emptyQueue.signalAll();      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">return</span> blockingQueue.size();      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;&#125;</code></pre></div><p>实现了一个简单的线程池</p><ul><li>阻塞队列BlockingQueue用于暂存来不及被线程执行的任务<ul><li>也可以说是平衡生产者和消费者执行速度上的差异</li><li>里面的获取任务和放入任务用到了<strong>生产者消费者模式</strong></li></ul></li><li>线程池中对线程Thread进行了再次的封装，封装为了Worker<ul><li>在调用任务的run方法时，线程会去执行该任务，执行完毕后还会<strong>到阻塞队列中获取新任务来执行</strong></li></ul></li><li>线程池中执行任务的主要方法为execute方法<ul><li>执行时要判断正在执行的线程数是否大于了线程池容量</li></ul></li></ul><h2 id="2、ThreadPoolExecutor"><a href="#2、ThreadPoolExecutor" class="headerlink" title="2、ThreadPoolExecutor"></a>2、ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png" alt="img"></a></p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 线程池状态</span><span class="hljs-comment">// runState is stored in the high-order bits</span><span class="hljs-comment">// RUNNING 高3位为111</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// SHUTDOWN 高3位为000</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 高3位 001</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 高3位 010</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 高3位 011</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;</code></pre></div><table><thead><tr><th>状态名称</th><th>高3位的值</th><th>描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>接收新任务，同时处理任务队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>不接受新任务，但是处理任务队列中的任务</td></tr><tr><td>STOP</td><td>001</td><td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td></tr><tr><td>TIDYING</td><td>010</td><td>任务执行完毕，活动线程为0时，即将进入终结阶段</td></tr><tr><td>TERMINATED</td><td>011</td><td>终结状态</td></tr></tbody></table><p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p><ul><li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<span class="hljs-comment">// 并不是所有平台的int都是32位。</span><span class="hljs-comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span><span class="hljs-comment">// 高3位为0，剩余位数全为1</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<span class="hljs-comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span><span class="hljs-comment">// CAPACITY 的高3位为 0</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;</code></pre></div><p>获取线程池状态、线程数量以及合并两个值的操作</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Packing and unpacking ctl</span><span class="hljs-comment">// 获取运行状态</span><span class="hljs-comment">// 该操作会让除高3位以外的数全部变为0</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<span class="hljs-comment">// 获取运行线程数</span><span class="hljs-comment">// 该操作会让高3位为0</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<span class="hljs-comment">// 计算ctl新值</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;</code></pre></div><h3 id="线程池属性"><a href="#线程池属性" class="headerlink" title="线程池属性"></a>线程池属性</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 工作线程，内部封装了Thread</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    ...&#125;<span class="hljs-comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<span class="hljs-comment">// 锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();</code></pre></div><h3 id="构造方法极其参数"><a href="#构造方法极其参数" class="headerlink" title="构造方法极其参数"></a>构造方法极其参数</h3><p><strong>ThreadPoolExecutor最全面的构造方法</strong></p><p>也是构造自定义线程池的方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span></code></pre></div><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h4><ul><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数<ul><li>maximumPoolSize - corePoolSize = 救急线程数</li></ul></li><li>keepAliveTime：救急线程空闲时的最大生存时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列（存放任务）<ul><li>有界阻塞队列 ArrayBlockingQueue</li><li>无界阻塞队列 LinkedBlockingQueue</li><li>最多只有一个同步元素的 SynchronousQueue</li><li>优先队列 PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂（给线程取名字）</li><li>handler：拒绝策略</li></ul><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>当一个任务传给线程池以后，可能有以下几种可能<ul><li>将任务分配给一个核心线程来执行</li><li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li><li><strong>阻塞队列满了，使用救急线程</strong>来执行任务<ul><li>救急线程用完以后，超过生存时间（keepAliveTime）后会被释放</li></ul></li><li>任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略</li></ul></li></ul><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png" alt="img"></a></p><ul><li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>这是默认策略</strong></li><li>CallerRunsPolicy：让调用者运行任务</li><li>DiscardPolicy：放弃本次任务</li><li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-keyword">static</span> AtomicInteger threadId = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 手动创建线程池</span>      <span class="hljs-comment">// 创建有界阻塞队列</span>      ArrayBlockingQueue&lt;Runnable&gt; runnable = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">10</span>);      <span class="hljs-comment">// 创建线程工厂</span>      ThreadFactory threadFactory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;            Thread thread = <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;working_thread_&quot;</span>+threadId.getAndIncrement());            <span class="hljs-keyword">return</span> thread;         &#125;      &#125;;      <span class="hljs-comment">// 手动创建线程池</span>      <span class="hljs-comment">// 拒绝策略采用默认策略</span>      ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS, runnable, threadFactory);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;         executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;               System.out.println(Thread.currentThread());               <span class="hljs-keyword">try</span> &#123;                  Thread.sleep(<span class="hljs-number">100000</span>);               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                  e.printStackTrace();               &#125;            &#125;         &#125;);      &#125;   &#125;&#125;</code></pre></div><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//没有救急线程，阻塞队列是无界的，可以放任意数量的任务</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFixedThreadPool</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 自定义线程工厂</span>      ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;         AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;myPool_&quot;</span> + atomicInteger.getAndIncrement());         &#125;      &#125;;      <span class="hljs-comment">// 创建核心线程数量为2的线程池</span>      <span class="hljs-comment">// 通过 ThreadFactory可以给线程添加名字</span>      ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">2</span>, factory);      <span class="hljs-comment">// 任务</span>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(Thread.currentThread().getName());            System.out.println(<span class="hljs-string">&quot;this is fixedThreadPool&quot;</span>);         &#125;      &#125;;      executorService.execute(runnable);   &#125;&#125;</code></pre></div><p>固定大小的线程池可以传入两个参数</p><ul><li>核心线程数：nThreads</li><li>线程工厂：threadFactory</li></ul><p>内部调用的构造方法</p><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadPoolExecutor(nThreads, nThreads,                              <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                              <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),                              threadFactory);</code></pre></div><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><div class="hljs code-wrapper"><pre><code class="hljs java">ExecutorService executorService = Executors.newCachedThreadPool();</code></pre></div><p><strong>内部构造方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                              <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                              <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</code></pre></div><ul><li><p>没有核心线程，最大线程数为Integer.MAX_VALUE，<strong>所有创建的线程都是救急线程</strong>，空闲时生存时间为60秒</p></li><li><p>阻塞队列使用的是SynchronousQueue</p><ul><li>SynchronousQueue是一种特殊的队列<ul><li><strong>没有容量</strong>，没有线程来取是放不进去的</li><li>只有当线程取任务时，才会将任务放入该阻塞队列中</li></ul></li></ul></li></ul><h3 id="SingleThread"><a href="#SingleThread" class="headerlink" title="SingleThread"></a>SingleThread</h3><div class="hljs code-wrapper"><pre><code class="hljs java">ExecutorService service = Executors.newSingleThreadExecutor();</code></pre></div><p><strong>内部构造方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService    (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                            <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                            <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</code></pre></div><p>内部调用了<strong>new ThreadPoolExecutor</strong>的构造方法，传入的corePoolSize和maximumPoolSize都为1。然后将该对象传给了FinalizableDelegatedExecutorService。该类修饰了ThreadPoolExecutor，让外部无法调用ThreadPoolExecutor内部的某些方法来修改所创建的线程池的大小。</p><h4 id="几个注意"><a href="#几个注意" class="headerlink" title="几个注意"></a>几个注意</h4><ul><li><p>SingleThread和自己创建一个线程来运行多个任务的区别</p><ul><li>当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而<strong>SingleThread会创建一个新线程，继续执行任务队列中剩余的任务</strong>。</li></ul></li><li><p>SingleThread和newFixedThreadPool(1)的区别</p><ul><li>newFixedThreadPool(1)传值为1，可以将FixedThreadPool强转为ThreadPoolExecutor，然后通过setCorePoolSize改变核心线程数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 强转为ThreadPoolExecutor</span>ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<span class="hljs-comment">// 改变核心线程数</span>threadPool.setCorePoolSize(<span class="hljs-number">2</span>);</code></pre></div><ul><li>而SingleThread无法修改核心线程数</li></ul></li></ul><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java">execute(Runnable command)</code></pre></div><p>传入一个Runnable对象，执行其中的run方法</p><p><strong>源码解析</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">// 获取ctl</span>    <span class="hljs-keyword">int</span> c = ctl.get();    <span class="hljs-comment">// 判断当前启用的线程数是否小于核心线程数</span>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;        <span class="hljs-comment">// 为该任务分配线程</span>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))            <span class="hljs-comment">// 分配成功就返回</span>            <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 分配失败再次获取ctl</span>        c = ctl.get();    &#125;    <span class="hljs-comment">// 分配和信息线程失败以后</span>    <span class="hljs-comment">// 如果池状态为RUNNING并且插入到任务队列成功</span>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        <span class="hljs-comment">// 双重检测，可能在添加后线程池状态变为了非RUNNING</span>        <span class="hljs-keyword">int</span> recheck = ctl.get();        <span class="hljs-comment">// 如果池状态为非RUNNING，则不会执行新来的任务</span>        <span class="hljs-comment">// 将该任务从阻塞队列中移除</span>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))            <span class="hljs-comment">// 调用拒绝策略，拒绝该任务的执行</span>            reject(command);        <span class="hljs-comment">// 如果没有正在运行的线程</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)            <span class="hljs-comment">// 就创建新线程来执行该任务</span>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">// 如果添加失败了（任务队列已满），就调用拒绝策略</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))        reject(command);&#125;</code></pre></div><p>其中调用了**addWoker()**方法，再看看看这个方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;    retry:    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-keyword">int</span> rs = runStateOf(c);        <span class="hljs-comment">// Check if queue empty only if necessary.</span>        <span class="hljs-comment">// 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务</span>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;            ! (rs == SHUTDOWN &amp;&amp;               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;               ! workQueue.isEmpty()))            <span class="hljs-comment">// 创建新线程失败</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">// 获得当前工作线程数</span>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);            <span class="hljs-comment">// 参数中 core 为true</span>            <span class="hljs-comment">// CAPACITY 为 1 &lt;&lt; COUNT_BITS-1，一般不会超过</span>            <span class="hljs-comment">// 如果工作线程数大于了核心线程数，则创建失败</span>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||                wc &gt;= (core ? corePoolSize : maximumPoolSize))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 通过CAS操作改变c的值</span>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                <span class="hljs-comment">// 更改成功就跳出多重循环，且不再运行循环</span>                <span class="hljs-keyword">break</span> retry;            <span class="hljs-comment">// 更改失败，重新获取ctl的值</span>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)                <span class="hljs-comment">// 跳出多重循环，且重新进入循环</span>                <span class="hljs-keyword">continue</span> retry;            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>        &#125;    &#125;    <span class="hljs-comment">// 用于标记work中的任务是否成功执行</span>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 用于标记worker是否成功加入了线程池中</span>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;    Worker w = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 创建新线程来执行任务</span>        w = <span class="hljs-keyword">new</span> Worker(firstTask);        <span class="hljs-keyword">final</span> Thread t = w.thread;        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;            <span class="hljs-comment">// 加锁</span>            mainLock.lock();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// Recheck while holding lock.</span>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span>                <span class="hljs-comment">// shut down before lock acquired.</span>                <span class="hljs-comment">// 加锁的同时再次检测</span>                <span class="hljs-comment">// 避免在释放锁之前调用了shut down</span>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();                    <span class="hljs-comment">// 将线程添加到线程池中</span>                    workers.add(w);                    <span class="hljs-keyword">int</span> s = workers.size();                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                        largestPoolSize = s;                    <span class="hljs-comment">// 添加成功标志位变为true</span>                    workerAdded = <span class="hljs-keyword">true</span>;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                mainLock.unlock();            &#125;            <span class="hljs-comment">// 如果worker成功加入了线程池，就执行其中的任务</span>            <span class="hljs-keyword">if</span> (workerAdded) &#123;                t.start();                <span class="hljs-comment">// 启动成功</span>                workerStarted = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 如果执行失败</span>        <span class="hljs-keyword">if</span> (! workerStarted)            <span class="hljs-comment">// 调用添加失败的函数</span>            addWorkerFailed(w);    &#125;    <span class="hljs-keyword">return</span> workerStarted;&#125;</code></pre></div><h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a>submit()方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span></code></pre></div><p>传入一个Callable对象，用Future来<strong>捕获返回值</strong></p><p><strong>使用</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 通过submit执行Callable中的call方法</span><span class="hljs-comment">// 通过Future来捕获返回值</span>Future&lt;String&gt; future = threadPool.submit(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello submit&quot;</span>;   &#125;&#125;);<span class="hljs-comment">// 查看捕获的返回值</span>System.out.println(future.get());</code></pre></div><h4 id="invokeAll-方法"><a href="#invokeAll-方法" class="headerlink" title="invokeAll()方法"></a>invokeAll()方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 提交 tasks 中所有任务 </span>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)   <span class="hljs-keyword">throws</span> InterruptedException;</code></pre></div><h4 id="invokeAny-方法"><a href="#invokeAny-方法" class="headerlink" title="invokeAny()方法"></a>invokeAny()方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消 </span>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;</code></pre></div><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><p>线程池状态变为SHUTDOWN</p><ul><li>不会接收新任务</li><li>但已提交任务会执行完</li><li>此方法不会阻塞调用线程的执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 将线程池的状态改为 SHUTDOWN</span><span class="hljs-comment">* 不再接受新任务，但是会将阻塞队列中的任务执行完</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        checkShutdownAccess();        <span class="hljs-comment">// 修改线程池状态为 SHUTDOWN</span>        advanceRunState(SHUTDOWN);          <span class="hljs-comment">// 中断空闲线程（没有执行任务的线程）</span>        <span class="hljs-comment">// Idle：空闲的</span>        interruptIdleWorkers();        onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span>    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;    <span class="hljs-comment">// 尝试终结，不一定成功</span>    tryTerminate();&#125; <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-comment">// 终结失败的条件</span>        <span class="hljs-comment">// 线程池状态为RUNNING</span>        <span class="hljs-comment">// 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）</span>        <span class="hljs-comment">// 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行</span>        <span class="hljs-keyword">if</span> (isRunning(c) ||            runStateAtLeast(c, TIDYING) ||            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))            <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 如果活跃线程数不为0</span>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span>            <span class="hljs-comment">// 中断空闲线程</span>            interruptIdleWorkers(ONLY_ONE);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;        mainLock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 处于可以终结的状态</span>            <span class="hljs-comment">// 通过CAS将线程池状态改为TIDYING</span>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;                <span class="hljs-keyword">try</span> &#123;                    terminated();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">// 通过CAS将线程池状态改为TERMINATED</span>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));                    termination.signalAll();                &#125;                <span class="hljs-keyword">return</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            mainLock.unlock();        &#125;        <span class="hljs-comment">// else retry on failed CAS</span>    &#125;&#125;</code></pre></div><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 将线程池的状态改为 STOP</span><span class="hljs-comment">* 不再接受新任务，也不会在执行阻塞队列中的任务</span><span class="hljs-comment">* 会将阻塞队列中未执行的任务返回给调用者</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;    List&lt;Runnable&gt; tasks;    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        checkShutdownAccess();        <span class="hljs-comment">// 修改状态为STOP，不执行任何任务</span>        advanceRunState(STOP);        <span class="hljs-comment">// 中断所有线程</span>        interruptWorkers();        <span class="hljs-comment">// 将未执行的任务从队列中移除，然后返回给调用者</span>        tasks = drainQueue();    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;    <span class="hljs-comment">// 尝试终结，一定会成功，因为阻塞队列为空了</span>    tryTerminate();    <span class="hljs-keyword">return</span> tasks;&#125;</code></pre></div><h2 id="3、创建多少线程池"><a href="#3、创建多少线程池" class="headerlink" title="3、创建多少线程池"></a>3、创建多少线程池</h2><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><h4 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a>CPU 密集型运算</h4><p>通常采用<code>cpu核数+1</code>能够实现最优的CPU利用率，+1是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证CPU时钟周期不被浪费</p><h4 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I/O 密集型运算"></a>I/O 密集型运算</h4><p>CPU不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用CPU资源，但当你执行I/O操作时、远程RPC调用时，包括进行数据库操作时，这时候CPU就闲下来了，你可以利用多线程提高它的利用率。</p><p>经验公式如下</p><p><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code></p><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p><p><code>4 * 100% * 100% / 50% = 8</code></p><p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p><p><code>4 * 100% * 100% / 10% = 40</code></p><h2 id="4、Tomcat线程池"><a href="#4、Tomcat线程池" class="headerlink" title="4、Tomcat线程池"></a>4、Tomcat线程池</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplpdijconj31ag0bmdkl.jpg" alt="image-20210416171541056"></p><ul><li>LimitLatch用来限流，可以控制最大连接个数，类似J.U.C中的Semaphore后面再讲</li><li>Acceptor只负责【接收新的socket连接】</li><li>Poller只负责监听socketchannel是否有【可读的I/O事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给Executor线程池处理</li><li>Executor线程池中的工作线程最终负责【处理请求】</li></ul><p><strong>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</strong></p><ul><li>如果总线程数达到 maximumPoolSize<ul><li>这时不会立刻抛 RejectedExecutionException 异常 </li><li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li></ul></li></ul><p>源码 tomcat-7.0.42</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;submittedCount.incrementAndGet();   <span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">super</span>.execute(command);   &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">super</span>.getQueue() <span class="hljs-keyword">instanceof</span> TaskQueue) &#123;<span class="hljs-keyword">final</span> TaskQueue queue = (TaskQueue)<span class="hljs-keyword">super</span>.getQueue();<span class="hljs-keyword">try</span> &#123;             <span class="hljs-keyword">if</span> (!queue.force(command, timeout, unit)) &#123;            submittedCount.decrementAndGet();             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Queue capacity is full.&quot;</span>);           &#125;&#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;             submittedCount.decrementAndGet();            Thread.interrupted();             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(x);&#125;      &#125; <span class="hljs-keyword">else</span> &#123;         submittedCount.decrementAndGet();         <span class="hljs-keyword">throw</span> rx;       &#125;&#125;&#125;</code></pre></div><p>Connector 配置</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplpsby8wnj31d00fiwhd.jpg" alt="image-20210416172958903"></p><p>Executor 线程配置</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplpsqz78uj31d40kiwir.jpg" alt="image-20210416173023391"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplptha33fj319a0c876b.jpg" alt="image-20210416173104274"></p><h2 id="5、Fork-Join"><a href="#5、Fork-Join" class="headerlink" title="5、Fork/Join"></a>5、Fork/Join</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算 </li><li>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解 </li><li>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率 </li><li>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</li></ul><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><p>提交给Fork/Join线程池的任务需要继承RecursiveTask（有返回值）或RecursiveAction（没有返回值），例如下面定义了一个对1~n之间的整数求和的任务</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplpzqfow9j30u00zpthz.jpg" alt="image-20210416173704832"></p><p>然后提交给 ForkJoinPool 来执行</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">4</span>);   System.out.println(pool.invoke(<span class="hljs-keyword">new</span> AddTask1(<span class="hljs-number">5</span>))); &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">[ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">0</span>] - fork() <span class="hljs-number">2</span> + &#123;<span class="hljs-number">1</span>&#125; [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] - fork() <span class="hljs-number">5</span> + &#123;<span class="hljs-number">4</span>&#125; [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">0</span>] - join() <span class="hljs-number">1</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">0</span>] - join() <span class="hljs-number">2</span> + &#123;<span class="hljs-number">1</span>&#125; = <span class="hljs-number">3</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] - fork() <span class="hljs-number">4</span> + &#123;<span class="hljs-number">3</span>&#125; [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span>] - fork() <span class="hljs-number">3</span> + &#123;<span class="hljs-number">2</span>&#125; [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span>] - join() <span class="hljs-number">3</span> + &#123;<span class="hljs-number">2</span>&#125; = <span class="hljs-number">6</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] - join() <span class="hljs-number">4</span> + &#123;<span class="hljs-number">3</span>&#125; = <span class="hljs-number">10</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] - join() <span class="hljs-number">5</span> + &#123;<span class="hljs-number">4</span>&#125; = <span class="hljs-number">15</span> <span class="hljs-number">15</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpltkmas1yj31d00dggnq.jpg" alt="image-20210416194057872"></p><h1 id="八、J-U-C"><a href="#八、J-U-C" class="headerlink" title="八、J.U.C"></a>八、J.U.C</h1><h2 id="1、AQS"><a href="#1、AQS" class="headerlink" title="1、AQS"></a>1、AQS</h2><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><p><strong>特点：</strong></p><ul><li><p>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p><ul><li>getState - 获取 state 状态 </li><li>setState - 设置 state 状态 </li><li>compareAndSetState - cas 机制设置 state 状态 </li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 </li></ul></li><li><p>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList </p></li><li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</p></li></ul><p><strong>子类主要实现这样一些方法</strong>（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire </li><li>tryRelease </li><li>tryAcquireShared </li><li>tryReleaseShared </li><li>isHeldExclusively</li></ul><p>获取锁的姿势</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果获取锁失败 </span><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123;   <span class="hljs-comment">// 入队, 可以选择阻塞当前线程 park unpark</span>&#125;</code></pre></div><p>释放锁的姿势</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果释放锁成功 </span><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;   <span class="hljs-comment">// 让阻塞线程恢复运行 </span>&#125;</code></pre></div><h4 id="实现不可重入锁"><a href="#实现不可重入锁" class="headerlink" title="实现不可重入锁"></a>实现不可重入锁</h4><p>自定义锁</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 自定义锁（不可重入锁）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;    <span class="hljs-comment">// 独占锁  同步器类</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;                <span class="hljs-comment">// 加上了锁，并设置 owner 为当前线程</span>                setExclusiveOwnerThread(Thread.currentThread());                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);            setState(<span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 是否持有独占锁</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();        &#125;    &#125;    <span class="hljs-keyword">private</span> MySync sync = <span class="hljs-keyword">new</span> MySync();    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 加锁（不成功会进入等待队列）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 加锁，可打断</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        sync.acquireInterruptibly(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 尝试加锁（一次）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 尝试加锁，带超时</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 解锁</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.release(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 创建条件变量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.newCondition();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAqs</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyLock lock = <span class="hljs-keyword">new</span> MyLock();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);                sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">finally</span> &#123;                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);                lock.unlock();            &#125;        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);            &#125; <span class="hljs-keyword">finally</span> &#123;                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);                lock.unlock();            &#125;        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre></div><p>输出</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">28.727</span> c.TestAqs [t1] - locking... <span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">29.732</span> c.TestAqs [t1] - unlocking... <span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">29.732</span> c.TestAqs [t2] - locking... <span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">29.732</span> c.TestAqs [t2] - unlocking...</code></pre></div><p>不可重入测试</p><p>如果改为下面代码，会发现自己也会被挡住（只会打印一次 locking）</p><div class="hljs code-wrapper"><pre><code class="hljs java">lock.lock(); log.debug(<span class="hljs-string">&quot;locking...&quot;</span>); lock.lock(); log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);</code></pre></div><h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不够优雅，于是在JSR166（java规范提案）中创建了AQS，提供了这种通用的同步器机制。</p><p><strong>目标</strong></p><p>AQS 要实现的功能目标</p><ul><li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire </li><li>获取锁超时机制</li><li>通过打断取消机制 </li><li>独占机制及共享机制 </li><li>条件不满足时的等待机制</li></ul><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>AQS 的基本思想其实很简单</p><p>获取锁的逻辑</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(state 状态不允许获取) &#123;   <span class="hljs-keyword">if</span>(队列中还没有此线程) &#123;    入队并阻塞   &#125; &#125; 当前线程出队</code></pre></div><p>释放锁的逻辑</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(state 状态允许了) &#123;   恢复阻塞的线程(s) &#125;</code></pre></div><p>要点</p><ul><li>原子维护 state 状态 </li><li>阻塞及恢复线程 </li><li>维护队列</li></ul><p><strong>(1)state设计</strong></p><ul><li>state 使用 volatile 配合 cas 保证其修改时的原子性 </li><li>state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想</li></ul><p><strong>(2)阻塞恢复设计</strong></p><ul><li>早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume 那么 suspend 将感知不到</li><li>解决方法是使用 park &amp; unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark 再 park 也没问题 </li><li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</li><li>park 线程还可以通过 interrupt 打断</li></ul><p><strong>(3)队列设计</strong></p><ul><li>使用了 FIFO 先入先出队列，并不支持优先级队列 </li><li>设计时借鉴了 CLH 队列，它是一种单向无锁队列</li></ul><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplus4v425j30p60rsjto.jpg" alt="image-20210416202245564" style="zoom:50%;" /><p>队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态 </p><p>入队伪代码，只需要考虑 tail 赋值的原子性</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<span class="hljs-comment">// 原来的 tail </span> Node prev = tail; <span class="hljs-comment">// 用 cas 在原来 tail 的基础上改为 node </span>&#125; <span class="hljs-keyword">while</span>(tail.compareAndSet(prev, node))</code></pre></div><p>出队伪代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// prev 是上一个节点 </span><span class="hljs-keyword">while</span>((Node prev=node.prev).state != 唤醒状态) &#123; &#125; <span class="hljs-comment">// 设置头节点 </span>head = node;</code></pre></div><p>CLH 好处：</p><ul><li>无锁，使用自旋</li><li>快速，无阻塞</li></ul><p>AQS 在一些方面改进了 CLH</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<span class="hljs-keyword">for</span> (;;) &#123;       Node t = tail;      <span class="hljs-comment">// 队列中还没有元素 tail 为 null </span>      <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">// 将 head 从 null -&gt; dummy </span>        <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))           tail = head;       &#125;<span class="hljs-keyword">else</span>&#123;         <span class="hljs-comment">// 将 node 的 prev 设置为原来的 tail </span>        node.prev = t;         <span class="hljs-comment">// 将 tail 从原来的 tail 设置为 node </span>        <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;           <span class="hljs-comment">// 原来 tail 的 next 设置为 node </span>          t.next = node;           <span class="hljs-keyword">return</span> t;         &#125;&#125;&#125;&#125;</code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpluy79sipj31fe0k048c.jpg" alt="image-20210416202836479"></p><h2 id="2、ReentranLock"><a href="#2、ReentranLock" class="headerlink" title="2、ReentranLock"></a>2、ReentranLock</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1uh4accj30vs0fudir.jpg" alt="image-20210418175513322"></p><h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a><strong>非公平锁实现原理</strong></h3><p><strong>加锁解锁流程</strong></p><p>先从构造器开始看，默认为非公平锁实现</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;   sync = <span class="hljs-keyword">new</span> NonfairSync(); &#125;</code></pre></div><p>NonfairSync 继承自 AQS</p><p>没有竞争时</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1vlvso1j30u20eaabh.jpg" alt="image-20210418175927482"></p><p>第一个竞争出现时</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1w3ptbhj30uy0e20va.jpg" alt="image-20210418175955873"></p><p>Thread-1 执行了</p><ol><li>CAS 尝试将 state 由 0 改为 1，结果失败</li><li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li><li>接下来进入 addWaiter 逻辑，构造 Node 队列 <ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态 </li><li>Node 的创建是懒惰的 </li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ul></li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1xpsvhxj30za0cmac3.jpg" alt="image-20210418180129167"></p><p>当前线程进入 acquireQueued 逻辑</p><ol><li><p>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</p></li><li><p>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</p></li><li><p>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1z9xf6sj30z40cuwgk.jpg" alt="image-20210418180257642"></p><ol start="4"><li><p>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</p></li><li><p>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</p></li><li><p>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1zpcge6j30zk0cen05.jpg" alt="image-20210418180324526"></p><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo24izl02j310008a3zx.jpg" alt="image-20210418180345185"></p><p>Thread-0释放锁，进入tryRelease流程，如果成功</p><ul><li>设置exclusiveOwnerThread为null</li><li>state=0</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo20zf7azj310407u0up.jpg" alt="image-20210418180436882"></p><p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程</p><p>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1 </p><p>回到 Thread-1 的 acquireQueued 流程</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo21l0tmuj310608kta0.jpg" alt="image-20210418180512195"></p><p>如果加锁成功（没有竞争），会设置 </p><ul><li>exclusiveOwnerThread 为 Thread-1，state = 1 </li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread </li><li>原本的 head 因为从链表断开，而可被垃圾回收 </li></ul><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo22axqamj310c09oaco.jpg" alt="image-20210418180554170"></p><p>如果不巧又被 Thread-4 占了先</p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state = 1 </li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ul><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;   <span class="hljs-comment">// ...</span><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处 </span>  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<span class="hljs-keyword">final</span> Thread current = Thread.currentThread();     <span class="hljs-keyword">int</span> c = getState();     <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;           setExclusiveOwnerThread(current);           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;         &#125;       &#125;    <span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入 </span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;       <span class="hljs-comment">// state++ </span>      <span class="hljs-keyword">int</span> nextc = c + acquires;       <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow </span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);       setState(nextc);       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;  <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处 </span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<span class="hljs-comment">// state--</span>    <span class="hljs-keyword">int</span> c = getState() - releases;     <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();     <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;     <span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功 </span>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;free = <span class="hljs-keyword">true</span>;setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);&#125;setState(c);     <span class="hljs-keyword">return</span> free; &#125;&#125;</code></pre></div><h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><p><strong>不可打断模式</strong></p><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能继续运行（是继续运行，只是打断标记被设置为true）</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo2gotu50j30u012rn3q.jpg" alt="image-20210418181943236"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo2h1aa9ij30sy0dedhe.jpg" alt="image-20210418182001896"></p><p><strong>可打断模式</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo2hpjb09j30u00xvdmc.jpg" alt="image-20210418182041288"></p><h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo2ilonptj30u010gwl3.jpg" alt="image-20210418182132330"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2iz4ws1j30s40agq4t.jpg" alt="image-20210418182154563"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2j8je4cj30q604gmxi.jpg" alt="image-20210418182210122"></p><h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p><p><strong>await 流程</strong></p><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程 </p><p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2kdqpmkj31ay0gwjuw.jpg" alt="image-20210418182314247"></p><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2kqp1clj31bc0ha77n.jpg" alt="image-20210418182335941"></p><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2l55unlj31bg0haado.jpg" alt="image-20210418182359834"></p><p>park 阻塞 Thread-0</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2lnbfbij31bq0h4q6h.jpg" alt="image-20210418182428801"></p><p><strong>signal 流程</strong></p><p>假设 Thread-1 要来唤醒 Thread-0</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2m6dzi5j31au0lujvm.jpg" alt="image-20210418182459334"></p><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2mlbrz8j31am0luaea.jpg" alt="image-20210418182522585"></p><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2n1hqisj31b20h477k.jpg" alt="image-20210418182547437"></p><p>Thread-1 释放锁，进入 unlock 流程</p><h2 id="3、ReentranReadWriteLock"><a href="#3、ReentranReadWriteLock" class="headerlink" title="3、ReentranReadWriteLock"></a>3、ReentranReadWriteLock</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>当读操作远远高于写操作时，这时候使用<code>读写锁</code>让<code>读-读</code>提高性能。 类似于数据库中的 <code>select ... from ... lock in share mode</code></p><p><strong>注意事项</strong></p><ul><li>读锁不支持条件变量 </li><li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li></ul><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo6c2t414j30xs0iqwfq.jpg" alt="image-20210418203339576" style="zoom: 67%;" /><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>更新时，是先清缓存还是先更新数据库 </p><p><strong>先清缓存</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo6k508roj31840k0q54.jpg" alt="image-20210418204125189"></p><p><strong>先更新数据库（通常使用的）</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo6kwvm2mj30v00u00yi.jpg" alt="image-20210418204208526"></p><p>这种情况的出现几率非常小，见 facebook 论文</p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p><p><strong>t1 w.lock，t2 r.lock</strong></p><p>1） t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁 使用的是 state 的高 16 位</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo6fn47u7j30uu0kk0v1.jpg" alt="image-20210418203705054"  /><p>2）t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写 锁占据，那么 tryAcquireShared 返回 -1 表示失败</p><blockquote><p>tryAcquireShared 返回值表示 </p><ul><li>-1 表示失败</li><li>0 表示成功，但后继节点不会继续唤醒 </li><li>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</li></ul></blockquote><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo6hjkzjwj30v80ksgo3.jpg" alt="image-20210418203853099"  /><p>3）这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo70kto80j312m0hyacj.jpg" alt="image-20210418205713020"></p><p>4）t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</p><p>5）如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo711ahexj312o0iyn00.jpg" alt="image-20210418205738331"></p><p><strong>t3 r.lock，t4 w.lock</strong></p><p>这种状态下，假设又有 t3 加读锁（共享状态Shared）和 t4 加写锁（独占状态Ex），这期间 t1 仍然持有锁，就变成了下面的样子</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo78pxcpdj31d20fqmzx.jpg" alt="image-20210418210503783"></p><p><strong>t1 w.unlock</strong></p><p>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7akuhgwj31dw0fcgo9.jpg" alt="image-20210418210650519"></p><p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7bb28gtj31ei0g0whg.jpg" alt="image-20210418210732099"></p><p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7e9zj7uj31de0iujuu.jpg" alt="image-20210418211022747"></p><p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 （为了防止其他线程重复唤醒）并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7fah466j31ee0j00wa.jpg" alt="image-20210418211121650"></p><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7g68m2gj31e20is0wa.jpg" alt="image-20210418211213069"></p><p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7gmq2taj31da0oyaeb.jpg" alt="image-20210418211239666"></p><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p><p><strong>t2 r.unlock，t3 r.unlock</strong></p><p>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7hftc0dj31dc0omaet.jpg" alt="image-20210418211326010"></p><p>t3进入sync.releaseShared(1)中，调用tryReleaseShared(1)让计数减一，这回计数为零了，进入doReleaseShared()将头节点从-1改为0并唤醒老二，即</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7hzy646j31dk0p2tcz.jpg" alt="image-20210418211358350"></p><p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他 竞争，tryAcquire(1) 成功，修改头结点，流程结束</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7igo09yj313g0q6tcf.jpg" alt="image-20210418211425394"></p><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><p><strong>加解读锁</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.readLock(); lock.unlockRead(stamp);</code></pre></div><p><strong>加解写锁</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.writeLock(); lock.unlockWrite(stamp);</code></pre></div><p>乐观读，StampedLock 支持 <strong>tryOptimisticRead()</strong> 方法（乐观读），读取完毕后需要做一次<strong>戳校验</strong>如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead(); <span class="hljs-comment">// 验戳 </span><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;   <span class="hljs-comment">// 锁升级 </span>&#125;</code></pre></div><p>提供一个数据容器类内部分别使用读锁保护数据的**read()<strong>方法，写锁保护数据的</strong>write()**方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainerStamped</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock lock = <span class="hljs-keyword">new</span> StampedLock();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataContainerStamped</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;       <span class="hljs-keyword">this</span>.data = data;     &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> readTime)</span> </span>&#123;<span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();     log.debug(<span class="hljs-string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);     sleep(readTime);     <span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<span class="hljs-keyword">return</span> data;       &#125;    <span class="hljs-comment">// 锁升级 - 读锁 </span>      log.debug(<span class="hljs-string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);    <span class="hljs-keyword">try</span> &#123;stamp = lock.readLock();log.debug(<span class="hljs-string">&quot;read lock &#123;&#125;&quot;</span>, stamp);sleep(readTime);log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<span class="hljs-keyword">return</span> data;       &#125; <span class="hljs-keyword">finally</span> &#123;log.debug(<span class="hljs-string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);lock.unlockRead(stamp);       &#125;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newData)</span> </span>&#123;<span class="hljs-keyword">long</span> stamp = lock.writeLock();     log.debug(<span class="hljs-string">&quot;write lock &#123;&#125;&quot;</span>, stamp);     <span class="hljs-keyword">try</span> &#123;sleep(<span class="hljs-number">2</span>);<span class="hljs-keyword">this</span>.data = newData;           &#125; <span class="hljs-keyword">finally</span> &#123;log.debug(<span class="hljs-string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);lock.unlockWrite(stamp);           &#125;&#125;&#125;</code></pre></div><p>测试<code>读-读</code>可以优化</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;DataContainerStamped dataContainer = <span class="hljs-keyword">new</span> DataContainerStamped(<span class="hljs-number">1</span>);   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;dataContainer.read(<span class="hljs-number">1</span>);     &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();   sleep(<span class="hljs-number">0.5</span>);   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;dataContainer.read(<span class="hljs-number">0</span>);     &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();&#125;</code></pre></div><p>输出结果，可以看到实际没有加读锁</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.217</span> c.DataContainerStamped [t1] - optimistic read locking..<span class="hljs-number">.256</span> <span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.717</span> c.DataContainerStamped [t2] - optimistic read locking..<span class="hljs-number">.256</span> <span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.717</span> c.DataContainerStamped [t2] - read finish..<span class="hljs-number">.256</span>, data:<span class="hljs-number">1</span><span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">51.220</span> c.DataContainerStamped [t1] - read finish..<span class="hljs-number">.256</span>, data:<span class="hljs-number">1</span></code></pre></div><p>测试<code>读-写</code>时优化读补加读锁</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;DataContainerStamped dataContainer = <span class="hljs-keyword">new</span> DataContainerStamped(<span class="hljs-number">1</span>);   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;dataContainer.read(<span class="hljs-number">1</span>);     &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();   sleep(<span class="hljs-number">0.5</span>);   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;dataContainer.write(<span class="hljs-number">100</span>);     &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();&#125;</code></pre></div><p>输出结果</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">00.219</span> c.DataContainerStamped [t1] - optimistic read locking..<span class="hljs-number">.256</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">00.717</span> c.DataContainerStamped [t2] - write lock <span class="hljs-number">384</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">01.225</span> c.DataContainerStamped [t1] - updating to read lock... <span class="hljs-number">256</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">02.719</span> c.DataContainerStamped [t2] - write unlock <span class="hljs-number">384</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">02.719</span> c.DataContainerStamped [t1] - read lock <span class="hljs-number">513</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">03.719</span> c.DataContainerStamped [t1] - read finish..<span class="hljs-number">.513</span>, data:<span class="hljs-number">1000</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">03.719</span> c.DataContainerStamped [t1] - read unlock <span class="hljs-number">513</span></code></pre></div><blockquote><p>注意</p><ul><li>StampedLock 不支持条件变量 </li><li>StampedLock 不支持可重入</li></ul></blockquote><h2 id="4、Semaphore"><a href="#4、Semaphore" class="headerlink" title="4、Semaphore"></a>4、Semaphore</h2><p>信号量，用来限制能同时访问共享资源的线程上限</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpou72jxqbj310u0tkn3h.jpg" alt="image-20210419101910684"></p><p>输出</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpou7e4yggj310s0o6tj9.jpg" alt="image-20210419101931207"></p><p><strong>加锁解锁流程</strong></p><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后 停车场显示空余车位减一</p><p>刚开始，permits（state）为 3，这时 5 个线程来获取资源</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpou93wrw9j31cs0qwdmg.jpg" alt="image-20210419102112057"></p><p>假设其中Thread-1，Thread-2，Thread-4cas竞争成功，而Thread-0和Thread-3竞争失败，进入AQS队列park阻塞</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpou9xdnv7j31cs0ceq59.jpg" alt="image-20210419102158503"></p><p>这时 Thread-4 释放了 permits，状态如下</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpouad858aj31dg0dmwhm.jpg" alt="image-20210419102225028"></p><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接 下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p><h2 id="5、线性安全集合类"><a href="#5、线性安全集合类" class="headerlink" title="5、线性安全集合类"></a>5、线性安全集合类</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpowxpot12j31nq0dugnz.jpg" alt="image-20210419115346068"></p><p>线程安全集合类可以分为三大类：</p><ul><li><p>遗留的线程安全集合如 Hashtable ， Vector </p></li><li><p>使用 Collections 装饰的线程安全集合，如：</p><ul><li>Collections.synchronizedCollection</li><li>Collections.synchronizedList</li><li>Collections.synchronizedMap</li><li>Collections.synchronizedSet</li><li>Collections.synchronizedNavigableMap</li><li>Collections.synchronizedNavigableSet</li><li>Collections.synchronizedSortedMap</li><li>Collections.synchronizedSortedSet</li></ul></li><li><p>java.util.concurrent.*</p></li></ul><p>重点介绍 java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词： Blocking、CopyOnWrite、Concurrent</p><ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 </li><li>CopyOnWrite 之类容器修改开销相对较重 </li><li>Concurrent 类型的容器 <ul><li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li><li>弱一致性 <ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li><li>求大小弱一致性，size 操作未必是 100% 准确 </li><li>读取弱一致性</li></ul></li></ul></li></ul><blockquote><p>遍历时如果发生了修改，对于非安全容器来讲，使用 <strong>fail-fast</strong> 机制也就是让遍历立刻失败，抛出 ConcurrentModiﬁcationException，不再继续遍历</p></blockquote><h2 id="6、ConcurrentHashMap"><a href="#6、ConcurrentHashMap" class="headerlink" title="6、ConcurrentHashMap"></a>6、ConcurrentHashMap</h2><h4 id="JDK-7-HashMap-并发死链"><a href="#JDK-7-HashMap-并发死链" class="headerlink" title="JDK 7 HashMap 并发死链"></a>JDK 7 HashMap 并发死链</h4><p>在JDK7下使用HashMap会发生死链，究其原因，是因为在多线程环境下使用了非线程安全的 map 集合 </p><p>JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能 够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</p><h4 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpp3gxgovjj30zl0u0n7q.jpg" alt="image-20210419154006079"></p><h4 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpp3kg3yovj316q0bawi6.jpg" alt="image-20210419154328609"></p><p><strong>Java 8 数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）</strong></p><ul><li>初始化，使用 cas 来保证并发安全，懒惰初始化 table </li><li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程 会用 synchronized 锁住链表头 </li><li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素 添加至 bin 的尾部 </li><li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索 </li><li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可 做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中 </li><li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加 即可</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM虚拟机</title>
    <link href="/2021/05/05/JVM/"/>
    <url>/2021/05/05/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h1 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>JVM JRE JDK的区别</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" alt="img"></a></p><h1 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h1><p><strong>整体架构</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" alt="img"></a></p><h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h2 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        method1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;        method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> c = a + b;        <span class="hljs-keyword">return</span> c;    &#125;&#125;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png" alt="img"></a></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li></ul></li></ul><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h2 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h2><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h2 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h2><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h2 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h2><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" alt="img"></a></p><h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png" alt="img"></a></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">F:\JAVA\JDK8.0\bin&gt;javac F:\Thread_study\src\com\nyima\JVM\day01\Main.java</code></pre></div><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><div class="hljs code-wrapper"><pre><code class="hljs sh">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.class</code></pre></div></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png" alt="img"></a></p></li><li><p>常量池</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png" alt="img"></a></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png" alt="img"></a></p></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></li></ul></li></ul><h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String a = <span class="hljs-string">&quot;a&quot;</span>;         String b = <span class="hljs-string">&quot;b&quot;</span>;        String ab = <span class="hljs-string">&quot;ab&quot;</span>;    &#125;&#125;</code></pre></div><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">0: ldc           <span class="hljs-comment">#2                  // String a</span>2: astore_13: ldc           <span class="hljs-comment">#3                  // String b</span>5: astore_26: ldc           <span class="hljs-comment">#4                  // String ab</span>8: astore_39: <span class="hljs-built_in">return</span></code></pre></div><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String a = <span class="hljs-string">&quot;a&quot;</span>;        String b = <span class="hljs-string">&quot;b&quot;</span>;        String ab = <span class="hljs-string">&quot;ab&quot;</span>;        <span class="hljs-comment">//拼接字符串对象来创建新的字符串</span>        String ab2 = a+b;     &#125;&#125;</code></pre></div><p>反编译后的结果</p><div class="hljs code-wrapper"><pre><code class="hljs shell">     Code:      stack=2, locals=5, args_size=1         0: ldc           #2                  // String a         2: astore_1         3: ldc           #3                  // String b         5: astore_2         6: ldc           #4                  // String ab         8: astore_3         9: new           #5                  // class java/lang/StringBuilder        12: dup        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        16: aload_1        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        20: aload_2        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        27: astore        4        29: return</code></pre></div><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">String ab = <span class="hljs-string">&quot;ab&quot;</span>;String ab2 = a+b;<span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span>System.out.println(ab == ab2);</code></pre></div><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String a = <span class="hljs-string">&quot;a&quot;</span>;        String b = <span class="hljs-string">&quot;b&quot;</span>;        String ab = <span class="hljs-string">&quot;ab&quot;</span>;        String ab2 = a+b;        <span class="hljs-comment">//使用拼接字符串的方法创建字符串</span>        String ab3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;    &#125;&#125;</code></pre></div><p>反编译后的结果</p><div class="hljs code-wrapper"><pre><code class="hljs java">       Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span>         0: ldc           #2                  // String a         <span class="hljs-number">2</span>: astore_1         3: ldc           #3                  // String b         <span class="hljs-number">5</span>: astore_2         6: ldc           #4                  // String ab         <span class="hljs-number">8</span>: astore_3         9: new           #5                  // class java/lang/StringBuilder        <span class="hljs-number">12</span>: dup        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        <span class="hljs-number">16</span>: aload_1        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        <span class="hljs-number">20</span>: aload_2        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-comment">//ab3初始化时直接从串池中获取字符串</span>        29: ldc           #4                  // String ab        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span>        <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span></code></pre></div><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span>        String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span>        String st2 = str.intern();        <span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span>        String str3 = <span class="hljs-string">&quot;ab&quot;</span>;        <span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span>        System.out.println(str == st2);        System.out.println(str == str3);    &#125;&#125;</code></pre></div><p><strong>例2</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span>        String str3 = <span class="hljs-string">&quot;ab&quot;</span>;        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span>        String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-comment">//此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span>        String str2 = str.intern();        <span class="hljs-comment">//false</span>        System.out.println(str == str2);        <span class="hljs-comment">//false</span>        System.out.println(str == str3);        <span class="hljs-comment">//true</span>        System.out.println(str2 == str3);    &#125;&#125;</code></pre></div><h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">StringTableSize</span>=xxxx</code></pre></div></li><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h2 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h2><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" alt="img"></a></p><p><strong>使用了DirectBuffer</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" alt="img"></a></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</code></pre></div><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);&#125;</code></pre></div><p>DirectByteBuffer类</p><div class="hljs code-wrapper"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();    <span class="hljs-keyword">int</span> ps = Bits.pageSize();    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));    Bits.reserveMemory(size, cap);    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;    <span class="hljs-keyword">try</span> &#123;        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;        Bits.unreserveMemory(size, cap);        <span class="hljs-keyword">throw</span> x;    &#125;    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;        <span class="hljs-comment">// Round up to page boundary</span>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));    &#125; <span class="hljs-keyword">else</span> &#123;        address = base;    &#125;    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span>    att = <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();                       &#125;                       System.exit(<span class="hljs-number">1</span>);                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                   &#125;               &#125;);           &#125;</code></pre></div><p>对应对象的run方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// Paranoia</span>        <span class="hljs-keyword">return</span>;    &#125;    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span>    address = <span class="hljs-number">0</span>;    Bits.unreserveMemory(size, capacity);&#125;</code></pre></div><h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><h2 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h2><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png" alt="img"></a></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" alt="img"></a></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;        <span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);    &#125;&#125;</code></pre></div><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;        <span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span>        ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();        <span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);        <span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span>        Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();        <span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span>            list.remove(poll);            <span class="hljs-comment">//移动到引用队列中的下一个元素</span>            poll = queue.poll();        &#125;    &#125;&#125;</code></pre></div><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入饮用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h2 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h2><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png" alt="img"></a></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" alt="img"></a></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" alt="img"></a></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h2 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" alt="img"></a></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" alt="img"></a></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" alt="img"></a></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" alt="img"></a></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" alt="img"></a></p><p>如果新生代老年代中的内存都满了，就会先出法Minor Gc，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h2 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h2><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" alt="img"></a></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" alt="img"></a></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" alt="img"></a></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png" alt="img"></a></p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png" alt="img"></a></p><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png" alt="img"></a></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>会STW</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png" alt="img"></a></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png" alt="img"></a></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png" alt="img"></a></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png" alt="img"></a></p><ul><li>卡表与Remembered Set<ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post-write barried + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png" alt="img"></a></p><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" alt="img"></a></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png" alt="img"></a></p><h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png" alt="img"></a></p><h2 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h2><p>查看虚拟机参数命令</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-string">&quot;F:\JAVA\JDK8.0\bin\java&quot;</span> -XX:+PrintFlagsFinal -version | findstr <span class="hljs-string">&quot;GC&quot;</span></code></pre></div><p>可以根据参数去查询具体的信息</p><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题 </p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul><li>新生代的特点<ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是<ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><h1 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h1><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png" alt="img"></a></p><h2 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h2><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>java终端中，执行javac X:…\XXX.java</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png" alt="img"></a></p><p>以下是字节码文件</p><div class="hljs code-wrapper"><pre><code class="hljs shell">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 640000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b 0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 0001120 00 00 02 00 14</code></pre></div><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><div class="hljs code-wrapper"><pre><code class="hljs java">u4              magicu2             minor_version;    u2             major_version;    u2             constant_pool_count;    cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];    u2             access_flags;    u2             this_class;    u2             super_class;   u2             interfaces_count;    u2             interfaces[interfaces_count];   u2             fields_count;    field_info     fields[fields_count];   u2             methods_count;    method_info    methods[methods_count];    u2             attributes_count;    attribute_info attributes[attributes_count];</code></pre></div><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic </p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2 minor_version; </p><p>u2 major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09 </p><p>34H = 52，代表JDK8</p><h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>见资料文件</p><p>…略</p><h2 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h2><p>可参考 </p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><div class="hljs code-wrapper"><pre><code class="hljs java">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopyF:\Thread_study&gt;javap -v F:\Thread_study\src\com\nyima\JVM\day5\Demo1.classClassfile /F:/Thread_study/src/com/nyima/JVM/day5/Demo1.class  Last modified <span class="hljs-number">2020</span>-<span class="hljs-number">6</span>-<span class="hljs-number">6</span>; size <span class="hljs-number">434</span> bytes  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e  Compiled from <span class="hljs-string">&quot;Demo1.java&quot;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">nyima</span>.<span class="hljs-title">JVM</span>.<span class="hljs-title">day5</span>.<span class="hljs-title">Demo1</span></span>  minor version: 0  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;   #3 = String             #18            // hello world   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V   #5 = Class              #21            // com/nyima/JVM/day5/Demo1   #6 = Class              #22            // java/lang/Object   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               main  #12 = Utf8               ([Ljava/lang/String;)V  #13 = Utf8               SourceFile  #14 = Utf8               Demo1.java  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V  #16 = Class              #23            // java/lang/System  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;  #18 = Utf8               hello world  #19 = Class              #26            // java/io/PrintStream  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V  #21 = Utf8               com/nyima/JVM/day5/Demo1  #22 = Utf8               java/lang/Object  #23 = Utf8               java/lang/System  #24 = Utf8               out  #25 = Utf8               Ljava/io/PrintStream;  #26 = Utf8               java/io/PrintStream  #27 = Utf8               println  #28 = Utf8               (Ljava/lang/String;)V&#123;  <span class="hljs-keyword">public</span> com.nyima.JVM.day5.Demo1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #3                  // String hello world         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">10</span>: <span class="hljs-number">8</span>&#125;</code></pre></div><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;                <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;                <span class="hljs-keyword">int</span> c = a + b;                System.out.println(c);       &#125; &#125;</code></pre></div><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png" alt="img"></a></p><p><strong>方法字节码载入方法区</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png" alt="img"></a></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong></p><ul><li><p>将一个 byte 压入操作数栈</p><p>（其长度会补齐 4 个字节），类似的指令还有</p></li><li><p>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</p></li><li><p>ldc 将一个 int 压入操作数栈 </p></li><li><p>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</p></li><li><p>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" alt="img"></a></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的 </p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">10</span></code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" alt="img"></a></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" alt="img"></a></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" alt="img"></a></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" alt="img"></a></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" alt="img"></a></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" alt="img"></a></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" alt="img"></a></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" alt="img"></a></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法 </p><p>生成新的栈帧（分配 locals、stack等） </p><p>传递参数，执行新栈帧中的字节码</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" alt="img"></a></p><p>执行完毕，弹出栈帧 </p><p>清除 main 操作数栈内容</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" alt="img"></a></p><p><strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;            x = x++;            i++;        &#125;        System.out.println(x); <span class="hljs-comment">//接过为0</span>    &#125;&#125;</code></pre></div><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>    <span class="hljs-comment">//操作数栈分配2个空间，局部变量表分配3个空间</span>        <span class="hljs-number">0</span>: iconst_0    <span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">1</span>: istore_1    <span class="hljs-comment">//将常数0放入局部变量表的1号槽位 i=0</span>        <span class="hljs-number">2</span>: iconst_0    <span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">3</span>: istore_2    <span class="hljs-comment">//将常数0放入局部变量的2号槽位 x=0    </span>        <span class="hljs-number">4</span>: iload_1        <span class="hljs-comment">//将局部变量表1号槽位的数放入操作数栈中</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span>    <span class="hljs-comment">//将数字10放入操作数栈中，此时操作数栈中有2个数</span>        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span>    <span class="hljs-comment">//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span>       <span class="hljs-number">10</span>: iload_2        <span class="hljs-comment">//将局部变量2号槽位的数放入操作数栈中，放入的值是0</span>       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span>    <span class="hljs-comment">//将局部变量2号槽位的数加1，自增后，槽位中的值为1</span>       <span class="hljs-number">14</span>: istore_2    <span class="hljs-comment">//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0</span>       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//1号槽位的值自增1</span>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-comment">//跳转到第4条指令</span>       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;       <span class="hljs-number">24</span>: iload_2       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span></code></pre></div><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    <span class="hljs-keyword">static</span> &#123;        i = <span class="hljs-number">20</span>;    &#125;    <span class="hljs-keyword">static</span> &#123;        i = <span class="hljs-number">30</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(i); <span class="hljs-comment">//结果为30</span>    &#125;&#125;</code></pre></div><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p><div class="hljs code-wrapper"><pre><code class="hljs java">stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>         2: putstatic     #3                  // Field i:I         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>         7: putstatic     #3                  // Field i:I        <span class="hljs-number">10</span>: bipush        <span class="hljs-number">30</span>        12: putstatic     #3                  // Field i:I        <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span></code></pre></div><h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;    <span class="hljs-keyword">private</span> String a = <span class="hljs-string">&quot;s1&quot;</span>;    &#123;        b = <span class="hljs-number">20</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;    &#123;        a = <span class="hljs-string">&quot;s2&quot;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">this</span>.a = a;        <span class="hljs-keyword">this</span>.b = b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Demo4 d = <span class="hljs-keyword">new</span> Demo4(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);        System.out.println(d.a);        System.out.println(d.b);    &#125;&#125;</code></pre></div><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span>        <span class="hljs-number">0</span>: aload_0        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V        <span class="hljs-number">4</span>: aload_0        5: ldc           #2                  // String s1        7: putfield      #3                  // Field a:Ljava/lang/String;       <span class="hljs-number">10</span>: aload_0       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       13: putfield      #4                  // Field b:I       <span class="hljs-number">16</span>: aload_0       <span class="hljs-number">17</span>: bipush        <span class="hljs-number">10</span>       19: putfield      #4                  // Field b:I       <span class="hljs-number">22</span>: aload_0       23: ldc           #5                  // String s2       25: putfield      #3                  // Field a:Ljava/lang/String;       <span class="hljs-comment">//原始构造方法在最后执行</span>       <span class="hljs-number">28</span>: aload_0       <span class="hljs-number">29</span>: aload_1       30: putfield      #3                  // Field a:Ljava/lang/String;       <span class="hljs-number">33</span>: aload_0       <span class="hljs-number">34</span>: iload_2       35: putfield      #4                  // Field b:I       <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span></code></pre></div><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();        demo5.test1();        demo5.test2();        demo5.test3();        Demo5.test4();    &#125;&#125;</code></pre></div><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>         0: new           #2                  // class com/nyima/JVM/day5/Demo5          <span class="hljs-number">3</span>: dup         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V         <span class="hljs-number">7</span>: astore_1         <span class="hljs-number">8</span>: aload_1         9: invokespecial #4                  // Method test1:()V        <span class="hljs-number">12</span>: aload_1        13: invokespecial #5                  // Method test2:()V        <span class="hljs-number">16</span>: aload_1        17: invokevirtual #6                  // Method test3:()V        20: invokestatic  #7                  // Method test4:()V        <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span></code></pre></div><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈 </li><li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量 </li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定 </li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】 </li></ul><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;            i = <span class="hljs-number">20</span>;        &#125;    &#125;&#125;</code></pre></div><p>对应字节码指令</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-number">5</span>: goto          <span class="hljs-number">12</span>        <span class="hljs-number">8</span>: astore_2        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">11</span>: istore_1       <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span>     <span class="hljs-comment">//多出来一个异常表</span>     Exception table:        from    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/Exception</code></pre></div><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号 </li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;        &#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;            i = <span class="hljs-number">20</span>;        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;            i = <span class="hljs-number">30</span>;        &#125;    &#125;&#125;</code></pre></div><p>对应的字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-number">5</span>: goto          <span class="hljs-number">19</span>        <span class="hljs-number">8</span>: astore_2        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">11</span>: istore_1       <span class="hljs-number">12</span>: goto          <span class="hljs-number">19</span>       <span class="hljs-number">15</span>: astore_2       <span class="hljs-number">16</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">18</span>: istore_1       <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span>     Exception table:        from    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/Exception</code></pre></div><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            i = <span class="hljs-number">20</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;            i = <span class="hljs-number">30</span>;        &#125;    &#125;&#125;</code></pre></div><p>对应字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-comment">//try块</span>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-comment">//try块执行完后，会执行finally    </span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span>        <span class="hljs-number">7</span>: istore_1        <span class="hljs-number">8</span>: goto          <span class="hljs-number">27</span>       <span class="hljs-comment">//catch块     </span>       <span class="hljs-number">11</span>: astore_2 <span class="hljs-comment">//异常信息放入局部变量表的2号槽位</span>       <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">14</span>: istore_1       <span class="hljs-comment">//catch块执行完后，会执行finally        </span>       <span class="hljs-number">15</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">17</span>: istore_1       <span class="hljs-number">18</span>: goto          <span class="hljs-number">27</span>       <span class="hljs-comment">//出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   </span>       <span class="hljs-number">21</span>: astore_3       <span class="hljs-number">22</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">24</span>: istore_1       <span class="hljs-number">25</span>: aload_3       <span class="hljs-number">26</span>: athrow  <span class="hljs-comment">//抛出异常</span>       <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span>     Exception table:        from    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">11</span>   Class java/lang/Exception            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">21</span>   any           <span class="hljs-number">11</span>    <span class="hljs-number">15</span>    <span class="hljs-number">21</span>   any</code></pre></div><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程 </p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = Demo3.test();        <span class="hljs-comment">//结果为20</span>        System.out.println(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> i;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;            <span class="hljs-keyword">return</span> i;        &#125; <span class="hljs-keyword">finally</span> &#123;            i = <span class="hljs-number">20</span>;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;&#125;</code></pre></div><p>对应字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_0        <span class="hljs-number">3</span>: iload_0        <span class="hljs-number">4</span>: istore_1  <span class="hljs-comment">//暂存返回值</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>        <span class="hljs-number">7</span>: istore_0        <span class="hljs-number">8</span>: iload_0        <span class="hljs-number">9</span>: ireturn    <span class="hljs-comment">//ireturn会返回操作数栈顶的整型值20</span>       <span class="hljs-comment">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span>       <span class="hljs-number">10</span>: astore_2       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: istore_0       <span class="hljs-number">14</span>: iload_0       <span class="hljs-number">15</span>: ireturn    <span class="hljs-comment">//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span>     Exception table:        from    to  target type            <span class="hljs-number">0</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any</code></pre></div><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准 </li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子 </li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> i = Demo3.test();      <span class="hljs-comment">//最终结果为20</span>      System.out.println(i);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> i;      <span class="hljs-keyword">try</span> &#123;         i = <span class="hljs-number">10</span>;         <span class="hljs-comment">//这里应该会抛出异常</span>         i = i/<span class="hljs-number">0</span>;         <span class="hljs-keyword">return</span> i;      &#125; <span class="hljs-keyword">finally</span> &#123;         i = <span class="hljs-number">20</span>;         <span class="hljs-keyword">return</span> i;      &#125;   &#125;&#125;</code></pre></div><p>会发现打印结果为20，并未抛出异常</p><h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = Demo4.test();        System.out.println(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> i;        &#125; <span class="hljs-keyword">finally</span> &#123;            i = <span class="hljs-number">20</span>;        &#125;    &#125;&#125;</code></pre></div><p>对应字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_0 <span class="hljs-comment">//赋值给i 10</span>        <span class="hljs-number">3</span>: iload_0    <span class="hljs-comment">//加载到操作数栈顶</span>        <span class="hljs-number">4</span>: istore_1 <span class="hljs-comment">//加载到局部变量表的1号位置</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>        <span class="hljs-number">7</span>: istore_0 <span class="hljs-comment">//赋值给i 20</span>        <span class="hljs-number">8</span>: iload_1 <span class="hljs-comment">//加载局部变量表1号位置的数10到操作数栈</span>        <span class="hljs-number">9</span>: ireturn <span class="hljs-comment">//返回操作数栈顶元素 10</span>       <span class="hljs-number">10</span>: astore_2       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: istore_0       <span class="hljs-number">14</span>: aload_2 <span class="hljs-comment">//加载异常</span>       <span class="hljs-number">15</span>: athrow <span class="hljs-comment">//抛出异常</span>     Exception table:        from    to  target type            <span class="hljs-number">3</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any</code></pre></div><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;        Lock lock = <span class="hljs-keyword">new</span> Lock();        <span class="hljs-keyword">synchronized</span> (lock) &#123;            System.out.println(i);        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;&#125;</code></pre></div><p>对应字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_1        3: new           #2                  // class com/nyima/JVM/day06/Lock        <span class="hljs-number">6</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span>        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V       <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">//剩下的一份放到局部变量表的2号位置</span>       <span class="hljs-number">11</span>: aload_2 <span class="hljs-comment">//加载到操作数栈</span>       <span class="hljs-number">12</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈，用于加锁时消耗</span>       <span class="hljs-number">13</span>: astore_3 <span class="hljs-comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span>       <span class="hljs-number">14</span>: monitorenter <span class="hljs-comment">//加锁</span>       <span class="hljs-comment">//锁住后代码块中的操作    </span>       15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;       <span class="hljs-number">18</span>: iload_1       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V       <span class="hljs-comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span>       <span class="hljs-number">22</span>: aload_3           <span class="hljs-number">23</span>: monitorexit <span class="hljs-comment">//解锁</span>       <span class="hljs-number">24</span>: goto          <span class="hljs-number">34</span>       <span class="hljs-comment">//异常操作    </span>       <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>       <span class="hljs-number">29</span>: aload_3       <span class="hljs-number">30</span>: monitorexit <span class="hljs-comment">//解锁</span>       <span class="hljs-number">31</span>: aload         <span class="hljs-number">4</span>       <span class="hljs-number">33</span>: athrow       <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span>     <span class="hljs-comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span>     Exception table:        from    to  target type           <span class="hljs-number">15</span>    <span class="hljs-number">24</span>    <span class="hljs-number">27</span>   any           <span class="hljs-number">27</span>    <span class="hljs-number">31</span>    <span class="hljs-number">27</span>   any</code></pre></div><h2 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h2><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。 </p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;&#125;</code></pre></div><p>经过编译期优化后</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span>      <span class="hljs-keyword">super</span>();   &#125;&#125;</code></pre></div><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Integer x = <span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> y = x;   &#125;&#125;</code></pre></div><p>转换过程如下</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span>      <span class="hljs-keyword">int</span> y = x.intValue();   &#125;&#125;</code></pre></div><h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      list.add(<span class="hljs-number">10</span>);      Integer x = list.get(<span class="hljs-number">0</span>);   &#125;&#125;</code></pre></div><p>对应字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>       0: new           #2                  // class java/util/ArrayList       <span class="hljs-number">3</span>: dup       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V       <span class="hljs-number">7</span>: astore_1       <span class="hljs-number">8</span>: aload_1       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span>      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;      <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是add(Objcet o)</span>      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z      <span class="hljs-number">19</span>: pop      <span class="hljs-number">20</span>: aload_1      <span class="hljs-number">21</span>: iconst_0      <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是get(Object o)   </span>      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;<span class="hljs-comment">//这里进行了类型转换，将Object转换成了Integer</span>      27: checkcast     #7                  // class java/lang/Integer      <span class="hljs-number">30</span>: astore_2      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span></code></pre></div><p>所以调用get函数取值时，有一个类型转换的操作</p><div class="hljs code-wrapper"><pre><code class="hljs java">Integer x = (Integer) list.get(<span class="hljs-number">0</span>);</code></pre></div><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = (Integer) list.get(<span class="hljs-number">0</span>).intValue();</code></pre></div><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span>      String[] arr = args;      System.out.println(arr.length);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);   &#125;&#125;</code></pre></div><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-keyword">public</span> Demo4 &#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String[] arr = args;      System.out.println(arr.length);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);   &#125;&#125;</code></pre></div><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) &#123;            System.out.println(x);        &#125;    &#125;&#125;</code></pre></div><p>编译器会帮我们转换为</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) &#123;            <span class="hljs-keyword">int</span> x = arr[i];            System.out.println(x);        &#125;    &#125;&#125;</code></pre></div><p><strong>如果是集合使用foreach</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);      <span class="hljs-keyword">for</span> (Integer x : list) &#123;         System.out.println(x);      &#125;   &#125;&#125;</code></pre></div><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);      <span class="hljs-comment">//获得该集合的迭代器</span>      Iterator&lt;Integer&gt; iterator = list.iterator();      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;         Integer x = iterator.next();         System.out.println(x);      &#125;   &#125;&#125;</code></pre></div><h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-keyword">switch</span> (str) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;</code></pre></div><p>在编译器中执行的操作</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;         <span class="hljs-comment">//hello的hashCode</span>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;               x = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">break</span>;         <span class="hljs-comment">//world的hashCode</span>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;               x = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-comment">//用第二个switch在进行输出判断</span>      <span class="hljs-keyword">switch</span> (x) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;</code></pre></div><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SEX sex = SEX.MALE;      <span class="hljs-keyword">switch</span> (sex) &#123;         <span class="hljs-keyword">case</span> MALE:            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> FEMALE:            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;   MALE, FEMALE;&#125;</code></pre></div><p>编译器中执行的代码如下</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-comment">/**     </span><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];      <span class="hljs-keyword">static</span> &#123;         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SEX sex = SEX.MALE;      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];      <span class="hljs-keyword">switch</span> (x) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;   MALE, FEMALE;&#125;</code></pre></div><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;   MALE, FEMALE;&#125;</code></pre></div><p>转换后的代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;      <span class="hljs-comment">//对应枚举类中的元素</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;    <span class="hljs-keyword">static</span> &#123;               <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span>        MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);            FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);           $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;;    &#125;   <span class="hljs-comment">//调用父类中的方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;             <span class="hljs-keyword">super</span>(name, ordinal);        &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;          <span class="hljs-keyword">return</span> $VALUES.clone();      &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123;         <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);      &#125; &#125;</code></pre></div><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);         &#125;      &#125;;   &#125;&#125;</code></pre></div><p>转换后的代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span>      Runnable runnable = <span class="hljs-keyword">new</span> Demo8$<span class="hljs-number">1</span>();   &#125;&#125;<span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);   &#125;&#125;</code></pre></div><p>如果匿名内部类中引用了<strong>局部变量</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;</code></pre></div><p>转化后代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-comment">//多创建了一个变量</span>   <span class="hljs-keyword">int</span> val$x;   <span class="hljs-comment">//变为了有参构造器</span>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123;      <span class="hljs-keyword">this</span>.val$x = x;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(val$x);   &#125;&#125;</code></pre></div><h2 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h2><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li><p>将类的字节码载入</p><p>方法区</p><p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p></li><li><p>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用 </p></li><li><p>_super 即父类</p></li><li><p>_ﬁelds 即成员变量 </p></li><li><p>_methods 即方法 </p></li><li><p>_constants 即常量池 </p></li><li><p>_class_loader 即类加载器 </p></li><li><p>_vtable 虚方法表 </p></li><li><p>_itable 接口方法</p></li><li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p></li><li><p>加载和链接可能是<strong>交替运行</strong>的</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" alt="img"></a></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>HSDB的使用</strong></p><ul><li>先获得要查看的进程ID</li></ul><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">jps</span></code></pre></div><ul><li>打开HSDB</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">java -cp F:\JAVA\JDK8<span class="hljs-number">.0</span>\lib\sa-jdi.jar sun.jvm.hotspot.HSDB</code></pre></div><ul><li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png" alt="img"></a></p><ul><li>定位需要的进程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png" alt="img"></a></p><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;      ClassLoader loader = Demo1.class.getClassLoader();      <span class="hljs-comment">//只加载不解析</span>      Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">&quot;com.nyima.JVM.day8.C&quot;</span>);      <span class="hljs-comment">//用于阻塞主线程</span>      System.in.read();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;   D d = <span class="hljs-keyword">new</span> D();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;&#125;</code></pre></div><ul><li>打开HSDB<ul><li>可以看到此时只加载了类C</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" alt="img"></a></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" alt="img"></a></p><ul><li>解析以后，会将常量池中的符号引用解析为直接引用<ul><li>可以看到，此时已加载并解析了类C和类D</li></ul><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" alt="img"></a></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" alt="img"></a></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li></ul><p><strong>注意</strong></p><p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png" alt="img"></a></p><h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化 </li><li>首次访问这个类的静态变量或静态方法时 </li><li>子类初始化，如果父类还没初始化，会引发 </li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName </li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h2 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h2><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)    <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span>        Class&lt;?&gt; c = findLoadedClass(name);        <span class="hljs-comment">//如果没有被加载过</span>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">long</span> t0 = System.nanoTime();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//看是否被启动类加载器加载过</span>                    c = findBootstrapClassOrNull(name);                &#125;            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                <span class="hljs-comment">// from the non-null parent class loader</span>                <span class="hljs-comment">//捕获异常，但不做任何处理</span>            &#125;            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span>                <span class="hljs-comment">//然后让应用类加载器去找classpath下找该类</span>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();                c = findClass(name);                <span class="hljs-comment">// 记录时间</span>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        <span class="hljs-keyword">if</span> (resolve) &#123;            resolveClass(c);        &#125;        <span class="hljs-keyword">return</span> c;    &#125;&#125;</code></pre></div><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>想加载非 classpath 随意路径中的类文件 </li><li>通过接口来使用实现，希望解耦时，常用在框架设计 </li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li><p>继承ClassLoader父类</p></li><li><p>要遵从双亲委派机制，重写 ﬁndClass 方法</p></li><li><p>不是重写loadClass方法，否则不会走双亲委派机制</p></li><li><p>读取类文件的字节码</p></li><li><p>调用父类的 deﬁneClass 方法来加载类 </p></li><li><p>使用者调用该类加载器的 loadClass 方法</p></li></ul><h4 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h4><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h2 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h2><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling） </li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li><p>解释器</p><ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释 </li><li>是将字节码解释为针对所有平台都通用的机器码 </li></ul></li><li><p>即时编译器</p></li><li><p>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译 </p></li><li><p>根据平台类型，生成平台特定的机器码</p></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-comment">// to do something  </span>&#125;Copy</code></pre></div><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong></p><p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;         <span class="hljs-comment">//这里调用了add2方法</span>        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);      &#125;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>&#123;          <span class="hljs-keyword">return</span> x1 + x2;      &#125;</code></pre></div><p>方法调用被替换后</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;          <span class="hljs-comment">//被替换为了方法本身</span>        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;      &#125;</code></pre></div><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">&quot;foo...&quot;</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;      Method foo = Demo3.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;         foo.invoke(<span class="hljs-keyword">null</span>);      &#125;   &#125;&#125;</code></pre></div><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><span class="hljs-function">       InvocationTargetException</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (!override) &#123;        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;            Class&lt;?&gt; caller = Reflection.getCallerClass();            checkAccess(caller, clazz, obj, modifiers);        &#125;    &#125;    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;        ma = acquireMethodAccessor();    &#125;    <span class="hljs-keyword">return</span> ma.invoke(obj, args);&#125;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png" alt="img"></a></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numInvocations;    NativeMethodAccessorImpl(Method var1) &#123;        <span class="hljs-keyword">this</span>.method = var1;    &#125;    <span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span>    <span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object var1, Object[] var2)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;        <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="hljs-keyword">this</span>.method.getDeclaringClass())) &#123;            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="hljs-keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="hljs-keyword">this</span>.method.getDeclaringClass(), <span class="hljs-keyword">this</span>.method.getName(), <span class="hljs-keyword">this</span>.method.getParameterTypes(), <span class="hljs-keyword">this</span>.method.getReturnType(), <span class="hljs-keyword">this</span>.method.getExceptionTypes(), <span class="hljs-keyword">this</span>.method.getModifiers());            <span class="hljs-keyword">this</span>.parent.setDelegate(var3);        &#125;        <span class="hljs-keyword">return</span> invoke0(<span class="hljs-keyword">this</span>.method, var1, var2);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;        <span class="hljs-keyword">this</span>.parent = var1;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">invoke0</span><span class="hljs-params">(Method var0, Object var1, Object[] var2)</span></span>;&#125;Copy<span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;</code></pre></div><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
