<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/07/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/07/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><blockquote><p>本笔记是根据王道考研所讲的操作系统所做的笔记，老师讲课风格诙谐幽默，值得一看</p></blockquote><h1 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h1><h2 id="1-操作系统的概念、特征、功能、目标"><a href="#1-操作系统的概念、特征、功能、目标" class="headerlink" title="1.操作系统的概念、特征、功能、目标"></a>1.操作系统的概念、特征、功能、目标</h2><blockquote><p>操作系统（ Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。计算机操作系统是随着计算机研究和应用的发展逐步形成并发展起来的，它是计算机系统中最基本的系统软件</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200401222215527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-1-操作系统的特征"><a href="#1-1-操作系统的特征" class="headerlink" title="1.1 操作系统的特征"></a>1.1 操作系统的特征</h3><blockquote><p>操作系统的基本特征包括并发、共享、虚拟和异步</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200528183517102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-1-1-并发-Concurrence"><a href="#1-1-1-并发-Concurrence" class="headerlink" title="1.1.1 并发(Concurrence)"></a>1.1.1 并发(Concurrence)</h4><p><code>并发是指两个或多个事件在同一时间间隔内发生</code>。在多道程序环境下，一段时间内宏观上有多道程序在同时执行，而在每一时刻，单处理机环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。操作系统的并发性是通过分时得以实现的。</p><p><strong>虽然现在CPU很多都是多核的,但是程序有可能很多,所以并发还是很重要.</strong></p><h4 id="1-1-2-共享-Sharing"><a href="#1-1-2-共享-Sharing" class="headerlink" title="1.1.2 共享(Sharing)"></a>1.1.2 共享(Sharing)</h4><p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可分为以下两种资源共享方式</p><ul><li><strong>互斥共享方式</strong> 系统中的某些资源，如打印机、磁带机，<code>虽然它们可以提供给多个进程使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程访问该资源</code>。为此，当进程A访问某资源时，必须先提出请求，如果此时该资源空闲，系统便可将之分配给进程A使用，此后若再有其他进程也要访问该资源时（只要A未用完）则必须等待。仅当进程A访问完并释放该资源后，才允许另一进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享</li><li><strong>同时共享方式</strong> 系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，<code>而在微观上，这些进程可能是交替地对该资源进行访问</code>，即“分时共享”,典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件. 要注意到，互斥共享，是因为一种资源在一段时间内（哪怕是一段很小的时间）只能满足一个请求，否则就会出现严重的问题（如打印机，第一行打印A文档的内容，第二行打印B文档的内容，你能想象是什么效果吗？）.而同时共享方式，通常要求，一个请求分几个时间片段间隔地完成的效果，与连续完成的效果相同</li></ul><p><strong>并发和共享是操作系统两个最基本的特征，这两者之间又是互为存在条件的：</strong></p><ul><li>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题</li><li>若系统不能对资源共享实施有效的管理，也必将影响到程序的并发执行，甚至根本无法并发执行</li></ul><h4 id="1-1-3-虚拟-Virtual"><a href="#1-1-3-虚拟-Virtual" class="headerlink" title="1.1.3 虚拟(Virtual)"></a>1.1.3 虚拟(Virtual)</h4><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。</p><p>在操作系统中利用了多种虚拟技术，分别用来实现<code>虚拟处理器、虚拟内存和虚拟外部设备</code>等。 在虚拟处理器技术中，是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU）在专门为它服务。利用多道程序设计技术，<code>把一个物理上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器</code> </p><p>类似地，<code>可以通过虚拟存储器技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上来扩充存储器的容量</code>。当然，这时用户所感觉到的内存容量是虚的。我们把用户所感觉到的存储器（实际是不存在的）称为虚拟存储器。</p><p>还可以通过虚拟设备技术，将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备，这样便可以使原来仅允许在一段时间内由一个用户访问的设备（即临界资源），变为在一段时间内允许多个用户同时访问的共享设备.因此，<code>操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器</code></p><p>把CPU抽象成进程，把磁盘抽象成文件，把内存抽象成地址空间</p><h4 id="1-1-4-异步-Asynchronism"><a href="#1-1-4-异步-Asynchronism" class="headerlink" title="1.1.4 异步(Asynchronism)"></a>1.1.4 异步(Asynchronism)</h4><p>在多道程序环境下，<code>允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停</code>，以不可预知的速度向前推进，这就是进程的异步性</p><h3 id="1-2-操作系统的目标和功能"><a href="#1-2-操作系统的目标和功能" class="headerlink" title="1.2 操作系统的目标和功能"></a>1.2 操作系统的目标和功能</h3><h4 id="1-2-1-操作系统作为计算机系统资源的管理者"><a href="#1-2-1-操作系统作为计算机系统资源的管理者" class="headerlink" title="1.2.1 操作系统作为计算机系统资源的管理者"></a>1.2.1 操作系统作为计算机系统资源的管理者</h4><p><img src="https://img-blog.csdnimg.cn/20200528180734868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>处理机管理<br>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。并发时在计算机内同时运行多个进程，所以，进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能<br>有：进程控制、进程同步、进程通信、死锁处理、处理机调度等。</li><li>存储器管理<br>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用以及提高内存的利用率，主要包括内存分配、地址映射、内存保护与共享和内存扩充等功能</li><li>文件管理<br>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</li><li>设备管理<br>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率.主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</li></ul><h4 id="1-2-2-操作系统作为用户与计算机硬件系统之间的接口"><a href="#1-2-2-操作系统作为用户与计算机硬件系统之间的接口" class="headerlink" title="1.2.2 操作系统作为用户与计算机硬件系统之间的接口"></a>1.2.2 操作系统作为用户与计算机硬件系统之间的接口</h4><p><img src="https://img-blog.csdnimg.cn/20200401223245841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200401223603928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>操作系统提供的接口主要分为两类<br>一类是<strong>命令接口</strong>，用户利用这些操作命令来组织和控制作业的执行；另一类是<strong>程序接口</strong>，编程人员可以使用它们来请求操作系统服务。</p><ul><li><p>命令接口<br>使用命令接口进行作业控制的主要方式有两种，<strong>即联机控制方式和脱机控制方式</strong>。按作业控制方式的不同，可以将命令接口分为联机命令接口和脱机命令接口。联机命令接口又称交互式命令接口，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入完一条命令，控制权就转入操作系统的命令解释程序，然后由命令解释程序对输入的命令解释并执行，完成指定的功能。之后，控制权又转回到控制台或终端，此时用户又可以输入下一条命令</p><ul><li><strong>脱机命令接口又称批处理命令接口</strong>，即适用于批处理系统，它由一组作业控制命令（或称作业控制语句）组成。脱机用户不能直接干预作业的运行，应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。当系统调度到该作业时，由系统中的命令解释程序.对作业说明书上的命令或作业控制语句逐条解释执行，从而间接地控制作业的运行.<br>联机命令接口可以理解为：“雇主”说一句话，“工人”做一件事，并做出反馈，这就强调了交互性。</li></ul></li><li><p>程序接口<br><strong>程序接口由一组系统调用命令</strong>（简称系统调用，也称广义指令）组成。用户通过在程序中使用这些系统调用命令来请求操作系统为其提供服务。用户在程序中可以直接使用这组系统调用命令向系统提出各种服务要求，如使用各种外部设备，进行有关磁盘文件的操作，申请分配和回收内存以及其他各种控制要求。操作系统不允许用户直接操作各种硬件资源，因此用户程序只能通过系统调用的方式来请求内核为其服务，间接地使用各种资源</p></li><li><p>GUI<br>图形用户界面（GUI）即图形接口，用户通过鼠标和键盘，在图形界面上单击或使用快捷键就能很方便地使用操作系统。有些系统提供了上述三种接口，但GUI最终是通过调用程序接口实现的，严格地说GUI图形接口不属于操作系统的一部分，但图形接口所调用的系统调用命令，属于操作系统的一部分</p></li></ul><h4 id="1-2-3-操作系统用做扩充机器"><a href="#1-2-3-操作系统用做扩充机器" class="headerlink" title="1.2.3 操作系统用做扩充机器"></a>1.2.3 操作系统用做扩充机器</h4><p>没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，它的外面是操作系统，由操作系统提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器，通常把<strong>覆盖了软件的机器称为扩充机器，又称之为虚拟机</strong></p><blockquote><p>单处理机系统中，可并行的是（D）. </p><p>I.进程与进程<br>Ⅱ.处理机与设备<br>Ⅲ.处理机与通道<br>Ⅳ.设备与设备 </p><p>A.I、Ⅱ、Ⅲ<br>B.I、Ⅱ、Ⅳ<br>C.I、Ⅲ、Ⅳ<br>D.Ⅱ、Ⅲ、Ⅳ</p></blockquote><p>在单处理机系统（不包含多核的情况）中，同一时刻只能有一个进程占用处理机，因此进程之间不能并行执行。通道是独立于CPU的控制输入输出的设备，两者可以并行，显然，处理器与设备是可以并行的，难道CPU和显示屏不能并行工作？设备与设备是可以并行的，难道显示屏与打印机不能并行工作？</p><h2 id="2-操作系统的发展与分类"><a href="#2-操作系统的发展与分类" class="headerlink" title="2. 操作系统的发展与分类"></a>2. 操作系统的发展与分类</h2><p><img src="https://img-blog.csdnimg.cn/20200402002639598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="hello"><br><img src="https://img-blog.csdnimg.cn/2020052914130223.png" alt="在这里插入图片描述"></p><h3 id="2-1-手工操作阶段（此阶段无操作系统）"><a href="#2-1-手工操作阶段（此阶段无操作系统）" class="headerlink" title="2.1 手工操作阶段（此阶段无操作系统）"></a>2.1 手工操作阶段（此阶段无操作系统）</h3><p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾（速度和资源利用）越来越大，必须寻求新的解决办法。</p><p>手工操作阶段有两个突出的缺点：</p><ul><li>用户独占全机。不会出现因资源已被其他用户占用而等待的现象，但资源利用率低</li><li>CPU等待手工操作，CPU的利用不充分</li></ul><p>唯一的解决办法就是用高速的机器代替相对较慢的手工操作来对作业进行控制</p><h3 id="2-2-批处理阶段（操作系统开始出现）"><a href="#2-2-批处理阶段（操作系统开始出现）" class="headerlink" title="2.2 批处理阶段（操作系统开始出现）"></a>2.2 批处理阶段（操作系统开始出现）</h3><p>为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，出现了批处理系统。它按发<br>展历程又分为<code>单道批处理系统、多道批处理系统</code>（多道程序设计技术出现以后）.</p><ul><li>单道批处理系统<br>系统对作业的处理是成批进行的，但内存中始终保持一道作业。该系统是在解决人机矛盾和CPU与I/O设备速率不匹配的矛盾中形成的。单道批处理系统的主要特征如下<ul><li>自动性。在顺利的情况下，在磁带上的一批作业能自动地逐个依次运行，而无需人工</li><li>顺序性。磁带上的各道作业是顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序，在正常情况下应完全相同，亦即先调入内存的作业先完成</li><li>单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行</li></ul></li></ul><p><strong>此时面临的问题是</strong></p><p>每次主机内存中仅存放一道作业，每当它运行期间（注意这里是“运行时”，并不是“完成后”）发出输入输出请求后，高速的CPU便处于等待低速的I/O完成状态.为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术.</p><ul><li><p>多道批处理系统<br><code>多道程序设计技术允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许们交替在CPU中运行</code>，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序</p><p>多道程序设计的特点有：多道、宏观上并行、微观上串行。</p><ul><li>多道：计算机内存中同时存放多道相互独立的程序。</li><li>宏观上并行：同时进入系统的多道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕。</li><li>微观上串行：内存中的多道程序轮流占有CPU，交替执行</li></ul></li></ul><p><strong>多道程序设计技术的实现需要解决下列问题</strong></p><ul><li>如何分配处理器</li><li>多道程序的内存分配问题</li><li>I/O设备如何分配</li><li>如何组织和存放大量的程序和数据，以便于用户使用和保证其安全性与一致性 </li></ul><p>优点是资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用：系统吞吐量大，CPU和其他资源保持“忙碌”状态。缺点是用户响应的时间较长。<code>不提供人机交互能力，用户既不能了解自己程序的运行情况，也不能控制计算机</code></p><h3 id="2-3-分时操作系统"><a href="#2-3-分时操作系统" class="headerlink" title="2.3 分时操作系统"></a>2.3 分时操作系统</h3><p>在操作系统中采用分时技术就形成了分时系统。所谓分时技术就是把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉好像是自己独占一台计算机.<br>分时操作系统是多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无需人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征，其主要特征如下：</p><ul><li>同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li><li>交互性。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</li><li>独立性。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样</li><li>及时性。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意</li></ul><p>虽然分时操作系统比较好地解决了人机交互问题，但是在一些应用场合，<code>需要系统能对外部的信息在规定的时间（比时间片的时间还短）内作出处理</code>（比如飞机订票系统或导弹制导系统）因此，实时系统应运而生</p><h3 id="2-4-实时操作系统"><a href="#2-4-实时操作系统" class="headerlink" title="2.4 实时操作系统"></a>2.4 实时操作系统</h3><p>为了能在某个时间限制内完成某些紧急任务而不需时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况：</p><ul><li>如果某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为硬实时系统。例如，飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成</li><li>如果能够接受偶尔违反时间规定，并且不会引起任何永久性的损害，则称为软实时系统，如飞机订票系统、银行管理系统</li></ul><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完接收的事件。实时操作系统的主要特点是及时性和可靠性。</p><h3 id="2-5-网络操作系统和分布式计算机系统"><a href="#2-5-网络操作系统和分布式计算机系统" class="headerlink" title="2.5 网络操作系统和分布式计算机系统"></a>2.5 网络操作系统和分布式计算机系统</h3><p>网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各个计算机之间的互相传送数据。网络操作系统最主要的特点是网络中各种资源的共享以及各台计算机之间的通信.</p><p>分布式计算机系统是由多台计算机组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息：系统中的每一台计算机都具有同等的地位，即没有主机也没有从机；每台计算机上的资源为所有用户共享；系统中的任意若干台计算机都可以构成一个子系统，并且还能重构；任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是：分布性和并行性。分布式操作系统与网络操作系统本质上的不同之处在于分布式操作系统中，若干台计算机相互协同完成同一任务。</p><h3 id="2-6-个人计算机操作系统"><a href="#2-6-个人计算机操作系统" class="headerlink" title="2.6 个人计算机操作系统"></a>2.6 个人计算机操作系统</h3><p>个人计算机操作系统是目前使用最广泛的操作系统，广泛应用于文字处理、电子表格、游戏等。常见的有 Windows、 Linux和 Macintosh等</p><h2 id="3-操作系统的运行机制跟体系结构"><a href="#3-操作系统的运行机制跟体系结构" class="headerlink" title="3. 操作系统的运行机制跟体系结构"></a>3. 操作系统的运行机制跟体系结构</h2><p><img src="https://img-blog.csdnimg.cn/20200706210933706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402092035655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210531175254267.png" alt="image-20210531175254267"></p><h3 id="3-1-操作系统的运行机制"><a href="#3-1-操作系统的运行机制" class="headerlink" title="3.1 操作系统的运行机制"></a>3.1 操作系统的运行机制</h3><p>计算机系统中，通常CPU执行两种不同性质的程序：<code>一种是操作系统内核程序；另一种是用户自编程序或系统外层的应用程序</code>。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”要执行一些特权指令，而“被管理程序”出于安全考虑不能执行这些指令。操作系统在具体实现上划分了用户态（目态）和核心态（管态），以严格区分两类程序.操作系统的各项功能分别被设置在不同的层次上。<code>一些与硬件关联较紧密的模块，诸如时钟管理、中断处理、设备驱动等处于最底层。其次是运行频率较高的程序，诸如进程管理、存储器管理和设备管理等</code>。这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。</p><p><code>内核是计算机上配置的底层软件，是计算机功能的延伸。不同系统对内核的定义稍有区别。大多数操作系统内核包括四个方面的内容</code></p><ul><li>时钟管理<br>在计算机的各种部件中，时钟是最关键的设备。时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现进程的切换。诸如，在分时操作系统中，采用时间片轮转调度的实现；在实时系统中，按截止时间控制运行的实现；在批处理系统中，通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面无不依赖于时钟。</li><li>中断机制<br>引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。<br>中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力</li><li>原语，按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。其特点是：<ul><li>它们处于操作系统的最底层，是最接近硬件的部分。</li><li>这些程序的运行具有原子性—其操作只能一气呵成（这主要是从系统的安全性和便于管理考虑的）</li><li>这些程序的运行时间都较短，而且调用频繁。</li></ul></li></ul><p>通常把具有这些特点的程序称为原语（ Atomic Operation）.定义原语的直接方法是关闭中断，让它的所有动作不可分割地进行完，再打开中断。</p><p><code>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可以定义为原语，使它们成为内核的组成部分</code></p><ul><li>系统控制的数据结构及处理<br>系统中用来登记状态信息的数据结构很多，比如作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下三种<br>1）进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块等<br>2）存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等<br>3）设备管理：缓冲区管理、设备分配和回收等<br>从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令</li></ul><h3 id="3-2-中断和异常"><a href="#3-2-中断和异常" class="headerlink" title="3.2 中断和异常"></a>3.2 中断和异常</h3><p><img src="https://img-blog.csdnimg.cn/20200706211009553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200402094023539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402094321685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402094734544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>中断（ Interruption），也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的I/O结束中断，表示设备输入输出处理已经完成，希望处理机能够向设备发下一个输入输出请求,同时让完成输入输出后的程序继续运行。<code>时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等</code>。这一类中断通常是与当前程序运行无关的事件，即它们与当前处理机运行的程序无关</p><p>异常（ Exception），也称内中断、例外或陷入（Trap），指源自CPU执行指令内部的事件，<br><code>如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页以及专门的陷入指令等引起的事件</code>。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一但出现应立即处理。</p><h3 id="3-3-系统调用"><a href="#3-3-系统调用" class="headerlink" title="3.3 系统调用"></a>3.3 系统调用</h3><p><img src="https://img-blog.csdnimg.cn/20200402100117545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200402100637106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402101046100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402102114944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706211048292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>所谓系统调用就是用户在程序中调用操作系统提供的一些子功能，系统调用可以被看做特殊的公共子程序</code>。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行I/O传输以及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十乃至上百条之多,这些系统调用按功能大致可分为如下几类</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能</li><li>文件管理。完成文件的读、写、创建及删除等功能</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能</li><li>进程通信。完成进程之间的消息传递或信号传递等功能</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li></ul><p>显然，<code>系统调用运行在系统的核心态。通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令</code>。系统调用命令是由操作系统提供的一个或多个子程序模块实现的。<br>下面列举一些由用户态转向核心态的例子：</p><p><img src="https://img-blog.csdnimg.cn/20200529111946326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-4-操作系统的体系结构"><a href="#3-4-操作系统的体系结构" class="headerlink" title="3.4 操作系统的体系结构"></a>3.4 操作系统的体系结构</h3><p><img src="https://img-blog.csdnimg.cn/2020040209232247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200708100758503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="二、进程同步和互斥"><a href="#二、进程同步和互斥" class="headerlink" title="二、进程同步和互斥"></a>二、进程同步和互斥</h1><p><img src="https://img-blog.csdnimg.cn/20200706161604234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706161654480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706161716690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706161813260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706161859429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706161933796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706171831433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706172629884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706174400154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706191129607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706180307698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706191956957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706193311914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200706194954529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200531193752627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-1-进程的概念和特征"><a href="#1-1-进程的概念和特征" class="headerlink" title="1.1 进程的概念和特征"></a>1.1 进程的概念和特征</h3><p><img src="https://img-blog.csdnimg.cn/20200706161228279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h4><p>进程（Process）以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性）<code>为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块（ProcessControlBlock，PCB）</code>系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，<code>由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）</code>。<code>所谓创建进程，实质上是创建进程映像中的PCB：而撤销进程，实质上是撤销进程的PCB。</code></p><p><code>值得注意的是进程映像是静态的，进程则是动态的</code></p><p>从不同的角度，进程可以有不同的定义，比较典型的定义有：<br>1）进程是程序的一次<code>执行过程</code><br>2）进程是一个程序及其数据在处理机上顺序执行时<code>所发生的活动</code>。<br>3）进程是具有独立功能的程序在一个数据集合上<code>运行的过程</code>，它是系统进行资源分配和调度的一个独立单位。</p><p>在引入进程实体的概念后，我们可以把传统操作系统中的进程定义为：“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位这里的系统资源，指的是处理机、存储器和其他设备服务于某进程的“时间”，比如，把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，即“时间片”分配的独立单位，这就决定了，进程一定是一个动态的、过程性的概念。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601100224159.png" alt="image-20210601100224159"></p><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><p>进程是由多程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求</p><ul><li>动态性：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征</li><li>并发性：指多个进程实体，同存于内存中，能在一段时间内同时运行，<code>并发性是进程的重要特征，同时也是操作系统的重要特征</code>。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率</li><li>独立性：指<code>进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</code>。凡未建立PCB的程序都不能作为一个独立的单位参与运行。</li><li>异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制</li><li>结构性：每个进程都配置一个PCB对其进行描述。从结构上看，<code>进程实体是由程序段、数据段和进程控制段三部分组成的</code></li></ul><h3 id="1-2-进程的状态与转换"><a href="#1-2-进程的状态与转换" class="headerlink" title="1.2 进程的状态与转换"></a>1.2 进程的状态与转换</h3><p><img src="https://img-blog.csdnimg.cn/20200706161301448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020040220064459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>通常进程有以下五种状态，前三种是进程的基本状态<br>1）运行状态：进程正在处理机上运行。<code>在单处理机环境下，每一时刻最多只有一个进程处于运行状态</code>。</p><p>2）就绪状态：进程已处于准备运行的状态，<code>即进程获得了除处理机之外的一切所需资源,一旦得到处理机即可运行</code></p><p>3）阻塞状态，又称等待状态：<code>进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入输出完成。即使处理机空闲，该进程也不能运行</code>。</p><p>4）创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：<code>首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必需的资源：最后把该进程转入到就绪状态</code></p><p>5）结束状态：进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，<code>系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收等工作。</code></p><p><code>注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。</code><br><code>之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒</code>。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪状态的：而其他资源（如外设）的使用和分配或者某一事件的发生（如I/O操作的完成）对应的时间相对来说很长，进程转换到等待状态的次数也相对较少。这样来看，就绪状态和等待状态是进程生命周期中两个完全不同的状态，很显然需要加以区分。</p><h4 id="状态的转换"><a href="#状态的转换" class="headerlink" title="状态的转换"></a>状态的转换</h4><p>就绪状态→运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片）于是进程由就绪状态转换为运行状态</p><p>运行状态→就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。</p><p>运行状态→阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如IO操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式</p><p>阻塞状态→就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态<br>需要注意的是，一个进程从运行状态变成阻塞状态是一个主动的行为，而从阻塞状态变到就就绪状态是一个被动的行为，需要其他相关进程的协助</p><h3 id="1-3-进程控制"><a href="#1-3-进程控制" class="headerlink" title="1.3 进程控制"></a>1.3 进程控制</h3><p><img src="https://img-blog.csdnimg.cn/20200706161406983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有<code>创建新进程、撤销已有进程、实现进程状态转换等功能</code>。<code>在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</code><br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601103352347.png" alt="image-20210601103352347"></p><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程</p><p>在操作系统中，<code>终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建</code>。操作系统创建一个新进程的过程如下（创建原语）：</p><p>1）为新进程分配一个唯一的进程标识号，并申请一个空白的PCB（PCB是有限的）.若PCB申请失败则创建失败。</p><p>2）为进程分配资源，为新进程的程序和数据，以及用户栈分配必要的内存空间（在PCB中体现）.注意：这里如果资源不足（比如内存空间），并不是创建失败，而是处于“等待状态或称为“阻塞状态”，等待的是内存这个资源</p><p>3）初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等</p><p>4）如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601103626193.png" alt="image-20210601103626193"></p><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p>引起进程终止的事件主要有：正常结束，表示进程的任务已经完成和准备退出运行。异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止</p><p>操作系统终止进程的过程如下（撤销原语）</p><p>1）根据被终止进程的标识符，检索PCB，从中读出该进程的状态<br>2）若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程<br>3）若该进程还有子进程，则应将其所有子进程终止<br>4）将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。<br>5）将该PCB从所在队列（链表）中删除</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601103701471.png" alt="image-20210601103701471"></p><h4 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成数据尚未到达或无新工作可做等，则由系统自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。阻塞原语的执行过程是</p><p>1）找到将要被阻塞进程的标识号对应的PCB.<br>2）若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。<br>3）把该PCB插入到相应事件的等待队列中去<br>当被阻塞进程所期待的事件出现时，如它所启动的IO操作已完成或其所期待的数据已到达则由有关进程（比如，提供数据的进程）调用喚醒原语（Wakeup），将等待该事件的进程唤醒唤醒原语的执行过程是</p><p>1）在该事件的等待队列中找到相应进程的PCB<br>2）将其从等待队列中移出，并置其状态为就绪状态<br>3）把该PCB插入就绪队列中，等待调度程序调度</p><p>需要注意的是，Block原语和 Wakeup原语是一对作用刚好相反的原语，必须成对使用。 Block原语是由被阻塞进程自我调用实现的，而 Wakeup原语则是由一个与被唤醒进程相合作或被其他相关的进程调用实现的</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601103839486.png" alt="image-20210601103839486"></p><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>对于通常的进程，其创建、撤销以及要求由系统设备完成的IO操作都是利用系统调用而进入内核，再由内核中相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的进程切换是指处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化。进程切换的过程如下</p><p>1）保存处理机上下文，包括程序计数器和其他寄存器。<br>2）更新PCB信息<br>3）把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<br>4）选择另一个进程执行，并更新其PCB<br>5）更新内存管理的数据结构<br>6）恢复处理机上下文</p><p>注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。如果进程因中断或异常进入到核心态运行，执行完后又回到用户态刚被中断的程序运行则操作系统只需恢复进程进入内核时所保存的CPU现场，无需改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。</p><p>注意：“调度”和“切换”的区别，调度是指决定资源分配给哪个进程的行为，是一种决策行为切换是指实际分配的行为，是执行行为。一般来说，先有资源的调度，然后才有进程的切换</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601104024983.png" alt="image-20210601104024983"></p><h3 id="1-4-进程的组织"><a href="#1-4-进程的组织" class="headerlink" title="1.4 进程的组织"></a>1.4 进程的组织</h3><p>进程是操作系统的资源分配和独立运行的基本单位。它一般由以下三个部分组成</p><ul><li>进程控制块<br>进程创建时，操作系统就新建一个PCB结构，它之后就常驻内存，任一时刻可以存取，在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。当创建一个进程时，系统为该进程建立一个PCB：当进程执行时，系统通过其PCB了解进程的现行状态信息，以便对其进行控制和管理；当进程结束时，系统收回其PCB，该进程随之消亡。操作系统通过PCB表来管理和控制进程PCB主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。各部分的主要说明如下：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200531175224684.png" alt="在这里插入图片描述"></p><p>1）进程描述信息<br>进程标识符：标志各个进程，每个进程都有一个并且是唯一的标识号<br>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务</p><p>2）进程控制和管理信息进程当前状态：描述进程的状态信息，作为处理机分配调度的依据进程优先级：描述进程抢占处理机的优先级，优先级高的进程可以优先获得处理机。</p><p>3）资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况：所打开文件的列表和所使用的输入输出设备信息。</p><p>4）处理机相关信息，主要指处理机中各寄存器值，当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能再从断点继续执行在一个系统中，通常存在着许多进程，有的处于就绪状态，有的处于阻塞状态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来。目前常用的组织方式有链接方式和索引方式两种。链接方式将同一状态的PCB链接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。索引方式是将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB不同状态对应不同的索引表，如就绪索引表和阻塞索引表等</p><ul><li><p>程序段<br>程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可以被多个进程共享，就是说多个进程可以运行同一个程序</p></li><li><p>数据段<br>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200402194654392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402194758818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402194818323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-5-进程的通信"><a href="#1-5-进程的通信" class="headerlink" title="1.5 进程的通信"></a>1.5 进程的通信</h3><p><img src="https://img-blog.csdnimg.cn/20200706161449867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类:</p><h4 id="1-5-1-共享存储"><a href="#1-5-1-共享存储" class="headerlink" title="1.5.1 共享存储"></a>1.5.1 共享存储</h4><p><img src="https://img-blog.csdnimg.cn/20200531184114689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200402205029332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_1,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-5-2-消息传递"><a href="#1-5-2-消息传递" class="headerlink" title="1.5.2 消息传递"></a>1.5.2 消息传递</h4><p><img src="https://img-blog.csdnimg.cn/2020053118444774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601105328555.png" alt="image-20210601105328555"></p><h4 id="1-5-3-管道通信"><a href="#1-5-3-管道通信" class="headerlink" title="1.5.3 管道通信"></a>1.5.3 管道通信</h4><p><img src="https://img-blog.csdnimg.cn/20200531184934335.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200531185020516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601105231233.png" alt="image-20210601105231233"></p><h3 id="1-6-线程概念和多线程模型"><a href="#1-6-线程概念和多线程模型" class="headerlink" title="1.6 线程概念和多线程模型"></a>1.6 线程概念和多线程模型</h3><p><img src="https://img-blog.csdnimg.cn/20200706161521969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-6-1-线程的基本概念"><a href="#1-6-1-线程的基本概念" class="headerlink" title="1.6.1 线程的基本概念"></a>1.6.1 线程的基本概念</h4><p>引入进程的目的，是为了更好地使多道程序并发执行，以提高资源利用率和系统吞吐量，增加并发程度；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。</p><p><code>线程是进程中的一个实体，是被系统独立调度和分派的基本单位</code>，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。<code>线程也有就绪、阻塞和运行三种基本状态</code>。</p><p>引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，<code>线程则作为处理机的分配单元。由于一个进程内部有多个线程，如果线程的切换发生在同一个进程内部，则只需要很少的时空开销</code></p><h4 id="1-6-2-线程与进程的比较"><a href="#1-6-2-线程与进程的比较" class="headerlink" title="1.6.2 线程与进程的比较"></a>1.6.2 线程与进程的比较</h4><ul><li>调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，<code>线程是独立调度的基本单位，进程是拥有资源的基本单位</code>。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>拥有资源。不论是传统操作系统还是设有线程的操作系统，<code>进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点必不可少的资源）</code>，但线程可以访问其隶属进程的系统资源。我们要知道，如果线程也是拥有资源的单位，那么，切换线程也需要较大的时空开销，线程这个概念的提出就没有意义了。</li><li>并发性。在引入线程的操作系统中，<code>不仅进程之间可以并发执行，而且多个线程之间也可以并发执行</code>，从而使操作系统具有更好的并发性，提高了系统的吞吐量。</li><li>系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、IO设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，<code>涉及当前执行进程CPU环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小</code>。此外，由于同一进程内的多个线程共享进程的地址空间，因此，这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预</li><li>地址空间和其他资源（如打开的文件）：进程的地址空间之间互相独立，同<code>一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见</code></li><li>通信方面：进程间通信（IPC）需要进程同步和互斥手段的辅助，以保证数据的一致性而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</li></ul><h4 id="1-6-3-线程的属性"><a href="#1-6-3-线程的属性" class="headerlink" title="1.6.3 线程的属性"></a>1.6.3 线程的属性</h4><p>在多线程操作系统中，把线程作为独立运行（或调度）的基本单位，此时的进程，已不再是个基本的可执行实体。但进程仍具有与执行相关的状态，所谓进程处于“执行”状态，实际上是指该进程中某线程正在执行。线程的主要属性如下</p><p>1）线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态<br>2）不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统为它们创建成不同的线程<br>3）同一进程中的各个线程共享该进程所拥有的资源<br>4）线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务则可缩短进程的处理时间。<br>5）一个线程被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历阻塞态就绪态和运行态等各种状态变化</p><p>为什么线程的提出有利于提高系统并发性？可以这样来理解：由于有了线程，线程切换时有可能会发生进程切换，也有可能不发生进程的切换，那么平均下来，每次切换所需要的开销就小了，因而，就能够让更多的线程参与并发，也不会影响到响应时间等问题了</p><h4 id="1-6-4-线程的实现方式"><a href="#1-6-4-线程的实现方式" class="headerlink" title="1.6.4 线程的实现方式"></a>1.6.4 线程的实现方式</h4><p>线程的实现可以分为两类：用户级线程（User-LevelThread，ULT）和内核级线程（Kernel-LevThread，KLT）.内核级线程又称为内核支持的线程。</p><p>在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。</p><ul><li>图（a）说明了用户级线程的实现方式在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。</li><li>图（b）说明了内核级线程的实现方式在一些系统中，使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。</li><li>图（c）说明了用户级与内核级的组合实现方式</li></ul><p><img src="https://img-blog.csdnimg.cn/20210103095251735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210103095317592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210103095348648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-6-5-多线程模型"><a href="#1-6-5-多线程模型" class="headerlink" title="1.6.5 多线程模型"></a>1.6.5 多线程模型</h4><p><img src="https://img-blog.csdnimg.cn/20210103095714208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210103095735307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021010309580711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式</p><p>1）多对一模型。将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（即透明）.优点：线程管理是在用户空间进行的，因而效率比较高。缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞：多个线程不能并行地运行在多处理机上。</p><p>2）一对一模型。将每个用户级线程映射到一个内核级线程。优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能</p><p>3）多对多模型。将n个用户级线程映射到m个内核级线程上，要求m≤n特点：在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长</p><h3 id="1-7-处理机调度的概念、层次"><a href="#1-7-处理机调度的概念、层次" class="headerlink" title="1.7 处理机调度的概念、层次"></a>1.7 处理机调度的概念、层次</h3><p><img src="https://img-blog.csdnimg.cn/20200602121604324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020040809253446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200408092917283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><p><img src="https://img-blog.csdnimg.cn/20210218200901411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><p><img src="https://img-blog.csdnimg.cn/20210218200945224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210601114353166.png" alt="image-20210601114353166"></p><h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><p><img src="https://img-blog.csdnimg.cn/2021021820113736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h4><p>在多道程序系统中，进程的数量往往多于处理机的个数，进程争用处理机的情况就在所难免。<br>处理机调度是对处理机进行分配，就是从就绪队列中，按照一定的算法（公平、高效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行，处理机调度是多道程序操作系统的基础，它是操作系统设计的核心问题</p><h4 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h4><p>作业从提交开始直到完成，往往要经历以下三级调度<br>1）作业调度。又称高级调度，其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入输出设备等必要的资源，并建立相应的进程，以使它（们）获得竞争处理机的权利。简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次，多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。<br>2）中级调度。又称内存调度。引入中级调度是为了提高内存利用率和系统吞吐量。为此应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待<br>3）进程调度。又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次</p><h4 id="三级调度的联系"><a href="#三级调度的联系" class="headerlink" title="三级调度的联系"></a>三级调度的联系</h4><p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行状态，把CPU分配给它。<br>中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒<br>1）作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间<br>2）作业调度次数少，中级调度次数略多，进程调度频率最高。<br>3）进程调度是最基本的，不可或缺</p><p><img src="https://img-blog.csdnimg.cn/20200408092848537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-8-进程调度的时机、切换与过程、方式"><a href="#1-8-进程调度的时机、切换与过程、方式" class="headerlink" title="1.8 进程调度的时机、切换与过程、方式"></a>1.8 进程调度的时机、切换与过程、方式</h3><h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h4><p><img src="https://img-blog.csdnimg.cn/20210218201609623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218201741149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218201824662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>进程调度和切换程序是操作系统内核程序。当请求调度的事件发生后，才可能会运行进程调度程序，当调度了新的就绪进程后，才会去进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，在操作系统内核程序运行时，如果某时发生了引起进程调度的因素，并不一定能够马上进行调度与切换。</p><p><strong>现代操作系统中，不能进行进程的调度与切换的情况有以下几种情况</strong><br>1）在处理中断的过程中：中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。<br>2）进程在操作系统内核程序临界区中：进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。<br>3）其他需要完全屏蔽中断的原子操作过程中：如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。如果在上述过程中发生了引起调度的条件，并不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。</p><p><strong>应该进行进程调度与切换的情况有</strong>：</p><p>1）当发生引起调度条件，且当前进程无法继续运行下去时，可以马上进行调度与切换。如果操作系统只在这种情况下进行进程调度，就是非剥夺调度<br>2）当中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。如果操作系统支持这种情况下的运行调度程序，就实现了剥夺方式的调度。<br>进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的现场信息推入到当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p><h4 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h4><p><img src="https://img-blog.csdnimg.cn/20210218201922547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>所谓进程调度方式是指当某一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。通常有以下两种进程调度方式</p><p>1）非剥夺调度方式，又称非抢占方式。是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。<br>在非剥夺调度方式下，一旦把CPU分配给一个进程，那么该进程就会保持CPU直到终止或转换到等待状态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。<br>2）剥夺调度方式，又称抢占方式。是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。</p><p>采用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有：优先权、短进程优先和时间片原则等。</p><h4 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h4><p><img src="https://img-blog.csdnimg.cn/20210218202035404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-9-调度算法的评价指标"><a href="#1-9-调度算法的评价指标" class="headerlink" title="1.9 调度算法的评价指标"></a>1.9 调度算法的评价指标</h3><h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h4><p><img src="https://img-blog.csdnimg.cn/20210218202359315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h4><p><img src="https://img-blog.csdnimg.cn/20210218202449483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p><img src="https://img-blog.csdnimg.cn/20210218202534195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218202623484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt=" "></p><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4><p><img src="https://img-blog.csdnimg.cn/20210218202824852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法所具有的特性。为了比较处理机调度算法的性能，人们提出很多评价准则，下面介绍主要的几种<br>1）CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU保持“忙”状态，使这一资源利用率最高<br>2）系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。<br>3）周转时间。是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处理机上运行以及进行输入输出操作所花费时间的总和。<br>4）等待时间。是指进程处于等处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法的优劣，常常只需简单地考察等待时间。<br>5）响应时间。是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一</p><h3 id="1-10-FCFS、SJF、HRRN调度算法"><a href="#1-10-FCFS、SJF、HRRN调度算法" class="headerlink" title="1.10 FCFS、SJF、HRRN调度算法"></a>1.10 FCFS、SJF、HRRN调度算法</h3><p>在操作系统中存在多种调度算法，<code>其中有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用</code>。下面介绍几种常用的调度算法。</p><p><img src="https://img-blog.csdnimg.cn/20210218204030759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="先来先服务（FCFS）调度算法"><a href="#先来先服务（FCFS）调度算法" class="headerlink" title="先来先服务（FCFS）调度算法"></a>先来先服务（FCFS）调度算法</h4><p><img src="https://img-blog.csdnimg.cn/20210218203207451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218203231218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。</p><p>FCFS调度算法属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。FCFS调度算法的特点是算法简单，但效率低：对长作业比较有利，但对短作业不利（相对SJF和高响应比）：有利于CPU繁忙型作业，而不利于I/O繁忙型作业。</p><h4 id="短作业优先（SJF）调度算法"><a href="#短作业优先（SJF）调度算法" class="headerlink" title="短作业优先（SJF）调度算法"></a>短作业优先（SJF）调度算法</h4><p><img src="https://img-blog.csdnimg.cn/20210218203434618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218203616700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218203707934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先（SJF）调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先（SPF）调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</p><p>SJF调度算法也存在不容忽视的缺点：<br>1）该算法对长作业不利，SJF调度算法中长作业的周转时间会增加。更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些（即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”.后者是系统环形等待，前者是调度策略问题）.<br>2）该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。<br>3）由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。<br>注意，SJF调度算法的平均等待时间、平均周转时间最少</p><h4 id="高响应比优先调度算法HRRN"><a href="#高响应比优先调度算法HRRN" class="headerlink" title="高响应比优先调度算法HRRN"></a>高响应比优先调度算法HRRN</h4><p><img src="https://img-blog.csdnimg.cn/20210218203839373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218203900804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行</p><h3 id="1-11-时间片轮转、优先级、多级反馈队列"><a href="#1-11-时间片轮转、优先级、多级反馈队列" class="headerlink" title="1.11 时间片轮转、优先级、多级反馈队列"></a>1.11 时间片轮转、优先级、多级反馈队列</h3><p><img src="https://img-blog.csdnimg.cn/20210218205155253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h4><p><img src="https://img-blog.csdnimg.cn/20210218204419708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218204514230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms.在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。<br>在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。</p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p><img src="https://img-blog.csdnimg.cn/20210218204646593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218204718346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218204738133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p><img src="https://img-blog.csdnimg.cn/20210218204948784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210218205035647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展，如图2-5所示。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间。</p><p>多级反馈队列调度算法的实现思想如下：<br>1）应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。</p><p>2）赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长1倍…第计+1级队列的时间片要比第i级队列的时间片长1倍。</p><p>3）当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列如此下去，当一个长进程从第1级队列依次降到第n级队列后，在第n级队列中便釆用时间片轮转的方式运行。</p><p>4）仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1（-1）级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时又有新进程进入优先级较高的队列（第1~（-1）中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。多级反馈队列的优势有以下几点。</p><p>1）终端型作业用户：短作业优先。<br>2）短批处理作业用户：周转时间较短<br>3）长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理</p><h3 id="1-12-进程同步、互斥"><a href="#1-12-进程同步、互斥" class="headerlink" title="1.12 进程同步、互斥"></a>1.12 进程同步、互斥</h3><p><img src="https://img-blog.csdnimg.cn/20200603000704755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>临界资源</strong><br>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等.此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源.<br>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。<br><strong>同步</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602105321250.png" alt="image-20210602105321250"></p><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作<br>例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A</p><p><strong>互斥</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602105226378.png" alt="image-20210602105226378"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602105446229.png" alt="image-20210602105446229"></p><p>互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源<br>例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时，系统已将打印机分配给进程B，则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。<br>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：<br>1）空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区<br>2）忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。<br>3）有限等待。对请求访问的进程，应保证能在有限时间内进入临界区<br>4)让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待</p><h4 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h4><p><img src="https://img-blog.csdnimg.cn/20210220212750798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210220212506232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220212543496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220212617407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220212710319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>软件实现方法</strong></p><ul><li>单标志法。</li><li>双标志法先检查</li><li>双标志法后检查。</li><li>Peterson’s Algorithm</li></ul><p><strong>硬件实现方法</strong></p><p>1）<code>中断屏蔽方法</code><br>当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单方法是禁止一切中断发生，或称之为屏蔽中断、关中断。因为CPU只在发生中断时引起进程切换，这样屏蔽中断就能保证当前运行进程将临界区代码顺利地执行完，从而保证了互斥的正确实现，然后再执行开中断。其典型模式<br>…<br>关中断；<br>临界区；<br>开中断；<br>…<br>这种方法限制了处理机交替执行程序的能力，因此执行的效率将会明显降低。对内核来说当它执行更新变量或列表的几条指令期间关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断之后不再开中断，则系统可能会因此终止。</p><p>2）<code>硬件指令方法</code></p><ul><li>TestAndSet指令</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602111641733.png" alt="image-20210602111641733"></p><ul><li>Swap指令</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210602111656074.png" alt="image-20210602111656074"></p><h3 id="1-13-信号量"><a href="#1-13-信号量" class="headerlink" title="1.13 信号量*"></a>1.13 信号量*</h3><p><img src="https://img-blog.csdnimg.cn/20210220212940947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213023527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213143348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213209435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213417600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213503108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220213534503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021022021355937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>信号量机构是一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准的原语wait(S)和 signal(S)来访问，也可以记为“P操作”和“V操作”.<br>原语是指完成某种功能且不被分割不被中断执行的操作序列，通常可由硬件来实现完成不被分割执行特性的功能。如前述的“ Test-and-Set”和“Swap”指令，就是由硬件实现的原子操作。<br>原语功能的不被中断执行特性在单处理机时可由软件通过屏蔽中断方法实现。<br>原语之所以不能被中断执行，是因为原语对变量的操作过程如果被打断，可能会去运行另个对同一变量的操作过程，从而出现临界段问题。如果能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。</p><ul><li>整型信号量 </li><li>记录型信号量</li><li>利用信号量实现同步</li><li>利用信号量实现进程互斥</li><li>利用信号量实现前驱关系</li></ul><h3 id="1-14-经典同步问题"><a href="#1-14-经典同步问题" class="headerlink" title="1.14 经典同步问题"></a>1.14 经典同步问题</h3><p>见PDF 223页</p><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>问题描述：一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待：只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者个消费者从中取出消息</p><h4 id="多生产者多消费者"><a href="#多生产者多消费者" class="headerlink" title="多生产者多消费者"></a>多生产者多消费者</h4><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>问题描述：有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作：②只允许一个写者往文件中写信息：③任一写者在完成写操作之前不允许其他读者或写者工作；④写者行写操作前，应让已有的读者和写者全部退出</p><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>问题描述：一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭.哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当晢学家饥饿的时候，才试图拿起左、右两根筷子（一根一根地拿起）.如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕筷子继续思考</p><h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><p>问题描述：假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉完成了，供应者就会放另外两种材料在桌上，这种过程一直重复（让三个抽烟者轮流地抽烟）</p><h3 id="1-15-管程"><a href="#1-15-管程" class="headerlink" title="1.15 管程"></a>1.15 管程</h3><p><img src="https://img-blog.csdnimg.cn/20210220214731921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1 管程的定义<br>系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略了它们的内部结构和实现细节。管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程.</p><p>2 管程的纽成<br>1）局部于管程的共享结构数据说明<br>2）对该数据结构进行操作的一组过程。<br>3）对局部于管程的共享数据设置初始值的语句</p><p>3 管程的基本特性<br>1）局部于管程的数据只能被局部于管程内的过程所访问<br>2）一个进程只有通过调用管程内的过程才能进入管程访问共享数据<br>3）每次仅允许一个进程在管程内执行某个内部过程。<br>由于管程是一个语言成分，所以管程的互斥访问完全由编译程序在编译时自动添加，无需程序员关注，而且保证正确.</p><p><strong>这里，我们再用生活化的语言介绍什么是管程。</strong><br>管程实质上是一个抽象类，这个抽象类有好几个成员变量，系统中任何设备都可以通过这几成员变量进行区分和描述：管程中还有对这些成员变量进行操作的一组成员函数，例如，对外设的操作中，会有read，write这一类函数。假如，进程P0要使用一台打印机，于是管程这个抽象类就会利用初始值语句对自身的几个成员变量赋初值（这个行为不需要程序员关注），特定的几个初值可以让管程表示成一台打印机，进程P0进入管程后，通过调用管程中的成员函数（即上面所说的过程）对这台打印机进行操作。每次进入这个管程的，只能是一个进程</p><h3 id="1-16-死锁"><a href="#1-16-死锁" class="headerlink" title="1.16 死锁"></a>1.16 死锁</h3><p><img src="https://img-blog.csdnimg.cn/20200603082933257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220214929860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021022021502281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220215048244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021022021511267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220215138752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>死锁的定义</strong><br>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题—死锁。所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进.在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入设备进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p><p><strong>死锁产生的原因</strong><br>（1）系统资源的竞争<br>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。<br>（2）进程推进顺序非法<br>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程P1P2分别保持了资源R1、R2，而进程Pl申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，结果也会使得这些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁.<br>（3）死锁产生的必要条件<br>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）.请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p><p><img src="https://img-blog.csdnimg.cn/20200603074928110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>资源分配图含圈而系统又不一定有死锁的原因是同类资源数大于1.但若系统中每类资源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。要注意区分不可剥夺条件与请求和保持条件，用一个简单的例子来说明：如果你手上拿着个苹果（即便你不打算吃），别人不能把你手上的苹果拿走，那就是不可剥夺条件；如果你左手拿着一个苹果，允许你右手再去拿一个苹果，那就是请求和保持条件。</p><h3 id="1-17-死锁的处理策略"><a href="#1-17-死锁的处理策略" class="headerlink" title="1.17 死锁的处理策略"></a>1.17 死锁的处理策略</h3><p>为使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一，或者允许死锁产生，但当死锁发生时能检测出死锁，并有能力实现恢复<br><strong>预防死锁</strong><br>设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个，以防止发生死锁<br><strong>避免死锁</strong><br>在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁<br><strong>死锁的检测及解除</strong><br>无需采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。<br>预防死锁和避免死锁都属于事先预防策略，但预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低：避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。</p><p><img src="https://img-blog.csdnimg.cn/20200603075414636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-17-1-死锁预防"><a href="#1-17-1-死锁预防" class="headerlink" title="1.17.1 死锁预防"></a>1.17.1 死锁预防</h4><p>防止死锁的发生只需破坏死锁产生的四个必要条件之一即可</p><p><strong>破坏互斥条件</strong><br>如果允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性</p><p><strong>破坏不剥夺条件</strong><br>当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放或者说是被剥夺了，或从而破坏了不可剥夺条件</p><p>该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量.这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源</p><p><strong>破坏请求和保持条件</strong><br>采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求这样就可以保证系统不会发生死锁</p><p>这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p><p><strong>破坏循环等待条件</strong><br>为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源.</p><p>这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加：尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费：此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦.</p><h4 id="1-17-2-死锁避免"><a href="#1-17-2-死锁避免" class="headerlink" title="1.17.2 死锁避免"></a>1.17.2 死锁避免</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210603162257147.png" alt="image-20210603162257147"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210603162451927.png" alt="image-20210603162451927"></p><p><strong>则可以引入银行家算法，见PDF 290页</strong></p><h4 id="1-17-3-死锁检测和解除"><a href="#1-17-3-死锁检测和解除" class="headerlink" title="1.17.3 死锁检测和解除"></a>1.17.3 死锁检测和解除</h4><p>前面介绍的死锁预防和避免算法，都是在为进程分配资源时施加限制条件或进行检测，若系统为进程分配资源时不采取任何措施，则应该提供死锁检测和解除的手段。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210603163502062.png" alt="image-20210603163502062"></p><p><strong>具体见PDF 299页</strong></p><h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><p><img src="https://img-blog.csdnimg.cn/20200711083859717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-1-内存管理的概念"><a href="#1-1-内存管理的概念" class="headerlink" title="1.1 内存管理的概念"></a>1.1 内存管理的概念</h2><p><img src="https://img-blog.csdnimg.cn/20200705083124193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200705083705203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>内存管理</strong>（ Memory Management）是操作系统设计中最重要和最复杂的内容之一。操作系统对内存的划分和动态分配，就是内存管理的概念<br>内存管理的功能有：<br>内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</p><p><strong>地址转换</strong>：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。</p><p>内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</p><p><strong>存储保护</strong>：保证各道作业在各自的存储空间内运行，互不干扰。<br>在进行具体的内存管理之前，需要了解进程运行的基本原理和要求。</p><p><strong>程序装入和链接</strong></p><p>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤</p><p><code>编译</code>：由编译程序将用户源代码编译成若干个目标模块<br><code>链接</code>：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块<br><code>装入</code>：由装入程序将装入模块装入内存运行。</p><p>程序的链接有以下三种方式</p><p><code>静态链接</code>：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。</p><p><code>装入时动态链接</code>：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式</p><p><img src="https://img-blog.csdnimg.cn/20200604130139117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>运行时动态链接</code>：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享</p><p>内存的装入模块在装入内存时，同样有以下三种方式：</p><p>1）<code>绝对装入</code>。在编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改<br>绝对装入方式只适用于单道程序环境。另外，程序中所使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。而通常情况下在程序中采用的是符号地址，编译或汇编时再转换为绝对地址。</p><p>2）<code>可重定位装入</code>。在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，所以又称为静态重定位，如图（a）所示。</p><p><img src="https://img-blog.csdnimg.cn/20200604130820626.png" alt="在这里插入图片描述"></p><p>静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。此外，作业一旦进入内存后，在整个运行期间不能在内存中移动，也不能再申请内存空间</p><p>动态运行时装入，也称为<code>动态重定位</code>，程序在内存中如果发生移动，就需要采用动态的装入方式。装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持，如图（b）所示<br>动态重定位的特点是可以将程序分配到不连续的存储区中：在程序运行之前可以只装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存：便于程序段的共享,可以向用户提供一个比存储空间大得多的地址空间</p><p><img src="https://img-blog.csdnimg.cn/20200604131137834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>逻辑地扯空间与物理地址空间</strong></p><p>编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址（或逻辑地址）.<br>链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间。用户程序和程序员只需知道逻辑地址而内存管理的具体机制则是完全透明的，它们只有系统编程人员才会涉及。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置.物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位</p><p><strong>内存保护</strong></p><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法</p><ul><li><p>在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界</p></li><li><p>通过采用重定位寄存器（或基址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值。每个逻辑地址值必须小于界地址寄存器；内存管理机构动态地将逻辑地址与界地址寄存器进行比较，如果未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如图3-3所示</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200604131837577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当CPU调度程序选择进程执行时，派遣程序会初始化重定位寄存器和界地址寄存器。每个逻辑地址都需要与这两个寄存器进行核对，以保证操作系统和其他用户程序及数据不被该进程的运行所影响.实现内存保护需要重定位寄存器和界地址寄存器，注意两者的区别。重定位寄存器是用来“加”的，逻辑地址加上重定位寄存器中的值就能得到物理地址;界地址寄存器是用来“比”的通过比较界地址寄存器中的值与重定位寄存器加上逻辑地址的值来判断是否越界</p><h2 id="1-2-覆盖与交换"><a href="#1-2-覆盖与交换" class="headerlink" title="1.2 覆盖与交换"></a>1.2 覆盖与交换</h2><p><img src="https://img-blog.csdnimg.cn/20200705085655673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法</p><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决</p><p><strong>覆盖的基本思想</strong>：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区.其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段.</p><p><strong>覆盖技术的特点</strong>是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆准区的段，不在覆盖区中的段会常驻内存</p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p><strong>交换（对换）的基本思想</strong>，把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出：把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。</p><p>例如，有一个CPU采用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。同时，CPU调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行.</p><p>有关交换需要注意以下几个问题<br>交换需要备份存储，通常是快速磁盘。它必须足够大，并且提供对这些内存映像的直接访问。为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间。转移时间与所交换的内存空间成正比.如果换出进程，必须确保该进程是完全处于空闲状态.交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。普通的交换使用不多，但交换策略的某些变种在许多系统中（如UNⅨ系统）仍发挥作用</p><p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史：而交换技术在现代操作系统中仍具有较强的生命力</p><h2 id="1-3-连续分配管理方式"><a href="#1-3-连续分配管理方式" class="headerlink" title="1.3 连续分配管理方式"></a>1.3 连续分配管理方式</h2><p><img src="https://img-blog.csdnimg.cn/20200705092720324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>连续分配方式，是指为一个用户程序分配一个连续的内存空间，比如说某用户需要1GB的内存空间，它就在内存空间中分配一块连续的1GB的空间给用户。它主要包括单一连续分配/固定分区分配和动态分区分</p><p><strong>单一连续分配</strong></p><p>内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分.用户区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。因为内存中永远只有一道程序，肯定不会因为访问越界而干扰其他程序。</p><p>这种方式的优点是简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低</p><p><strong>固定分区分配</strong></p><p>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中，选择适当大小的作业装入该分区，如此循环固定分区分配在划分分区时，有两种不同的方法，如图3-4所示</p><p><img src="https://img-blog.csdnimg.cn/20200604134943455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>分区大小相等</code>：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性</p><p><code>分区大小不等</code>：划分为含有多个较小的分区、适量的中等分区及少量的大分区。</p><p>为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配），如图3-5（a）所示。当有用户程序要装入时，便检索该表，以找到合适的分区给予分配并将其状态置为“已分配”,未找到合适分区则拒绝为该用户程序分配内存。存储空间的分配情况如图3-5（b）所示</p><p><strong>这种分区方式存在两个问题</strong>：一是程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间：二是主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部有空间浪费，这种现象称为内部碎片。</p><p>固定分区是可用于多道程序设计最简单的存储分配，无外部碎片，但不能实现多进程共享一个主存区，所以存储空间利用率低。固定分区分配很少用于现在通用的操作系统中，但在某些用于控制多个相同对象的控制系统中仍发挥着一定的作用。</p><p><img src="https://img-blog.csdnimg.cn/20200604135858857.png" alt="在这里插入图片描述"></p><h2 id="1-4-动态分区分配"><a href="#1-4-动态分区分配" class="headerlink" title="1.4 动态分区分配"></a>1.4 动态分区分配</h2><p><img src="https://img-blog.csdnimg.cn/2020070509353090.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>动态分区分配又称为可变分区分配</code>，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。</p><p><img src="https://img-blog.csdnimg.cn/2020060414101810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如图所示，系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。开始时装入前三个进程，在它们分别分配到所需空间后，内存只剩下4MB，进程4无法装入。在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4.由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。之后CPU又出现空闲，而主存无法容纳进程2，操作系统就换出进程1，换入进程2.</p><p>动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块。随着时间的推移，内存中会产生越来越多的碎片（图3-6中最后的4MB和中间的6MB，且随着进程的换入换出,很可能会出现更多更小的内存块），内存的利用率随之下降。这些小的内存块称为外部碎片，指在所有分区外的存储空间会变成越来越多的碎片，这与固定分区中的内部碎片正好相对。克服外部碎片可以通过紧凑（ Compaction）技术来解决，就是操作系统不时地对进程进行移动和整理</p><p>但是这需要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于 Windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑.<br>在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略，考虑以下几种算法</p><p>1）<code>首次适应（ First Fit）算法</code>：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区<br>2）<code>最佳适应（ Best Fit）算法</code>：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区<br>最坏适应（ Worst Fit）算法：又称最大适应（ Largest Fit）算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区<br>3）<code>邻近适应（ Next Fit）算法</code>：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找</p><p>在这几种方法中，首次适应算法不仅是最简单的，而且通常也是最好和最快的。在UNIX系统的最初版本中，就是使用首次适应算法为进程分配内存空间，其中使用数组的数据结构（而非链表）来实现。不过，首次适应算法会使得内存的低地址部分出现很多小的空闲分区,而每次分配查找时，都要经过这些分区，因此也增加了查找的开销</p><p>邻近适应算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间（因为在遍扫描中，内存前面部分使用后再释放时，不会参与分配），分裂成小碎片。它通常比首次适应算法的结果要差</p><p>最佳适应算法虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，它会产生最多的外部碎片</p><p>最坏适应算法与最佳适应算法相反，选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大的内存块，因此性能也非常差</p><p>Knuth和Shore分别就前三种方法对内存空间的利用情况做了模拟实验，结果表明首次适应算法可能比最佳适应法效果好，而它们两者一定比最大适应法效果好。另外注意，在算法实现时，分配操作中最佳适应法和最大适应法需要对可用块进行排序或遍历查找，而首次适应法和邻近适应法只需要简单查找：回收操作中，当回收的块与原来的空闲块相邻时（有三种相邻的情况，比较复杂），需要将这些块合并。在算法实现时，使用数组或链表进行管理。除了内存的利用率，这里的算法开销也是操作系统设计需要考虑的一个因素</p><p><img src="https://img-blog.csdnimg.cn/2020060414223979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-5-基本分页存储管理的基本概念"><a href="#1-5-基本分页存储管理的基本概念" class="headerlink" title="1.5 基本分页存储管理的基本概念"></a>1.5 基本分页存储管理的基本概念</h2><p><img src="https://img-blog.csdnimg.cn/20200705144615215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>非连续分配管理方式</strong></p><p>非连续分配允许一个程序分散地装入到不相邻的内存分区中。在连续分配管理方式中我们发现，即使内存有超过1GB的空闲空间，但如果没有连续的1GB的空间，需要1GB空间的作业仍然是无法运行的；但如果采用非连续分配管理方式，作业所要求的1GB内存空间可以分散地分配在内存的各个区域，当然，这也需要额外的空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续存储方式</p><p>非连续分配管理方式根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。下面介绍基本分页存储管理方式。</p><p><strong>基本分页存储管理方式</strong></p><p>固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低.我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。但它又有本质的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才生成主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平<br>均只产生半个块大小的内部碎片（也称页内碎片）.</p><p><img src="https://img-blog.csdnimg.cn/20200604144448210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604150239308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>*<img src="https://img-blog.csdnimg.cn/20200604150407527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="加粗样式"></p><h2 id="1-6-基本地址变换机构"><a href="#1-6-基本地址变换机构" class="headerlink" title="1.6 基本地址变换机构"></a>1.6 基本地址变换机构</h2><p><img src="https://img-blog.csdnimg.cn/20200705161226230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604152256836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604154934221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-7-具有快表的地址变换机构"><a href="#1-7-具有快表的地址变换机构" class="headerlink" title="1.7 具有快表的地址变换机构"></a>1.7 具有快表的地址变换机构</h2><p><img src="https://img-blog.csdnimg.cn/20200604155151158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604155409990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="加粗样式"><br><img src="https://img-blog.csdnimg.cn/20200705162805426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-8-两级页表"><a href="#1-8-两级页表" class="headerlink" title="1.8 两级页表"></a>1.8 两级页表</h2><p><img src="https://img-blog.csdnimg.cn/20200604155533303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604155611809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202007051653310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-9-基本分段存储管理方式"><a href="#1-9-基本分段存储管理方式" class="headerlink" title="1.9 基本分段存储管理方式"></a>1.9 基本分段存储管理方式</h2><p><img src="https://img-blog.csdnimg.cn/2020060416083722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604160902726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604161001886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200705171647698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-10-段页式管理方式"><a href="#1-10-段页式管理方式" class="headerlink" title="1.10 段页式管理方式"></a>1.10 段页式管理方式</h2><p><img src="https://img-blog.csdnimg.cn/20200604161136560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200604161206254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200705175323749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-11-虚拟内存的基本概念"><a href="#1-11-虚拟内存的基本概念" class="headerlink" title="1.11 虚拟内存的基本概念"></a>1.11 虚拟内存的基本概念</h2><p><strong>传统存储管理方式的特征</strong></p><p>1）时间局部性<br>2）空间局部性</p><p><strong>虚拟存储器的定义和特征</strong></p><p>1）多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存<br>2）对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。<br>3）虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。</p><p><strong>虚拟内存技术的实现</strong></p><p>虚拟内存的实现有以下三种方式</p><p><code>请求分页存储管理 请求分段存储管理 请求段页式存储管理</code></p><p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面</p><ul><li>定容量的内存和外存</li><li>页表机制（或段表机制），作为主要的数据结构</li><li>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断</li><li>地址变换机构，逻辑地址到物理地址的变换</li></ul><p><img src="https://img-blog.csdnimg.cn/20200705182312176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-12-请求分页管理方式"><a href="#1-12-请求分页管理方式" class="headerlink" title="1.12 请求分页管理方式"></a>1.12 请求分页管理方式</h2><p><img src="https://img-blog.csdnimg.cn/20200705184734624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-13-页面置换算法（决定应该换入哪页换出哪页）"><a href="#1-13-页面置换算法（决定应该换入哪页换出哪页）" class="headerlink" title="1.13 页面置换算法（决定应该换入哪页换出哪页）"></a>1.13 页面置换算法（决定应该换入哪页换出哪页）</h2><p><img src="https://img-blog.csdnimg.cn/20200705195258840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200710184701146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200710184719340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200710184731447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200710184747935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-14-页面分配策略"><a href="#1-14-页面分配策略" class="headerlink" title="1.14 页面分配策略"></a>1.14 页面分配策略</h2><p><img src="https://img-blog.csdnimg.cn/20200705201739116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-15-抖动"><a href="#1-15-抖动" class="headerlink" title="1.15 抖动"></a>1.15 抖动</h2><p><img src="https://img-blog.csdnimg.cn/20210221101932861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-16-工作集"><a href="#1-16-工作集" class="headerlink" title="1.16 工作集"></a>1.16 工作集</h2><p><img src="https://img-blog.csdnimg.cn/20210221102019306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="四、文件管理"><a href="#四、文件管理" class="headerlink" title="四、文件管理"></a>四、文件管理</h1><h2 id="1-1-初识文件管理"><a href="#1-1-初识文件管理" class="headerlink" title="1.1 初识文件管理"></a>1.1 初识文件管理</h2><p><img src="https://img-blog.csdnimg.cn/20210221102430890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>文件</strong>（File）是操作系统中的一个重要概念。文件是以计算机硬盘为载体存储在计算机上的信息集合，文件可以是文本文档、图片、程序，等等。</p><p>1）数据项。数据项是文件系统中最低级的数据组织形式，可分为以下两种类型：<br>基本数据项：用于描述一个对象的某种属性的一个值，如姓名、日期或证件号等，是数据中可命名的最小逻辑数据单位，即原子数据<br>组合数据项：由多个基本数据项组成。<br>2）记录。记录是一组相关的数据项的集合，用于描述一个对象在某方面的属性，如一个考生报名记录包括考生姓名、出生日期、报考学校代号、身份证号等一系列域<br>3）文件。文件是指由创建者所定义的一组相关信息的集合，逻辑上可分为有结构文件和无结构文件两种。在有结构文件中，文件由一组相似记录组成，如报考某学校的所有考生的报考信息记录，又称记录式文件：而无结构文件则被看成是一个字符流，比如一个二进制文件或字符文件，又称流式文件.</p><p><strong>文件的属性</strong></p><p>文件有一定的属性，这根据系统的不同而有所不同，但是通常都包括如下属性。<br>①名称：文件名称唯一，以容易读取的形式保存<br>②标识符：标识文件系统内文件的唯一标签，通常为数字，它是对人不可读的一种内部名称。<br>③类型：被支持不同类型的文件系统所使用<br>④位置：指向设备和设备上文件的指针。<br>⑤大小：文件当前大小（用字节、字或块表示），也可包含文件允许的最大值。<br>⑥保护：对文件进行保护的访问控制信息<br>⑦时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息，用于保护、安全跟踪文件的使用.<br>所有文件的信息都保存在目录结构中，而目录结构也保存在外存上。文件信息当需要时再调入内存。通常，目录条目包括文件名称及其唯一标识符，而标识符定位其他属性的信息.</p><p><strong>文件的基本操作</strong></p><p>文件属于抽象数据类型。为了恰当地定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，它对文件进行创建、写、读、定位和截断。<br>①创建文件：创建文件有两个必要步骤，一是在文件系统中为文件找到空间：二是在目录中为新文件创建条目，该条目记录文件名称、在文件系统中的位置及其他可能信息<br>②写文件：为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容。对于给定文件名称，系统搜索目录以查找文件位置。系统必须为该文件维护一个写位置的指针。每当发生写操作，便更新写指针<br>③读文件：为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置。<br>同样，需要搜索目录以找到相关目录项，系统维护一个读位置的指针。每当发生读操作时，更新读指针。一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。由于读和写操作都使用同一指针，节省了空间也降低了系统复杂度。<br>④文件重定位（文件寻址）：按某条件搜索目录，将当前文件位置设为给定值，并且不会读写文件<br>⑤删除文件：先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间<br>⑥截断文件：允许文件所有属性不变，并删除文件内容，即将其长度设为0并释放其空间<br>这6个基本操作可以组合执行其他文件操作。例如，一个文件的复制，可以创建新文件、从旧文件读出并写入到新文件</p><p><strong>文件的打开与关闭</strong></p><h2 id="1-2-文件的逻辑结构"><a href="#1-2-文件的逻辑结构" class="headerlink" title="1.2 文件的逻辑结构"></a>1.2 文件的逻辑结构</h2><p><img src="https://img-blog.csdnimg.cn/20200704080830897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>按逻辑结构，文件有无结构文件和有结构文件两种类型：<br>1 无结构文件（流式文件）<br>2.有结构文件（记录式文件）<br>1）顺序文件<br>2）索引文件<br>3）索引顺序文件是顺序和索引两种组织形式的结合.<br>4）直接文件或散列文件（ Hash File）</p><h2 id="1-3-文件目录"><a href="#1-3-文件目录" class="headerlink" title="1.3 文件目录"></a>1.3 文件目录</h2><p><img src="https://img-blog.csdnimg.cn/20200704083545250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>文件控制块和索引结点</strong><br>1）文件控制块。文件控制块（FCB）是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”.FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。为了创建配一个FCB并存放在文件目录中，成为目录项</p><p><strong>FCB主要包含以下信息：</strong><br>基本信息，如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。<br>存取控制信息，如文件存取权限等<br>使用信息，如文件建立时间、修改时间等<br>2）索引结点</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><img src="https://img-blog.csdnimg.cn/20200610161755526.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610162141697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610162211853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610162700847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="4）无环图目录结构。"></p><p><img src="https://img-blog.csdnimg.cn/20200704114453333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-4-文件物理结构"><a href="#1-4-文件物理结构" class="headerlink" title="1.4 文件物理结构"></a>1.4 文件物理结构</h2><p><img src="https://img-blog.csdnimg.cn/20210221111739893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-4-1-链接分配"><a href="#1-4-1-链接分配" class="headerlink" title="1.4.1 链接分配"></a>1.4.1 链接分配</h3><p><img src="https://img-blog.csdnimg.cn/2021022111153759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-4-2-索引分配"><a href="#1-4-2-索引分配" class="headerlink" title="1.4.2 索引分配"></a>1.4.2 索引分配</h3><p><img src="https://img-blog.csdnimg.cn/20210221111647235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-5-文件存储空间管理"><a href="#1-5-文件存储空间管理" class="headerlink" title="1.5 文件存储空间管理"></a>1.5 文件存储空间管理</h2><p><img src="https://img-blog.csdnimg.cn/20200704123728867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-6-文件的基本操作"><a href="#1-6-文件的基本操作" class="headerlink" title="1.6 文件的基本操作"></a>1.6 文件的基本操作</h2><p><img src="https://img-blog.csdnimg.cn/20200704124644171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-7-文件共享"><a href="#1-7-文件共享" class="headerlink" title="1.7 文件共享"></a>1.7 文件共享</h2><p><img src="https://img-blog.csdnimg.cn/20200704125140509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-8-文件保护"><a href="#1-8-文件保护" class="headerlink" title="1.8 文件保护"></a>1.8 文件保护</h2><p><img src="https://img-blog.csdnimg.cn/20210221112629665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-9-文件系统层次结构"><a href="#1-9-文件系统层次结构" class="headerlink" title="1.9 文件系统层次结构"></a>1.9 文件系统层次结构</h2><p><img src="https://img-blog.csdnimg.cn/20200704130311622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200704130352457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610200728418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610200858608.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200610200955594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="五、磁盘管理"><a href="#五、磁盘管理" class="headerlink" title="五、磁盘管理"></a>五、磁盘管理</h1><h2 id="1-1-磁盘的结构"><a href="#1-1-磁盘的结构" class="headerlink" title="1.1 磁盘的结构"></a>1.1 磁盘的结构</h2><p><img src="https://img-blog.csdnimg.cn/20200704130854420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-2-磁盘调度算法"><a href="#1-2-磁盘调度算法" class="headerlink" title="1.2 磁盘调度算法"></a>1.2 磁盘调度算法</h2><p><img src="https://img-blog.csdnimg.cn/20200704133834864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200704133927225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200704134016916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020070413410374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200704134142131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200704134254195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200704134413468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-3-减少磁盘延迟时间的方法"><a href="#1-3-减少磁盘延迟时间的方法" class="headerlink" title="1.3 减少磁盘延迟时间的方法"></a>1.3 减少磁盘延迟时间的方法</h2><p><img src="https://img-blog.csdnimg.cn/20200704135844178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-4-磁盘的管理"><a href="#1-4-磁盘的管理" class="headerlink" title="1.4 磁盘的管理"></a>1.4 磁盘的管理</h2><p><img src="https://img-blog.csdnimg.cn/20200704142108418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200610215752183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="六、设备管理"><a href="#六、设备管理" class="headerlink" title="六、设备管理"></a>六、设备管理</h1><h2 id="输入输出（I-O）管理"><a href="#输入输出（I-O）管理" class="headerlink" title="输入输出（I/O）管理"></a>输入输出（I/O）管理</h2><h3 id="1-I-O设备的概念和分类"><a href="#1-I-O设备的概念和分类" class="headerlink" title="1. I-O设备的概念和分类"></a>1. I-O设备的概念和分类</h3><p><img src="https://img-blog.csdnimg.cn/2020070315120126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>按使用特性可分为以下类型</strong><br>1）人机交互类外部设备：用于与计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换的。<br>2）存储设备：用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。<br>3）网络通信设备：用于与远程设备通信的设备，如各种网络接口、调制解调器等。其速度介于前两类设备之间。<br>除了上面最常见的分类方法，I/O设备还可以按以下方法分类</p><p><strong>按传输速率分类</strong><br>1）低速设备：传输速率仅为每秒几个到数百个字节的一类设备，如键盘、鼠标等。<br>2）中速设备：传输速率在每秒数千个字节至数万个字节的一类设备，如行式打印机、激光打印机等<br>3）高速设备：传输速率在数百个千字节至千兆字节的一类设备，如磁带机、磁盘机、光盘机等。</p><p><strong>按信息交换的单位分类</strong><br>1）块设备：由于信息的存取总是以数据块为单位的，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高，以及可寻址，即对它可随机地读/写任一块<br>2）字符设备：用于数据输入输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且在输入输出时常采用中断驱动方式。</p><h3 id="2-I-O控制器"><a href="#2-I-O控制器" class="headerlink" title="2. I-O控制器"></a>2. I-O控制器</h3><p><img src="https://img-blog.csdnimg.cn/20200703151309306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-I-O控制方式"><a href="#3-I-O控制方式" class="headerlink" title="3. I-O控制方式"></a>3. I-O控制方式</h3><p><img src="https://img-blog.csdnimg.cn/2020070315140685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>设备管理的主要任务之一是控制设备和内存或处理机之间的数据传送。外围设备和内存之间的输入输出控制方式有四种，下面分别介绍。</p><p><strong>程序直接控制方式</strong></p><p>如图5-1（a）所示，计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在IO控制器的数据寄存器中。在程序直接控制方式中，由于CPU的高速性和I/O设备的低速性，致使CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中，造成了CPU资源的极大浪费。在该方式中，CPU之所以要不断地测试I/O设备的状态，就是因为在CPU中没有采用中断机构，使I/O设备无法向CPU报告它已完成了一个字符的输入操作。</p><p><strong>中断驱动方式</strong></p><p>中断驱动方式的思想是，允许I/O设备主动打断CPU的运行并请求服务，从而“解放”CPU，使得其向I/O控制器发送读命令后可以继续做其他有用的工作。如图5-1（b）所示，我们从I/O控制器和CPU两个角度分别来看中断驱动方式的工作过程：</p><p>从I/O控制器的角度来看，I/O控制器从CPU接收一个读命令，然后从外围设备读数据，一旦数据读入到该I/O控制器的数据寄存器，便通过控制线给CPU发出一个中断信号，表示数据已准备好，然后等待CPU请求该数据。I/O控制器收到CPU发出的取数据请求后，将数据放到数据总线上，传到CPU的寄存器中。至此，本次I/O操作完成，I/O控制器又可开始下一次I/O操作。</p><p>从CPU的角度来看，CPU发出读命令，然后保存当前运行程序的上下文（现场，包括程序计数器及处理机寄存器），转去执行其他程序。在每个指令周期的末尾，CPU检查中断。当有来自I/O控制器的中断时，CPU保存当前正在运行程序的上下文，转去执行中断处理程序处理该中断。这时，CPU从I/O控制器读一个字的数据传送到寄存器，并存入主存。接着，CPU恢复发出I/O命令的程序（或其他程序）的上下文，然后继续运行。中断驱动方式比程序直接控制方式有效，但由于数据中的每个字在存储器与I/O控制器之间的传输都必须经过CPU，这就导致了中断驱动方式仍然会消耗较多的CPU时间。</p><p><strong>DMA方式</strong></p><p>在中断驱动方式中，I/O设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度还是受限，而DMA（直接存储器存取）方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底“解放”CPU.DMA方式的特点是<br>1）基本单位是数据块<br>2）所传送的数据，是从设备直接送入内存的，或者相反。<br>3）仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。</p><p><strong>通道控制方式</strong></p><p><img src="https://img-blog.csdnimg.cn/20200611002131137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-I-O软件层次结构"><a href="#4-I-O软件层次结构" class="headerlink" title="4. I-O软件层次结构"></a>4. I-O软件层次结构</h3><p><img src="https://img-blog.csdnimg.cn/20200703151513481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5-I-O核心子系统"><a href="#5-I-O核心子系统" class="headerlink" title="5. I-O核心子系统"></a>5. I-O核心子系统</h3><p><img src="https://img-blog.csdnimg.cn/20200703151554310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>由于I/O设备种类繁多，功能和传输速率差异巨大，需要多种方法来进行设备控制。这些方法共同组成了操作系统内核的I/O子系统，它将内核的其他方面从繁重的I/O设备管理中解放出来。I/O核心子系统提供的服务主要有：IO调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等</p><h3 id="6-假脱机技术"><a href="#6-假脱机技术" class="headerlink" title="6. 假脱机技术"></a>6. 假脱机技术</h3><p><img src="https://img-blog.csdnimg.cn/20200703151714594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>为了缓和CPU的高速性与I/O设备低速性之间的矛盾而引入了脱机输入/输出技术。该技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上；或者相反。 SPOOLing的意思是外部设备同时联机操作，又称为假脱机输入输出操作，是操作系统中采用的一项将独占设备改造成共享设备的技术。</p><p><strong>输入井和输出井</strong></p><p><img src="https://img-blog.csdnimg.cn/20200611082824989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>输入缓冲区和输出缓冲区</strong></p><p>在内存中开辟的两个缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备</p><p><strong>输入进程和输出进程</strong></p><p>输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井。当CPU需要输入数据时，直接将数据从输入井读入内存。输出进程模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备</p><h3 id="7-设备的分配与回收"><a href="#7-设备的分配与回收" class="headerlink" title="7. 设备的分配与回收"></a>7. 设备的分配与回收</h3><p><img src="https://img-blog.csdnimg.cn/20200703152532663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p><p><strong>设备分配概述</strong></p><p>设备分配是指根据用户的I/O请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。从设备的特性来看，采用下述三种使用方式的设备分别称为独占设备、共享设备和虚拟设备。</p><p>1）独占式使用设备。指在申请设备时，如果设备空闲，就将其独占，不再允许其他进程申请使用，一直等到该设备被释放才允许其他进程申请使用。例如，打印机，在使用它打印时，只能独占式使用，否则在同一张纸上交替打印不同任务的内容，无法正常阅读。<br>2）分时式共享使用设备。独占式使用设备时，设备利用率很低，当设备没有独占使用的要求时，可以通过分时共享使用提高利用率。例如，对磁盘设备的I/O操作，各进程的每次I/O操作请求可以通过分时来交替进行。<br>3）以 SPOOLing方式使用外部设备。 SPOOLing（ Simultaneous Peripheral Operation On-Line)技术是在批处理操作系统时代引入的，即假脱机IO技术。这种技术用于对设备的操作，实质上就是对I/O操作进行批处理。 SPOOLing技术实质上是一种以空间换时间的技术，而我们熟悉的请求分页系统中的页面调度算法就刚好相反，是以时间换空间的技术。</p><p><strong>设备分配的数据结构</strong></p><p><strong>设备分配的策略</strong></p><p>1）设备分配原则：设备分配应根据设备特性、用户要求和系统配置情况。分配的总原则：既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。<br>2）设备分配方式：设备分配方式有静态分配和动态分配两种：<br>静态分配主要用于对独占设备的分配，它在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、控制器（如通道等）.一旦分配后，这些设备、控制器（和通道）就一直为该作业所占用，直到该作业被撤销。静态分配方式不会出现死锁，但设备的使用效率低。因此，静态分配方式并不符合分配的总原则。<br>动态分配是在进程执行过程中根据执行需要进行。当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按照事先规定的策略给进程分配所需要的设备、IO控制器，一旦用完之后，便立即释放。动态分配方式有利于提高设备的利用率，但如果分配算法使用不当，则有可能造成进程死锁。<br>3）设备分配算法：常用的动态设备分配算法有先请求先分配、优先级高者优先等。<br>对于独占设备，既可以采用动态分配方式也可以采用静态分配方式，往往采用静态分配方式，即在作业执行前，将作业所要用的这一类设备分配给它。共享设备可被多个进程所共享，一般采用动态分配方式，但在每个I/O传输的单位时间内只被一个进程所占有，通常采用先请求先分配和优先级高者优先的分配算法</p><p><strong>设备分配的安全性</strong></p><p>设备分配的安全性是指设备分配中应防止发生进程死锁。<br>1）安全分配方式：每当进程发出I/O请求后便进入阻塞状态，直到其I/O操作完成时才被唤醒。这样，一旦进程已经获得某种设备后便阻塞，不能再请求任何资源，而且在它阻塞时也不保持任何资源。优点是设备分配安全：缺点是CPU和I/O设备是串行工作的（对同一进程而言）<br>2）不安全分配方式：进程在发出I/O请求后继续运行，需要时又发出第二个、第三个I/O请求等。仅当进程所请求的设备已被另一进程占用时，才进入阻塞状态。优点是一个进程可同时操作多个设备，从而使进程推进迅速；缺点是这种设备分配有可能产生死锁。</p><p><strong>逻辑设备名到物理设备名的映射</strong></p><p>为了提高设备分配的灵活性和设备的利用率、方便实现I/O重定向，因此引入了设备独立性。设备独立性是指应用程序独立于具体使用的物理设备。<br>为了实现设备独立性，在应用程序中使用逻辑设备名来请求使用某类设备，在系统中设置张逻辑设备表（ Logical Unit Table，LUT），用于将逻辑设备名映射为物理设备名。LUT表项包括逻辑设备名、物理设备名和设备驱动程序入口地址；当进程用逻辑设备名来请求分配设备时，系统为它分配相应的物理设备，并在LUT中建立一个表项，以后进程再利用逻辑设备名请求IO操作时，系统通过查找LUT来寻找相应的物理设备和驱动程序。</p><p>在系统中可采取两种方式建立逻辑设备表<br>1）在整个系统中只设置一张LUT.这样，所有进程的设备分配情况都记录在这张表中，故不允许有相同的逻辑设备名，主要适用于单用户系统中。<br>2）为每个用户设置一张LUT.当用户登录时，系统便为该用户建立一个进程，同时也为之建立一张LUT，并将该表放入进程的PCB中。</p><h3 id="8-缓冲区管理"><a href="#8-缓冲区管理" class="headerlink" title="8. 缓冲区管理"></a>8. 缓冲区管理</h3><p><img src="https://img-blog.csdnimg.cn/20200703153108478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153304460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153345702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153438901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153706542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153803582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200703153927302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>磁盘高速缓存（ Disk Cache）</strong></p><p>操作系统中使用磁盘高速缓存技术来提高磁盘的I/O速度，对高速缓存复制的访问要比原始数据访问更为高效。例如，正在运行的进程的指令既存储在磁盘上，也存储在物理内存上，也被复制到CPU的二级和一级高速缓存中。<br>不过，磁盘高速缓存技术不同于通常意义下的介于CPU与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存在逻辑上属于磁盘，物理上则是驻留在内存中的盘块。<br>高速缓存在内存中分为两种形式：一种是在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定；另一种是把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I/O时共享。</p><p><strong>缓冲区（ Buffer）</strong><br>在设备管理子系统中，引入缓冲区的目的主要有：<br>1）缓和CPU与I/O设备间速度不匹配的矛盾。<br>2）减少对CPU的中断频率，放宽对CPU中断响应时间的限制<br>3）解决基本数据单元大小（即数据粒度）不匹配的问题。<br>4）提高CPU和I/O设备之间的并行性</p><p>其实现方法有：<br>1）采用硬件缓冲器，但由于成本太高，除一些关键部位外，一般不采用硬件缓冲器。<br>2）采用缓冲区（位于内存区域）.<br>缓冲区有一个特点，当缓冲区的数据非空的时候，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</p><p>根据系统设置缓冲器的个数，缓冲技术可以分为</p><p>1）单缓冲：在设备和处理机之间设置一个缓冲区。设备和处理机交换数据时，先把被交换<br>数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据。<br>2）双缓冲：根据单缓冲的特点，CPU在传送时间M内处于空闲状态，由此引入双缓冲。I/O设备输入数据时先装填到缓冲区1，在缓冲区1填满后才开始装填缓冲区2，与此同时处理机可<br>以从缓冲区1中取出数据放入用户进程处理，当缓冲区1中的数据处理完后，若缓冲区2已填满，则处理机又从缓冲区2中取出数据放入用户进程处理，而IO设备又可以装填缓冲区1.要注意，必须等缓冲区2充满才能让处理机从缓冲区2取出数据。双缓冲机制提高了处理机和输入设备的并行操作的程度3）循环缓冲：包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。</p><p>循环缓冲用于输入输出时，还需要有两个指针in和out对输入而言，首先要从设备接收数据到缓冲区中，in指针指向可以输入数据的第一个空缓冲区；当运行进程需要数据时，从循环缓冲区中取一个装满数据的缓冲区，并从此缓冲区中提取数据，out指针指向可以提取数据的第一个满缓冲区。输出则正好相反.</p><p>4）缓冲池：由多个系统公用的缓冲区组成，缓冲区按其使用状况可以形成三个队列：空缓冲队列、装满输入数据的缓冲队列（输入队列）和装满输出数据的缓冲队列（输出队列）.还应具有四种缓冲区：用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区及用于提取输出数据的工作缓冲区</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node-sass安装失败解决方案</title>
    <link href="/2021/07/08/node-sass%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/07/08/node-sass%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="node-sass安装失败解决方案"><a href="#node-sass安装失败解决方案" class="headerlink" title="node-sass安装失败解决方案"></a>node-sass安装失败解决方案</h1><p>在Github上看到一个用Vue写的<a href="https://github.com/is-liyiwei/vue-Chat-demo">仿造VX的聊天界面</a>，比较美观，想用在自己的项目中</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708171357360.png" alt="image-20210708171357360"></p><p>可惜<code>npm install</code>后意外发生了</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708171832501.png" alt="image-20210708171832501"></p><p>部署的时候报错<code>Module build failed: Error: Cannot find module &#39;node-sass&#39;</code></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708171504322.png" alt="image-20210708171504322"></p><p>很明显是node-sass包并没有安装成功，当我以为是外网的问题，重试使用淘宝镜像安装的时候</p><div class="hljs code-wrapper"><pre><code class="hljs shell">npm uninstall node-sass //使用淘宝镜像安装npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</code></pre></div><p>又报了其他模块无法解析的错误，很明显，还还是模块安装不完全的问题</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708172109790.png" alt="image-20210708172109790"></p><p>所以需要重新安装相关的模块</p><div class="hljs code-wrapper"><pre><code class="hljs shell">npm uninstall sass-loadernpm uninstall style-loadernpm install sass-loader@7.3.1 --save-dev　　　 //安装7.3.1版本的sassnpm install style-loader --save-dev // 安装style-loader</code></pre></div><p>发现这里又报了版本不对应的错误</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708172411081.png" alt="image-20210708172411081"></p><p>这才恍然大悟，<strong>淘宝镜像默认下载的是最新版本的包，所以需要在下载的时候指定版本</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">npm uninstall node-sass npm i node-sass@4.14.1 --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</code></pre></div><p>最终部署成功，成功解决</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210708172544043.png" alt="image-20210708172544043"></p><p><strong>总结：</strong></p><p><strong>根据报错内容，一步一步的去信息解决问题是很重要的，一次报错不可怕，能仔细观察日记解决问题才是最重要的，希望下次引以为戒</strong></p>]]></content>
    
    
    <categories>
      
      <category>Bug解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JetBrains IDE Git操作报错解决方案</title>
    <link href="/2021/06/07/JetBrains%20IDE%20Git%E6%93%8D%E4%BD%9C%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/06/07/JetBrains%20IDE%20Git%E6%93%8D%E4%BD%9C%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="JetBrains-IDE-Git报错解决方案"><a href="#JetBrains-IDE-Git报错解决方案" class="headerlink" title="JetBrains IDE Git报错解决方案"></a>JetBrains IDE Git报错解决方案</h1><p>在使用<code>IDEA、WebStorm、PyCharm</code>的时候，在设置Github的时候</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607091401404.png" alt="image-20210607091401404"></p><p>或者在使用自带的版本管理插件进行Git操作的时候</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607091600563.png" alt="image-20210607091600563"></p><p>容易出现<code>invalid authentication data. connection reset</code>或者<code>LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 </code>之类的报错，试过网上许多解决方案，都没有一个统一的解答</p><h2 id="如果Ping不通"><a href="#如果Ping不通" class="headerlink" title="如果Ping不通"></a>如果Ping不通</h2><p>博主是使用了代理工具的，开始以为是网络的问题，但是<code>ping github.com</code>也能ping通，如果有ping不通的话，这里提供一个解决方案，利用域名解析器，看看github.com域名下映射的IP地址，这里可以去 <a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a> 上查看自己的映射地址</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607092335451.png" alt="image-20210607092335451"></p><p>填入到自己的Host文件配置中</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607092424140.png" alt="image-20210607092424140"></p><p><strong>基本就能解决Ping的问题</strong></p><h2 id="invalid-authentication-data-connection-reset"><a href="#invalid-authentication-data-connection-reset" class="headerlink" title="invalid authentication data. connection reset"></a>invalid authentication data. connection reset</h2><p>这是由于使用了代理工具但是在IDE并不能有效的识别，先设置</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607092615434.png" alt="image-20210607092615434"></p><p><strong>然后就可以发现添加账号成功</strong></p><h2 id="LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443"><a href="#LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443" class="headerlink" title="LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443"></a>LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</h2><p>这时候虽然能够配置上Github账号，但是在项目进行Push到github的时候会容易报这个错误，这是因为使用了代理工具，在<code>~</code>目录下使用<code>vim .gitconfig</code>目录对Git进行配置，最为关键的是添加如下配置</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210607093139972.png" alt="image-20210607093139972"></p><p>进行如下配置后，Push成功</p><blockquote><p>不要一上来就进行这个配置，如果先配置了这个，会在设置Github的时候报错<code>invalid authentication data. connection reset</code>，先设置好Github账号后需要Push的时候再再上此配置行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Bug解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java NIO</title>
    <link href="/2021/05/13/NIO/"/>
    <url>/2021/05/13/NIO/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，<strong>可以替代标准的Java IO API</strong>。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持<strong>面向缓冲区的、基于通道的IO操作</strong>。NIO将以更加高效的方式进行文件的读写操作。</p><h1 id="二、IO与NIO的区别"><a href="#二、IO与NIO的区别" class="headerlink" title="二、IO与NIO的区别"></a>二、IO与NIO的区别</h1><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(NonBlocking IO)</td></tr><tr><td></td><td>选择器(Selectors)</td></tr></tbody></table><h2 id="面向流和缓冲区"><a href="#面向流和缓冲区" class="headerlink" title="面向流和缓冲区"></a>面向流和缓冲区</h2><p><strong>IO</strong></p><p>传统IO在传输数据时，根据输入输出的不同需要分别建立不同的链接，而且传输的数据是以流的形式在链接上进行传输的</p><p>就像自来水要通过水管将自来水厂和家连接起来一样</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109084453.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109084453.png" alt="img"></a></p><p><strong>NIO</strong></p><p>NIO在传输数据时，会在输入输出端之间建立<strong>通道</strong>，然后将数据放入到<strong>缓冲区</strong>中。缓冲区通过通道来传输数据</p><p>这里通道就像是铁路，能够连通两个地点。缓冲区就像是火车，能够真正地进行数据的传输</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222459918.png" alt="image-20210513222459918"></p><h1 id="三、通道与缓冲区"><a href="#三、通道与缓冲区" class="headerlink" title="三、通道与缓冲区"></a>三、通道与缓冲区</h1><p>Java NIO系统的核心在于：**通道(Channel)和缓冲区(Buffer)**。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理</p><p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p><h1 id="四、缓冲区-Buffer"><a href="#四、缓冲区-Buffer" class="headerlink" title="四、缓冲区(Buffer)"></a>四、缓冲区(Buffer)</h1><h2 id="1、缓冲区类型"><a href="#1、缓冲区类型" class="headerlink" title="1、缓冲区类型"></a>1、缓冲区类型</h2><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(<strong>boolean 除外</strong>) ，有以下Buffer 常用子类</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p><strong>各种类型的缓冲区中，都有一个对应类型的数组</strong>，如</p><p>ByteBuffer</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] hb;                  <span class="hljs-comment">// Non-null only for heap buffersCopy</span></code></pre></div><p>IntBuffer</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] hb;                  <span class="hljs-comment">// Non-null only for heap buffersCopy</span></code></pre></div><p><strong>他们的继承关系如下</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222534808.png" alt="image-20210513222534808"></p><h2 id="2、获取缓冲区"><a href="#2、获取缓冲区" class="headerlink" title="2、获取缓冲区"></a>2、获取缓冲区</h2><p>通过<strong>allocate方法</strong>可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法</p><p>例</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获取一个容量大小为1024字节的字节缓冲区</span>ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);</code></pre></div><h2 id="3、核心属性"><a href="#3、核心属性" class="headerlink" title="3、核心属性"></a>3、核心属性</h2><p>缓冲区的父类Buffer中有几个核心属性，如下</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mark = -<span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;</code></pre></div><ul><li>capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li>limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li>position：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li>mark：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h2 id="4、核心方法"><a href="#4、核心方法" class="headerlink" title="4、核心方法"></a>4、核心方法</h2><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222603127.png" alt="image-20210513222603127"></p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222630105.png" alt="image-20210513222630105"></p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222642585.png" alt="image-20210513222642585"></p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222657733.png" alt="image-20210513222657733"></p><h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h4><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222714944.png" alt="image-20210513222714944"></p><h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值</li></ul><h4 id="使用展示"><a href="#使用展示" class="headerlink" title="使用展示"></a>使用展示</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        System.out.println(<span class="hljs-string">&quot;放入前参数&quot;</span>);        System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());        System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());        System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());        System.out.println();        System.out.println(<span class="hljs-string">&quot;------put()------&quot;</span>);        System.out.println(<span class="hljs-string">&quot;放入3个数据&quot;</span>);        <span class="hljs-keyword">byte</span> bt = <span class="hljs-number">1</span>;        byteBuffer.put(bt);        byteBuffer.put(bt);        byteBuffer.put(bt);        System.out.println(<span class="hljs-string">&quot;放入后参数&quot;</span>);        System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());        System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());        System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());        System.out.println();        System.out.println(<span class="hljs-string">&quot;------flip()-get()------&quot;</span>);        System.out.println(<span class="hljs-string">&quot;读取一个数据&quot;</span>);        <span class="hljs-comment">// 切换模式</span>        byteBuffer.flip();        byteBuffer.get();        System.out.println(<span class="hljs-string">&quot;读取后参数&quot;</span>);        System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());        System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());        System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());        System.out.println();        System.out.println(<span class="hljs-string">&quot;------rewind()------&quot;</span>);        byteBuffer.rewind();        System.out.println(<span class="hljs-string">&quot;恢复后参数&quot;</span>);        System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());        System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());        System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());        System.out.println();        System.out.println(<span class="hljs-string">&quot;------clear()------&quot;</span>);        <span class="hljs-comment">// 清空缓冲区，这里只是恢复了各个属性的值，但是缓冲区里的数据依然存在</span>        <span class="hljs-comment">// 但是下次写入的时候会覆盖缓冲区中之前的数据</span>        byteBuffer.clear();        System.out.println(<span class="hljs-string">&quot;清空后参数&quot;</span>);        System.out.println(<span class="hljs-string">&quot;position &quot;</span> + byteBuffer.position());        System.out.println(<span class="hljs-string">&quot;limit &quot;</span> + byteBuffer.limit());        System.out.println(<span class="hljs-string">&quot;capacity &quot;</span> + byteBuffer.capacity());        System.out.println();        System.out.println(<span class="hljs-string">&quot;清空后获得数据&quot;</span>);        System.out.println(byteBuffer.get());    &#125;&#125;</code></pre></div><p>打印结果</p><div class="hljs code-wrapper"><pre><code class="hljs java">放入前参数position <span class="hljs-number">0</span>limit <span class="hljs-number">1024</span>capacity <span class="hljs-number">1024</span>------put()------放入<span class="hljs-number">3</span>个数据放入后参数position <span class="hljs-number">3</span>limit <span class="hljs-number">1024</span>capacity <span class="hljs-number">1024</span>------flip()-get()------读取一个数据读取后参数position <span class="hljs-number">1</span>limit <span class="hljs-number">3</span>capacity <span class="hljs-number">1024</span>------rewind()------恢复后参数position <span class="hljs-number">0</span>limit <span class="hljs-number">3</span>capacity <span class="hljs-number">1024</span>------clear()------清空后参数position <span class="hljs-number">0</span>limit <span class="hljs-number">1024</span>capacity <span class="hljs-number">1024</span>清空后获得数据<span class="hljs-number">1</span></code></pre></div><h2 id="5、非直接缓冲区和直接缓冲区"><a href="#5、非直接缓冲区和直接缓冲区" class="headerlink" title="5、非直接缓冲区和直接缓冲区"></a>5、非直接缓冲区和直接缓冲区</h2><h4 id="非直接缓冲区"><a href="#非直接缓冲区" class="headerlink" title="非直接缓冲区"></a>非直接缓冲区</h4><p>通过<strong>allocate()<strong>方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM</strong>堆内存</strong>之中的。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-comment">// 在堆内存中开辟空间</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeapByteBuffer(capacity, capacity);&#125;HeapByteBuffer(<span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> lim) &#123;        <span class="hljs-comment">// package-private</span>    <span class="hljs-comment">// new byte[cap] 创建数组，在堆内存中开辟空间</span>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, lim, cap, <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[cap], <span class="hljs-number">0</span>);    <span class="hljs-comment">/*</span><span class="hljs-comment">    hb = new byte[cap];</span><span class="hljs-comment">    offset = 0;</span><span class="hljs-comment">    */</span>&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222737771.png" alt="image-20210513222737771"></p><p>通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。<strong>都需要经过JVM和操作系统</strong>，数据在两个地址空间中传输时，会<strong>copy</strong>一份保存在对方的空间中。所以费直接缓冲区的读取效率较低</p><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p><strong>只有ByteBuffer可以获得直接缓冲区</strong>，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在<strong>物理内存</strong>之中的。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);&#125;DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;                   <span class="hljs-comment">// package-private</span>    ...    <span class="hljs-comment">// 申请物理内存</span>    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();    ...&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222756664.png" alt="image-20210513222756664"></p><p>直接缓冲区通过在操作系统和JVM之间创建<strong>物理内存映射文件</strong>加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中</p><h1 id="五、通道-Channel"><a href="#五、通道-Channel" class="headerlink" title="五、通道(Channel)"></a>五、通道(Channel)</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Channel由java.nio.channels 包定义的。Channel 表示<strong>IO 源与目标打开的连接</strong>。Channel 类似于传统的“流”。只不过<strong>Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互</strong></p><h2 id="2、图解"><a href="#2、图解" class="headerlink" title="2、图解"></a>2、图解</h2><p>应用程序进行读写操作调用函数时，<strong>底层调用的操作系统提供给用户的读写API</strong>，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，<strong>所有读写请求的指令都有CPU去执行</strong>，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222809288.png" alt="image-20210513222809288"></p><p>后来，<strong>DMA</strong>(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，<strong>DMA会向CPU请求，让DMA去处理这些IO操作</strong>，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。<strong>当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222817234.png" alt="image-20210513222817234"></p><p>于是便有了<strong>Channel(通道)<strong>，Channel相当于一个</strong>专门用于IO操作的独立处理器</strong>，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222824224.png" alt="image-20210513222824224"></p><h2 id="3、Java-Channel"><a href="#3、Java-Channel" class="headerlink" title="3、Java Channel"></a>3、Java Channel</h2><h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222909219.png" alt="image-20210513222909219"></p><ul><li>本地文件IO<ul><li>FileChannel</li></ul></li><li>网络IO<ul><li>SocketChanel、ServerSocketChannel：用于TCP传输</li><li>DatagramChannel：用于UDP传输</li></ul></li></ul><h4 id="获得通道的方法"><a href="#获得通道的方法" class="headerlink" title="获得通道的方法"></a>获得通道的方法</h4><p>获取通道的一种方式是对支持通道的<strong>对象调用getChannel() 方法</strong>。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 本地通道</span>      FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;&quot;</span>);      FileChannel channel1 = fileInputStream.getChannel();      FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;&quot;</span>);      FileChannel channel2 = fileOutputStream.getChannel();      <span class="hljs-comment">// 网络通道</span>      Socket socket = <span class="hljs-keyword">new</span> Socket();      SocketChannel channel3 = socket.getChannel();      ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();      ServerSocketChannel channel4 = serverSocket.getChannel();      DatagramSocket datagramSocket = <span class="hljs-keyword">new</span> DatagramSocket();      DatagramChannel channel5 = datagramSocket.getChannel();      <span class="hljs-comment">// 最后要关闭通道</span>   &#125;&#125;</code></pre></div><p><strong>也可以通过通道的静态方法open()来获取</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   FileChannel open = FileChannel.open(Paths.get(<span class="hljs-string">&quot;&quot;</span>));   SocketChannel open1 = SocketChannel.open();   ...&#125;</code></pre></div><p><strong>同时可以利用Files工具类的newByteChannel()方法来获取</strong></p><h4 id="getChannel-非直接缓冲区"><a href="#getChannel-非直接缓冲区" class="headerlink" title="getChannel()+非直接缓冲区"></a>getChannel()+非直接缓冲区</h4><ul><li>getChannel()获得通道</li><li>allocate()获得<strong>非直接缓冲区</strong></li></ul><p>通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      FileInputStream is = <span class="hljs-keyword">null</span>;      FileOutputStream os = <span class="hljs-keyword">null</span>;      <span class="hljs-comment">// 获得通道</span>      FileChannel inChannel = <span class="hljs-keyword">null</span>;      FileChannel outChannel = <span class="hljs-keyword">null</span>;      <span class="hljs-comment">// 利用 try-catch-finally 保证关闭</span>      <span class="hljs-keyword">try</span> &#123;         is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;</span>);         os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\2.jpg&quot;</span>);         <span class="hljs-comment">// 获得通道</span>         inChannel = is.getChannel();         outChannel = os.getChannel();         <span class="hljs-comment">// 获得缓冲区，用于在通道中传输数据</span>         ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);         <span class="hljs-comment">// 循环将字节数据放入到buffer中，然后写入磁盘中</span>         <span class="hljs-keyword">while</span> (inChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 切换模式</span>            byteBuffer.flip();            outChannel.write(byteBuffer);            byteBuffer.clear();         &#125;      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;         e.printStackTrace();      &#125; <span class="hljs-keyword">finally</span> &#123;         <span class="hljs-keyword">if</span> (inChannel != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               inChannel.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-keyword">if</span> (outChannel != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               outChannel.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               is.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-keyword">if</span> (os != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               os.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;      &#125;   &#125;&#125;</code></pre></div><p><strong>图片读取后，被写入到了指定位置</strong><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222934130.png" alt="image-20210513222934130"></p><h4 id="open-直接缓冲区"><a href="#open-直接缓冲区" class="headerlink" title="open()+直接缓冲区"></a>open()+直接缓冲区</h4><ul><li>通过open获得通道</li><li>通过FileChannel.map()获取直接缓冲区</li></ul><p>使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 通过open()方法来获得通道</span>      FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;</span>), StandardOpenOption.READ);      <span class="hljs-comment">// outChannel需要为 READ WRITE CREATE模式</span>      <span class="hljs-comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span>      <span class="hljs-comment">// CREATE是因为要创建新的文件</span>      FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\3.jpg&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);      <span class="hljs-comment">// 获得直接缓冲区</span>      MappedByteBuffer inMapBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, inChannel.size());      MappedByteBuffer outMapBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, inChannel.size());      <span class="hljs-comment">// 字节数组</span>      <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inMapBuf.limit()];      <span class="hljs-comment">// 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输</span>      inMapBuf.get(bytes);      outMapBuf.put(bytes);      <span class="hljs-comment">// 关闭缓冲区，这里没有用try-catch-finally</span>      inChannel.close();      outChannel.close();   &#125;&#125;</code></pre></div><p><strong>运行结果，图片被创建</strong><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513222959909.png" alt="image-20210513222959909"></p><h4 id="通道间直接传输"><a href="#通道间直接传输" class="headerlink" title="通道间直接传输"></a>通道间直接传输</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelToChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   <span class="hljs-keyword">long</span> start = System.currentTimeMillis();   <span class="hljs-comment">// 通过open()方法来获得通道</span>   FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.mp4&quot;</span>), StandardOpenOption.READ);   <span class="hljs-comment">// outChannel需要为 READ WRITE CREATE模式</span>   <span class="hljs-comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span>   <span class="hljs-comment">// CREATE是因为要创建新的文件</span>   FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\4.mp4&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);   <span class="hljs-comment">// 通道间直接传输</span>   inChannel.transferTo(<span class="hljs-number">0</span>, inChannel.size(), outChannel);   <span class="hljs-comment">// 对应的还有transferFrom</span>   <span class="hljs-comment">// outChannel.transferFrom(inChannel, 0, inChannel.size());</span>   inChannel.close();   outChannel.close();&#125;</code></pre></div><h4 id="直接缓冲区VS非直接缓冲区"><a href="#直接缓冲区VS非直接缓冲区" class="headerlink" title="直接缓冲区VS非直接缓冲区"></a>直接缓冲区VS非直接缓冲区</h4><p><strong>效率</strong></p><p>读取一个MP4文件，通过二者花费时间的多少来判定执行的速度</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// getChannel() + 非直接缓冲区耗时</span><span class="hljs-number">708</span><span class="hljs-comment">// open() + 直接缓冲区耗时</span><span class="hljs-number">115</span><span class="hljs-comment">// channel transferTo channel耗时</span><span class="hljs-number">47</span></code></pre></div><p><strong>内存占用</strong></p><p>直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得计算机运行速度变慢</p><h2 id="4、分散和聚集"><a href="#4、分散和聚集" class="headerlink" title="4、分散和聚集"></a>4、分散和聚集</h2><h4 id="分散读取"><a href="#分散读取" class="headerlink" title="分散读取"></a>分散读取</h4><p>分散读取（Scattering Reads）是指<strong>从Channel 中读取的数据“分散”到多个Buffer 中</strong></p><p><strong>注意</strong>：按照缓冲区的<strong>顺序</strong>，从Channel 中读取的数据依次将 Buffer 填满</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223014213.png" alt="image-20210513223014213"></p><h4 id="聚集写入"><a href="#聚集写入" class="headerlink" title="聚集写入"></a>聚集写入</h4><p>聚集写入（Gathering Writes）是指将<strong>多个Buffer 中的数据“聚集”到Channel</strong></p><p>按照缓冲区的<strong>顺序</strong>，写入position 和limit 之间的数据到Channel </p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223022650.png" alt="image-20210513223022650"></p><p><strong>代码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划.txt&quot;</span>);      FileOutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划2.txt&quot;</span>);      FileChannel inChannel = is.getChannel();      FileChannel outChannel = os.getChannel();      <span class="hljs-comment">// 获得多个缓冲区，并且放入到缓冲区数组中</span>      ByteBuffer byteBuffer1 = ByteBuffer.allocate(<span class="hljs-number">50</span>);      ByteBuffer byteBuffer2 = ByteBuffer.allocate(<span class="hljs-number">1024</span>);      ByteBuffer[] byteBuffers = &#123;byteBuffer1, byteBuffer2&#125;;      <span class="hljs-comment">// 分散读取</span>      inChannel.read(byteBuffers);      byteBuffer1.flip();      byteBuffer2.flip();      <span class="hljs-comment">//打印结果</span>      System.out.println(<span class="hljs-keyword">new</span> String(byteBuffers[<span class="hljs-number">0</span>].array(),<span class="hljs-number">0</span>,byteBuffers[<span class="hljs-number">0</span>].limit()));      System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);      System.out.println(<span class="hljs-keyword">new</span> String(byteBuffers[<span class="hljs-number">1</span>].array(),<span class="hljs-number">0</span>,byteBuffers[<span class="hljs-number">1</span>].limit()));      <span class="hljs-comment">// 聚集写入</span>      outChannel.write(byteBuffers);   &#125;&#125;</code></pre></div><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223043503.png" alt="image-20210513223043503"></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223052049.png" alt="image-20210513223052049"></p><h1 id="六、非阻塞式网络通信"><a href="#六、非阻塞式网络通信" class="headerlink" title="六、非阻塞式网络通信"></a>六、非阻塞式网络通信</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>双11买的快递到了，快递小哥给你打电话说马上到，麻烦在门口等一下，方便签收快递</p><ul><li>若为<strong>阻塞式</strong>的，你到了小区门口以后，快递小哥还没到的期间，你什么事儿也做不了</li><li>若为<strong>非阻塞式</strong>的，快递小哥将快递放到门卫处，门卫给你发消息说快递到了，麻烦去取一下。当快递还没到的时候你可以做你自己的事儿</li></ul><h4 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h4><p>传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，<strong>该线程被阻塞</strong>，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p><p>因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以<strong>服务器端必须为每个客户端都提供一个独立的线程进行处理</strong>，当服务器端需要处理大量客户端时，<strong>性能急剧下降</strong></p><p>也就是说，服务器在等待IO准备就绪的期间，<strong>线程处于阻塞状态</strong>，若为单线程，等待期间CPU未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待IO准备就绪时，CPU可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223107153.png" alt="image-20210513223107153"></p><h4 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h4><p>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，<strong>若没有数据可用时，该线程可以进行其他任务</strong>。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以<strong>单独的线程可以管理多个输入和输出通道</strong></p><p>因此，NIO 可以让服务器端<strong>使用一个或有限几个线程来同时处理连接到服务器端的所有客户端</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223114797.png" alt="image-20210513223114797"></p><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><h4 id="阻塞式网络通信演示"><a href="#阻塞式网络通信演示" class="headerlink" title="阻塞式网络通信演示"></a>阻塞式网络通信演示</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 一、使用 NIO 完成网络通信的三个核心：</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 1. 通道（Channel）：负责连接</span><span class="hljs-comment"> *         </span><span class="hljs-comment"> *        java.nio.channels.Channel 接口：</span><span class="hljs-comment"> *             |--SelectableChannel</span><span class="hljs-comment"> *                 |--SocketChannel</span><span class="hljs-comment"> *                 |--ServerSocketChannel</span><span class="hljs-comment"> *                 |--DatagramChannel</span><span class="hljs-comment"> * </span><span class="hljs-comment"> *                 |--Pipe.SinkChannel</span><span class="hljs-comment"> *                 |--Pipe.SourceChannel</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 2. 缓冲区（Buffer）：负责数据的存取</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 3. 选择器（Selector）：是 SelectableChannel 的多路复用器。用于监控 SelectableChannel 的 IO 状况</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBlockingNIO</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-keyword">try</span> &#123;            server();         &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();         &#125;      &#125;);      Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-keyword">try</span> &#123;            client();         &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();         &#125;      &#125;);      thread1.start();      thread2.start();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 创建客户端通道</span>      SocketChannel socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">2022</span>));      <span class="hljs-comment">// 读取信息</span>      FileChannel fileChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\nio\\day3\\1.jpg&quot;</span>), StandardOpenOption.READ);      <span class="hljs-comment">// 创建缓冲区</span>      ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);      <span class="hljs-comment">// 写入数据</span>      <span class="hljs-keyword">while</span> (fileChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">//切换为读模式</span>         byteBuffer.flip();         socketChannel.write(byteBuffer);         byteBuffer.clear();      &#125;      fileChannel.close();      socketChannel.close();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">// 创建服务端通道</span>      ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();      FileChannel fileChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;F:\\JDKLearning\\src\\main\\nio\\day3\\2.jpg&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);      <span class="hljs-comment">// 绑定链接</span>      serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">2022</span>));      <span class="hljs-comment">// 获取客户端的通道</span>      SocketChannel socketChannel = serverSocketChannel.accept();      <span class="hljs-comment">// 创建缓冲区</span>      ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);      <span class="hljs-keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;         byteBuffer.flip();         fileChannel.write(byteBuffer);         byteBuffer.clear();      &#125;      socketChannel.close();      fileChannel.close();      serverSocketChannel.close();   &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBlockingNIO2</span> </span>&#123;    <span class="hljs-comment">//客户端</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        SocketChannel sChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9898</span>));        FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;1.jpg&quot;</span>), StandardOpenOption.READ);        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-keyword">while</span>(inChannel.read(buf) != -<span class="hljs-number">1</span>)&#123;            buf.flip();            sChannel.write(buf);            buf.clear();        &#125;        sChannel.shutdownOutput();        <span class="hljs-comment">//接收服务端的反馈</span>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>((len = sChannel.read(buf)) != -<span class="hljs-number">1</span>)&#123;            buf.flip();            System.out.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, len));            buf.clear();        &#125;        inChannel.close();        sChannel.close();    &#125;    <span class="hljs-comment">//服务端</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        ServerSocketChannel ssChannel = ServerSocketChannel.open();        FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;2.jpg&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);        ssChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9898</span>));        SocketChannel sChannel = ssChannel.accept();        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-keyword">while</span>(sChannel.read(buf) != -<span class="hljs-number">1</span>)&#123;            buf.flip();            <span class="hljs-comment">//保存到本地</span>            outChannel.write(buf);            buf.clear();        &#125;        <span class="hljs-comment">//发送反馈给客户端</span>        buf.put(<span class="hljs-string">&quot;服务端接收数据成功&quot;</span>.getBytes());        buf.flip();        sChannel.write(buf);        sChannel.close();        outChannel.close();        ssChannel.close();    &#125;&#125;</code></pre></div><h4 id="非阻塞式网络通信演示"><a href="#非阻塞式网络通信演示" class="headerlink" title="非阻塞式网络通信演示"></a>非阻塞式网络通信演示</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNonBlockingNIO2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;                server();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;);        Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;                client();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;);        thread1.start();        thread2.start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        SocketChannel socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">2020</span>));        <span class="hljs-comment">// 设置为非阻塞模式</span>        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;            String str = scanner.next();            byteBuffer.put(str.getBytes());            byteBuffer.flip();            socketChannel.write(byteBuffer);            byteBuffer.clear();        &#125;        byteBuffer.clear();        socketChannel.close();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//获取通道</span>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        <span class="hljs-comment">//切换为非阻塞</span>        serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//绑定链接</span>        serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">2020</span>));        <span class="hljs-comment">// 获得选择器</span>        Selector selector = Selector.open();        <span class="hljs-comment">// 将通道注册到选择器中，设定为接收操作</span>        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        <span class="hljs-comment">// 轮训接受</span>        <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();            <span class="hljs-comment">// 获得事件的key</span>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                <span class="hljs-comment">//获取准备就绪的事件</span>                SelectionKey key = iterator.next();                <span class="hljs-comment">//判断具体是什么事件准备就绪</span>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;                    <span class="hljs-comment">//若接受就绪，则获取客户端连接</span>                    SocketChannel socketChannel = serverSocketChannel.accept();                    socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);                    <span class="hljs-comment">//将该通道注册到选择器上</span>                    socketChannel.register(selector, SelectionKey.OP_READ);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;                    <span class="hljs-comment">// 从选择器中获取读就绪通道</span>                    SocketChannel socketChannel = (SocketChannel) key.channel();                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);                    <span class="hljs-keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;                        <span class="hljs-keyword">int</span> len = byteBuffer.limit();                        byteBuffer.flip();                        System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array(), <span class="hljs-number">0</span>, len));                        byteBuffer.clear();                    &#125;                    socketChannel.close();                &#125;                <span class="hljs-comment">//取消选择键</span>                iterator.remove();            &#125;        &#125;        serverSocketChannel.close();    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//演示DatagramChannel</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNonBlockingNIO2</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        DatagramChannel dc = DatagramChannel.open();        dc.configureBlocking(<span class="hljs-keyword">false</span>);        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span>(scan.hasNext())&#123;            String str = scan.next();            buf.put((<span class="hljs-keyword">new</span> Date().toString() + <span class="hljs-string">&quot;:\n&quot;</span> + str).getBytes());            buf.flip();            dc.send(buf, <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9898</span>));            buf.clear();        &#125;        dc.close();    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        DatagramChannel dc = DatagramChannel.open();        dc.configureBlocking(<span class="hljs-keyword">false</span>);        dc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9898</span>));        Selector selector = Selector.open();        dc.register(selector, SelectionKey.OP_READ);        <span class="hljs-keyword">while</span>(selector.select() &gt; <span class="hljs-number">0</span>)&#123;            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();            <span class="hljs-keyword">while</span>(it.hasNext())&#123;                SelectionKey sk = it.next();                <span class="hljs-keyword">if</span>(sk.isReadable())&#123;                    ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);                    dc.receive(buf);                    buf.flip();                    System.out.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, buf.limit()));                    buf.clear();                &#125;            &#125;            it.remove();        &#125;    &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPipe</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        <span class="hljs-comment">//1. 获取管道</span>        Pipe pipe = Pipe.open();        <span class="hljs-comment">//2. 将缓冲区中的数据写入管道</span>        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        Pipe.SinkChannel sinkChannel = pipe.sink();        buf.put(<span class="hljs-string">&quot;通过单向管道发送数据&quot;</span>.getBytes());        buf.flip();        sinkChannel.write(buf);        <span class="hljs-comment">//3. 读取缓冲区中的数据</span>        Pipe.SourceChannel sourceChannel = pipe.source();        buf.flip();        <span class="hljs-keyword">int</span> len = sourceChannel.read(buf);        System.out.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, len));        sourceChannel.close();        sinkChannel.close();    &#125;&#125;</code></pre></div><h5 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h5><p>选择器（Selector）是<strong>SelectableChannle</strong> 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。<strong>Selector 是非阻塞IO 的核心</strong></p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223137934.png" alt="image-20210513223137934"></p><p><strong>选择器的创建</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个选择器</span>Selector selector = Selector.open();</code></pre></div><p><strong>绑定选择器</strong></p><p>通过调用通道的register方法可以绑定选择器，register方法有两个参数</p><ul><li><p>Selector：即绑定哪个选择器</p></li><li><p>ops：监听事件类型。ops有4个值可以选择，为<strong>SelectionKey</strong>的静态属性</p><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210513223148530.png" alt="image-20210513223148530"></p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 让选择器监听一种状态</span>myChannel.register(selector, SelectionKey.OP_READ);<span class="hljs-comment">// 让选择器监听多种状态</span>myChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);</code></pre></div><p><strong>SelectionKey</strong></p><p><strong>表示SelectableChannel 和Selector 之间的注册关系</strong>。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程</title>
    <link href="/2021/05/05/JUC/"/>
    <url>/2021/05/05/JUC/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><blockquote><p>本文是在B站学习并发编程时候所做的笔记，对应<a href="https://www.bilibili.com/video/BV16J411h7Rd">视频链接</a>，和JVM是同一个老师，讲的十分通透，推荐观看</p></blockquote><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。 </li><li>一个线程就是一<strong>个指令流</strong>，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集进程拥有共享的资源，如内存空间等，供其内部的线程共享 <ul><li>进程间通信较为复杂，<strong>同一台计算机的进程通信称为 IPC</strong>（Inter-process communication） </li><li>不同计算机之间的<strong>进程通信，需要通过网络，并遵守共同的协议</strong>，例如 HTTP </li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量线程更轻量，<strong>线程上下文切换成本一般上要比进程上下文切换低</strong></li></ul><h4 id="进程和线程的切换"><a href="#进程和线程的切换" class="headerlink" title="进程和线程的切换"></a>进程和线程的切换</h4><p><strong>上下文切换</strong></p><p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态</strong>包括以下内容：</p><ul><li>通用目的寄存器</li><li>浮点寄存器</li><li>程序计数器</li><li>用户栈</li><li>状态寄存器</li><li>内核栈</li><li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li></ul><p><strong>进程切换和线程切换的主要区别</strong></p><p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p><p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p><p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p><p><strong>为什么TLB能加快访问速度</strong></p><p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p><h2 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h2><p><strong>并发是一个CPU在不同的时间去不同线程中执行指令</strong></p><p><strong>并行是多个CPU同时处理不同的线程</strong></p><p>引用 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力 </li><li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li></ul><h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><h4 id="应用之异步调用（案例1）"><a href="#应用之异步调用（案例1）" class="headerlink" title="应用之异步调用（案例1）"></a>应用之异步调用（案例1）</h4><p>以调用方角度来讲，如果</p><ul><li><strong>需要等待结果返回，才能继续运行就是同步</strong> </li><li><strong>不需要等待结果返回，就能继续运行就是异步</strong></li></ul><ol><li>设计<br>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</li><li>结论 </li></ol><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li><li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><p>结论 </p><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 </li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 <ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 </li></ul></li><li>IO 操作不占用 cpu，只是我们<strong>一般拷贝文件使用的是【阻塞 IO】</strong>，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，<strong>没能充分利用线程</strong>。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li></ol><h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="1、创建一个线程（非主线程）"><a href="#1、创建一个线程（非主线程）" class="headerlink" title="1、创建一个线程（非主线程）"></a>1、创建一个线程（非主线程）</h2><h3 id="方法一：通过继承dead创建线程"><a href="#方法一：通过继承dead创建线程" class="headerlink" title="方法一：通过继承dead创建线程"></a>方法一：通过继承dead创建线程</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread myThread = <span class="hljs-keyword">new</span> MyThread();        <span class="hljs-comment">// 启动线程</span>        myThread.start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;my thread running...&quot;</span>);    &#125;&#125;</code></pre></div><p>使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p><h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建线程任务</span>        Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>);            &#125;        &#125;;        <span class="hljs-comment">//将Runnable对象传给Thread</span>        Thread t = <span class="hljs-keyword">new</span> Thread(r);        <span class="hljs-comment">//启动线程</span>        t.start();    &#125;&#125;</code></pre></div><p>或者</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread2</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;         System.out.println(<span class="hljs-string">&quot;my runnable running...&quot;</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      MyRunnable myRunnable = <span class="hljs-keyword">new</span> MyRunnable();      Thread thread = <span class="hljs-keyword">new</span> Thread(myRunnable);      thread.start();   &#125;&#125;</code></pre></div><p>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</p><h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p><p>所以方法二中的代码可以被简化为</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建线程任务</span>        Runnable r = () -&gt; &#123;            <span class="hljs-comment">//直接写方法体即可</span>            System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>);            System.out.println(<span class="hljs-string">&quot;Hello Thread&quot;</span>);        &#125;;        <span class="hljs-comment">//将Runnable对象传给Thread</span>        Thread t = <span class="hljs-keyword">new</span> Thread(r);        <span class="hljs-comment">//启动线程</span>        t.start();    &#125;&#125;</code></pre></div><p>可以再Runnable上使用Alt+Enter(option+Enter)</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png" alt="img"></a></p><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起</li><li>方法2 是把线程和任务分开了 </li><li>用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        <span class="hljs-comment">//需要传入一个Callable对象</span>        FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">&quot;线程执行!&quot;</span>);                Thread.sleep(<span class="hljs-number">1000</span>);                <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;            &#125;        &#125;);        Thread r1 = <span class="hljs-keyword">new</span> Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);        r1.start();        <span class="hljs-comment">//获取线程中方法执行后的返回结果</span>        System.out.println(task.get());    &#125;&#125;</code></pre></div><p>或</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseFutureTask</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;      FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyCall());      Thread thread = <span class="hljs-keyword">new</span> Thread(futureTask);      thread.start();      <span class="hljs-comment">// 获得线程运行后的返回值</span>      System.out.println(futureTask.get());   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;   &#125;&#125;</code></pre></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。<strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p><h2 id="2、原理之线程运行"><a href="#2、原理之线程运行" class="headerlink" title="2、原理之线程运行"></a>2、原理之线程运行</h2><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p><ul><li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li><li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong>，栈帧里包含<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法返回地址</strong>、<strong>运行时常量池引用</strong>和<strong>锁记录</strong></li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能 </li></ul><h2 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h2><h3 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h3><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p><h3 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h4><ol><li><p>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p></li><li><p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<span class="hljs-comment">//休眠一分钟</span>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);</code></pre></div></li></ol><h4 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h4><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程 </li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 </p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">//设置为优先级最高 </span></code></pre></div></li></ul><h3 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h3><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p><div class="hljs code-wrapper"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread();<span class="hljs-comment">//等待thread线程执行结束</span>thread.join();<span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span>thread.join(<span class="hljs-number">1000</span>);</code></pre></div><h3 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。 </li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//用于查看打断标记，返回值被boolean类型</span>t1.isInterrupted();</code></pre></div><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;        <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre></div><h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png" alt="img"></a></p><p><strong>代码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();        monitor.start();        Thread.sleep(<span class="hljs-number">3500</span>);        monitor.stop();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;    Thread monitor;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 启动监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//开始不停的监控</span>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-comment">//判断当前线程是否被打断了</span>                    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);                        <span class="hljs-comment">//终止线程执行</span>                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//线程休眠</span>                        Thread.sleep(<span class="hljs-number">1000</span>);                        System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                        <span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span>                        Thread.currentThread().interrupt();                    &#125;                &#125;            &#125;        &#125;;        monitor.start();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *     用于停止监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//打断线程</span>        monitor.interrupt();    &#125;&#125;</code></pre></div><h3 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h3><ul><li>stop方法 停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）</li><li>suspend（暂停线程）/resume（恢复线程）方法</li></ul><h3 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h3><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将线程设置为守护线程, 默认为false</span>monitor.setDaemon(<span class="hljs-keyword">true</span>);</code></pre></div><p><strong>守护线程的应用</strong></p><ul><li>垃圾回收器线程就是一种守护线程 </li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul><h2 id="4、线程的状态"><a href="#4、线程的状态" class="headerlink" title="4、线程的状态"></a>4、线程的状态</h2><h3 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h3><p>这是从 <strong>操作系统</strong> 层面来描述的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png" alt="img"></a></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 </li><li>【运行状态】指获取了 CPU 时间片运行中的状态 <ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 </li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 </li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们 </li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h3 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png" alt="img"></a></p><ul><li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行） </li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。 </li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul><h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="1、共享带来的问题"><a href="#1、共享带来的问题" class="headerlink" title="1、共享带来的问题"></a>1、共享带来的问题</h2><h3 id="1-临界区-Critical-Section"><a href="#1-临界区-Critical-Section" class="headerlink" title="(1)临界区 Critical Section"></a>(1)临界区 Critical Section</h3><ul><li><p>一个程序运行多个线程本身是没有问题的</p></li><li><p>问题出在多个线程访问<strong>共享资源</strong></p></li><li><p><strong>多个线程读共享资源</strong>其实也没有问题 </p></li><li><p>在<strong>多个线程对共享资源读写操作</strong>时发生指令交错，就会出现问题 </p></li><li><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;       counter++; &#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;     counter--; &#125;</code></pre></div><h3 id="2-竞态条件-Race-Condition"><a href="#2-竞态条件-Race-Condition" class="headerlink" title="(2)竞态条件 Race Condition"></a><strong>(2)竞态条件 Race Condition</strong></h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="2、synchronized-解决方案"><a href="#2、synchronized-解决方案" class="headerlink" title="2、synchronized 解决方案"></a>2、synchronized 解决方案</h2><h3 id="1-解决手段"><a href="#1-解决手段" class="headerlink" title="(1)解决手段"></a>(1)解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock </li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h3 id="2-synchronized语法"><a href="#2-synchronized语法" class="headerlink" title="(2)synchronized语法"></a>(2)synchronized语法</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;    <span class="hljs-comment">//临界区</span>&#125;</code></pre></div><p>例：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//创建一个公共对象，作为对象锁的对象</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                    <span class="hljs-keyword">synchronized</span> (room) &#123;             counter++;                        &#125;               &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                     <span class="hljs-keyword">synchronized</span> (room) &#123;                        counter--;                      &#125;            &#125;     &#125;, <span class="hljs-string">&quot;t2&quot;</span>);    t1.start();        t2.start();     t1.join();       t2.join();        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter); &#125;</code></pre></div><h3 id="3-synchronized加在方法上"><a href="#3-synchronized加在方法上" class="headerlink" title="(3)synchronized加在方法上"></a>(3)synchronized加在方法上</h3><ul><li><p>加在<strong>成员方法</strong>上</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;    <span class="hljs-comment">//在方法上加上synchronized关键字</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">//等价于</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;        &#125;    &#125;&#125;</code></pre></div></li><li><p>加在<strong>静态方法</strong>上</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-comment">//在静态方法上加上synchronized关键字</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">//等价于</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span>(Demo.class) &#123;        &#125;    &#125;&#125;</code></pre></div></li></ul><h2 id="3、变量的线程安全分析"><a href="#3、变量的线程安全分析" class="headerlink" title="3、变量的线程安全分析"></a>3、变量的线程安全分析</h2><h4 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h4><ul><li>如果它们<strong>没有共享，则线程安全</strong></li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果<strong>只有读</strong>操作，则线程安全 </li><li>如果<strong>有读写</strong>操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h4 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h4><ul><li><p>局部变量是<strong>线程安全</strong>的</p></li><li><p>但<strong>局部变量引用的对象则未必</strong> （要看该对象是否被共享且被执行了读写操作）</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li><li><p><strong>局部变量是线程安全</strong>的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;  i++;&#125;</code></pre></div></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png" alt="img"></a></p><ul><li><p>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span> </span>&#123;    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            method2();            method3();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;        list.add(<span class="hljs-string">&quot;1&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;        list.remove(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png" alt="img"></a></p><ul><li><p>如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> </span>&#123;  <span class="hljs-comment">//final保证子类不对其有影响，保障线性安全</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-comment">//改为局部变量</span>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            method2(list);            method3(list);        &#125;    &#125;<span class="hljs-comment">//设为private为了保护有子类时能复写方法则不安全</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;        list.add(<span class="hljs-string">&quot;1&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;        System.out.println(<span class="hljs-number">1</span>);        list.remove(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre></div></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png" alt="img"></a></p><p>从以上例子可以看出，使用<strong>private或者final</strong>提供<strong>安全</strong>的意义所在</p><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuﬀer </li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p><ul><li>它们的每个方法是原子的（都被加上了synchronized）</li><li>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png" alt="img"></a></p><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 </p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;       <span class="hljs-comment">//安全</span>       String S1  = <span class="hljs-string">&quot;...&quot;</span>;       <span class="hljs-comment">//安全</span>       <span class="hljs-keyword">final</span> String S2  = <span class="hljs-string">&quot;...&quot;</span>;       <span class="hljs-comment">//不安全</span>       Date D1 = <span class="hljs-keyword">new</span> Date();       <span class="hljs-comment">//不安全，因为Date不是String，内部属性会被修改</span>       <span class="hljs-keyword">final</span> Date D2 = <span class="hljs-keyword">new</span> Date();       <span class="hljs-comment">//不安全</span>       <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();       <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;           <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;           <span class="hljs-comment">//有可能多个代码来修改里面的值</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;               <span class="hljs-comment">// ...</span>               count++;           &#125;       &#125;  &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;    <span class="hljs-comment">//不安全，因为start会被修改</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">0L</span>;    <span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;       start = System.nanoTime();     &#125;    <span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> end = System.nanoTime();        System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start));    &#125;&#125;</code></pre></div><h2 id="4、Monitor（锁）概念"><a href="#4、Monitor（锁）概念" class="headerlink" title="4、Monitor（锁）概念"></a>4、Monitor（锁）概念</h2><h3 id="1-原理之Monitor"><a href="#1-原理之Monitor" class="headerlink" title="(1)原理之Monitor"></a>(1)原理之Monitor</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png" alt="img"></a></p><ul><li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p><ul><li><p>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</p></li><li><p>如果已经绑定，则会去查询该Monitor是否已经有了Owner</p><ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList，进入阻塞状态(blocked)</li></ul></li></ul></li><li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p></li><li><p><strong>注意</strong>：</p><ul><li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li><li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li></ul></li></ul><h2 id="5、Synchronized原理进阶"><a href="#5、Synchronized原理进阶" class="headerlink" title="5、Synchronized原理进阶"></a>5、Synchronized原理进阶</h2><h3 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h3><p>普通对象</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gph8nfmtlrj30ya086gmo.jpg" alt="image-20210412203347281"></p><p>数组对象</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gph8n1ce41j316w07yag2.jpg" alt="image-20210412203425689"></p><p>其中Klass可以找到类对象，有<strong>类型指针Object reference</strong>，Mac Word结构为</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png" alt="img"></a></p><h3 id="1-轻量级锁（用于优化Monitor这类的重量级锁）"><a href="#1-轻量级锁（用于优化Monitor这类的重量级锁）" class="headerlink" title="(1)轻量级锁（用于优化Monitor这类的重量级锁）"></a>(1)轻量级锁（用于优化Monitor这类的重量级锁）</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p><ul><li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的<strong>栈帧都会包含一个锁记录对象</strong>，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png" alt="img"></a></p></li><li><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png" alt="img"></a></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png" alt="img"></a></p><ul><li>如果cas失败，是自己执行了Synchronized锁重入，那么再添加一条Lock Record作为重入的计数</li></ul><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gph7zqfw55j30rw0hu7d2.jpg" alt="image-20210412201158273"  /><ul><li>当退出Synchronized代码块（解锁时）如果有取值为null的锁记录，表示<strong>有重入</strong>，这时<strong>重置锁记录</strong>，表示重入计数减一</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gph84y06q0j30qu0g4jy0.jpg" alt="image-20210412201704193"></p><ul><li>当退出Synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mac Word的值恢复给对象头<ul><li>成功则解锁成功</li><li>失败说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h3 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="(2)锁膨胀"></a>(2)锁膨胀</h3><ul><li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png" alt="img"></a></p><ul><li><p>此时便会给对象加上重量级锁（使用Monitor）</p><ul><li><p>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</p></li><li><p>并且该线程放入入EntryList中，并进入阻塞状态(blocked)</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png" alt="img"></a></p></li></ul></li><li><p>当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为Null，唤醒Entrylist中BLOCKED线程</p></li></ul><h3 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="(3)自旋优化"></a>(3)自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自选来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p><ul><li>第一种情况</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png" alt="img"></a></p><ul><li>第二种情况</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png" alt="img"></a></p><h3 id="4-偏向锁-用于优化轻量级锁重入"><a href="#4-偏向锁-用于优化轻量级锁重入" class="headerlink" title="(4)偏向锁(用于优化轻量级锁重入)"></a>(4)偏向锁(用于优化轻量级锁重入)</h3><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png" alt="img"></a></p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png" alt="img"></a></p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态，可用VM参数 -XX: BiasedLockingStartopDelay=0来禁用延迟</li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001，这时候它的hashcode、age都为0，第一次用到hashcode时才会赋值</li></ul><h4 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h4><p>以下几种情况会使对象的<strong>偏向锁失效</strong></p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h3 id="5-批量重偏向"><a href="#5-批量重偏向" class="headerlink" title="(5)批量重偏向"></a>(5)批量重偏向</h3><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>重偏向会重置Thread ID</li></ul></li><li>当<strong>撤销超过20次后</strong>（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，<strong>重新偏向至加锁线程</strong>。</li></ul><h3 id="6-批量撤销"><a href="#6-批量撤销" class="headerlink" title="(6)批量撤销"></a>(6)批量撤销</h3><p>当撤销偏向锁的阈值<strong>超过40以后</strong>，就会将<strong>整个类的对象都改为不可偏向的</strong></p><h2 id="6、Wait-Notify"><a href="#6、Wait-Notify" class="headerlink" title="6、Wait/Notify"></a>6、Wait/Notify</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="(1)原理"></a>(1)原理</h3><p> <a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png" alt="img"></a></p><ul><li><p>锁对象调用wait方法（obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</p></li><li><p>处于<strong>BLOCKED和WAITING状态的线程都为阻塞</strong>状态，CPU都不会分给他们时间片。但是有所区别：</p><ul><li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li></ul></li><li><p>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。</p></li></ul><p><strong>注：只有当对象被锁以后，才能调用wait和notify方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object LOCK = <span class="hljs-keyword">new</span> Object();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//只有在对象被锁住后才能调用wait方法</span>        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;            LOCK.wait();        &#125;    &#125;&#125;</code></pre></div><h3 id="2-Wait与Sleep的区别"><a href="#2-Wait与Sleep的区别" class="headerlink" title="(2)Wait与Sleep的区别"></a>(2)Wait与Sleep的区别</h3><p><strong>不同点</strong></p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li><strong>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</strong></li><li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li></ul><p><strong>相同点</strong></p><ul><li>阻塞状态都为<strong>TIMED_WAITING</strong></li></ul><h3 id="3-优雅地使用wait-notify"><a href="#3-优雅地使用wait-notify" class="headerlink" title="(3)优雅地使用wait/notify"></a>(3)优雅地使用wait/notify</h3><p><strong>什么时候适合使用wait</strong></p><ul><li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。</li></ul><p><strong>使用wait/notify需要注意什么</strong></p><ul><li>当有<strong>多个</strong>线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了<strong>notify</strong>方法，可能会造成<strong>虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用<strong>notifyAll</strong>方法，同时将wait方法置于while循环中判断，同样避免虚假唤醒。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (LOCK) &#123;    <span class="hljs-keyword">while</span>(<span class="hljs-comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span>        LOCK.wait();    &#125;    <span class="hljs-comment">//满足条件后再运行</span>&#125;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;    <span class="hljs-comment">//唤醒所有等待线程</span>    LOCK.notifyAll();&#125;</code></pre></div><h2 id="7、同步模式之保护性暂停"><a href="#7、同步模式之保护性暂停" class="headerlink" title="7、同步模式之保护性暂停"></a>7、同步模式之保护性暂停</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1)定义"></a>(1)定义</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png" alt="img"></a></p><h3 id="2-举例"><a href="#2-举例" class="headerlink" title="(2)举例"></a>(2)举例</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String hello = <span class="hljs-string">&quot;hello thread!&quot;</span>;        Guarded guarded = <span class="hljs-keyword">new</span> Guarded();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(<span class="hljs-string">&quot;想要得到结果&quot;</span>);            <span class="hljs-keyword">synchronized</span> (guarded) &#123;                System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span>+guarded.getResponse());            &#125;            System.out.println(<span class="hljs-string">&quot;得到结果&quot;</span>);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            System.out.println(<span class="hljs-string">&quot;设置结果&quot;</span>);            <span class="hljs-keyword">synchronized</span> (guarded) &#123;                guarded.setResponse(hello);            &#125;        &#125;).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Guarded</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 要返回的结果</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Object response;    <span class="hljs-comment">//优雅地使用wait/notify</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//如果返回结果为空就一直等待，避免虚假唤醒</span>        <span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">this</span>.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> response;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;        <span class="hljs-keyword">this</span>.response = response;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">//唤醒休眠的线程</span>            <span class="hljs-keyword">this</span>.notifyAll();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Guarded&#123;&quot;</span> +                <span class="hljs-string">&quot;response=&quot;</span> + response +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p><strong>带超时判断的暂停</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">//获取开始时间</span>            <span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis();            <span class="hljs-comment">//用于保存已经等待了的时间</span>            <span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//看经过的时间-开始时间是否超过了指定时间</span>                <span class="hljs-keyword">long</span> waitTime = time -passedTime;                <span class="hljs-keyword">if</span>(waitTime &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">try</span> &#123;                       <span class="hljs-comment">//等待剩余时间</span>                    <span class="hljs-keyword">this</span>.wait(waitTime);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-comment">//获取当前时间</span>                passedTime = System.currentTimeMillis()-currentTime                    &#125;        &#125;        <span class="hljs-keyword">return</span> response;    &#125;</code></pre></div><h3 id="3-join源码——使用保护性暂停模式"><a href="#3-join源码——使用保护性暂停模式" class="headerlink" title="(3)join源码——使用保护性暂停模式"></a>(3)join源码——使用保护性暂停模式</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> base = System.currentTimeMillis();        <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span> (isAlive()) &#123;                wait(<span class="hljs-number">0</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">while</span> (isAlive()) &#123;              <span class="hljs-comment">//同样的思想，用于join</span>                <span class="hljs-keyword">long</span> delay = millis - now;                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                wait(delay);                now = System.currentTimeMillis() - base;            &#125;        &#125;    &#125;</code></pre></div><h2 id="8、异步模式之生产者-消费者"><a href="#8、异步模式之生产者-消费者" class="headerlink" title="8、异步模式之生产者/消费者"></a>8、异步模式之生产者/消费者</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1)定义"></a>(1)定义</h3><ul><li>与前面的保护性暂停中的GuardObject不同，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpj133103oj31bo0bmahb.jpg" alt="image-20210414094410348"></p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="(2)代码"></a>(2)代码</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test21&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMessageQueue</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MessageQueue queue = <span class="hljs-keyword">new</span> MessageQueue(<span class="hljs-number">2</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">int</span> id = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                queue.put(<span class="hljs-keyword">new</span> Message(id , <span class="hljs-string">&quot;值&quot;</span>+id));            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();        &#125;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;                sleep(<span class="hljs-number">1</span>);                Message message = queue.take();            &#125;        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();    &#125;&#125;<span class="hljs-comment">// 消息队列类 ， java 线程之间通信</span><span class="hljs-meta">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;    <span class="hljs-comment">// 消息的队列集合,双向队列</span>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-comment">// 队列容量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;        <span class="hljs-keyword">this</span>.capcity = capcity;    &#125;    <span class="hljs-comment">// 获取消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 检查队列是否为空</span>        <span class="hljs-keyword">synchronized</span> (list) &#123;            <span class="hljs-keyword">while</span>(list.isEmpty()) &#123;                <span class="hljs-keyword">try</span> &#123;                    log.debug(<span class="hljs-string">&quot;队列为空, 消费者线程等待&quot;</span>);                    list.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-comment">// 从队列头部获取消息并返回</span>            Message message = list.removeFirst();            log.debug(<span class="hljs-string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);            list.notifyAll();            <span class="hljs-keyword">return</span> message;        &#125;    &#125;    <span class="hljs-comment">// 存入消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Message message)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (list) &#123;            <span class="hljs-comment">// 检查对象是否已满</span>            <span class="hljs-keyword">while</span>(list.size() == capcity) &#123;                <span class="hljs-keyword">try</span> &#123;                    log.debug(<span class="hljs-string">&quot;队列已满, 生产者线程等待&quot;</span>);                    list.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-comment">// 将消息加入队列尾部</span>            list.addLast(message);            log.debug(<span class="hljs-string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);            list.notifyAll();        &#125;    &#125;&#125;<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> Object value;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, Object value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.value = value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, value=&quot;</span> + value +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><h2 id="9、park-unpark"><a href="#9、park-unpark" class="headerlink" title="9、park/unpark"></a>9、park/unpark</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1)基本使用"></a>(1)基本使用</h3><p><strong>park/unpark都是LockSupport类中的的方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//暂停线程运行</span>LockSupport.park;<span class="hljs-comment">//恢复线程运行</span>LockSupport.unpark(thread); <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            System.out.println(<span class="hljs-string">&quot;park&quot;</span>);            <span class="hljs-comment">//暂停线程运行</span>            LockSupport.park();            System.out.println(<span class="hljs-string">&quot;resume&quot;</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);        thread.start();        Thread.sleep(<span class="hljs-number">1000</span>);        System.out.println(<span class="hljs-string">&quot;unpark&quot;</span>);        <span class="hljs-comment">//恢复线程运行</span>        LockSupport.unpark(thread);    &#125;</code></pre></div><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h3><p><strong>与wait/notify的区别</strong></p><ul><li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li><li>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</li><li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li><li><strong>park不会释放锁</strong>，而wait会释放锁</li></ul><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="(3)原理"></a>(3)原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象**_counter, _cond,__mutex**组成</p><ul><li>先调用park再调用unpark时<ul><li><p>先调用park</p><ul><li>线程运行时，会将Park对象中的**_counter的值设为0**；</li><li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li><li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li></ul></li><li><p>然后调用unpark</p><ul><li><p>调用unpark方法后，会将counter的值设置为1</p></li><li><p>去唤醒阻塞队列cond中的线程</p></li><li><p>线程继续运行并将counter的值设为0</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png" alt="img"></a></p></li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png" alt="img"></a></p><ul><li>先调用unpark，再调用park<ul><li>调用unpark<ul><li>会将counter设置为1（运行时0）</li></ul></li><li>调用park方法<ul><li>查看counter是否为0</li><li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png" alt="img"></a></p><h2 id="10、线程中的状态转换"><a href="#10、线程中的状态转换" class="headerlink" title="10、线程中的状态转换"></a>10、线程中的状态转换</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png" alt="img"></a></p><h3 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h3><ul><li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE </li></ul><h3 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul><li><p>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</p></li><li><p>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时</p><ul><li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE </li><li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED </li></ul></li></ul></li></ul><h3 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h3><ul><li><p>当前线程</p><p>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</p><ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</p></li></ul><h3 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ul><h3 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ul><li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED </li></ul></li></ul><h3 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li><p>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p></li><li><p>注意是当前线程在t 线程对象的监视器上等待 </p></li><li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</p></li></ul><h3 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING </li><li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h3 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE –&gt; TIMED_WAITING </li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li></ul><h3 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h3><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED </li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然 BLOCKED </li></ul><h3 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p><h2 id="11、多把锁"><a href="#11、多把锁" class="headerlink" title="11、多把锁"></a>11、多把锁</h2><p><strong>将锁的粒度细分</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;    <span class="hljs-comment">//额外创建对象来作为锁</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();&#125;</code></pre></div><ul><li>好处，是可以增加并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><h2 id="12、活跃性"><a href="#12、活跃性" class="headerlink" title="12、活跃性"></a>12、活跃性</h2><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="(1)定义"></a>(1)定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p><h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：t1线程获得A对象锁，接下来想获取B对象的锁</p><p>​         t2线程获得B对象锁，接下来想获取A对象的锁 </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> Object A = <span class="hljs-keyword">new</span> Object();        <span class="hljs-keyword">final</span> Object B = <span class="hljs-keyword">new</span> Object();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">synchronized</span> (A) &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">2000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">synchronized</span> (B) &#123;                &#125;            &#125;        &#125;).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">synchronized</span> (B) &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">synchronized</span> (A) &#123;                &#125;            &#125;        &#125;).start();    &#125;</code></pre></div><h4 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h4><ul><li>互斥条件<ul><li>在一段时间内，一种资源只能被一个进程所使用</li></ul></li><li>请求和保持条件<ul><li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li></ul></li><li>不可抢占条件<ul><li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li></ul></li><li>循环等待条件<ul><li>发生死锁时，必然存在一个进程——资源的循环链。</li></ul></li></ul><h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul><li><p><code>jps+jstack ThreadID</code></p><ul><li>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID，使用<strong>jstack ThreadID</strong>可以查看线程状态。<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png" alt="img"></a></li></ul><div class="hljs code-wrapper"><pre><code class="hljs sh">❯ jps14196 RemoteMavenServer36694 NutstoreGUI14871 Launcher14872 TestDeadLock14121 14876 Jps❯ ❯ ❯ jstack 14872</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs smali">  - 打印的结果    ```java  //找到一个java级别的死锁  Found one Java-level deadlock:  =============================  <span class="hljs-string">&quot;Thread-1&quot;</span>:    waiting to lock<span class="hljs-built_in"> monitor </span>0x0000000017f40de8 (object 0x00000000d6188880, a java.lang.Object),    which is held by <span class="hljs-string">&quot;Thread-0&quot;</span>  <span class="hljs-string">&quot;Thread-0&quot;</span>:    waiting to lock<span class="hljs-built_in"> monitor </span>0x0000000017f43678 (object 0x00000000d6188890, a java.lang.Object),    which is held by <span class="hljs-string">&quot;Thread-1&quot;</span></code></pre></div></li><li><p>jconsole检测死锁</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png" alt="img"></a></p></li></ul><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png" alt="img"></a></p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png" alt="img"></a></p><h3 id="3-活锁"><a href="#3-活锁" class="headerlink" title="(3)活锁"></a>(3)活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h3 id="4-饥饿"><a href="#4-饥饿" class="headerlink" title="(4)饥饿"></a>(4)饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p><strong>在使用顺序加锁时，可能会出现饥饿现象</strong></p><h2 id="13、ReentrantLock"><a href="#13、ReentrantLock" class="headerlink" title="13、ReentrantLock"></a>13、ReentrantLock</h2><p><strong>和synchronized相比具有的的特点</strong></p><ul><li>可中断 </li><li>可以设置超时时间 </li><li>可以设置为公平锁 (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li></ul><p><strong>基本语法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取ReentrantLock对象</span><span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//加锁</span>lock.lock();<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//需要执行的代码</span>&#125;<span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">//释放锁</span>    lock.unlock();&#125;</code></pre></div><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//加锁，可打断锁</span>                lock.lockInterruptibly();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();                <span class="hljs-comment">//被打断，返回，不再向下执行</span>                <span class="hljs-keyword">return</span>;            &#125;<span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">//释放锁</span>                lock.unlock();            &#125;        &#125;);        lock.lock();        <span class="hljs-keyword">try</span> &#123;            t1.start();            Thread.sleep(<span class="hljs-number">1000</span>);            <span class="hljs-comment">//打断</span>            t1.interrupt();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;</code></pre></div><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>不设置等待时间</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-comment">//未设置等待时间，一旦获取失败，直接返回false</span>            <span class="hljs-keyword">if</span>(!lock.tryLock()) &#123;                System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);                <span class="hljs-comment">//获取失败，不再向下执行，返回</span>                <span class="hljs-keyword">return</span>;            &#125;            System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);            lock.unlock();        &#125;);        lock.lock();        <span class="hljs-keyword">try</span>&#123;            t1.start();            Thread.sleep(<span class="hljs-number">3000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;</code></pre></div><p>设置等待时间</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//判断获取锁是否成功，最多等待1秒</span>                <span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;                    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);                    <span class="hljs-comment">//获取失败，不再向下执行，直接返回</span>                    <span class="hljs-keyword">return</span>;                &#125;            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();                <span class="hljs-comment">//被打断，不再向下执行，直接返回</span>                <span class="hljs-keyword">return</span>;            &#125;            System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);            <span class="hljs-comment">//释放锁</span>            lock.unlock();        &#125;);        lock.lock();        <span class="hljs-keyword">try</span>&#123;            t1.start();            <span class="hljs-comment">//打断等待</span>            t1.interrupt();            Thread.sleep(<span class="hljs-number">3000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;</code></pre></div><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre></div><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比 </p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息 </li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li></ul><p>使用要点：</p><ul><li>await 前需要<strong>获得锁</strong></li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁 </li><li>竞争 lock 锁成功后，从 await 后继续执</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-comment">//获得条件变量</span>    Condition condition = lock.newCondition();    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        lock.lock();        <span class="hljs-keyword">try</span>&#123;            <span class="hljs-keyword">while</span>(!judge) &#123;                System.out.println(<span class="hljs-string">&quot;不满足条件，等待...&quot;</span>);                <span class="hljs-comment">//等待</span>                condition.await();            &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(<span class="hljs-string">&quot;执行完毕！&quot;</span>);            lock.unlock();        &#125;    &#125;).start();    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1</span>);            judge = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">//释放</span>            condition.signal();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;).start();&#125;</code></pre></div><h4 id="通过Lock与AQS实现可重入锁"><a href="#通过Lock与AQS实现可重入锁" class="headerlink" title="通过Lock与AQS实现可重入锁"></a>通过Lock与AQS实现可重入锁</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;               setExclusiveOwnerThread(Thread.currentThread());               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;         &#125;         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == Thread.currentThread()) &#123;            <span class="hljs-keyword">int</span> state = getState();            compareAndSetState(state, state + <span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;         &#125;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;         <span class="hljs-keyword">if</span> (getState() &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();         &#125;         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();         &#125;         <span class="hljs-keyword">int</span> state = getState();         <span class="hljs-keyword">if</span> (state == <span class="hljs-number">1</span>) &#123;            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);            compareAndSetState(state, <span class="hljs-number">0</span>);         &#125; <span class="hljs-keyword">else</span> &#123;            compareAndSetState(state, state - <span class="hljs-number">1</span>);         &#125;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> getState() &gt;= <span class="hljs-number">1</span>;      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();      &#125;   &#125;   Sync sync = <span class="hljs-keyword">new</span> Sync();   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;      sync.acquire(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      sync.acquireInterruptibly(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;      <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, time);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;      sync.release(<span class="hljs-number">1</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> sync.newCondition();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException </span>&#123;      MyLock lock = <span class="hljs-keyword">new</span> MyLock();      Object syncLock = <span class="hljs-keyword">new</span> Object();      Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;               lock.lock();               <span class="hljs-keyword">try</span> &#123;                  lock.lock();                  <span class="hljs-keyword">try</span> &#123;                     num++;                  &#125; <span class="hljs-keyword">finally</span> &#123;                     lock.unlock();                  &#125;               &#125; <span class="hljs-keyword">finally</span> &#123;                  lock.unlock();               &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;               lock.unlock();            &#125;         &#125;      &#125;);      Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;               lock.lock();               <span class="hljs-keyword">try</span> &#123;                  lock.lock();                  <span class="hljs-keyword">try</span> &#123;                     num--;                  &#125; <span class="hljs-keyword">finally</span> &#123;                     lock.unlock();                  &#125;               &#125; <span class="hljs-keyword">finally</span> &#123;                  lock.unlock();               &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;               lock.unlock();            &#125;         &#125;      &#125;);      t1.start();      t2.start();      t1.join();      t2.join();      <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;   &#125;&#125;</code></pre></div><h2 id="14、同步模式之顺序控制"><a href="#14、同步模式之顺序控制" class="headerlink" title="14、同步模式之顺序控制"></a>14、同步模式之顺序控制</h2><h3 id="Wait-Notify版本"><a href="#Wait-Notify版本" class="headerlink" title="Wait/Notify版本"></a>Wait/Notify版本</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//判断先执行的内容是否执行完毕</span><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;            <span class="hljs-keyword">while</span> (!judge) &#123;                <span class="hljs-keyword">try</span> &#123;                    LOCK.wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);        &#125;    &#125;).start();    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;            System.out.println(<span class="hljs-string">&quot;1&quot;</span>);            judge = <span class="hljs-keyword">true</span>;               <span class="hljs-comment">//执行完毕，唤醒所有等待线程</span>            LOCK.notifyAll();        &#125;    &#125;).start();&#125;</code></pre></div><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><h5 id="wait-notify版本"><a href="#wait-notify版本" class="headerlink" title="wait/notify版本"></a><strong>wait/notify版本</strong></h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test27&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test27</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        WaitNotify wn = <span class="hljs-keyword">new</span> WaitNotify(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            wn.print(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            wn.print(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            wn.print(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);        &#125;).start();    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">输出内容       等待标记     下一个标记</span><span class="hljs-comment">   a           1             2</span><span class="hljs-comment">   b           2             3</span><span class="hljs-comment">   c           3             1</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;    <span class="hljs-comment">// 打印               a           1             2</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> waitFlag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                <span class="hljs-keyword">while</span>(flag != waitFlag) &#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">this</span>.wait();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                System.out.print(str);                flag = nextFlag;                <span class="hljs-keyword">this</span>.notifyAll();            &#125;        &#125;    &#125;    <span class="hljs-comment">// 等待标记</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag; <span class="hljs-comment">// 2</span>    <span class="hljs-comment">// 循环次数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WaitNotify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">this</span>.flag = flag;        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;    &#125;&#125;</code></pre></div><h5 id="await-signal版本"><a href="#await-signal版本" class="headerlink" title="await/signal版本"></a>await/signal版本</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test30</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal(<span class="hljs-number">5</span>);        Condition a = awaitSignal.newCondition();        Condition b = awaitSignal.newCondition();        Condition c = awaitSignal.newCondition();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a, b);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b, c);        &#125;).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c, a);        &#125;).start();        Thread.sleep(<span class="hljs-number">1000</span>);        <span class="hljs-comment">//刚开始所有线程都在await，需要主线程唤醒a</span>        awaitSignal.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(<span class="hljs-string">&quot;开始...&quot;</span>);            a.signal();        &#125; <span class="hljs-keyword">finally</span> &#123;            awaitSignal.unlock();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AwaitSignal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;    &#125;    <span class="hljs-comment">//            参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            <span class="hljs-comment">//继承了ReentrantLock，可以直接Lock，相当于this.lock()</span>            lock();            <span class="hljs-keyword">try</span> &#123;                current.await();                System.out.print(str);                next.signal();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                unlock();            &#125;        &#125;    &#125;&#125;</code></pre></div><h5 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park/unpark"></a>park/unpark</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test31&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test31</span> </span>&#123;    <span class="hljs-keyword">static</span> Thread t1;    <span class="hljs-keyword">static</span> Thread t2;    <span class="hljs-keyword">static</span> Thread t3;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ParkUnpark pu = <span class="hljs-keyword">new</span> ParkUnpark(<span class="hljs-number">5</span>);        t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            pu.print(<span class="hljs-string">&quot;a&quot;</span>, t2);        &#125;);        t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            pu.print(<span class="hljs-string">&quot;b&quot;</span>, t3);        &#125;);        t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            pu.print(<span class="hljs-string">&quot;c&quot;</span>, t1);        &#125;);        t1.start();        t2.start();        t3.start();        <span class="hljs-comment">//主线程发起者</span>        LockSupport.unpark(t1);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnpark</span> </span>&#123;    <span class="hljs-comment">//park不需要记录当前，因为park会自己记录</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Thread next)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;            LockSupport.park();            System.out.print(str);            LockSupport.unpark(next);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParkUnpark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;    &#125;&#125;</code></pre></div><h2 id="14、ThreadLocal"><a href="#14、ThreadLocal" class="headerlink" title="14、ThreadLocal"></a>14、ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么<strong>访问这个变量的每个线程都会有这个变量的一个本地副本</strong>。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而<strong>避免了线程安全</strong>问题</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalStudy</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 创建ThreadLocal变量</span>      ThreadLocal&lt;String&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();      ThreadLocal&lt;User&gt; userThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();      <span class="hljs-comment">// 创建两个线程，分别使用上面的两个ThreadLocal变量</span>      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-comment">// stringThreadLocal第一次赋值</span>         stringThreadLocal.set(<span class="hljs-string">&quot;thread1 stringThreadLocal first&quot;</span>);         <span class="hljs-comment">// stringThreadLocal第二次赋值</span>         stringThreadLocal.set(<span class="hljs-string">&quot;thread1 stringThreadLocal second&quot;</span>);         <span class="hljs-comment">// userThreadLocal赋值</span>         userThreadLocal.set(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Lucifer&quot;</span>, <span class="hljs-number">24</span>));         <span class="hljs-comment">// 取值</span>         System.out.println(stringThreadLocal.get());         System.out.println(userThreadLocal.get());          <span class="hljs-comment">// 移除</span>         userThreadLocal.remove();         System.out.println(userThreadLocal.get());      &#125;);      Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-comment">// stringThreadLocal第一次赋值</span>         stringThreadLocal.set(<span class="hljs-string">&quot;thread2 stringThreadLocal first&quot;</span>);         <span class="hljs-comment">// stringThreadLocal第二次赋值</span>         stringThreadLocal.set(<span class="hljs-string">&quot;thread2 stringThreadLocal second&quot;</span>);         <span class="hljs-comment">// userThreadLocal赋值</span>         userThreadLocal.set(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Melrose&quot;</span>, <span class="hljs-number">9</span>));         <span class="hljs-comment">// 取值</span>         System.out.println(stringThreadLocal.get());         System.out.println(userThreadLocal.get());      &#125;);      <span class="hljs-comment">// 启动线程</span>      thread1.start();      thread2.start();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;   String name;   <span class="hljs-keyword">int</span> age;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;      <span class="hljs-keyword">this</span>.age = age;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +            <span class="hljs-string">&quot;, age=&quot;</span> + age +            <span class="hljs-string">&#x27;&#125;&#x27;</span>;   &#125;&#125;</code></pre></div><p><strong>运行结果</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">thread1 stringThreadLocal secondthread2 stringThreadLocal secondUser&#123;name=&#x27;Lucifer&#x27;, age=24&#125;User&#123;name=&#x27;Melrose&#x27;, age=9&#125;null</code></pre></div><p>从运行结果可以看出</p><ul><li><strong>每个线程中的ThreadLocal变量是线程私有的</strong>，而不是共享的<ul><li>从线程1和线程2的打印结果可以看出</li></ul></li><li>ThreadLocal其实就相当于其泛型类型的一个变量，只不过是每个线程私有的<ul><li>stringThreadLocal被赋值了两次，保存的是最后一次赋值的结果</li></ul></li><li>ThreadLocal可以进行以下几个操作<ul><li>set 设置值</li><li>get 取出值</li><li>remove 移除值</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Thread中的threadLocals"><a href="#Thread中的threadLocals" class="headerlink" title="Thread中的threadLocals"></a>Thread中的threadLocals</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123; ... ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 放在后面说</span> ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>; ...&#125; <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;            <span class="hljs-keyword">super</span>(k);            value = v;        &#125;    &#125;</code></pre></div><p>可以看出Thread类中有一个threadLocals和一个inheritableThreadLocals，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的Hashmap。在默认情况下，每个线程中的这两个变量都为null。此处先讨论threadLocals，inheritableThreadLocals放在后面讨论</p><h4 id="ThreadLocal中的方法"><a href="#ThreadLocal中的方法" class="headerlink" title="ThreadLocal中的方法"></a><strong>ThreadLocal中的方法</strong></h4><p><strong>set方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;    <span class="hljs-comment">// 获取当前线程</span>    Thread t = Thread.currentThread();    <span class="hljs-comment">// 获得ThreadLocalMap对象 </span>    <span class="hljs-comment">// 这里的get会返回Thread类中的threadLocals</span>    ThreadLocalMap map = getMap(t);    <span class="hljs-comment">// 判断map是否已经创建，没创建就创建并放入值，创建了就直接放入</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// ThreadLocal自生的引用作为key，传入的值作为value</span>        map.set(<span class="hljs-keyword">this</span>, value);    <span class="hljs-keyword">else</span>        createMap(t, value);&#125;</code></pre></div><p><strong>如果未创建</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;    <span class="hljs-comment">// 创建的同时设置想放入的值</span>    <span class="hljs-comment">// hreadLocal自生的引用作为key，传入的值作为value</span>    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);&#125;</code></pre></div><p><strong>get方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 获取当前线程</span>    Thread t = Thread.currentThread();    <span class="hljs-comment">// 获取当前线程的threadLocals变量</span>    ThreadLocalMap map = getMap(t);    <span class="hljs-comment">// 判断threadLocals是否被初始化了</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 已经初始化则直接返回</span>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            T result = (T)e.value;            <span class="hljs-keyword">return</span> result;        &#125;    &#125;    <span class="hljs-comment">// 否则就创建threadLocals</span>    <span class="hljs-keyword">return</span> setInitialValue();&#125; <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">setInitialValue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 这个方法返回是null</span>    T value = initialValue();    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    <span class="hljs-comment">// 无论map创建与否，最终value的值都为null</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)        map.set(<span class="hljs-keyword">this</span>, value);    <span class="hljs-keyword">else</span>        createMap(t, value);    <span class="hljs-keyword">return</span> value;&#125;<span class="hljs-function">Cop otected T <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p><strong>remove方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    ThreadLocalMap m = getMap(Thread.currentThread());    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// 如果threadLocals已经被初始化，则移除</span>        m.remove(<span class="hljs-keyword">this</span>);&#125;</code></pre></div><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为HashMap，其中<strong>key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值</strong>。每个线程的本地变量存放在线程自己的内存变量threadLocals中</p><p>只有当前线程<strong>第一次调用ThreadLocal的set或者get方法时才会创建threadLocals</strong>（inheritableThreadLocals也是一样）。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</p><h2 id="15、InheritableThreadLocal"><a href="#15、InheritableThreadLocal" class="headerlink" title="15、InheritableThreadLocal"></a>15、InheritableThreadLocal</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>从ThreadLocal的源码可以看出，无论是set、get、还是remove，都是相对于当前线程操作的</p><div class="hljs code-wrapper"><pre><code class="hljs java">Thread.currentThread()</code></pre></div><p><strong>ThreadLocal无法从父线程传向子线程</strong>，<strong>InheritableThreadLocal它能够让父线程中ThreadLocal的值传给子线程。</strong></p><p>也就是从main所在的线程，传给thread1或thread2</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ThreadLocal&lt;String&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();      InheritableThreadLocal&lt;String&gt; stringInheritable = <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;&gt;();      <span class="hljs-comment">// 主线程赋对上面两个变量进行赋值</span>      stringThreadLocal.set(<span class="hljs-string">&quot;this is threadLocal&quot;</span>);      stringInheritable.set(<span class="hljs-string">&quot;this is inheritableThreadLocal&quot;</span>);      <span class="hljs-comment">// 创建线程</span>      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;         <span class="hljs-comment">// 获得ThreadLocal中存放的值</span>         System.out.println(stringThreadLocal.get());         <span class="hljs-comment">// 获得InheritableThreadLocal存放的值</span>         System.out.println(stringInheritable.get());      &#125;);      thread1.start();   &#125;&#125;</code></pre></div><p><strong>运行结果</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">nullthis is inheritableThreadLocal</code></pre></div><p>可以看出InheritableThreadLocal的值成功从主线程传入了子线程，而ThreadLocal则没有</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritableThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">// 传入父线程中的一个值，然后直接返回</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">childValue</span><span class="hljs-params">(T parentValue)</span> </span>&#123;        <span class="hljs-keyword">return</span> parentValue;    &#125;      <span class="hljs-comment">// 返回传入线程的inheritableThreadLocals</span>    <span class="hljs-comment">// Thread中有一个inheritableThreadLocals变量</span>    <span class="hljs-comment">// ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span>    <span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;    &#125;     <span class="hljs-comment">// 创建一个inheritableThreadLocals</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);    &#125;&#125;</code></pre></div><p>由如上代码可知，InheritableThreadLocal继承了ThreadLocal，并重写了三个方法。InheritableThreadLocal重写了<strong>createMap方法</strong>，那么现在当第一次调用set方法时，创建的是当前线程的inheritableThreadLocals变量的实例而不再是threadLocals。当调用<strong>getMap方法</strong>获取当前线程内部的map变量时，获取的是inheritableThreadLocals而不再是threadLocals</p><h4 id="childValue-T-parentValue-方法的调用"><a href="#childValue-T-parentValue-方法的调用" class="headerlink" title="childValue(T parentValue)方法的调用"></a>childValue(T parentValue)方法的调用</h4><p>在主函数运行时，会调用Thread的默认构造函数（<strong>创建主线程</strong>，也就是父线程），所以我们先看看Thread的默认构造函数</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span> </span>&#123;    init(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);&#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span></span><span class="hljs-function"><span class="hljs-params">                  <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><span class="hljs-function"><span class="hljs-params">                  <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;       ...    <span class="hljs-comment">// 获得当前线程的，在这里是主线程</span>    Thread parent = currentThread();    ...    <span class="hljs-comment">// 如果父线程的inheritableThreadLocals存在</span>    <span class="hljs-comment">// 我们在主线程中调用set和get时，会创建inheritableThreadLocals</span>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// 设置子线程的inheritableThreadLocals</span>        <span class="hljs-keyword">this</span>.inheritableThreadLocals =            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);    <span class="hljs-comment">/* Stash the specified stack size in case the VM cares */</span>    <span class="hljs-keyword">this</span>.stackSize = stackSize;    <span class="hljs-comment">/* Set thread ID */</span>    tid = nextThreadID();&#125;<span class="hljs-function">Cop atic ThreadLocalMap <span class="hljs-title">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadLocalMap(parentMap);&#125;</code></pre></div><p>在createInheritedMap内部使用父线程的inheritableThreadLocals变量作为构造函数创建了一个新的ThreadLocalMap变量，然后赋值给了子线程的inheritableThreadLocals变量</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ThreadLocalMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> </span>&#123;    Entry[] parentTable = parentMap.table;    <span class="hljs-keyword">int</span> len = parentTable.length;    setThreshold(len);    table = <span class="hljs-keyword">new</span> Entry[len];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;        Entry e = parentTable[j];        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();            <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 这里调用了 childValue 方法</span>                <span class="hljs-comment">// 该方法会返回parent的值</span>                Object value = key.childValue(e.value);                Entry c = <span class="hljs-keyword">new</span> Entry(key, value);                <span class="hljs-keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);                <span class="hljs-keyword">while</span> (table[h] != <span class="hljs-keyword">null</span>)                    h = nextIndex(h, len);                table[h] = c;                size++;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>在该构造函数内部把父线程的inheritableThreadLocals成员变量的值复制到新的ThreadLocalMap对象中</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>InheritableThreadLocal类通过重写getMap和createMap，让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程在通过InheritableThreadLocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritableThreadLocals变量。</p><p><strong>当父线程创建子线程时，构造函数会把父线程中inheritableThreadLocals变量里面的本地变量复制一份保存到子线程的inheritableThreadLocals变量里面。</strong></p><h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="1、JAVA内存模型（JMM）"><a href="#1、JAVA内存模型（JMM）" class="headerlink" title="1、JAVA内存模型（JMM）"></a>1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。 </p><p><strong>JMM体现在以下几个方面</strong></p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h4><p><strong>退出不出的循环</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">while</span> (run) &#123;                <span class="hljs-comment">//如果run为真，则一直执行</span>            &#125;        &#125;).start();        Thread.sleep(<span class="hljs-number">1000</span>);        System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);        run = <span class="hljs-keyword">false</span>;    &#125;</code></pre></div><p><strong>为什么无法退出该循环</strong></p><ul><li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png" alt="img"></a></p><ul><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png" alt="img"></a></p><ul><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png" alt="img"></a></p><p><strong>解决方法</strong></p><ul><li>使用<strong>volatile</strong>易变关键字</li><li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//使用易变关键字</span><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        <span class="hljs-keyword">while</span> (run) &#123;            <span class="hljs-comment">//如果run为真，则一直执行</span>        &#125;    &#125;).start();    Thread.sleep(<span class="hljs-number">1000</span>);    System.out.println(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);    run = <span class="hljs-keyword">false</span>;&#125;</code></pre></div><h4 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h4><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</p></li><li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p><ul><li>因为使用了<strong>synchronized</strong>关键字<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;        <span class="hljs-comment">//使用了synchronized关键字</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            print(x);            newLine();        &#125;    &#125;</code></pre></div></li></ul></li></ul><h4 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();        monitor.start();        Thread.sleep(<span class="hljs-number">3500</span>);        monitor.stop();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;    Thread monitor;    <span class="hljs-comment">//设置标记，用于判断是否被终止了</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 启动监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//开始不停的监控</span>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-keyword">if</span>(stop) &#123;                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                    System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//线程休眠</span>                        Thread.sleep(<span class="hljs-number">1000</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);                    &#125;                &#125;            &#125;        &#125;;        monitor.start();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *     用于停止监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//打断线程</span>        monitor.interrupt();        <span class="hljs-comment">//修改标记</span>        stop = <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h4 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h4><p><strong>定义</strong></p><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong></p><ul><li>用一个标记来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题<ul><li>加锁的代码块要尽量的小，以保证性能</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();        monitor.start();        monitor.start();        Thread.sleep(<span class="hljs-number">3500</span>);        monitor.stop();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;    Thread monitor;    <span class="hljs-comment">//设置标记，用于判断是否被终止了</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 启动监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">if</span> (starting) &#123;                <span class="hljs-comment">//已被启动，直接返回</span>                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">//启动监视器，改变标记</span>            starting = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>        monitor = <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//开始不停的监控</span>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-keyword">if</span>(stop) &#123;                        System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);                        <span class="hljs-keyword">break</span>;                    &#125;                    System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//线程休眠</span>                        Thread.sleep(<span class="hljs-number">1000</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);                    &#125;                &#125;            &#125;        &#125;;        monitor.start();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *     用于停止监控器线程</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//打断线程</span>        monitor.interrupt();        stop = <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png" alt="img"></a></p><p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p><h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul><li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png" alt="img"></a></p><ul><li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></p></li><li><p>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子 </span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; System.out.println( a + b );<span class="hljs-comment">// 不能重排的例子 </span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> b = a - <span class="hljs-number">5</span>;</code></pre></div></li></ul><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级<strong>指令流水线</strong>，例如支持<strong>同时</strong>执行 <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地<strong>吞吐率</strong>。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png" alt="img"></a></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p><ul><li>禁止的是加volatile关键字变量之前的代码被重排序</li></ul><h2 id="4、内存屏障"><a href="#4、内存屏障" class="headerlink" title="4、内存屏障"></a>4、内存屏障</h2><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><ul><li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中 </li><li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后</strong>，对共享变量的读取，加载的是主存中新数据 </li></ul><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><ul><li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后 </li><li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li></ul><h2 id="5、volatile-原理"><a href="#5、volatile-原理" class="headerlink" title="5、volatile 原理"></a>5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障 </li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png" alt="img"></a></p></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png" alt="img"></a></p></li></ul><h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png" alt="img"></a></p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png" alt="img"></a></p><p><strong>但是不能解决指令交错问题</strong></p><ul><li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去 </li><li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li></ul><h3 id="double-checked-locking"><a href="#double-checked-locking" class="headerlink" title="double-checked locking"></a>double-checked locking</h3><p>以著名的 double-checked locking 单例模式为例</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span><span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;   <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-comment">// t1 </span>   INSTANCE = <span class="hljs-keyword">new</span> Singleton();   &#125;&#125;&#125;   <span class="hljs-keyword">return</span> INSTANCE;&#125;&#125;</code></pre></div><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li></ul><p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpjnh8hyzhj31ba0u0wjy.jpg" alt="image-20210414223856348"></p><p>其中</p><ul><li>17 表示创建对象，将对象引用入栈 // new Singleton</li><li>20 表示复制一份对象引用 // 引用地址</li><li>21 表示利用一个对象引用，调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpjnibyqsnj31j50u0n0r.jpg" alt="image-20210414224002739"></p><p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值 </p><p>这时 <strong>t1 还未完全将构造方法执行完毕</strong>，如果在构造方法中要执行很多初始化操作，那么 <strong>t2 拿到的是将是一个未初始化完毕的单例</strong> </p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><p><strong>如何解决：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;   <span class="hljs-comment">//解决重排序的问题</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">// t2 </span>         <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次 </span>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1 </span>          INSTANCE = <span class="hljs-keyword">new</span> Singleton();         &#125;&#125;&#125;     <span class="hljs-keyword">return</span> INSTANCE;&#125;&#125;</code></pre></div><p>字节码上看不出来 volatile 指令的效果</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span>0: getstatic  #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpk7c82cqxj31c00u0dpb.jpg" alt="image-20210415100608659"></p><p>如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证可见性和有序性</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpk7dys4gzj31gq0u0443.jpg" alt="image-20210415100749610"></p><h3 id="balking模式习题"><a href="#balking模式习题" class="headerlink" title="balking模式习题"></a>balking模式习题</h3><p>希望doInit方法仅被调用一次，下面实现有问题</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span></span>&#123;  <span class="hljs-comment">//volatile只能保证共享变量可见性，不能保证原子性</span>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> initialized = <span class="hljs-keyword">false</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//一次出现，volatile有序性也只能保证变量之前的读写屏障</span>    <span class="hljs-keyword">if</span>(initialized)&#123;      <span class="hljs-keyword">return</span>;    &#125;    doInit();    <span class="hljs-comment">//二次出现，线程1还没来得及赋值，线程2已经进入到了if判断</span>    initialized = <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span><span class="hljs-params">()</span></span>&#123;&#125;&#125;</code></pre></div><p>所以要用<strong>synchronized</strong>来保证以上的问题</p><h3 id="实现原理之Lock前缀"><a href="#实现原理之Lock前缀" class="headerlink" title="实现原理之Lock前缀"></a>实现原理之Lock前缀</h3><p>在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时</p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">instance</span> = new Singleton()<span class="hljs-comment">; </span></code></pre></div><p>对应的汇编代码是</p><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">...</span> lock addl <span class="hljs-string">...</span></code></pre></div><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，<strong>Lock前缀</strong>的指令在多核处理器下会引发了两件事</p><ul><li>Lock前缀指令会引起处理器缓存回写到内存<ul><li>Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是<strong>锁缓存</strong>，毕竟锁总线开销的比较大。使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong></li></ul></li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效<ul><li>在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能<strong>嗅探其他处理器访问系统内存和它们的内部缓存</strong>。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致</li></ul></li></ul><h2 id="6、final原理"><a href="#6、final原理" class="headerlink" title="6、final原理"></a>6、final原理</h2><p>理解了 volatile 原理，再对比 ﬁnal 的实现就比较简单了</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinal</span> </span>&#123;   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>; &#125;</code></pre></div><p>字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">0</span>: aload_0 1: invokespecial #1 <span class="hljs-number">4</span>: aload_0 <span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span> 7: putfield #2 &lt;-- 写屏障 <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span></code></pre></div><p>发现ﬁnal变量的赋值也会通过putﬁeld指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为0的情况</p><p><strong>final修饰的变量会有一个栈内存读取速度的优化</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">10</span>;<span class="hljs-comment">//直接从栈内存拿取</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkvwtaow5j30m605gtbi.jpg" alt="image-20210416001619162"></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">10</span>;<span class="hljs-comment">//从共享内存拿取，效率低，在堆中</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkvxy4mlpj30mg05cq6p.jpg" alt="image-20210416001725052"></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> B = Short.MAX_VALUE+<span class="hljs-number">1</span>;<span class="hljs-comment">//数值太大，此时从常量池中拿取</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkvzmusmoj30lw05ujuf.jpg" alt="image-20210416001902406"></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> B = Short.MAX_VALUE+<span class="hljs-number">1</span>;<span class="hljs-comment">//同理，从共享内存拿取，效率低，在堆中</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkw0d2xsyj30m60580w6.jpg" alt="image-20210416001944201"></p><h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="1、无锁解决线程安全问题"><a href="#1、无锁解决线程安全问题" class="headerlink" title="1、无锁解决线程安全问题"></a>1、无锁解决线程安全问题</h2><p>使用<strong>原子整数</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">AtomicInteger balance = <span class="hljs-keyword">new</span> AtomicInteger();</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">long</span> start = System.nanoTime();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                account.withdraw(<span class="hljs-number">10</span>);            &#125;));        &#125;        ts.forEach(Thread::start);        ts.forEach(t -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                t.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        <span class="hljs-keyword">long</span> end = System.nanoTime();        System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);    &#125;&#125;<span class="hljs-comment">//线程不安全的做法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer balance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;        <span class="hljs-keyword">this</span>.balance = balance;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;        balance -= amount;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Account.demo(<span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>));        Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));    &#125;&#125;<span class="hljs-comment">//线程安全的做法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;    <span class="hljs-comment">//使用原子整数</span>    <span class="hljs-keyword">private</span> AtomicInteger balance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//得到原子整数的值</span>        <span class="hljs-keyword">return</span> balance.get();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">//获得修改前的值</span>            <span class="hljs-keyword">int</span> prev = balance.get();            <span class="hljs-comment">//获得修改后的值</span>            <span class="hljs-keyword">int</span> next = prev-amount;            <span class="hljs-comment">//比较并设值</span>            <span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="2、CAS与volatile"><a href="#2、CAS与volatile" class="headerlink" title="2、CAS与volatile"></a>2、CAS与volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><p>其中的<strong>关键是 compareAndSwap</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png" alt="img"></a></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul><li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li></ul></li></ul><p><strong>注意</strong></p><ul><li>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</li><li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。即一个线程对volatile变量的修改，对另一个线程可见。</p><p><strong>注意</strong></p><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">volatile</span> 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）</code></pre></div><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果 </p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png" alt="img"></a></p><p><strong>原因</strong></p><h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p><ul><li><p>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 </p></li><li><p>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 </p></li><li><p>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</p><ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 </li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="3、原子整数"><a href="#3、原子整数" class="headerlink" title="3、原子整数"></a>3、原子整数</h2><p>J.U.C 并发包提供了</p><ul><li>AtomicBoolean</li><li>AtomicInteger </li><li>AtomicLong</li></ul><p><strong>以 AtomicInteger 为例</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement());</span><span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet());</span><span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet());</span><span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span>System.out.println(i.getAndDecrement());<span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0） </span>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0） </span>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><span class="hljs-keyword">final</span> System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));</code></pre></div><h2 id="4、原子引用"><a href="#4、原子引用" class="headerlink" title="4、原子引用"></a>4、原子引用</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;    <span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    </span><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccountImpl account)</span> </span>&#123;        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">long</span> start = System.nanoTime();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                account.withdraw(BigDecimal.TEN);            &#125;));        &#125;        ts.forEach(Thread::start);        ts.forEach(t -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                t.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        <span class="hljs-keyword">long</span> end = System.nanoTime();        System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;    <span class="hljs-comment">//原子引用，泛型类型为小数类型</span>    AtomicReference&lt;BigDecimal&gt; balance;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountImpl</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;BigDecimal&gt;(balance);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> balance.get();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            BigDecimal pre = balance.get();            BigDecimal next = pre.subtract(amount);            <span class="hljs-keyword">if</span>(balance.compareAndSet(pre, next)) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountImpl(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>)));    &#125;&#125;</code></pre></div><h2 id="5、ABA问题"><a href="#5、ABA问题" class="headerlink" title="5、ABA问题"></a>5、ABA问题</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            String pre = str.get();            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                other();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">//把str中的A改为C</span>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C &quot;</span> + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>));        &#125;).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            System.out.println(<span class="hljs-string">&quot;change A-&gt;B &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>));        &#125;).start();        Thread.sleep(<span class="hljs-number">500</span>);        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            System.out.println(<span class="hljs-string">&quot;change B-&gt;A &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>));        &#125;).start();    &#125;&#125;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png" alt="img"></a></p><p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;    <span class="hljs-comment">//指定版本号</span>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            String pre = str.getReference();            <span class="hljs-comment">//获得版本号</span>            <span class="hljs-keyword">int</span> stamp = str.getStamp();            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                other();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C stamp &quot;</span> + stamp + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));        &#125;).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-keyword">int</span> stamp = str.getStamp();            System.out.println(<span class="hljs-string">&quot;change A-&gt;B stamp &quot;</span> + stamp + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));        &#125;).start();        Thread.sleep(<span class="hljs-number">500</span>);        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-keyword">int</span> stamp = str.getStamp();            System.out.println(<span class="hljs-string">&quot;change B-&gt;A stamp &quot;</span> + stamp +  str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp+<span class="hljs-number">1</span>));        &#125;).start();    &#125;&#125;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png" alt="img"></a></p><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;    <span class="hljs-comment">//指定版本号</span>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            String pre = str.getReference();            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                other();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C mark &quot;</span> +  str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));        &#125;).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;change A-&gt;A mark &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));        &#125;).start();    &#125;&#125;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png" alt="img"></a></p><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul><li><strong>AtomicStampedReference</strong> 需要我们传入<strong>整型变量</strong>作为版本号，来判定是否被更改过</li><li><strong>AtomicMarkableReference</strong>需要我们传入<strong>布尔变量</strong>作为标记，来判断是否被更改过</li></ul><h2 id="6、原子数组"><a href="#6、原子数组" class="headerlink" title="6、原子数组"></a>6、原子数组</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray </li><li>AtomicReferenceArray</li></ul><h3 id="lamba表达式的使用"><a href="#lamba表达式的使用" class="headerlink" title="lamba表达式的使用"></a>lamba表达式的使用</h3><ul><li><p>提供者</p></li><li><p>无参又返回</p></li><li><p>()-&gt;返回结果</p></li><li><p>方法</p><ul><li>有参有返回</li><li>(参数一…)-&gt;返回结果</li></ul></li><li><p>消费者</p><ul><li>有参无返回</li><li>(参数一…)-&gt;void</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkipn3olxj30u00usthn.jpg" alt="image-20210415163935411"></p><p>不安全的数组</p><div class="hljs code-wrapper"><pre><code class="hljs java">demo(   ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>],   (array)-&gt;array.length,   (array, index) -&gt; array[index]++,   array-&gt; System.out.println(Arrays.toString(array)) );<span class="hljs-comment">//[9870, 9862, 9774, 9697, 9683, 9678, 9679, 9668, 9680, 9698]</span></code></pre></div><p>安全的数组</p><div class="hljs code-wrapper"><pre><code class="hljs java">demo(   ()-&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),   (array) -&gt; array.length(),   (array, index) -&gt; array.getAndIncrement(index),   array -&gt; System.out.println(array) );<span class="hljs-comment">//[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span></code></pre></div><h2 id="7、原子更新器"><a href="#7、原子更新器" class="headerlink" title="7、原子更新器"></a>7、原子更新器</h2><ul><li>AtomicReferenceFieldUpdater // 域 字段 </li><li>AtomicIntegerFieldUpdater </li><li>AtomicLongFieldUpdate</li></ul><p>原子更新器用于帮助我们改变某个对象中的某个属性</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Student student = <span class="hljs-keyword">new</span> Student();      <span class="hljs-comment">// 获得原子更新器</span>      <span class="hljs-comment">// 泛型</span>      <span class="hljs-comment">// 参数1 持有属性的类 参数2 被更新的属性的类</span>      <span class="hljs-comment">// newUpdater中的参数：第三个为属性的名称</span>      AtomicReferenceFieldUpdater&lt;Student, String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);      <span class="hljs-comment">// 修改</span>      updater.compareAndSet(student, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;LLL&quot;</span>);      System.out.println(student);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-keyword">volatile</span> String name;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +            <span class="hljs-string">&#x27;&#125;&#x27;</span>;   &#125;&#125;</code></pre></div><h3 id="原子更新器初始化过程"><a href="#原子更新器初始化过程" class="headerlink" title="原子更新器初始化过程"></a>原子更新器初始化过程</h3><p>从上面的例子可以看出，原子更新器是通过newUpdater来获取实例的。其中传入了三个参数</p><ul><li>拥有属性的类的Class</li><li>属性的Class</li><li>属性的名称</li></ul><p>大概可以猜出来，<strong>初始化过程用到了反射</strong>，让我们看看源码来验证一下这个猜测。</p><h4 id="newUpdater方法"><a href="#newUpdater方法" class="headerlink" title="newUpdater方法"></a>newUpdater方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U,W&gt; <span class="hljs-function">AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="hljs-title">newUpdater</span><span class="hljs-params">(Class&lt;U&gt; tclass,</span></span><span class="hljs-function"><span class="hljs-params">                                                                Class&lt;W&gt; vclass,</span></span><span class="hljs-function"><span class="hljs-params">                                                                String fieldName)</span> </span>&#123;    <span class="hljs-comment">// 返回了一个AtomicReferenceFieldUpdaterImpl实例</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;        (tclass, vclass, fieldName, Reflection.getCallerClass());&#125;</code></pre></div><p>从newUpdater方法还并不能看出来具体的初始化过程</p><h4 id="内部实现类"><a href="#内部实现类" class="headerlink" title="内部实现类"></a>内部实现类</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png" alt="img"></a></p><p>AtomicReferenceFieldUpdater为抽象类，该类<strong>内部有一个自己的实现类AtomicReferenceFieldUpdaterImpl</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceFieldUpdaterImpl</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">V</span>&gt;</span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AtomicReferenceFieldUpdater</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">V</span>&gt; </span></code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png" alt="img"></a></p><p><strong>构造方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">AtomicReferenceFieldUpdaterImpl(<span class="hljs-keyword">final</span> Class&lt;T&gt; tclass,                                <span class="hljs-keyword">final</span> Class&lt;V&gt; vclass,                                <span class="hljs-keyword">final</span> String fieldName,                                <span class="hljs-keyword">final</span> Class&lt;?&gt; caller) &#123;    <span class="hljs-comment">// 用于保存要被修改的属性</span>    <span class="hljs-keyword">final</span> Field field;    <span class="hljs-comment">// 属性的Class</span>    <span class="hljs-keyword">final</span> Class&lt;?&gt; fieldClass;    <span class="hljs-comment">// field的修饰符</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> modifiers;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 反射获得属性</span>        field = AccessController.doPrivileged(            <span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> Field <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;                    <span class="hljs-comment">// tclass为传入的属性的Class，可以通过它来获得属性</span>                    <span class="hljs-keyword">return</span> tclass.getDeclaredField(fieldName);                &#125;            &#125;);        <span class="hljs-comment">// 获得属性的修饰符，主要用于判断</span>        <span class="hljs-comment">// 1、vclass 与 属性确切的类型是否匹配</span>        <span class="hljs-comment">// 2、是否为引用类型</span>        <span class="hljs-comment">// 3、被修改的属性是否加了volatile关键字</span>        modifiers = field.getModifiers();        sun.reflect.misc.ReflectUtil.ensureMemberAccess(            caller, tclass, <span class="hljs-keyword">null</span>, modifiers);        ClassLoader cl = tclass.getClassLoader();        ClassLoader ccl = caller.getClassLoader();        <span class="hljs-keyword">if</span> ((ccl != <span class="hljs-keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;            ((cl == <span class="hljs-keyword">null</span>) || !isAncestor(cl, ccl))) &#123;            sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);        &#125;        <span class="hljs-comment">// 获得属性类的Class</span>        fieldClass = field.getType();    &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(pae.getException());    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);    &#125;    <span class="hljs-keyword">if</span> (vclass != fieldClass)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassCastException();    <span class="hljs-keyword">if</span> (vclass.isPrimitive())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Must be reference type&quot;</span>);    <span class="hljs-keyword">if</span> (!Modifier.isVolatile(modifiers))        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Must be volatile type&quot;</span>);    <span class="hljs-comment">// Access to protected field members is restricted to receivers only</span>    <span class="hljs-comment">// of the accessing class, or one of its subclasses, and the</span>    <span class="hljs-comment">// accessing class must in turn be a subclass (or package sibling)</span>    <span class="hljs-comment">// of the protected member&#x27;s defining class.</span>    <span class="hljs-comment">// If the updater refers to a protected field of a declaring class</span>    <span class="hljs-comment">// outside the current package, the receiver argument will be</span>    <span class="hljs-comment">// narrowed to the type of the accessing class.</span>     <span class="hljs-comment">// 对类中的属性进行初始化</span>    <span class="hljs-keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;                   tclass.isAssignableFrom(caller) &amp;&amp;                   !isSamePackage(tclass, caller))                  ? caller : tclass;    <span class="hljs-keyword">this</span>.tclass = tclass;    <span class="hljs-keyword">this</span>.vclass = vclass;    <span class="hljs-comment">// 获得偏移量</span>    <span class="hljs-keyword">this</span>.offset = U.objectFieldOffset(field);&#125;</code></pre></div><p><strong>可以看出，原子引用更新器确实使用了反射</strong></p><h2 id="8、LongAdder原理"><a href="#8、LongAdder原理" class="headerlink" title="8、LongAdder原理"></a>8、LongAdder原理</h2><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p> <a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png" alt="img"></a></p><p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png" alt="img"></a></p><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png" alt="img"></a></p><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1] </li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p><p>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p><p><strong>@sun.misc.Contended 用来解决这个问题</strong>，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png" alt="img"></a></p><p><strong>累加主要调用以下方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;       Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;       <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;           <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;           <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||               (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||               !(uncontended = a.cas(v = a.value, v + x)))               longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);       &#125;   &#125;</code></pre></div><p><strong>累加流程图</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png" alt="img"></a></p><h2 id="9、Unsafe"><a href="#9、Unsafe" class="headerlink" title="9、Unsafe"></a>9、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetUnsafe</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;        <span class="hljs-comment">// 通过反射获得Unsafe对象</span>        Class unsafeClass = Unsafe.class;        <span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span>        Constructor constructor = unsafeClass.getDeclaredConstructor();        <span class="hljs-comment">// 设置为允许访问私有内容</span>        constructor.setAccessible(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">// 创建Unsafe对象</span>        Unsafe unsafe = (Unsafe) constructor.newInstance();        <span class="hljs-comment">// 创建Person对象</span>        Person person = <span class="hljs-keyword">new</span> Person();        <span class="hljs-comment">// 获得其属性 name 的偏移量</span>        Field field = Person.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);        <span class="hljs-keyword">long</span> offset = unsafe.objectFieldOffset(field);        <span class="hljs-comment">// 通过unsafe的CAS操作改变值</span>        unsafe.compareAndSwapObject(person, offset, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;OOOOh&quot;</span>);        System.out.println(person);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span>     <span class="hljs-keyword">volatile</span> String name;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><p><strong>自定义AcomicData实现之前线程安全的原子整数Account实现</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpksjiq4abj30u00uh7cm.jpg" alt="image-20210415221945212"></p><p>Account 实现</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpkskfabo3j30tg0eyacp.jpg" alt="image-20210415222036997"></p><h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h3 id="1、不可变"><a href="#1、不可变" class="headerlink" title="1、不可变"></a>1、不可变</h3><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p><h3 id="2、不可变设计"><a href="#2、不可变设计" class="headerlink" title="2、不可变设计"></a>2、不可变设计</h3><h4 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-comment">/** The value is used for character storage. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];    <span class="hljs-comment">/** Cache the hash code for the string */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span>   <span class="hljs-comment">//....</span>  &#125;&#125;</code></pre></div><p>**ﬁnal 的使用 **<br>发现该类、类中所有属性都是 <strong>ﬁnal</strong>的</p><ul><li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改 </li><li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，<strong>防止子类无意间破坏不可变性</strong></li></ul><p>**保护性拷贝 **</p><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);        &#125;        <span class="hljs-keyword">int</span> subLen = value.length - beginIndex;        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);        &#125;        <span class="hljs-comment">//返回的是一个新的对象</span>        <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);    &#125;</code></pre></div><p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        &#125;        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);            &#125;            <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;                <span class="hljs-keyword">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span>        <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);        &#125;        <span class="hljs-keyword">this</span>.value = Arrays. OfRange(value, offset, offset+count);    &#125;Cop</code></pre></div><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【<strong>保护性拷贝</strong>（defensive  ）】</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><blockquote><p>Flyweight pattern是一个通过与其他类似对象共享尽可能多的数据来最小化内存使用的对象</p></blockquote><h6 id="自己DIY一个"><a href="#自己DIY一个" class="headerlink" title="自己DIY一个"></a>自己DIY一个</h6><p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时 预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约 了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;<span class="hljs-comment">// 1. 连接池大小 </span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;<span class="hljs-comment">// 2. 连接对象数组 </span>  <span class="hljs-keyword">private</span> Connection[] connections;<span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙 </span>  <span class="hljs-keyword">private</span> AtomicIntegerArray states;<span class="hljs-comment">// 4. 构造方法初始化 </span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<span class="hljs-keyword">this</span>.poolSize = poolSize;     <span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];     <span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;       connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));     &#125;&#125;  <span class="hljs-comment">// 5. 借连接 </span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;           <span class="hljs-comment">// 获取空闲连接 </span>          <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;           log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);                 <span class="hljs-keyword">return</span> connections[i];             &#125;           &#125;&#125;     <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待 </span>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">try</span> &#123;           log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);           <span class="hljs-keyword">this</span>.wait();         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();         &#125;&#125;&#125;&#125;  <span class="hljs-comment">// 6. 归还连接 </span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;           <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;             states.set(i, <span class="hljs-number">0</span>);             <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;              log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);               <span class="hljs-keyword">this</span>.notifyAll();             &#125;             <span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span> </span>&#123;   <span class="hljs-comment">// 实现略 </span>&#125;</code></pre></div><p>使用连接池：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Pool pool = <span class="hljs-keyword">new</span> Pool(<span class="hljs-number">2</span>); <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;     Connection conn = pool.borrow();     <span class="hljs-keyword">try</span> &#123;       Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;       e.printStackTrace();     &#125;     pool.free(conn);   &#125;).start();&#125;</code></pre></div><p>以上实现没有考虑：</p><ul><li>连接的动态增长与收缩 </li><li>连接保活（可用性检测） </li><li>等待超时处理 </li><li>分布式 hash</li></ul><p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p><h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="1、自定义线程池"><a href="#1、自定义线程池" class="headerlink" title="1、自定义线程池"></a>1、自定义线程池</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png" alt="img"></a></p><ul><li>阻塞队列中维护了由主线程（或者其他线程）所产生的的任务</li><li>主线程类似于<strong>生产者</strong>，产生任务并放入阻塞队列中</li><li>线程池类似于<strong>消费者</strong>，得到阻塞队列中已有的任务并执行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ThreadPool threadPool = <span class="hljs-keyword">new</span> ThreadPool(<span class="hljs-number">2</span>,  TimeUnit.SECONDS, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;         threadPool.execute(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;               TimeUnit.SECONDS.sleep(<span class="hljs-number">10000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">&quot;任务正在执行!&quot;</span>);         &#125;);      &#125;   &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 自定义线程池</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 自定义阻塞队列</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; blockingQueue;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 核心线程数</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> coreSize;   <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 用于指定线程最大存活时间</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> TimeUnit timeUnit;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timeout;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 工作线程类</span><span class="hljs-comment">    * 内部封装了Thread类，并且添加了一些属性</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;      Runnable task;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable task)</span> </span>&#123;         System.out.println(<span class="hljs-string">&quot;初始化任务&quot;</span>);         <span class="hljs-keyword">this</span>.task = task;      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-comment">// 如果有任务就执行</span>         <span class="hljs-comment">// 如果阻塞队列中有任务，就继续执行</span>         <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = blockingQueue.take()) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;               System.out.println(<span class="hljs-string">&quot;执行任务&quot;</span>);               task.run();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;               e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;               <span class="hljs-comment">// 任务执行完毕，设为空</span>               System.out.println(<span class="hljs-string">&quot;任务执行完毕&quot;</span>);               task = <span class="hljs-keyword">null</span>;            &#125;         &#125;         <span class="hljs-comment">// 移除任务</span>         <span class="hljs-keyword">synchronized</span> (workers) &#123;            System.out.println(<span class="hljs-string">&quot;移除任务&quot;</span>);            workers.remove(<span class="hljs-keyword">this</span>);         &#125;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> coreSize, TimeUnit timeUnit, <span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> capacity)</span> </span>&#123;      <span class="hljs-keyword">this</span>.coreSize = coreSize;      <span class="hljs-keyword">this</span>.timeUnit = timeUnit;      blockingQueue = <span class="hljs-keyword">new</span> BlockingQueue&lt;&gt;(capacity);      <span class="hljs-keyword">this</span>.timeout = timeout;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;      <span class="hljs-keyword">synchronized</span> (workers) &#123;         <span class="hljs-comment">// 创建任务</span>         <span class="hljs-comment">// 池中还有空余线程时，可以运行任务</span>         <span class="hljs-comment">// 否则阻塞</span>         <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;            Worker worker = <span class="hljs-keyword">new</span> Worker(task);            workers.add(worker);            worker.start();         &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;线程池中线程已用完，请稍等&quot;</span>);            blockingQueue.put(task);         &#125;      &#125;   &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 阻塞队列</span><span class="hljs-comment"> * 用于存放主线程或其他线程产生的任务</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 阻塞队列</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span>  Deque&lt;T&gt; blockingQueue;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 阻塞队列容量</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 锁</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> ReentrantLock lock;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 条件队列</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> Condition fullQueue;   <span class="hljs-keyword">private</span> Condition emptyQueue;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;      blockingQueue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(capacity);      lock = <span class="hljs-keyword">new</span> ReentrantLock();      fullQueue = lock.newCondition();      emptyQueue = lock.newCondition();      <span class="hljs-keyword">this</span>.capacity = capacity;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 获取任务的方法</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">// 加锁</span>      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// 如果阻塞队列为空（没有任务），就一直等待</span>         <span class="hljs-keyword">while</span> (blockingQueue.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;               emptyQueue.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;         &#125;         <span class="hljs-comment">// 获取任务并唤醒生产者线程</span>         T task = blockingQueue.removeFirst();         fullQueue.signalAll();         <span class="hljs-keyword">return</span> task;      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">takeNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;      <span class="hljs-comment">// 转换等待时间</span>      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);         <span class="hljs-keyword">while</span> (blockingQueue.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// awaitNanos会返回剩下的等待时间</span>               nanos = emptyQueue.awaitNanos(nanos);               <span class="hljs-keyword">if</span> (nanos &lt; <span class="hljs-number">0</span>) &#123;                  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;               &#125;            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;         &#125;         T task = blockingQueue.removeFirst();         fullQueue.signalAll();         <span class="hljs-keyword">return</span> task;      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 放入任务的方法</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> task 放入阻塞队列的任务</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T task)</span> </span>&#123;      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">while</span> (blockingQueue.size() == capacity) &#123;            <span class="hljs-keyword">try</span> &#123;               System.out.println(<span class="hljs-string">&quot;阻塞队列已满&quot;</span>);               fullQueue.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;               e.printStackTrace();            &#125;         &#125;         blockingQueue.add(task);         <span class="hljs-comment">// 唤醒等待的消费者</span>         emptyQueue.signalAll();      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;      lock.lock();      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-keyword">return</span> blockingQueue.size();      &#125; <span class="hljs-keyword">finally</span> &#123;         lock.unlock();      &#125;   &#125;&#125;</code></pre></div><p>实现了一个简单的线程池</p><ul><li>阻塞队列BlockingQueue用于暂存来不及被线程执行的任务<ul><li>也可以说是平衡生产者和消费者执行速度上的差异</li><li>里面的获取任务和放入任务用到了<strong>生产者消费者模式</strong></li></ul></li><li>线程池中对线程Thread进行了再次的封装，封装为了Worker<ul><li>在调用任务的run方法时，线程会去执行该任务，执行完毕后还会<strong>到阻塞队列中获取新任务来执行</strong></li></ul></li><li>线程池中执行任务的主要方法为execute方法<ul><li>执行时要判断正在执行的线程数是否大于了线程池容量</li></ul></li></ul><h2 id="2、ThreadPoolExecutor"><a href="#2、ThreadPoolExecutor" class="headerlink" title="2、ThreadPoolExecutor"></a>2、ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png" alt="img"></a></p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 线程池状态</span><span class="hljs-comment">// runState is stored in the high-order bits</span><span class="hljs-comment">// RUNNING 高3位为111</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// SHUTDOWN 高3位为000</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 高3位 001</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 高3位 010</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">// 高3位 011</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;</code></pre></div><table><thead><tr><th>状态名称</th><th>高3位的值</th><th>描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>接收新任务，同时处理任务队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>不接受新任务，但是处理任务队列中的任务</td></tr><tr><td>STOP</td><td>001</td><td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td></tr><tr><td>TIDYING</td><td>010</td><td>任务执行完毕，活动线程为0时，即将进入终结阶段</td></tr><tr><td>TERMINATED</td><td>011</td><td>终结状态</td></tr></tbody></table><p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p><ul><li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<span class="hljs-comment">// 并不是所有平台的int都是32位。</span><span class="hljs-comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span><span class="hljs-comment">// 高3位为0，剩余位数全为1</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<span class="hljs-comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span><span class="hljs-comment">// CAPACITY 的高3位为 0</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;</code></pre></div><p>获取线程池状态、线程数量以及合并两个值的操作</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Packing and unpacking ctl</span><span class="hljs-comment">// 获取运行状态</span><span class="hljs-comment">// 该操作会让除高3位以外的数全部变为0</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<span class="hljs-comment">// 获取运行线程数</span><span class="hljs-comment">// 该操作会让高3位为0</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<span class="hljs-comment">// 计算ctl新值</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;</code></pre></div><h3 id="线程池属性"><a href="#线程池属性" class="headerlink" title="线程池属性"></a>线程池属性</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 工作线程，内部封装了Thread</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    ...&#125;<span class="hljs-comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<span class="hljs-comment">// 锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();</code></pre></div><h3 id="构造方法极其参数"><a href="#构造方法极其参数" class="headerlink" title="构造方法极其参数"></a>构造方法极其参数</h3><p><strong>ThreadPoolExecutor最全面的构造方法</strong></p><p>也是构造自定义线程池的方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span></code></pre></div><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h4><ul><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数<ul><li>maximumPoolSize - corePoolSize = 救急线程数</li></ul></li><li>keepAliveTime：救急线程空闲时的最大生存时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列（存放任务）<ul><li>有界阻塞队列 ArrayBlockingQueue</li><li>无界阻塞队列 LinkedBlockingQueue</li><li>最多只有一个同步元素的 SynchronousQueue</li><li>优先队列 PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂（给线程取名字）</li><li>handler：拒绝策略</li></ul><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>当一个任务传给线程池以后，可能有以下几种可能<ul><li>将任务分配给一个核心线程来执行</li><li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li><li><strong>阻塞队列满了，使用救急线程</strong>来执行任务<ul><li>救急线程用完以后，超过生存时间（keepAliveTime）后会被释放</li></ul></li><li>任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略</li></ul></li></ul><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png" alt="img"></a></p><ul><li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>这是默认策略</strong></li><li>CallerRunsPolicy：让调用者运行任务</li><li>DiscardPolicy：放弃本次任务</li><li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-keyword">static</span> AtomicInteger threadId = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 手动创建线程池</span>      <span class="hljs-comment">// 创建有界阻塞队列</span>      ArrayBlockingQueue&lt;Runnable&gt; runnable = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">10</span>);      <span class="hljs-comment">// 创建线程工厂</span>      ThreadFactory threadFactory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;            Thread thread = <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;working_thread_&quot;</span>+threadId.getAndIncrement());            <span class="hljs-keyword">return</span> thread;         &#125;      &#125;;      <span class="hljs-comment">// 手动创建线程池</span>      <span class="hljs-comment">// 拒绝策略采用默认策略</span>      ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS, runnable, threadFactory);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;         executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;               System.out.println(Thread.currentThread());               <span class="hljs-keyword">try</span> &#123;                  Thread.sleep(<span class="hljs-number">100000</span>);               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                  e.printStackTrace();               &#125;            &#125;         &#125;);      &#125;   &#125;&#125;</code></pre></div><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//没有救急线程，阻塞队列是无界的，可以放任意数量的任务</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFixedThreadPool</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 自定义线程工厂</span>      ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;         AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;myPool_&quot;</span> + atomicInteger.getAndIncrement());         &#125;      &#125;;      <span class="hljs-comment">// 创建核心线程数量为2的线程池</span>      <span class="hljs-comment">// 通过 ThreadFactory可以给线程添加名字</span>      ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">2</span>, factory);      <span class="hljs-comment">// 任务</span>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(Thread.currentThread().getName());            System.out.println(<span class="hljs-string">&quot;this is fixedThreadPool&quot;</span>);         &#125;      &#125;;      executorService.execute(runnable);   &#125;&#125;</code></pre></div><p>固定大小的线程池可以传入两个参数</p><ul><li>核心线程数：nThreads</li><li>线程工厂：threadFactory</li></ul><p>内部调用的构造方法</p><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadPoolExecutor(nThreads, nThreads,                              <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                              <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),                              threadFactory);</code></pre></div><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><div class="hljs code-wrapper"><pre><code class="hljs java">ExecutorService executorService = Executors.newCachedThreadPool();</code></pre></div><p><strong>内部构造方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                              <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                              <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</code></pre></div><ul><li><p>没有核心线程，最大线程数为Integer.MAX_VALUE，<strong>所有创建的线程都是救急线程</strong>，空闲时生存时间为60秒</p></li><li><p>阻塞队列使用的是SynchronousQueue</p><ul><li>SynchronousQueue是一种特殊的队列<ul><li><strong>没有容量</strong>，没有线程来取是放不进去的</li><li>只有当线程取任务时，才会将任务放入该阻塞队列中</li></ul></li></ul></li></ul><h3 id="SingleThread"><a href="#SingleThread" class="headerlink" title="SingleThread"></a>SingleThread</h3><div class="hljs code-wrapper"><pre><code class="hljs java">ExecutorService service = Executors.newSingleThreadExecutor();</code></pre></div><p><strong>内部构造方法</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService    (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                            <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                            <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</code></pre></div><p>内部调用了<strong>new ThreadPoolExecutor</strong>的构造方法，传入的corePoolSize和maximumPoolSize都为1。然后将该对象传给了FinalizableDelegatedExecutorService。该类修饰了ThreadPoolExecutor，让外部无法调用ThreadPoolExecutor内部的某些方法来修改所创建的线程池的大小。</p><h4 id="几个注意"><a href="#几个注意" class="headerlink" title="几个注意"></a>几个注意</h4><ul><li><p>SingleThread和自己创建一个线程来运行多个任务的区别</p><ul><li>当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而<strong>SingleThread会创建一个新线程，继续执行任务队列中剩余的任务</strong>。</li></ul></li><li><p>SingleThread和newFixedThreadPool(1)的区别</p><ul><li>newFixedThreadPool(1)传值为1，可以将FixedThreadPool强转为ThreadPoolExecutor，然后通过setCorePoolSize改变核心线程数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 强转为ThreadPoolExecutor</span>ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<span class="hljs-comment">// 改变核心线程数</span>threadPool.setCorePoolSize(<span class="hljs-number">2</span>);</code></pre></div><ul><li>而SingleThread无法修改核心线程数</li></ul></li></ul><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java">execute(Runnable command)</code></pre></div><p>传入一个Runnable对象，执行其中的run方法</p><p><strong>源码解析</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">// 获取ctl</span>    <span class="hljs-keyword">int</span> c = ctl.get();    <span class="hljs-comment">// 判断当前启用的线程数是否小于核心线程数</span>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;        <span class="hljs-comment">// 为该任务分配线程</span>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))            <span class="hljs-comment">// 分配成功就返回</span>            <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 分配失败再次获取ctl</span>        c = ctl.get();    &#125;    <span class="hljs-comment">// 分配和信息线程失败以后</span>    <span class="hljs-comment">// 如果池状态为RUNNING并且插入到任务队列成功</span>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        <span class="hljs-comment">// 双重检测，可能在添加后线程池状态变为了非RUNNING</span>        <span class="hljs-keyword">int</span> recheck = ctl.get();        <span class="hljs-comment">// 如果池状态为非RUNNING，则不会执行新来的任务</span>        <span class="hljs-comment">// 将该任务从阻塞队列中移除</span>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))            <span class="hljs-comment">// 调用拒绝策略，拒绝该任务的执行</span>            reject(command);        <span class="hljs-comment">// 如果没有正在运行的线程</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)            <span class="hljs-comment">// 就创建新线程来执行该任务</span>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">// 如果添加失败了（任务队列已满），就调用拒绝策略</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))        reject(command);&#125;</code></pre></div><p>其中调用了**addWoker()**方法，再看看看这个方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;    retry:    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-keyword">int</span> rs = runStateOf(c);        <span class="hljs-comment">// Check if queue empty only if necessary.</span>        <span class="hljs-comment">// 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务</span>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;            ! (rs == SHUTDOWN &amp;&amp;               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;               ! workQueue.isEmpty()))            <span class="hljs-comment">// 创建新线程失败</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">// 获得当前工作线程数</span>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);            <span class="hljs-comment">// 参数中 core 为true</span>            <span class="hljs-comment">// CAPACITY 为 1 &lt;&lt; COUNT_BITS-1，一般不会超过</span>            <span class="hljs-comment">// 如果工作线程数大于了核心线程数，则创建失败</span>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||                wc &gt;= (core ? corePoolSize : maximumPoolSize))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 通过CAS操作改变c的值</span>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                <span class="hljs-comment">// 更改成功就跳出多重循环，且不再运行循环</span>                <span class="hljs-keyword">break</span> retry;            <span class="hljs-comment">// 更改失败，重新获取ctl的值</span>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)                <span class="hljs-comment">// 跳出多重循环，且重新进入循环</span>                <span class="hljs-keyword">continue</span> retry;            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>        &#125;    &#125;    <span class="hljs-comment">// 用于标记work中的任务是否成功执行</span>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 用于标记worker是否成功加入了线程池中</span>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;    Worker w = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 创建新线程来执行任务</span>        w = <span class="hljs-keyword">new</span> Worker(firstTask);        <span class="hljs-keyword">final</span> Thread t = w.thread;        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;            <span class="hljs-comment">// 加锁</span>            mainLock.lock();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// Recheck while holding lock.</span>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span>                <span class="hljs-comment">// shut down before lock acquired.</span>                <span class="hljs-comment">// 加锁的同时再次检测</span>                <span class="hljs-comment">// 避免在释放锁之前调用了shut down</span>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();                    <span class="hljs-comment">// 将线程添加到线程池中</span>                    workers.add(w);                    <span class="hljs-keyword">int</span> s = workers.size();                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                        largestPoolSize = s;                    <span class="hljs-comment">// 添加成功标志位变为true</span>                    workerAdded = <span class="hljs-keyword">true</span>;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                mainLock.unlock();            &#125;            <span class="hljs-comment">// 如果worker成功加入了线程池，就执行其中的任务</span>            <span class="hljs-keyword">if</span> (workerAdded) &#123;                t.start();                <span class="hljs-comment">// 启动成功</span>                workerStarted = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 如果执行失败</span>        <span class="hljs-keyword">if</span> (! workerStarted)            <span class="hljs-comment">// 调用添加失败的函数</span>            addWorkerFailed(w);    &#125;    <span class="hljs-keyword">return</span> workerStarted;&#125;</code></pre></div><h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a>submit()方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span></code></pre></div><p>传入一个Callable对象，用Future来<strong>捕获返回值</strong></p><p><strong>使用</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 通过submit执行Callable中的call方法</span><span class="hljs-comment">// 通过Future来捕获返回值</span>Future&lt;String&gt; future = threadPool.submit(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello submit&quot;</span>;   &#125;&#125;);<span class="hljs-comment">// 查看捕获的返回值</span>System.out.println(future.get());</code></pre></div><h4 id="invokeAll-方法"><a href="#invokeAll-方法" class="headerlink" title="invokeAll()方法"></a>invokeAll()方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 提交 tasks 中所有任务 </span>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)   <span class="hljs-keyword">throws</span> InterruptedException;</code></pre></div><h4 id="invokeAny-方法"><a href="#invokeAny-方法" class="headerlink" title="invokeAny()方法"></a>invokeAny()方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消 </span>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;</code></pre></div><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><p>线程池状态变为SHUTDOWN</p><ul><li>不会接收新任务</li><li>但已提交任务会执行完</li><li>此方法不会阻塞调用线程的执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 将线程池的状态改为 SHUTDOWN</span><span class="hljs-comment">* 不再接受新任务，但是会将阻塞队列中的任务执行完</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        checkShutdownAccess();        <span class="hljs-comment">// 修改线程池状态为 SHUTDOWN</span>        advanceRunState(SHUTDOWN);          <span class="hljs-comment">// 中断空闲线程（没有执行任务的线程）</span>        <span class="hljs-comment">// Idle：空闲的</span>        interruptIdleWorkers();        onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span>    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;    <span class="hljs-comment">// 尝试终结，不一定成功</span>    tryTerminate();&#125; <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-comment">// 终结失败的条件</span>        <span class="hljs-comment">// 线程池状态为RUNNING</span>        <span class="hljs-comment">// 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）</span>        <span class="hljs-comment">// 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行</span>        <span class="hljs-keyword">if</span> (isRunning(c) ||            runStateAtLeast(c, TIDYING) ||            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))            <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 如果活跃线程数不为0</span>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span>            <span class="hljs-comment">// 中断空闲线程</span>            interruptIdleWorkers(ONLY_ONE);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;        mainLock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 处于可以终结的状态</span>            <span class="hljs-comment">// 通过CAS将线程池状态改为TIDYING</span>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;                <span class="hljs-keyword">try</span> &#123;                    terminated();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">// 通过CAS将线程池状态改为TERMINATED</span>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));                    termination.signalAll();                &#125;                <span class="hljs-keyword">return</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            mainLock.unlock();        &#125;        <span class="hljs-comment">// else retry on failed CAS</span>    &#125;&#125;</code></pre></div><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 将线程池的状态改为 STOP</span><span class="hljs-comment">* 不再接受新任务，也不会在执行阻塞队列中的任务</span><span class="hljs-comment">* 会将阻塞队列中未执行的任务返回给调用者</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;    List&lt;Runnable&gt; tasks;    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        checkShutdownAccess();        <span class="hljs-comment">// 修改状态为STOP，不执行任何任务</span>        advanceRunState(STOP);        <span class="hljs-comment">// 中断所有线程</span>        interruptWorkers();        <span class="hljs-comment">// 将未执行的任务从队列中移除，然后返回给调用者</span>        tasks = drainQueue();    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;    <span class="hljs-comment">// 尝试终结，一定会成功，因为阻塞队列为空了</span>    tryTerminate();    <span class="hljs-keyword">return</span> tasks;&#125;</code></pre></div><h2 id="3、创建多少线程池"><a href="#3、创建多少线程池" class="headerlink" title="3、创建多少线程池"></a>3、创建多少线程池</h2><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><h4 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a>CPU 密集型运算</h4><p>通常采用<code>cpu核数+1</code>能够实现最优的CPU利用率，+1是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证CPU时钟周期不被浪费</p><h4 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I/O 密集型运算"></a>I/O 密集型运算</h4><p>CPU不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用CPU资源，但当你执行I/O操作时、远程RPC调用时，包括进行数据库操作时，这时候CPU就闲下来了，你可以利用多线程提高它的利用率。</p><p>经验公式如下</p><p><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code></p><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p><p><code>4 * 100% * 100% / 50% = 8</code></p><p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p><p><code>4 * 100% * 100% / 10% = 40</code></p><h2 id="4、Tomcat线程池"><a href="#4、Tomcat线程池" class="headerlink" title="4、Tomcat线程池"></a>4、Tomcat线程池</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplpdijconj31ag0bmdkl.jpg" alt="image-20210416171541056"></p><ul><li>LimitLatch用来限流，可以控制最大连接个数，类似J.U.C中的Semaphore后面再讲</li><li>Acceptor只负责【接收新的socket连接】</li><li>Poller只负责监听socketchannel是否有【可读的I/O事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给Executor线程池处理</li><li>Executor线程池中的工作线程最终负责【处理请求】</li></ul><p><strong>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</strong></p><ul><li>如果总线程数达到 maximumPoolSize<ul><li>这时不会立刻抛 RejectedExecutionException 异常 </li><li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li></ul></li></ul><p>源码 tomcat-7.0.42</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;submittedCount.incrementAndGet();   <span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">super</span>.execute(command);   &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">super</span>.getQueue() <span class="hljs-keyword">instanceof</span> TaskQueue) &#123;<span class="hljs-keyword">final</span> TaskQueue queue = (TaskQueue)<span class="hljs-keyword">super</span>.getQueue();<span class="hljs-keyword">try</span> &#123;             <span class="hljs-keyword">if</span> (!queue.force(command, timeout, unit)) &#123;            submittedCount.decrementAndGet();             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Queue capacity is full.&quot;</span>);           &#125;&#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;             submittedCount.decrementAndGet();            Thread.interrupted();             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(x);&#125;      &#125; <span class="hljs-keyword">else</span> &#123;         submittedCount.decrementAndGet();         <span class="hljs-keyword">throw</span> rx;       &#125;&#125;&#125;</code></pre></div><p>Connector 配置</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplpsby8wnj31d00fiwhd.jpg" alt="image-20210416172958903"></p><p>Executor 线程配置</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplpsqz78uj31d40kiwir.jpg" alt="image-20210416173023391"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplptha33fj319a0c876b.jpg" alt="image-20210416173104274"></p><h2 id="5、Fork-Join"><a href="#5、Fork-Join" class="headerlink" title="5、Fork/Join"></a>5、Fork/Join</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算 </li><li>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解 </li><li>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率 </li><li>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</li></ul><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><p>提交给Fork/Join线程池的任务需要继承RecursiveTask（有返回值）或RecursiveAction（没有返回值），例如下面定义了一个对1~n之间的整数求和的任务</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplpzqfow9j30u00zpthz.jpg" alt="image-20210416173704832"></p><p>然后提交给 ForkJoinPool 来执行</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">4</span>);   System.out.println(pool.invoke(<span class="hljs-keyword">new</span> AddTask1(<span class="hljs-number">5</span>))); &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java">[ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">0</span>] - fork() <span class="hljs-number">2</span> + &#123;<span class="hljs-number">1</span>&#125; [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] - fork() <span class="hljs-number">5</span> + &#123;<span class="hljs-number">4</span>&#125; [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">0</span>] - join() <span class="hljs-number">1</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">0</span>] - join() <span class="hljs-number">2</span> + &#123;<span class="hljs-number">1</span>&#125; = <span class="hljs-number">3</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] - fork() <span class="hljs-number">4</span> + &#123;<span class="hljs-number">3</span>&#125; [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span>] - fork() <span class="hljs-number">3</span> + &#123;<span class="hljs-number">2</span>&#125; [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">3</span>] - join() <span class="hljs-number">3</span> + &#123;<span class="hljs-number">2</span>&#125; = <span class="hljs-number">6</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span>] - join() <span class="hljs-number">4</span> + &#123;<span class="hljs-number">3</span>&#125; = <span class="hljs-number">10</span> [ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>] - join() <span class="hljs-number">5</span> + &#123;<span class="hljs-number">4</span>&#125; = <span class="hljs-number">15</span> <span class="hljs-number">15</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpltkmas1yj31d00dggnq.jpg" alt="image-20210416194057872"></p><h1 id="八、J-U-C"><a href="#八、J-U-C" class="headerlink" title="八、J.U.C"></a>八、J.U.C</h1><h2 id="1、AQS"><a href="#1、AQS" class="headerlink" title="1、AQS"></a>1、AQS</h2><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><p><strong>特点：</strong></p><ul><li><p>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p><ul><li>getState - 获取 state 状态 </li><li>setState - 设置 state 状态 </li><li>compareAndSetState - cas 机制设置 state 状态 </li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 </li></ul></li><li><p>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList </p></li><li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</p></li></ul><p><strong>子类主要实现这样一些方法</strong>（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire </li><li>tryRelease </li><li>tryAcquireShared </li><li>tryReleaseShared </li><li>isHeldExclusively</li></ul><p>获取锁的姿势</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果获取锁失败 </span><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123;   <span class="hljs-comment">// 入队, 可以选择阻塞当前线程 park unpark</span>&#125;</code></pre></div><p>释放锁的姿势</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果释放锁成功 </span><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;   <span class="hljs-comment">// 让阻塞线程恢复运行 </span>&#125;</code></pre></div><h4 id="实现不可重入锁"><a href="#实现不可重入锁" class="headerlink" title="实现不可重入锁"></a>实现不可重入锁</h4><p>自定义锁</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 自定义锁（不可重入锁）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;    <span class="hljs-comment">// 独占锁  同步器类</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;                <span class="hljs-comment">// 加上了锁，并设置 owner 为当前线程</span>                setExclusiveOwnerThread(Thread.currentThread());                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);            setState(<span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 是否持有独占锁</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();        &#125;    &#125;    <span class="hljs-keyword">private</span> MySync sync = <span class="hljs-keyword">new</span> MySync();    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 加锁（不成功会进入等待队列）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        sync.acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 加锁，可打断</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        sync.acquireInterruptibly(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 尝试加锁（一次）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 尝试加锁，带超时</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 解锁</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        sync.release(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 创建条件变量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sync.newCondition();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAqs</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyLock lock = <span class="hljs-keyword">new</span> MyLock();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);                sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">finally</span> &#123;                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);                lock.unlock();            &#125;        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            lock.lock();            <span class="hljs-keyword">try</span> &#123;                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);            &#125; <span class="hljs-keyword">finally</span> &#123;                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);                lock.unlock();            &#125;        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre></div><p>输出</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">28.727</span> c.TestAqs [t1] - locking... <span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">29.732</span> c.TestAqs [t1] - unlocking... <span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">29.732</span> c.TestAqs [t2] - locking... <span class="hljs-number">22</span>:<span class="hljs-number">29</span>:<span class="hljs-number">29.732</span> c.TestAqs [t2] - unlocking...</code></pre></div><p>不可重入测试</p><p>如果改为下面代码，会发现自己也会被挡住（只会打印一次 locking）</p><div class="hljs code-wrapper"><pre><code class="hljs java">lock.lock(); log.debug(<span class="hljs-string">&quot;locking...&quot;</span>); lock.lock(); log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);</code></pre></div><h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不够优雅，于是在JSR166（java规范提案）中创建了AQS，提供了这种通用的同步器机制。</p><p><strong>目标</strong></p><p>AQS 要实现的功能目标</p><ul><li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire </li><li>获取锁超时机制</li><li>通过打断取消机制 </li><li>独占机制及共享机制 </li><li>条件不满足时的等待机制</li></ul><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>AQS 的基本思想其实很简单</p><p>获取锁的逻辑</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(state 状态不允许获取) &#123;   <span class="hljs-keyword">if</span>(队列中还没有此线程) &#123;    入队并阻塞   &#125; &#125; 当前线程出队</code></pre></div><p>释放锁的逻辑</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(state 状态允许了) &#123;   恢复阻塞的线程(s) &#125;</code></pre></div><p>要点</p><ul><li>原子维护 state 状态 </li><li>阻塞及恢复线程 </li><li>维护队列</li></ul><p><strong>(1)state设计</strong></p><ul><li>state 使用 volatile 配合 cas 保证其修改时的原子性 </li><li>state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想</li></ul><p><strong>(2)阻塞恢复设计</strong></p><ul><li>早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume 那么 suspend 将感知不到</li><li>解决方法是使用 park &amp; unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark 再 park 也没问题 </li><li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</li><li>park 线程还可以通过 interrupt 打断</li></ul><p><strong>(3)队列设计</strong></p><ul><li>使用了 FIFO 先入先出队列，并不支持优先级队列 </li><li>设计时借鉴了 CLH 队列，它是一种单向无锁队列</li></ul><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gplus4v425j30p60rsjto.jpg" alt="image-20210416202245564" style="zoom:50%;" /><p>队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态 </p><p>入队伪代码，只需要考虑 tail 赋值的原子性</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<span class="hljs-comment">// 原来的 tail </span> Node prev = tail; <span class="hljs-comment">// 用 cas 在原来 tail 的基础上改为 node </span>&#125; <span class="hljs-keyword">while</span>(tail.compareAndSet(prev, node))</code></pre></div><p>出队伪代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// prev 是上一个节点 </span><span class="hljs-keyword">while</span>((Node prev=node.prev).state != 唤醒状态) &#123; &#125; <span class="hljs-comment">// 设置头节点 </span>head = node;</code></pre></div><p>CLH 好处：</p><ul><li>无锁，使用自旋</li><li>快速，无阻塞</li></ul><p>AQS 在一些方面改进了 CLH</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<span class="hljs-keyword">for</span> (;;) &#123;       Node t = tail;      <span class="hljs-comment">// 队列中还没有元素 tail 为 null </span>      <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">// 将 head 从 null -&gt; dummy </span>        <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))           tail = head;       &#125;<span class="hljs-keyword">else</span>&#123;         <span class="hljs-comment">// 将 node 的 prev 设置为原来的 tail </span>        node.prev = t;         <span class="hljs-comment">// 将 tail 从原来的 tail 设置为 node </span>        <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;           <span class="hljs-comment">// 原来 tail 的 next 设置为 node </span>          t.next = node;           <span class="hljs-keyword">return</span> t;         &#125;&#125;&#125;&#125;</code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpluy79sipj31fe0k048c.jpg" alt="image-20210416202836479"></p><h2 id="2、ReentranLock"><a href="#2、ReentranLock" class="headerlink" title="2、ReentranLock"></a>2、ReentranLock</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1uh4accj30vs0fudir.jpg" alt="image-20210418175513322"></p><h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a><strong>非公平锁实现原理</strong></h3><p><strong>加锁解锁流程</strong></p><p>先从构造器开始看，默认为非公平锁实现</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;   sync = <span class="hljs-keyword">new</span> NonfairSync(); &#125;</code></pre></div><p>NonfairSync 继承自 AQS</p><p>没有竞争时</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1vlvso1j30u20eaabh.jpg" alt="image-20210418175927482"></p><p>第一个竞争出现时</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1w3ptbhj30uy0e20va.jpg" alt="image-20210418175955873"></p><p>Thread-1 执行了</p><ol><li>CAS 尝试将 state 由 0 改为 1，结果失败</li><li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li><li>接下来进入 addWaiter 逻辑，构造 Node 队列 <ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态 </li><li>Node 的创建是懒惰的 </li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ul></li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1xpsvhxj30za0cmac3.jpg" alt="image-20210418180129167"></p><p>当前线程进入 acquireQueued 逻辑</p><ol><li><p>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</p></li><li><p>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</p></li><li><p>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1z9xf6sj30z40cuwgk.jpg" alt="image-20210418180257642"></p><ol start="4"><li><p>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</p></li><li><p>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</p></li><li><p>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo1zpcge6j30zk0cen05.jpg" alt="image-20210418180324526"></p><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo24izl02j310008a3zx.jpg" alt="image-20210418180345185"></p><p>Thread-0释放锁，进入tryRelease流程，如果成功</p><ul><li>设置exclusiveOwnerThread为null</li><li>state=0</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo20zf7azj310407u0up.jpg" alt="image-20210418180436882"></p><p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程</p><p>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1 </p><p>回到 Thread-1 的 acquireQueued 流程</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo21l0tmuj310608kta0.jpg" alt="image-20210418180512195"></p><p>如果加锁成功（没有竞争），会设置 </p><ul><li>exclusiveOwnerThread 为 Thread-1，state = 1 </li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread </li><li>原本的 head 因为从链表断开，而可被垃圾回收 </li></ul><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo22axqamj310c09oaco.jpg" alt="image-20210418180554170"></p><p>如果不巧又被 Thread-4 占了先</p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state = 1 </li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ul><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;   <span class="hljs-comment">// ...</span><span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处 </span>  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<span class="hljs-keyword">final</span> Thread current = Thread.currentThread();     <span class="hljs-keyword">int</span> c = getState();     <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;           setExclusiveOwnerThread(current);           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;         &#125;       &#125;    <span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入 </span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;       <span class="hljs-comment">// state++ </span>      <span class="hljs-keyword">int</span> nextc = c + acquires;       <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow </span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);       setState(nextc);       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;  <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处 </span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<span class="hljs-comment">// state--</span>    <span class="hljs-keyword">int</span> c = getState() - releases;     <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();     <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;     <span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功 </span>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;free = <span class="hljs-keyword">true</span>;setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);&#125;setState(c);     <span class="hljs-keyword">return</span> free; &#125;&#125;</code></pre></div><h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><p><strong>不可打断模式</strong></p><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能继续运行（是继续运行，只是打断标记被设置为true）</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo2gotu50j30u012rn3q.jpg" alt="image-20210418181943236"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo2h1aa9ij30sy0dedhe.jpg" alt="image-20210418182001896"></p><p><strong>可打断模式</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo2hpjb09j30u00xvdmc.jpg" alt="image-20210418182041288"></p><h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo2ilonptj30u010gwl3.jpg" alt="image-20210418182132330"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2iz4ws1j30s40agq4t.jpg" alt="image-20210418182154563"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2j8je4cj30q604gmxi.jpg" alt="image-20210418182210122"></p><h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p><p><strong>await 流程</strong></p><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程 </p><p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2kdqpmkj31ay0gwjuw.jpg" alt="image-20210418182314247"></p><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2kqp1clj31bc0ha77n.jpg" alt="image-20210418182335941"></p><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2l55unlj31bg0haado.jpg" alt="image-20210418182359834"></p><p>park 阻塞 Thread-0</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2lnbfbij31bq0h4q6h.jpg" alt="image-20210418182428801"></p><p><strong>signal 流程</strong></p><p>假设 Thread-1 要来唤醒 Thread-0</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2m6dzi5j31au0lujvm.jpg" alt="image-20210418182459334"></p><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2mlbrz8j31am0luaea.jpg" alt="image-20210418182522585"></p><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo2n1hqisj31b20h477k.jpg" alt="image-20210418182547437"></p><p>Thread-1 释放锁，进入 unlock 流程</p><h2 id="3、ReentranReadWriteLock"><a href="#3、ReentranReadWriteLock" class="headerlink" title="3、ReentranReadWriteLock"></a>3、ReentranReadWriteLock</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>当读操作远远高于写操作时，这时候使用<code>读写锁</code>让<code>读-读</code>提高性能。 类似于数据库中的 <code>select ... from ... lock in share mode</code></p><p><strong>注意事项</strong></p><ul><li>读锁不支持条件变量 </li><li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li></ul><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo6c2t414j30xs0iqwfq.jpg" alt="image-20210418203339576" style="zoom: 67%;" /><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>更新时，是先清缓存还是先更新数据库 </p><p><strong>先清缓存</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo6k508roj31840k0q54.jpg" alt="image-20210418204125189"></p><p><strong>先更新数据库（通常使用的）</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo6kwvm2mj30v00u00yi.jpg" alt="image-20210418204208526"></p><p>这种情况的出现几率非常小，见 facebook 论文</p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p><p><strong>t1 w.lock，t2 r.lock</strong></p><p>1） t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁 使用的是 state 的高 16 位</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo6fn47u7j30uu0kk0v1.jpg" alt="image-20210418203705054"  /><p>2）t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写 锁占据，那么 tryAcquireShared 返回 -1 表示失败</p><blockquote><p>tryAcquireShared 返回值表示 </p><ul><li>-1 表示失败</li><li>0 表示成功，但后继节点不会继续唤醒 </li><li>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</li></ul></blockquote><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpo6hjkzjwj30v80ksgo3.jpg" alt="image-20210418203853099"  /><p>3）这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo70kto80j312m0hyacj.jpg" alt="image-20210418205713020"></p><p>4）t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</p><p>5）如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo711ahexj312o0iyn00.jpg" alt="image-20210418205738331"></p><p><strong>t3 r.lock，t4 w.lock</strong></p><p>这种状态下，假设又有 t3 加读锁（共享状态Shared）和 t4 加写锁（独占状态Ex），这期间 t1 仍然持有锁，就变成了下面的样子</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo78pxcpdj31d20fqmzx.jpg" alt="image-20210418210503783"></p><p><strong>t1 w.unlock</strong></p><p>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7akuhgwj31dw0fcgo9.jpg" alt="image-20210418210650519"></p><p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7bb28gtj31ei0g0whg.jpg" alt="image-20210418210732099"></p><p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7e9zj7uj31de0iujuu.jpg" alt="image-20210418211022747"></p><p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 （为了防止其他线程重复唤醒）并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7fah466j31ee0j00wa.jpg" alt="image-20210418211121650"></p><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7g68m2gj31e20is0wa.jpg" alt="image-20210418211213069"></p><p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7gmq2taj31da0oyaeb.jpg" alt="image-20210418211239666"></p><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p><p><strong>t2 r.unlock，t3 r.unlock</strong></p><p>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7hftc0dj31dc0omaet.jpg" alt="image-20210418211326010"></p><p>t3进入sync.releaseShared(1)中，调用tryReleaseShared(1)让计数减一，这回计数为零了，进入doReleaseShared()将头节点从-1改为0并唤醒老二，即</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7hzy646j31dk0p2tcz.jpg" alt="image-20210418211358350"></p><p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他 竞争，tryAcquire(1) 成功，修改头结点，流程结束</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpo7igo09yj313g0q6tcf.jpg" alt="image-20210418211425394"></p><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><p><strong>加解读锁</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.readLock(); lock.unlockRead(stamp);</code></pre></div><p><strong>加解写锁</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.writeLock(); lock.unlockWrite(stamp);</code></pre></div><p>乐观读，StampedLock 支持 <strong>tryOptimisticRead()</strong> 方法（乐观读），读取完毕后需要做一次<strong>戳校验</strong>如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead(); <span class="hljs-comment">// 验戳 </span><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;   <span class="hljs-comment">// 锁升级 </span>&#125;</code></pre></div><p>提供一个数据容器类内部分别使用读锁保护数据的**read()<strong>方法，写锁保护数据的</strong>write()**方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainerStamped</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock lock = <span class="hljs-keyword">new</span> StampedLock();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataContainerStamped</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;       <span class="hljs-keyword">this</span>.data = data;     &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> readTime)</span> </span>&#123;<span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();     log.debug(<span class="hljs-string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);     sleep(readTime);     <span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<span class="hljs-keyword">return</span> data;       &#125;    <span class="hljs-comment">// 锁升级 - 读锁 </span>      log.debug(<span class="hljs-string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);    <span class="hljs-keyword">try</span> &#123;stamp = lock.readLock();log.debug(<span class="hljs-string">&quot;read lock &#123;&#125;&quot;</span>, stamp);sleep(readTime);log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<span class="hljs-keyword">return</span> data;       &#125; <span class="hljs-keyword">finally</span> &#123;log.debug(<span class="hljs-string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);lock.unlockRead(stamp);       &#125;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newData)</span> </span>&#123;<span class="hljs-keyword">long</span> stamp = lock.writeLock();     log.debug(<span class="hljs-string">&quot;write lock &#123;&#125;&quot;</span>, stamp);     <span class="hljs-keyword">try</span> &#123;sleep(<span class="hljs-number">2</span>);<span class="hljs-keyword">this</span>.data = newData;           &#125; <span class="hljs-keyword">finally</span> &#123;log.debug(<span class="hljs-string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);lock.unlockWrite(stamp);           &#125;&#125;&#125;</code></pre></div><p>测试<code>读-读</code>可以优化</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;DataContainerStamped dataContainer = <span class="hljs-keyword">new</span> DataContainerStamped(<span class="hljs-number">1</span>);   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;dataContainer.read(<span class="hljs-number">1</span>);     &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();   sleep(<span class="hljs-number">0.5</span>);   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;dataContainer.read(<span class="hljs-number">0</span>);     &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();&#125;</code></pre></div><p>输出结果，可以看到实际没有加读锁</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.217</span> c.DataContainerStamped [t1] - optimistic read locking..<span class="hljs-number">.256</span> <span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.717</span> c.DataContainerStamped [t2] - optimistic read locking..<span class="hljs-number">.256</span> <span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">50.717</span> c.DataContainerStamped [t2] - read finish..<span class="hljs-number">.256</span>, data:<span class="hljs-number">1</span><span class="hljs-number">15</span>:<span class="hljs-number">58</span>:<span class="hljs-number">51.220</span> c.DataContainerStamped [t1] - read finish..<span class="hljs-number">.256</span>, data:<span class="hljs-number">1</span></code></pre></div><p>测试<code>读-写</code>时优化读补加读锁</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;DataContainerStamped dataContainer = <span class="hljs-keyword">new</span> DataContainerStamped(<span class="hljs-number">1</span>);   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;dataContainer.read(<span class="hljs-number">1</span>);     &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();   sleep(<span class="hljs-number">0.5</span>);   <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;dataContainer.write(<span class="hljs-number">100</span>);     &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();&#125;</code></pre></div><p>输出结果</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">00.219</span> c.DataContainerStamped [t1] - optimistic read locking..<span class="hljs-number">.256</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">00.717</span> c.DataContainerStamped [t2] - write lock <span class="hljs-number">384</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">01.225</span> c.DataContainerStamped [t1] - updating to read lock... <span class="hljs-number">256</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">02.719</span> c.DataContainerStamped [t2] - write unlock <span class="hljs-number">384</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">02.719</span> c.DataContainerStamped [t1] - read lock <span class="hljs-number">513</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">03.719</span> c.DataContainerStamped [t1] - read finish..<span class="hljs-number">.513</span>, data:<span class="hljs-number">1000</span> <span class="hljs-number">15</span>:<span class="hljs-number">57</span>:<span class="hljs-number">03.719</span> c.DataContainerStamped [t1] - read unlock <span class="hljs-number">513</span></code></pre></div><blockquote><p>注意</p><ul><li>StampedLock 不支持条件变量 </li><li>StampedLock 不支持可重入</li></ul></blockquote><h2 id="4、Semaphore"><a href="#4、Semaphore" class="headerlink" title="4、Semaphore"></a>4、Semaphore</h2><p>信号量，用来限制能同时访问共享资源的线程上限</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpou72jxqbj310u0tkn3h.jpg" alt="image-20210419101910684"></p><p>输出</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpou7e4yggj310s0o6tj9.jpg" alt="image-20210419101931207"></p><p><strong>加锁解锁流程</strong></p><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后 停车场显示空余车位减一</p><p>刚开始，permits（state）为 3，这时 5 个线程来获取资源</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpou93wrw9j31cs0qwdmg.jpg" alt="image-20210419102112057"></p><p>假设其中Thread-1，Thread-2，Thread-4cas竞争成功，而Thread-0和Thread-3竞争失败，进入AQS队列park阻塞</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpou9xdnv7j31cs0ceq59.jpg" alt="image-20210419102158503"></p><p>这时 Thread-4 释放了 permits，状态如下</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpouad858aj31dg0dmwhm.jpg" alt="image-20210419102225028"></p><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接 下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p><h2 id="5、线性安全集合类"><a href="#5、线性安全集合类" class="headerlink" title="5、线性安全集合类"></a>5、线性安全集合类</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpowxpot12j31nq0dugnz.jpg" alt="image-20210419115346068"></p><p>线程安全集合类可以分为三大类：</p><ul><li><p>遗留的线程安全集合如 Hashtable ， Vector </p></li><li><p>使用 Collections 装饰的线程安全集合，如：</p><ul><li>Collections.synchronizedCollection</li><li>Collections.synchronizedList</li><li>Collections.synchronizedMap</li><li>Collections.synchronizedSet</li><li>Collections.synchronizedNavigableMap</li><li>Collections.synchronizedNavigableSet</li><li>Collections.synchronizedSortedMap</li><li>Collections.synchronizedSortedSet</li></ul></li><li><p>java.util.concurrent.*</p></li></ul><p>重点介绍 java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词： Blocking、CopyOnWrite、Concurrent</p><ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 </li><li>CopyOnWrite 之类容器修改开销相对较重 </li><li>Concurrent 类型的容器 <ul><li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li><li>弱一致性 <ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li><li>求大小弱一致性，size 操作未必是 100% 准确 </li><li>读取弱一致性</li></ul></li></ul></li></ul><blockquote><p>遍历时如果发生了修改，对于非安全容器来讲，使用 <strong>fail-fast</strong> 机制也就是让遍历立刻失败，抛出 ConcurrentModiﬁcationException，不再继续遍历</p></blockquote><h2 id="6、ConcurrentHashMap"><a href="#6、ConcurrentHashMap" class="headerlink" title="6、ConcurrentHashMap"></a>6、ConcurrentHashMap</h2><h4 id="JDK-7-HashMap-并发死链"><a href="#JDK-7-HashMap-并发死链" class="headerlink" title="JDK 7 HashMap 并发死链"></a>JDK 7 HashMap 并发死链</h4><p>在JDK7下使用HashMap会发生死链，究其原因，是因为在多线程环境下使用了非线程安全的 map 集合 </p><p>JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能 够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</p><h4 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpp3gxgovjj30zl0u0n7q.jpg" alt="image-20210419154006079"></p><h4 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpp3kg3yovj316q0bawi6.jpg" alt="image-20210419154328609"></p><p><strong>Java 8 数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）</strong></p><ul><li>初始化，使用 cas 来保证并发安全，懒惰初始化 table </li><li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程 会用 synchronized 锁住链表头 </li><li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素 添加至 bin 的尾部 </li><li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索 </li><li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可 做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中 </li><li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加 即可</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM虚拟机</title>
    <link href="/2021/05/05/JVM/"/>
    <url>/2021/05/05/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><blockquote><p>本文是在B站学习JVM时候所做的笔记，对应<a href="https://www.bilibili.com/video/BV1yE411Z7AP">视频链接</a></p></blockquote><h1 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>JVM JRE JDK的区别</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" alt="img"></a></p><h1 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h1><p><strong>整体架构</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" alt="img"></a></p><h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h2 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        method1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;        method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> c = a + b;        <span class="hljs-keyword">return</span> c;    &#125;&#125;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png" alt="img"></a></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li></ul></li></ul><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h2 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h2><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h2 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h2><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h2 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h2><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" alt="img"></a></p><h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png" alt="img"></a></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><div class="hljs code-wrapper"><pre><code class="hljs shell">F:\JAVA\JDK8.0\bin&gt;javac F:\Thread_study\src\com\nyima\JVM\day01\Main.java</code></pre></div><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><div class="hljs code-wrapper"><pre><code class="hljs sh">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.class</code></pre></div></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png" alt="img"></a></p></li><li><p>常量池</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png" alt="img"></a></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png" alt="img"></a></p></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></li></ul></li></ul><h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String a = <span class="hljs-string">&quot;a&quot;</span>;         String b = <span class="hljs-string">&quot;b&quot;</span>;        String ab = <span class="hljs-string">&quot;ab&quot;</span>;    &#125;&#125;</code></pre></div><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><div class="hljs code-wrapper"><pre><code class="hljs sh">0: ldc           <span class="hljs-comment">#2                  // String a</span>2: astore_13: ldc           <span class="hljs-comment">#3                  // String b</span>5: astore_26: ldc           <span class="hljs-comment">#4                  // String ab</span>8: astore_39: <span class="hljs-built_in">return</span></code></pre></div><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String a = <span class="hljs-string">&quot;a&quot;</span>;        String b = <span class="hljs-string">&quot;b&quot;</span>;        String ab = <span class="hljs-string">&quot;ab&quot;</span>;        <span class="hljs-comment">//拼接字符串对象来创建新的字符串</span>        String ab2 = a+b;     &#125;&#125;</code></pre></div><p>反编译后的结果</p><div class="hljs code-wrapper"><pre><code class="hljs shell">     Code:      stack=2, locals=5, args_size=1         0: ldc           #2                  // String a         2: astore_1         3: ldc           #3                  // String b         5: astore_2         6: ldc           #4                  // String ab         8: astore_3         9: new           #5                  // class java/lang/StringBuilder        12: dup        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        16: aload_1        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        20: aload_2        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        27: astore        4        29: return</code></pre></div><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">String ab = <span class="hljs-string">&quot;ab&quot;</span>;String ab2 = a+b;<span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span>System.out.println(ab == ab2);</code></pre></div><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String a = <span class="hljs-string">&quot;a&quot;</span>;        String b = <span class="hljs-string">&quot;b&quot;</span>;        String ab = <span class="hljs-string">&quot;ab&quot;</span>;        String ab2 = a+b;        <span class="hljs-comment">//使用拼接字符串的方法创建字符串</span>        String ab3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;    &#125;&#125;</code></pre></div><p>反编译后的结果</p><div class="hljs code-wrapper"><pre><code class="hljs java">       Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span>         0: ldc           #2                  // String a         <span class="hljs-number">2</span>: astore_1         3: ldc           #3                  // String b         <span class="hljs-number">5</span>: astore_2         6: ldc           #4                  // String ab         <span class="hljs-number">8</span>: astore_3         9: new           #5                  // class java/lang/StringBuilder        <span class="hljs-number">12</span>: dup        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        <span class="hljs-number">16</span>: aload_1        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        <span class="hljs-number">20</span>: aload_2        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-comment">//ab3初始化时直接从串池中获取字符串</span>        29: ldc           #4                  // String ab        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span>        <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span></code></pre></div><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span>        String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span>        String st2 = str.intern();        <span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span>        String str3 = <span class="hljs-string">&quot;ab&quot;</span>;        <span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span>        System.out.println(str == st2);        System.out.println(str == str3);    &#125;&#125;</code></pre></div><p><strong>例2</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span>        String str3 = <span class="hljs-string">&quot;ab&quot;</span>;        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span>        String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-comment">//此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span>        String str2 = str.intern();        <span class="hljs-comment">//false</span>        System.out.println(str == str2);        <span class="hljs-comment">//false</span>        System.out.println(str == str3);        <span class="hljs-comment">//true</span>        System.out.println(str2 == str3);    &#125;&#125;</code></pre></div><h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">StringTableSize</span>=xxxx</code></pre></div></li><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h2 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h2><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" alt="img"></a></p><p><strong>使用了DirectBuffer</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" alt="img"></a></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</code></pre></div><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);&#125;</code></pre></div><p>DirectByteBuffer类</p><div class="hljs code-wrapper"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();    <span class="hljs-keyword">int</span> ps = Bits.pageSize();    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));    Bits.reserveMemory(size, cap);    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;    <span class="hljs-keyword">try</span> &#123;        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;        Bits.unreserveMemory(size, cap);        <span class="hljs-keyword">throw</span> x;    &#125;    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;        <span class="hljs-comment">// Round up to page boundary</span>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));    &#125; <span class="hljs-keyword">else</span> &#123;        address = base;    &#125;    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span>    att = <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();                       &#125;                       System.exit(<span class="hljs-number">1</span>);                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                   &#125;               &#125;);           &#125;</code></pre></div><p>对应对象的run方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// Paranoia</span>        <span class="hljs-keyword">return</span>;    &#125;    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span>    address = <span class="hljs-number">0</span>;    Bits.unreserveMemory(size, capacity);&#125;</code></pre></div><h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><h2 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h2><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png" alt="img"></a></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" alt="img"></a></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;        <span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);    &#125;&#125;</code></pre></div><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;        <span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span>        ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();        <span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);        <span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span>        Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();        <span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span>            list.remove(poll);            <span class="hljs-comment">//移动到引用队列中的下一个元素</span>            poll = queue.poll();        &#125;    &#125;&#125;</code></pre></div><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入饮用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h2 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h2><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png" alt="img"></a></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" alt="img"></a></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" alt="img"></a></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h2 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" alt="img"></a></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" alt="img"></a></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" alt="img"></a></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" alt="img"></a></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" alt="img"></a></p><p>如果新生代老年代中的内存都满了，就会先出法Minor Gc，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h2 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h2><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" alt="img"></a></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" alt="img"></a></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" alt="img"></a></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png" alt="img"></a></p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png" alt="img"></a></p><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png" alt="img"></a></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>会STW</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png" alt="img"></a></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png" alt="img"></a></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png" alt="img"></a></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png" alt="img"></a></p><ul><li>卡表与Remembered Set<ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post-write barried + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png" alt="img"></a></p><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" alt="img"></a></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png" alt="img"></a></p><h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png" alt="img"></a></p><h2 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h2><p>查看虚拟机参数命令</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-string">&quot;F:\JAVA\JDK8.0\bin\java&quot;</span> -XX:+PrintFlagsFinal -version | findstr <span class="hljs-string">&quot;GC&quot;</span></code></pre></div><p>可以根据参数去查询具体的信息</p><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题 </p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul><li>新生代的特点<ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是<ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><h1 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h1><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png" alt="img"></a></p><h2 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h2><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>java终端中，执行javac X:…\XXX.java</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png" alt="img"></a></p><p>以下是字节码文件</p><div class="hljs code-wrapper"><pre><code class="hljs shell">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 640000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b 0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 0001120 00 00 02 00 14</code></pre></div><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><div class="hljs code-wrapper"><pre><code class="hljs java">u4              magicu2             minor_version;    u2             major_version;    u2             constant_pool_count;    cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];    u2             access_flags;    u2             this_class;    u2             super_class;   u2             interfaces_count;    u2             interfaces[interfaces_count];   u2             fields_count;    field_info     fields[fields_count];   u2             methods_count;    method_info    methods[methods_count];    u2             attributes_count;    attribute_info attributes[attributes_count];</code></pre></div><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic </p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2 minor_version; </p><p>u2 major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09 </p><p>34H = 52，代表JDK8</p><h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>见资料文件</p><p>…略</p><h2 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h2><p>可参考 </p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><div class="hljs code-wrapper"><pre><code class="hljs java">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopyF:\Thread_study&gt;javap -v F:\Thread_study\src\com\nyima\JVM\day5\Demo1.classClassfile /F:/Thread_study/src/com/nyima/JVM/day5/Demo1.class  Last modified <span class="hljs-number">2020</span>-<span class="hljs-number">6</span>-<span class="hljs-number">6</span>; size <span class="hljs-number">434</span> bytes  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e  Compiled from <span class="hljs-string">&quot;Demo1.java&quot;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">nyima</span>.<span class="hljs-title">JVM</span>.<span class="hljs-title">day5</span>.<span class="hljs-title">Demo1</span></span>  minor version: 0  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;   #3 = String             #18            // hello world   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V   #5 = Class              #21            // com/nyima/JVM/day5/Demo1   #6 = Class              #22            // java/lang/Object   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               main  #12 = Utf8               ([Ljava/lang/String;)V  #13 = Utf8               SourceFile  #14 = Utf8               Demo1.java  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V  #16 = Class              #23            // java/lang/System  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;  #18 = Utf8               hello world  #19 = Class              #26            // java/io/PrintStream  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V  #21 = Utf8               com/nyima/JVM/day5/Demo1  #22 = Utf8               java/lang/Object  #23 = Utf8               java/lang/System  #24 = Utf8               out  #25 = Utf8               Ljava/io/PrintStream;  #26 = Utf8               java/io/PrintStream  #27 = Utf8               println  #28 = Utf8               (Ljava/lang/String;)V&#123;  <span class="hljs-keyword">public</span> com.nyima.JVM.day5.Demo1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #3                  // String hello world         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">10</span>: <span class="hljs-number">8</span>&#125;</code></pre></div><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;                <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;                <span class="hljs-keyword">int</span> c = a + b;                System.out.println(c);       &#125; &#125;</code></pre></div><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png" alt="img"></a></p><p><strong>方法字节码载入方法区</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png" alt="img"></a></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong></p><ul><li><p>将一个 byte 压入操作数栈</p><p>（其长度会补齐 4 个字节），类似的指令还有</p></li><li><p>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</p></li><li><p>ldc 将一个 int 压入操作数栈 </p></li><li><p>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</p></li><li><p>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" alt="img"></a></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的 </p><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">10</span></code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" alt="img"></a></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" alt="img"></a></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" alt="img"></a></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" alt="img"></a></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" alt="img"></a></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" alt="img"></a></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" alt="img"></a></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" alt="img"></a></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法 </p><p>生成新的栈帧（分配 locals、stack等） </p><p>传递参数，执行新栈帧中的字节码</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" alt="img"></a></p><p>执行完毕，弹出栈帧 </p><p>清除 main 操作数栈内容</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" alt="img"></a></p><p><strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;            x = x++;            i++;        &#125;        System.out.println(x); <span class="hljs-comment">//接过为0</span>    &#125;&#125;</code></pre></div><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>    <span class="hljs-comment">//操作数栈分配2个空间，局部变量表分配3个空间</span>        <span class="hljs-number">0</span>: iconst_0    <span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">1</span>: istore_1    <span class="hljs-comment">//将常数0放入局部变量表的1号槽位 i=0</span>        <span class="hljs-number">2</span>: iconst_0    <span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">3</span>: istore_2    <span class="hljs-comment">//将常数0放入局部变量的2号槽位 x=0    </span>        <span class="hljs-number">4</span>: iload_1        <span class="hljs-comment">//将局部变量表1号槽位的数放入操作数栈中</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span>    <span class="hljs-comment">//将数字10放入操作数栈中，此时操作数栈中有2个数</span>        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span>    <span class="hljs-comment">//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span>       <span class="hljs-number">10</span>: iload_2        <span class="hljs-comment">//将局部变量2号槽位的数放入操作数栈中，放入的值是0</span>       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span>    <span class="hljs-comment">//将局部变量2号槽位的数加1，自增后，槽位中的值为1</span>       <span class="hljs-number">14</span>: istore_2    <span class="hljs-comment">//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0</span>       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//1号槽位的值自增1</span>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-comment">//跳转到第4条指令</span>       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;       <span class="hljs-number">24</span>: iload_2       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span></code></pre></div><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    <span class="hljs-keyword">static</span> &#123;        i = <span class="hljs-number">20</span>;    &#125;    <span class="hljs-keyword">static</span> &#123;        i = <span class="hljs-number">30</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(i); <span class="hljs-comment">//结果为30</span>    &#125;&#125;</code></pre></div><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p><div class="hljs code-wrapper"><pre><code class="hljs java">stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>         2: putstatic     #3                  // Field i:I         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>         7: putstatic     #3                  // Field i:I        <span class="hljs-number">10</span>: bipush        <span class="hljs-number">30</span>        12: putstatic     #3                  // Field i:I        <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span></code></pre></div><h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;    <span class="hljs-keyword">private</span> String a = <span class="hljs-string">&quot;s1&quot;</span>;    &#123;        b = <span class="hljs-number">20</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;    &#123;        a = <span class="hljs-string">&quot;s2&quot;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">this</span>.a = a;        <span class="hljs-keyword">this</span>.b = b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Demo4 d = <span class="hljs-keyword">new</span> Demo4(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);        System.out.println(d.a);        System.out.println(d.b);    &#125;&#125;</code></pre></div><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span>        <span class="hljs-number">0</span>: aload_0        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V        <span class="hljs-number">4</span>: aload_0        5: ldc           #2                  // String s1        7: putfield      #3                  // Field a:Ljava/lang/String;       <span class="hljs-number">10</span>: aload_0       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       13: putfield      #4                  // Field b:I       <span class="hljs-number">16</span>: aload_0       <span class="hljs-number">17</span>: bipush        <span class="hljs-number">10</span>       19: putfield      #4                  // Field b:I       <span class="hljs-number">22</span>: aload_0       23: ldc           #5                  // String s2       25: putfield      #3                  // Field a:Ljava/lang/String;       <span class="hljs-comment">//原始构造方法在最后执行</span>       <span class="hljs-number">28</span>: aload_0       <span class="hljs-number">29</span>: aload_1       30: putfield      #3                  // Field a:Ljava/lang/String;       <span class="hljs-number">33</span>: aload_0       <span class="hljs-number">34</span>: iload_2       35: putfield      #4                  // Field b:I       <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span></code></pre></div><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();        demo5.test1();        demo5.test2();        demo5.test3();        Demo5.test4();    &#125;&#125;</code></pre></div><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>         0: new           #2                  // class com/nyima/JVM/day5/Demo5          <span class="hljs-number">3</span>: dup         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V         <span class="hljs-number">7</span>: astore_1         <span class="hljs-number">8</span>: aload_1         9: invokespecial #4                  // Method test1:()V        <span class="hljs-number">12</span>: aload_1        13: invokespecial #5                  // Method test2:()V        <span class="hljs-number">16</span>: aload_1        17: invokevirtual #6                  // Method test3:()V        20: invokestatic  #7                  // Method test4:()V        <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span></code></pre></div><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈 </li><li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量 </li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定 </li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】 </li></ul><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;            i = <span class="hljs-number">20</span>;        &#125;    &#125;&#125;</code></pre></div><p>对应字节码指令</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-number">5</span>: goto          <span class="hljs-number">12</span>        <span class="hljs-number">8</span>: astore_2        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">11</span>: istore_1       <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span>     <span class="hljs-comment">//多出来一个异常表</span>     Exception table:        from    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/Exception</code></pre></div><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号 </li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;        &#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;            i = <span class="hljs-number">20</span>;        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;            i = <span class="hljs-number">30</span>;        &#125;    &#125;&#125;</code></pre></div><p>对应的字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-number">5</span>: goto          <span class="hljs-number">19</span>        <span class="hljs-number">8</span>: astore_2        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">11</span>: istore_1       <span class="hljs-number">12</span>: goto          <span class="hljs-number">19</span>       <span class="hljs-number">15</span>: astore_2       <span class="hljs-number">16</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">18</span>: istore_1       <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span>     Exception table:        from    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/Exception</code></pre></div><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            i = <span class="hljs-number">20</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;            i = <span class="hljs-number">30</span>;        &#125;    &#125;&#125;</code></pre></div><p>对应字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-comment">//try块</span>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-comment">//try块执行完后，会执行finally    </span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span>        <span class="hljs-number">7</span>: istore_1        <span class="hljs-number">8</span>: goto          <span class="hljs-number">27</span>       <span class="hljs-comment">//catch块     </span>       <span class="hljs-number">11</span>: astore_2 <span class="hljs-comment">//异常信息放入局部变量表的2号槽位</span>       <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">14</span>: istore_1       <span class="hljs-comment">//catch块执行完后，会执行finally        </span>       <span class="hljs-number">15</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">17</span>: istore_1       <span class="hljs-number">18</span>: goto          <span class="hljs-number">27</span>       <span class="hljs-comment">//出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   </span>       <span class="hljs-number">21</span>: astore_3       <span class="hljs-number">22</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">24</span>: istore_1       <span class="hljs-number">25</span>: aload_3       <span class="hljs-number">26</span>: athrow  <span class="hljs-comment">//抛出异常</span>       <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span>     Exception table:        from    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">11</span>   Class java/lang/Exception            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">21</span>   any           <span class="hljs-number">11</span>    <span class="hljs-number">15</span>    <span class="hljs-number">21</span>   any</code></pre></div><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程 </p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = Demo3.test();        <span class="hljs-comment">//结果为20</span>        System.out.println(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> i;        <span class="hljs-keyword">try</span> &#123;            i = <span class="hljs-number">10</span>;            <span class="hljs-keyword">return</span> i;        &#125; <span class="hljs-keyword">finally</span> &#123;            i = <span class="hljs-number">20</span>;            <span class="hljs-keyword">return</span> i;        &#125;    &#125;&#125;</code></pre></div><p>对应字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_0        <span class="hljs-number">3</span>: iload_0        <span class="hljs-number">4</span>: istore_1  <span class="hljs-comment">//暂存返回值</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>        <span class="hljs-number">7</span>: istore_0        <span class="hljs-number">8</span>: iload_0        <span class="hljs-number">9</span>: ireturn    <span class="hljs-comment">//ireturn会返回操作数栈顶的整型值20</span>       <span class="hljs-comment">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span>       <span class="hljs-number">10</span>: astore_2       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: istore_0       <span class="hljs-number">14</span>: iload_0       <span class="hljs-number">15</span>: ireturn    <span class="hljs-comment">//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span>     Exception table:        from    to  target type            <span class="hljs-number">0</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any</code></pre></div><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准 </li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子 </li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> i = Demo3.test();      <span class="hljs-comment">//最终结果为20</span>      System.out.println(i);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> i;      <span class="hljs-keyword">try</span> &#123;         i = <span class="hljs-number">10</span>;         <span class="hljs-comment">//这里应该会抛出异常</span>         i = i/<span class="hljs-number">0</span>;         <span class="hljs-keyword">return</span> i;      &#125; <span class="hljs-keyword">finally</span> &#123;         i = <span class="hljs-number">20</span>;         <span class="hljs-keyword">return</span> i;      &#125;   &#125;&#125;</code></pre></div><p>会发现打印结果为20，并未抛出异常</p><h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = Demo4.test();        System.out.println(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> i;        &#125; <span class="hljs-keyword">finally</span> &#123;            i = <span class="hljs-number">20</span>;        &#125;    &#125;&#125;</code></pre></div><p>对应字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_0 <span class="hljs-comment">//赋值给i 10</span>        <span class="hljs-number">3</span>: iload_0    <span class="hljs-comment">//加载到操作数栈顶</span>        <span class="hljs-number">4</span>: istore_1 <span class="hljs-comment">//加载到局部变量表的1号位置</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>        <span class="hljs-number">7</span>: istore_0 <span class="hljs-comment">//赋值给i 20</span>        <span class="hljs-number">8</span>: iload_1 <span class="hljs-comment">//加载局部变量表1号位置的数10到操作数栈</span>        <span class="hljs-number">9</span>: ireturn <span class="hljs-comment">//返回操作数栈顶元素 10</span>       <span class="hljs-number">10</span>: astore_2       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: istore_0       <span class="hljs-number">14</span>: aload_2 <span class="hljs-comment">//加载异常</span>       <span class="hljs-number">15</span>: athrow <span class="hljs-comment">//抛出异常</span>     Exception table:        from    to  target type            <span class="hljs-number">3</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any</code></pre></div><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;        Lock lock = <span class="hljs-keyword">new</span> Lock();        <span class="hljs-keyword">synchronized</span> (lock) &#123;            System.out.println(i);        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;&#125;</code></pre></div><p>对应字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_1        3: new           #2                  // class com/nyima/JVM/day06/Lock        <span class="hljs-number">6</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span>        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V       <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">//剩下的一份放到局部变量表的2号位置</span>       <span class="hljs-number">11</span>: aload_2 <span class="hljs-comment">//加载到操作数栈</span>       <span class="hljs-number">12</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈，用于加锁时消耗</span>       <span class="hljs-number">13</span>: astore_3 <span class="hljs-comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span>       <span class="hljs-number">14</span>: monitorenter <span class="hljs-comment">//加锁</span>       <span class="hljs-comment">//锁住后代码块中的操作    </span>       15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;       <span class="hljs-number">18</span>: iload_1       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V       <span class="hljs-comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span>       <span class="hljs-number">22</span>: aload_3           <span class="hljs-number">23</span>: monitorexit <span class="hljs-comment">//解锁</span>       <span class="hljs-number">24</span>: goto          <span class="hljs-number">34</span>       <span class="hljs-comment">//异常操作    </span>       <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>       <span class="hljs-number">29</span>: aload_3       <span class="hljs-number">30</span>: monitorexit <span class="hljs-comment">//解锁</span>       <span class="hljs-number">31</span>: aload         <span class="hljs-number">4</span>       <span class="hljs-number">33</span>: athrow       <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span>     <span class="hljs-comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span>     Exception table:        from    to  target type           <span class="hljs-number">15</span>    <span class="hljs-number">24</span>    <span class="hljs-number">27</span>   any           <span class="hljs-number">27</span>    <span class="hljs-number">31</span>    <span class="hljs-number">27</span>   any</code></pre></div><h2 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h2><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。 </p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;&#125;</code></pre></div><p>经过编译期优化后</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span>      <span class="hljs-keyword">super</span>();   &#125;&#125;</code></pre></div><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Integer x = <span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> y = x;   &#125;&#125;</code></pre></div><p>转换过程如下</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span>      <span class="hljs-keyword">int</span> y = x.intValue();   &#125;&#125;</code></pre></div><h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      list.add(<span class="hljs-number">10</span>);      Integer x = list.get(<span class="hljs-number">0</span>);   &#125;&#125;</code></pre></div><p>对应字节码</p><div class="hljs code-wrapper"><pre><code class="hljs java">Code:    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>       0: new           #2                  // class java/util/ArrayList       <span class="hljs-number">3</span>: dup       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V       <span class="hljs-number">7</span>: astore_1       <span class="hljs-number">8</span>: aload_1       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span>      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;      <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是add(Objcet o)</span>      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z      <span class="hljs-number">19</span>: pop      <span class="hljs-number">20</span>: aload_1      <span class="hljs-number">21</span>: iconst_0      <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是get(Object o)   </span>      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;<span class="hljs-comment">//这里进行了类型转换，将Object转换成了Integer</span>      27: checkcast     #7                  // class java/lang/Integer      <span class="hljs-number">30</span>: astore_2      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span></code></pre></div><p>所以调用get函数取值时，有一个类型转换的操作</p><div class="hljs code-wrapper"><pre><code class="hljs java">Integer x = (Integer) list.get(<span class="hljs-number">0</span>);</code></pre></div><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = (Integer) list.get(<span class="hljs-number">0</span>).intValue();</code></pre></div><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span>      String[] arr = args;      System.out.println(arr.length);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);   &#125;&#125;</code></pre></div><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-keyword">public</span> Demo4 &#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String[] arr = args;      System.out.println(arr.length);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);   &#125;&#125;</code></pre></div><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) &#123;            System.out.println(x);        &#125;    &#125;&#125;</code></pre></div><p>编译器会帮我们转换为</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) &#123;            <span class="hljs-keyword">int</span> x = arr[i];            System.out.println(x);        &#125;    &#125;&#125;</code></pre></div><p><strong>如果是集合使用foreach</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);      <span class="hljs-keyword">for</span> (Integer x : list) &#123;         System.out.println(x);      &#125;   &#125;&#125;</code></pre></div><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);      <span class="hljs-comment">//获得该集合的迭代器</span>      Iterator&lt;Integer&gt; iterator = list.iterator();      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;         Integer x = iterator.next();         System.out.println(x);      &#125;   &#125;&#125;</code></pre></div><h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-keyword">switch</span> (str) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;</code></pre></div><p>在编译器中执行的操作</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">&quot;hello&quot;</span>;      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;         <span class="hljs-comment">//hello的hashCode</span>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;               x = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">break</span>;         <span class="hljs-comment">//world的hashCode</span>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;               x = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-comment">//用第二个switch在进行输出判断</span>      <span class="hljs-keyword">switch</span> (x) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;</code></pre></div><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SEX sex = SEX.MALE;      <span class="hljs-keyword">switch</span> (sex) &#123;         <span class="hljs-keyword">case</span> MALE:            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> FEMALE:            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;   MALE, FEMALE;&#125;</code></pre></div><p>编译器中执行的代码如下</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-comment">/**     </span><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];      <span class="hljs-keyword">static</span> &#123;         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SEX sex = SEX.MALE;      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];      <span class="hljs-keyword">switch</span> (x) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;   MALE, FEMALE;&#125;</code></pre></div><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;   MALE, FEMALE;&#125;</code></pre></div><p>转换后的代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;      <span class="hljs-comment">//对应枚举类中的元素</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;    <span class="hljs-keyword">static</span> &#123;               <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span>        MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);            FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);           $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;;    &#125;   <span class="hljs-comment">//调用父类中的方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;             <span class="hljs-keyword">super</span>(name, ordinal);        &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;          <span class="hljs-keyword">return</span> $VALUES.clone();      &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123;         <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);      &#125; &#125;</code></pre></div><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);         &#125;      &#125;;   &#125;&#125;</code></pre></div><p>转换后的代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span>      Runnable runnable = <span class="hljs-keyword">new</span> Demo8$<span class="hljs-number">1</span>();   &#125;&#125;<span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);   &#125;&#125;</code></pre></div><p>如果匿名内部类中引用了<strong>局部变量</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;</code></pre></div><p>转化后代码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-comment">//多创建了一个变量</span>   <span class="hljs-keyword">int</span> val$x;   <span class="hljs-comment">//变为了有参构造器</span>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123;      <span class="hljs-keyword">this</span>.val$x = x;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(val$x);   &#125;&#125;</code></pre></div><h2 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h2><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li><p>将类的字节码载入</p><p>方法区</p><p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p></li><li><p>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用 </p></li><li><p>_super 即父类</p></li><li><p>_ﬁelds 即成员变量 </p></li><li><p>_methods 即方法 </p></li><li><p>_constants 即常量池 </p></li><li><p>_class_loader 即类加载器 </p></li><li><p>_vtable 虚方法表 </p></li><li><p>_itable 接口方法</p></li><li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p></li><li><p>加载和链接可能是<strong>交替运行</strong>的</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" alt="img"></a></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>HSDB的使用</strong></p><ul><li>先获得要查看的进程ID</li></ul><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">jps</span></code></pre></div><ul><li>打开HSDB</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">java -cp F:\JAVA\JDK8<span class="hljs-number">.0</span>\lib\sa-jdi.jar sun.jvm.hotspot.HSDB</code></pre></div><ul><li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png" alt="img"></a></p><ul><li>定位需要的进程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png" alt="img"></a></p><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;      ClassLoader loader = Demo1.class.getClassLoader();      <span class="hljs-comment">//只加载不解析</span>      Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">&quot;com.nyima.JVM.day8.C&quot;</span>);      <span class="hljs-comment">//用于阻塞主线程</span>      System.in.read();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;   D d = <span class="hljs-keyword">new</span> D();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;&#125;</code></pre></div><ul><li>打开HSDB<ul><li>可以看到此时只加载了类C</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" alt="img"></a></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" alt="img"></a></p><ul><li>解析以后，会将常量池中的符号引用解析为直接引用<ul><li>可以看到，此时已加载并解析了类C和类D</li></ul><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" alt="img"></a></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" alt="img"></a></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li></ul><p><strong>注意</strong></p><p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png" alt="img"></a></p><h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化 </li><li>首次访问这个类的静态变量或静态方法时 </li><li>子类初始化，如果父类还没初始化，会引发 </li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName </li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h2 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h2><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)    <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span>        Class&lt;?&gt; c = findLoadedClass(name);        <span class="hljs-comment">//如果没有被加载过</span>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">long</span> t0 = System.nanoTime();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//看是否被启动类加载器加载过</span>                    c = findBootstrapClassOrNull(name);                &#125;            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                <span class="hljs-comment">// from the non-null parent class loader</span>                <span class="hljs-comment">//捕获异常，但不做任何处理</span>            &#125;            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span>                <span class="hljs-comment">//然后让应用类加载器去找classpath下找该类</span>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();                c = findClass(name);                <span class="hljs-comment">// 记录时间</span>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        <span class="hljs-keyword">if</span> (resolve) &#123;            resolveClass(c);        &#125;        <span class="hljs-keyword">return</span> c;    &#125;&#125;</code></pre></div><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>想加载非 classpath 随意路径中的类文件 </li><li>通过接口来使用实现，希望解耦时，常用在框架设计 </li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li><p>继承ClassLoader父类</p></li><li><p>要遵从双亲委派机制，重写 ﬁndClass 方法</p></li><li><p>不是重写loadClass方法，否则不会走双亲委派机制</p></li><li><p>读取类文件的字节码</p></li><li><p>调用父类的 deﬁneClass 方法来加载类 </p></li><li><p>使用者调用该类加载器的 loadClass 方法</p></li></ul><h4 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h4><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h2 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h2><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling） </li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li><p>解释器</p><ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释 </li><li>是将字节码解释为针对所有平台都通用的机器码 </li></ul></li><li><p>即时编译器</p></li><li><p>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译 </p></li><li><p>根据平台类型，生成平台特定的机器码</p></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-comment">// to do something  </span>&#125;Copy</code></pre></div><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong></p><p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;         <span class="hljs-comment">//这里调用了add2方法</span>        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);      &#125;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>&#123;          <span class="hljs-keyword">return</span> x1 + x2;      &#125;</code></pre></div><p>方法调用被替换后</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;          <span class="hljs-comment">//被替换为了方法本身</span>        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;      &#125;</code></pre></div><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">&quot;foo...&quot;</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;      Method foo = Demo3.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;         foo.invoke(<span class="hljs-keyword">null</span>);      &#125;   &#125;&#125;</code></pre></div><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><span class="hljs-function">       InvocationTargetException</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (!override) &#123;        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;            Class&lt;?&gt; caller = Reflection.getCallerClass();            checkAccess(caller, clazz, obj, modifiers);        &#125;    &#125;    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;        ma = acquireMethodAccessor();    &#125;    <span class="hljs-keyword">return</span> ma.invoke(obj, args);&#125;</code></pre></div><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png" alt="img"></a></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numInvocations;    NativeMethodAccessorImpl(Method var1) &#123;        <span class="hljs-keyword">this</span>.method = var1;    &#125;    <span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span>    <span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object var1, Object[] var2)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;        <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="hljs-keyword">this</span>.method.getDeclaringClass())) &#123;            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="hljs-keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="hljs-keyword">this</span>.method.getDeclaringClass(), <span class="hljs-keyword">this</span>.method.getName(), <span class="hljs-keyword">this</span>.method.getParameterTypes(), <span class="hljs-keyword">this</span>.method.getReturnType(), <span class="hljs-keyword">this</span>.method.getExceptionTypes(), <span class="hljs-keyword">this</span>.method.getModifiers());            <span class="hljs-keyword">this</span>.parent.setDelegate(var3);        &#125;        <span class="hljs-keyword">return</span> invoke0(<span class="hljs-keyword">this</span>.method, var1, var2);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;        <span class="hljs-keyword">this</span>.parent = var1;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">invoke0</span><span class="hljs-params">(Method var0, Object var1, Object[] var2)</span></span>;&#125;Copy<span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;</code></pre></div><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
