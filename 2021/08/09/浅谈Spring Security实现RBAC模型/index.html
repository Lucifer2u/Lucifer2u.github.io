

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bat.png">
  <link rel="icon" href="/img/bat.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Lucifer">
  <meta name="keywords" content="">
  
  <title>浅谈Spring Security实现RBAC模型 - Lucifer&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/monokai.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lucifer2u.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Q8utolFFXQsi71pQY6bCltkI-gzGzoHsz","app_key":"x4RAlPOpmFX9HdGyI6MLoCGn","server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Lucifer</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Flower.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="浅谈Spring Security实现RBAC模型">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-09 22:12" pubdate>
        2021年8月9日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      18.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      228
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">浅谈Spring Security实现RBAC模型</h1>
            
            <div class="markdown-body">
              <h1 id="浅谈Spring-Security实现RBAC模型"><a href="#浅谈Spring-Security实现RBAC模型" class="headerlink" title="浅谈Spring Security实现RBAC模型"></a>浅谈Spring Security实现RBAC模型</h1><blockquote>
<p>本文将结合我所做的项目来探讨一下利用Spring Security实现RBAC模型的简要步骤以及利用Spring Security做项目时候发现与改进</p>
</blockquote>
<h2 id="🤔️什么是RBAC"><a href="#🤔️什么是RBAC" class="headerlink" title="🤔️什么是RBAC"></a>🤔️什么是RBAC</h2><p><strong>RBAC权限模型（Role-Based Access Control）</strong>即：基于角色的权限控制。模型中有几个关键的术语：</p>
<ul>
<li>用户：系统接口及功能访问的操作者</li>
<li>权限：能够访问某接口或者做某操作的授权资格</li>
<li>角色：具有一类相同操作权限的用户的总称</li>
</ul>
<p><strong>RBAC权限模型核心授权逻辑如下：</strong></p>
<ul>
<li>某用户是什么角色？</li>
<li>某角色具有什么权限？</li>
<li>通过角色的权限推导用户的权限</li>
</ul>
<p>对于一个用户来说，如果直接将用户与权限关联，会有以下问题：</p>
<ul>
<li>现在用户是Lucifer、Melrose，以后随着人员增加，每一个用户都需要重新授权</li>
<li>或者Lucifer、Melrose离职，需要针对每一个用户进行多种权限的回收</li>
</ul>
<p><strong>如果给每个用户分配一个角色呢？</strong></p>
<ul>
<li>一个用户有一个角色</li>
<li>一个角色有多个操作（菜单）权限</li>
<li>一个操作权限可以赋予多个角色</li>
</ul>
<p>但是在实际的应用系统中，<strong>一个用户一个角色远远满足不了需求</strong>。如果我们希望一个用户既担任销售角色、又暂时担任副总角色。该怎么做呢？为了增加系统设计的适用性，我们通常设计：</p>
<ul>
<li>一个用户有一个或多个角色</li>
<li>一个角色包含多个用户</li>
<li>一个角色有多种权限</li>
<li>一个权限可以赋予多个角色</li>
</ul>
<p>所以，每个角色的权限可以对应为访问某个URL的权利，即所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面访问权限。</p>
<h2 id="✏️权限表的设计"><a href="#✏️权限表的设计" class="headerlink" title="✏️权限表的设计"></a>✏️权限表的设计</h2><p>在设计表的时候，可以引入RBAC模型的思想</p>
<blockquote>
<p>下面是我做的一个项目中所设计的表，项目链接：<a target="_blank" rel="noopener" href="https://github.com/Lucifer2u/xm-luciferpro">https://github.com/Lucifer2u/xm-luciferpro</a></p>
</blockquote>
<p><strong>权限数据库</strong>主要包含了五张表，分别是<strong>资源表、角色表、用户表、资源角色表、用户角色表</strong>，数据库关系模型如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/p274.png" srcset="/img/loading.gif" lazyload alt="p274"></p>
<ul>
<li>hr表是<strong>用户表</strong>，存放了用户的基本信息</li>
<li>role是<strong>角色表</strong>，name字段表示角色的英文名称，按照SpringSecurity的规范，将以<code>ROLE_</code>开始，nameZh字段表示角色的中文名称</li>
<li>menu表是一个资源表，该表涉及到的字段有点多，由于我的前端采用了Vue来做，因此当用户登录成功之后，系统将根据用户的角色动态加载需要的模块，所有模块的信息将保存在menu表中，menu表中的<strong>path、component、iconCls、keepAlive、requireAuth等字段都是Vue-Router中需要的字段</strong>，也就是说<strong>menu中的数据到时候会以json的形式返回给前端，再由vue动态更新router，menu中还有一个字段url，表示一个url pattern，即路径匹配规则</strong>，假设有一个路径匹配规则为<code>/admin/**</code>,那么当用户在客户端发起一个<code>/admin/user</code>的请求，将被<code>/admin/**</code>拦截到，系统再去查看这个规则对应的角色是哪些，然后再去查看该用户是否具备相应的角色，进而判断该请求是否合法</li>
</ul>
<p><strong>这样每个人都有相应的角色，然后都需要根据实际的角色权限去访问不同的菜单</strong></p>
<h2 id="🔒动态处理角色和资源的关系"><a href="#🔒动态处理角色和资源的关系" class="headerlink" title="🔒动态处理角色和资源的关系"></a>🔒动态处理角色和资源的关系</h2><p>要分析以上问题，我们需要回顾Spring Security的登录流程对整体流程进行了解才能更好的把握此节的内容</p>
<h3 id="Spring-Security的登录流程"><a href="#Spring-Security的登录流程" class="headerlink" title="Spring Security的登录流程"></a>Spring Security的登录流程</h3><p>Spring Security的登录验证流程核心就是过滤器链。</p>
<p><img src="https://img.kancloud.cn/73/50/73506bb0f3f3834c410ba17353a8168e_1409x389.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>贯穿于整个过滤器链始终有一个上下文对象<code>SecurityContext</code>和一个<code>Authentication</code>对象（登录认证的主体）</li>
<li>一旦某一个该主体通过其中某一个过滤器的认证，<code>Authentication</code>对象信息被填充，比如：<code>isAuthenticated=true</code>表示该主体通过验证。</li>
<li>如果该主体通过了所有的过滤器，仍然没有被认证，在整个过滤器链的最后方有一个<code>FilterSecurityInterceptor</code>过滤器（虽然叫Interceptor，但它是名副其实的过滤器，不是拦截器）。判断<code>Authentication</code>对象的认证状态，如果没有通过认证则抛出异常，通过认证则访问后端API。</li>
<li>之后进入响应阶段，<code>FilterSecurityInterceptor</code>抛出的异常被<code>ExceptionTranslationFilter</code>对异常进行相应的处理。比如：用户名密码登录异常，会被引导到登录页重新登陆。</li>
<li>如果是登陆成功且没有任何异常，在请求响应中最后一个过滤器<code>SecurityContextPersistenceFilter</code>中将<code>SecurityContext</code>放入session。下次再进行请求的时候，直接从<code>SecurityContextPersistenceFilter</code>的session中取出认证信息。从而避免多次重复认证。（如果想修改用户信息，可以从这里拿）</li>
</ul>
<p>SpringSecurity提供了多种登录认证的方式，由多种Filter过滤器来实现，比如：</p>
<ul>
<li><code>BasicAuthenticationFilter</code>实现的是HttpBasic模式的登录认证</li>
<li><code>UsernamePasswordAuthenticationFilter</code>实现用户名密码的登录认证</li>
<li><code>RememberMeAuthenticationFilter</code>实现登录认证的“记住我”的功能</li>
<li><code>SocialAuthenticationFilter</code>实现社交媒体方式登录认证的处理，如：QQ、微信</li>
<li><code>Oauth2AuthenticationProcessingFilter</code>和<code>Oauth2ClientAuthenticationProcessingFilter</code>实现Oauth2的鉴权方式</li>
</ul>
<p>根据我们不同的需求实现及配置，不同的Filter会被加载到应用中。</p>
<h3 id="过滤器登录验证细节"><a href="#过滤器登录验证细节" class="headerlink" title="过滤器登录验证细节"></a>过滤器登录验证细节</h3><p><img src="https://img.kancloud.cn/ce/5e/ce5e1f7877e0155577d5511b95ea2100_660x441.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="构建登录认证主体"><a href="#构建登录认证主体" class="headerlink" title="构建登录认证主体"></a><strong>构建登录认证主体</strong></h4><p>如图所示，当用户登陆的时候首先被某一种认证方式的过滤器拦截（以用户名密码登录为例）。如：<code>UsernamePasswordAuthenticationFilter</code>会使用用户名和密码创建一个登录认证凭证：<code>UsernamePasswordAuthenticationToken</code>，进而获取一个<code>Authentication</code>对象，该对象代表身份验证的主体，贯穿于用户认证流程始终。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808215018034.png" srcset="/img/loading.gif" lazyload alt="image-20210808215018034"></p>
<h4 id="多种认证方式的管理-ProviderManager"><a href="#多种认证方式的管理-ProviderManager" class="headerlink" title="多种认证方式的管理 ProviderManager"></a><strong>多种认证方式的管理 ProviderManager</strong></h4><p>随后使用<code>AuthenticationManager</code> 接口对登录认证主体进行authenticate认证。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthenticationManager</span> </span>&#123;
    <span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;
&#125;</code></pre></div>

<p><code>ProviderManager</code>继承于<code>AuthenticationManager</code>是登录验证的核心类。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationManager</span>, <span class="hljs-title">MessageSourceAware</span>, <span class="hljs-title">InitializingBean</span> </span>&#123;
    ……
    <span class="hljs-keyword">private</span> List&lt;AuthenticationProvider&gt; providers;
    ……</code></pre></div>

<p><code>ProviderManager</code>保管了多个<code>AuthenticationProvider</code>，每一种登录认证方式都可以尝试对登录认证主体进行认证。只要有一种方式被认证成功，<code>Authentication</code>对象就成为被认可的主体。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;
    <span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication var1)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; var1)</span></span>;
&#125;</code></pre></div>

<blockquote>
<p><code>RememberMeAuthenticationProvider</code>定义了“记住我”功能的登录验证逻辑</p>
<p><code>DaoAuthenticationProvider</code>加载数据库用户信息，进行用户密码的登录验证</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808220226118.png" srcset="/img/loading.gif" lazyload alt="image-20210808220226118"></p>
</blockquote>
<p>而<code>DaoAuthenticationProvider</code>就是我们实现登录的关键，下面详细分析</p>
<h4 id="数据库加载用户信息-DaoAuthenticationProvider"><a href="#数据库加载用户信息-DaoAuthenticationProvider" class="headerlink" title="数据库加载用户信息 DaoAuthenticationProvider"></a><strong>数据库加载用户信息 DaoAuthenticationProvider</strong></h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoAuthenticationProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractUserDetailsAuthenticationProvider</span> </span></code></pre></div>

<p>从源码中发现，需要从数据库获取用户信息的时候，即我们需要加载用户信息进行登录验证的时候，我们需要实现<code>UserDetailsService</code>接口，重写<code>loadUserByUsername</code>方法，参数是用户输入的用户名。返回值是<code>UserDetails</code></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808220514527.png" srcset="/img/loading.gif" lazyload alt="image-20210808220514527"></p>
<h4 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a><strong>SecurityContext</strong></h4><p>完成登录认证之后，将认证完成的<code>Authentication</code>对象(authenticate: true, 有授权列表authority list, 和username信息)放入<code>SecurityContext</code>上下文里面。后续的请求就直接从<code>SecurityContextFilter</code>中获得认证主体，从而访问资源。</p>
<h3 id="结合源码讲解登录验证流程"><a href="#结合源码讲解登录验证流程" class="headerlink" title="结合源码讲解登录验证流程"></a>结合源码讲解登录验证流程</h3><p>我们就以用户名、密码登录方式为例讲解一下Spring Security的登录认证流程。</p>
<p><img src="https://img.kancloud.cn/96/5b/965b390cafd239b8f33c44496a99dd64_978x674.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a><strong>UsernamePasswordAuthenticationFilter</strong></h4><p>该过滤器封装用户基本信息（用户名、密码），定义登录表单数据接收相关的信息。如：</p>
<ul>
<li>默认的表单用户名密码input框name是username、password</li>
<li>默认的处理登录请求路径是/login、使用POST方法</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808222037202.png" srcset="/img/loading.gif" lazyload alt="image-20210808222037202"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808222219124.png" srcset="/img/loading.gif" lazyload alt="image-20210808222219124"></p>
<h4 id="AbstractAuthenticationProcessingFilter的doFilter方法的验证过程"><a href="#AbstractAuthenticationProcessingFilter的doFilter方法的验证过程" class="headerlink" title="AbstractAuthenticationProcessingFilter的doFilter方法的验证过程"></a><strong>AbstractAuthenticationProcessingFilter的doFilter方法的验证过程</strong></h4><p><code>UsernamePasswordAuthenticationFilter</code>继承自抽象类<code>AbstractAuthenticationProcessingFilter</code>，该抽象类定义了验证成功与验证失败的处理方法。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span></span>
<span class="hljs-class">      <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationEventPublisherAware</span>, <span class="hljs-title">MessageSourceAware</span> </span></code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808222657609.png" srcset="/img/loading.gif" lazyload alt="image-20210808222657609"></p>
<h4 id="验证成功之后的Handler和验证失败之后的handler"><a href="#验证成功之后的Handler和验证失败之后的handler" class="headerlink" title="验证成功之后的Handler和验证失败之后的handler"></a><strong>验证成功之后的Handler和验证失败之后的handler</strong></h4><p><code>AbstractAuthenticationProcessingFilter</code>中定义了验证成功与验证失败的处理Handler。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AuthenticationSuccessHandler successHandler = <span class="hljs-keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();
<span class="hljs-keyword">private</span> AuthenticationFailureHandler failureHandler = <span class="hljs-keyword">new</span> SimpleUrlAuthenticationFailureHandler();</code></pre></div>

<p>也就是说当我们需要自定义验证成功或失败的处理方法时，要去实现<code>AuthenticationSuccessHandler</code>或<code>AuthenticationfailureHandler</code>接口</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210808222936948.png" srcset="/img/loading.gif" lazyload alt="image-20210808222936948"></p>
<h3 id="👏回到正题"><a href="#👏回到正题" class="headerlink" title="👏回到正题"></a>👏回到正题</h3><p>我们知道如果我们不希望用户、角色、权限信息写死在配置里面。我们应该实现<code>UserDetails</code>与<code>UserDetailsService</code>接口，从而从数据库或者其他的存储上动态的加载这些信息。</p>
<h4 id="UserDetails与UserDetailsService是什么呢？"><a href="#UserDetails与UserDetailsService是什么呢？" class="headerlink" title="UserDetails与UserDetailsService是什么呢？"></a><strong>UserDetails与UserDetailsService是什么呢？</strong></h4><p><code>UserDetailsService</code>接口表达的是如何动态加载<code>UserDetails</code>数据。</p>
<ul>
<li><code>UserDetailsService</code>接口有一个方法叫做<code>loadUserByUsername</code>，我们实现动态加载用户、角色、权限信息就是通过实现该方法。函数见名知义：通过用户名加载用户。该方法的返回值就是<code>UserDetails</code></li>
<li><code>UserDetails</code>就是用户信息，即：用户名、密码、该用户所具有的权限。</li>
</ul>
<p>下面我们来看一下<code>UserDetails</code>接口都有哪些方法。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-comment">//获取用户的权限集合</span>
    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();

    <span class="hljs-comment">//获取密码</span>
    <span class="hljs-function">String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">//获取用户名</span>
    <span class="hljs-function">String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">//账号是否没过期</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">//账号是否没被锁定</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">//密码是否没过期</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">//账户是否可用</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p>现在我们明白了，只要我们把这些信息提供给Spring Security，Spring Security就知道怎么做登录验证了，根本不需要我们自己写Controller实现登录验证逻辑。那我们怎么把这些信息提供给Spring Security，用的就是下面的接口方法。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;
   <span class="hljs-function">UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException</span>;
&#125;</code></pre></div>

<p>现在我们明白了，只要我们把这些信息提供给Spring Security，Spring Security就知道怎么做登录验证了，根本不需要我们自己写Controller实现登录验证逻辑。那我们怎么把这些信息提供给Spring Security，用的就是下面的接口方法。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;
   <span class="hljs-function">UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException</span>;
&#125;</code></pre></div>

<h4 id="实现UserDetails-接口"><a href="#实现UserDetails-接口" class="headerlink" title="实现UserDetails 接口"></a>实现UserDetails 接口</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;

  String password;  <span class="hljs-comment">//密码</span>
  String username;  <span class="hljs-comment">//用户名</span>
  <span class="hljs-keyword">boolean</span> accountNonExpired;   <span class="hljs-comment">//是否没过期</span>
  <span class="hljs-keyword">boolean</span> accountNonLocked;   <span class="hljs-comment">//是否没被锁定</span>
  <span class="hljs-keyword">boolean</span> credentialsNonExpired;  <span class="hljs-comment">//密码是否没过期</span>
  <span class="hljs-keyword">boolean</span> enabled;  <span class="hljs-comment">//账号是否可用</span>
  Collection&lt;? extends GrantedAuthority&gt; authorities;  <span class="hljs-comment">//用户的权限集合</span>


  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.password = password;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.username = username;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAccountNonExpired</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> accountNonExpired)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.accountNonExpired = accountNonExpired;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAccountNonLocked</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> accountNonLocked)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.accountNonLocked = accountNonLocked;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCredentialsNonExpired</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> credentialsNonExpired)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.credentialsNonExpired = credentialsNonExpired;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnabled</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> enabled)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.enabled = enabled;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthorities</span><span class="hljs-params">(Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.authorities = authorities;
  &#125;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;
    <span class="hljs-keyword">return</span> authorities;
  &#125;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> password;
  &#125;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> username;
  &#125;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//暂时未用到，直接返回true，表示账户未过期</span>
  &#125;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//暂时未用到，直接返回true，表示账户未被锁定</span>
  &#125;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//暂时未用到，直接返回true，表示账户密码未过期</span>
  &#125;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> enabled;
  &#125;
&#125;</code></pre></div>

<p>我们就是写了一个适应于<code>UserDetails</code>的Bean类，所谓的 <code>UserDetails</code>接口实现就是一些get方法。</p>
<ul>
<li>get方法由Spring Security调用，获取认证及鉴权的数据</li>
<li>我们通过set方法或构造函数为 Spring Security 提供<code>UserDetails</code>数据（从数据库查询）。</li>
<li><strong>当enabled的值为false的时候，Spring Security 会自动的禁用该用户，禁止该用户进行系统登录。</strong></li>
<li>通常数据库表sys_user字段要和Hr 属性一一对应，比如username、password、enabled。</li>
</ul>
<blockquote>
<p>目前数据库表里面没有定义accountNonExpired、accountNonLocked、credentialsNonExpired这三个字段，我一般不喜欢搞这么多字段控制用户的登录认证行为，笔者觉得简单点好，一个enabled字段就够了。所以这三个成员变量对应的get方法，直接返回true即可。</p>
</blockquote>
<p>另外，<strong>UserDetails中还有一个方法叫做getAuthorities，该方法用来获取当前用户所具有的角色</strong>，我的角色中有一个roles属性（即role表）用来描述当前用户的角色，因此我的getAuthorities方法的实现如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;
    List&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (Role role : roles) &#123;
        authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));
    &#125;
    <span class="hljs-keyword">return</span> authorities;
&#125;</code></pre></div>

<p>即直接从<code>roles</code>中获取当前用户所具有的角色，构造<code>SimpleGrantedAuthority</code>然后返回即可</p>
<p><code>SimpleGrantedAuthority</code>简单来说就是存储授予<code>Authentication</code>对象的权限的字符串表示形式。</p>
<h4 id="SimpleGrantedAuthority"><a href="#SimpleGrantedAuthority" class="headerlink" title="SimpleGrantedAuthority"></a><strong>SimpleGrantedAuthority</strong></h4><p>在Security中，角色和权限共用<code>GrantedAuthority</code>接口，唯一的不同角色就是多了个前缀”ROLE_”，而且它没有Shiro的那种从属关系，即一个角色包含哪些权限等等。在Security看来角色和权限时一样的，它认证的时候，把所有权限（角色、权限）都取出来，而不是分开验证。</p>
<p>所以，在Security提供的<code>UserDetailsService</code>默认实现<code>JdbcDaoImpl</code>中，角色和权限都存储在auhtorities表中。而不是像Shiro那样，角色有个roles表，权限有个permissions表。以及相关的管理表等等。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleGrantedAuthority</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GrantedAuthority</span> </span>&#123;

   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;

   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String role;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleGrantedAuthority</span><span class="hljs-params">(String role)</span> </span>&#123;
      Assert.hasText(role, <span class="hljs-string">&quot;A granted authority textual representation is required&quot;</span>);
      <span class="hljs-keyword">this</span>.role = role;
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthority</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.role;
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == obj) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
      &#125;
      <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> SimpleGrantedAuthority) &#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.role.equals(((SimpleGrantedAuthority) obj).role);
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.role.hashCode();
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.role;
   &#125;

&#125;</code></pre></div>

<p>注意，在构建<code>SimpleGrantedAuthority</code>对象的时候，它没有添加任何前缀。所以表示”角色”的权限，在数据库中就带有”ROLE_”前缀了。所以<code>authorities</code>表中的视图可能是这样的。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220537827.png" srcset="/img/loading.gif" lazyload alt="image-20210809220537827"></p>
<p><strong>角色和权限能否分开存储？角色能不能不带”ROLE_”前缀</strong></p>
<p>当然可以分开存储，你可以定义两张表，一张存角色，一张存权限。但是你自定义<code>UserDetailsService</code>的时候，需要保证把这两张表的数据都取出来，放到<code>UserDails</code>的权限集合中。当然你数据库中存储的角色也可以不带”ROLE_”前缀，就像这样。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220551920.png" srcset="/img/loading.gif" lazyload alt="image-20210809220551920"></p>
<p>但是前面说到了，Security才不管你是角色，还是权限。它只比对字符串。</p>
<p>比如它有个表达式hasRole(“ADMIN”)。那它实际上查询的是用户权限集合中是否存在字符串”ROLE_ADMIN”。如果你从角色表中取出用户所拥有的角色时不加上”ROLE_”前缀，那验证的时候就匹配不上了。</p>
<p>所以角色信息存储的时候可以没有”ROLE_”前缀，但是包装成<code>GrantedAuthority</code>对象的时候必须要有。</p>
<h4 id="自定义Service"><a href="#自定义Service" class="headerlink" title="自定义Service"></a>自定义Service</h4><p>创建好<code>Hr</code>之后，接下来我们需要创建<code>HrService</code>，用来执行登录等操作，**<code>HrService</code>需要实现<code>UserDetailsService</code>接口，如下：**</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HrService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    HrMapper hrMapper;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;

        Hr hr = hrMapper.loadUserByUsername(username);
        <span class="hljs-keyword">if</span> (hr == <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;用户名不存在！&quot;</span>);
        &#125;

        hr.setRoles(hrMapper.getHrRolesById(hr.getId()));

        <span class="hljs-keyword">return</span> hr;
    &#125;</code></pre></div>

<p>这里最主要是实现了**<code>UserDetailsService</code>接口中的<code>loadUserByUsername</code>方法**，在执行登录的过程中，这个方法将根据用户名去查找用户，如果用户不存在，则抛出<code>UsernameNotFoundException</code>异常，否则直接将查到的<code>Hr</code>返回。<code>HrMapper</code>用来执行数据库的查询操作。</p>
<h2 id="🔑根据请求地址获取角色"><a href="#🔑根据请求地址获取角色" class="headerlink" title="🔑根据请求地址获取角色"></a>🔑根据请求地址获取角色</h2><p>先引入一下<code>SecurityMetadataSource</code>的概念：</p>
<h3 id="SecurityMetadataSource"><a href="#SecurityMetadataSource" class="headerlink" title="SecurityMetadataSource"></a>SecurityMetadataSource</h3><p><code>SecurityMetadataSource</code>是<code>Spring Security</code>的一个概念模型接口。用于表示对受权限保护的”安全对象”的权限设置信息。一个该类对象可以被理解成一个映射表，映射表中的每一项包含如下信息 :</p>
<ul>
<li>安全对象</li>
<li>安全对象所需权限信息</li>
</ul>
<p>围绕该映射表，<code>SecurityMetadataSource</code> 定义了如下方法 :</p>
<ul>
<li><code>Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException;</code></li>
</ul>
<blockquote>
<p>获取某个受保护的安全对象<code>object</code>的所需要的权限信息,是一组<code>ConfigAttribute</code>对象的集合，如果该安全对象<code>object</code>不被当前<code>SecurityMetadataSource</code>对象支持,则抛出异常<code>IllegalArgumentException</code>。<br>该方法通常配合<code>boolean supports(Class&lt;?&gt; clazz)</code>一起使用，先使用<code>boolean supports(Class&lt;?&gt; clazz)</code>确保安全对象能被当前<code>SecurityMetadataSource</code>支持，然后再调用该方法。</p>
</blockquote>
<ul>
<li><code>Collection&lt;ConfigAttribute&gt; getAllConfigAttributes()</code></li>
</ul>
<blockquote>
<p>获取该<code>SecurityMetadataSource</code>对象中保存的针对所有安全对象的权限信息的集合。该方法的主要目的是被<code>AbstractSecurityInterceptor</code>用于启动时校验每个<code>ConfigAttribute</code>对象。</p>
</blockquote>
<ul>
<li><code>boolean supports(Class&lt;?&gt; clazz)</code></li>
</ul>
<blockquote>
<p>这里<code>clazz</code>表示安全对象的类型，该方法用于告知调用者当前<code>SecurityMetadataSource</code>是否支持此类安全对象，只有支持的时候，才能对这类安全对象调用<code>getAttributes</code>方法。</p>
</blockquote>
<p><strong>继承关系</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190623090023883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZHlfemhhbmcyMDA3,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="SecurityMetadataSource"><br><code>Spring Security</code>对<code>SecurityMetadataSource</code>提供了两个子接口 :</p>
<ul>
<li><p>```<br>MethodSecurityMetadataSource</p>
<div class="hljs code-wrapper"><pre><code class="hljs autohotkey">
  &gt; 由`Spring Security Core`定义，用于表示安全对象是方法调用(`MethodInvocation`)的安全元数据源。

- ```
  FilterInvocationSecurityMetadataSource</code></pre></div>

<blockquote>
<p>由<code>Spring Security Web</code>定义，用于表示安全对象是<code>Web</code>请求(<code>FilterInvocation</code>)的安全元数据源。</p>
</blockquote>
</li>
</ul>
<h3 id="FilterInvocationSecurityMetadataSource"><a href="#FilterInvocationSecurityMetadataSource" class="headerlink" title="FilterInvocationSecurityMetadataSource"></a>FilterInvocationSecurityMetadataSource</h3><p>一般情况下，我们如果需要自定义权限拦截，则需要涉及到<code>FilterInvocationSecurityMetadataSource</code>这个接口了。</p>
<p>这里有个坑爹的地方。如果用户未登录，但是已经设置了拦截白名单的URL，仍然会进入到权限验证里面来。起初，我以为不会进来，但后来跟踪源代码发现，还是会进来。只是此时的身份是一个匿名用户。其默认的实现为<code>DefaultFilterInvocationSecurityMetadataSource</code></p>
<p>spring security的认证和权限流程，大概就是有多个过滤器，一步步调用filter chain。它的身份认证其实是始于访问资源开始。如果一个用户已登录，那么访问受保护的资源，则会校验该用户是否有权限访问。如果没有权限，则会调用权限拒绝的处理器进行处理。如果有权限，则能顺利访问该资源；</p>
<p>一个用户未登录情况下，也即匿名用户，访问受保护的资源时，spring security会首先检查该资源是否需要权限，如果需要权限，然后再检查，该资源是否是白名单里面。如果是白名单，也能正常访问。如果是受保护的资源，则会提示该用户需要登录。</p>
<p>也即，当一个匿名用户，访问受保护的资源时，就会提示该用户需要登录。</p>
<p>所以说，在<code>FilterInvocationSecurityMetadataSource</code>中默认的实现类<code>DefaultFilterInvocationSecurityMetadataSource</code><strong>的主要功能就是通过当前的请求地址，获取该地址需要的用户角色</strong></p>
<p>我们可以参考这个实现类，自己也定义一个<code>FilterInvocationSecurityMetadataSource</code>，如下</p>
<p>主要工作为：</p>
<ul>
<li>从数据源中加载<code>ConfigAttribute</code>到<code>SecurityMetadataSource</code>资源器中</li>
<li>重写<code>getAttributes()</code>加载<code>ConfigAttribute</code>为<code>AccessDecisionManager.decide()</code>授权决策做准备。</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomFilterInvocationSecurityMetadataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterInvocationSecurityMetadataSource</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    MenuService menuService;
    <span class="hljs-comment">//路径匹配</span>
    AntPathMatcher antPathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAttributes</span><span class="hljs-params">(Object object)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;
        <span class="hljs-comment">//获取请求的地址</span>
        String requestUrl = ((FilterInvocation) object).getRequestUrl();
        List&lt;Menu&gt; menus = menuService.getAllMenusWithRole();
        <span class="hljs-keyword">for</span> (Menu menu : menus) &#123;
            <span class="hljs-keyword">if</span> (antPathMatcher.match(menu.getUrl(), requestUrl)) &#123;
                List&lt;Role&gt; roles = menu.getRoles();

                String[] str = <span class="hljs-keyword">new</span> String[roles.size()];
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; roles.size(); i++) &#123;
                    str[i] = roles.get(i).getName();
                &#125;
                <span class="hljs-keyword">return</span> SecurityConfig.createList(str);
            &#125;
        &#125;
        <span class="hljs-comment">//没有匹配上的资源，都是登录访问</span>
        <span class="hljs-keyword">return</span> SecurityConfig.createList(<span class="hljs-string">&quot;ROLE_LOGIN&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAllConfigAttributes</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
&#125;</code></pre></div>

<ul>
<li>一开始注入了<code>MenuService</code>，<code>MenuService</code>的作用是用来查询数据库中url pattern和role的对应关系（ <code>menuService.getAllMenu()</code>后面可用缓存来存），查询结果是一个List集合，集合中是Menu类，<strong>Menu类有两个核心属性，一个是url pattern，即匹配规则(比如<code>/admin/**</code>)，还有一个是List，即这种规则的路径需要哪些角色才能访问。</strong></li>
<li>我们可以从<code>getAttributes(Object o)</code>方法的参数o中提取出当前的请求url，然后将这个请求url和数据库中查询出来的所有url pattern一一对照，看符合哪一个url pattern，然后就获取到该url pattern所对应的角色，当然这个角色可能有多个，所以遍历角色，最后利用<code>SecurityConfig.createList</code>方法来创建一个角色集合。</li>
<li>第二步的操作中，涉及到一个优先级问题，比如我的地址是<code>/employee/basic/hello</code>,这个地址既能被<code>/employee/**</code>匹配，也能被<code>/employee/basic/**</code>匹配，这就要求我们从数据库查询的时候对数据进行排序，将<code>/employee/basic/**</code>类型的url pattern放在集合的前面去比较。</li>
<li>如果<code>getAttributes(Object o)</code>方法返回null的话，意味着当前这个请求不需要任何角色就能访问，甚至不需要登录。但是在我的整个业务中，并不存在这样的请求，我这里的要求是，<strong>所有未匹配到的路径，都是认证(登录)后可访问，因此我在这里返回一个<code>ROLE_LOGIN</code>的角色，这种角色在我的角色数据库中并不存在，因此我将在下一步的角色比对过程中特殊处理这种角色</strong>。</li>
<li>如果地址是<code>/login_p</code>，这个是登录页，不需要任何角色即可访问，直接返回null。</li>
<li><code>getAttributes(Object o)</code>方法返回的集合最终会来到<code>AccessDecisionManager</code>类中，接下来我们再来看<code>AccessDecisionManager</code>类</li>
</ul>
<h2 id="🔑-检查角色是否满足匹配"><a href="#🔑-检查角色是否满足匹配" class="headerlink" title="🔑  检查角色是否满足匹配"></a>🔑  检查角色是否满足匹配</h2><p>先引入一下<code>AccessDecisionManager</code>的概念：</p>
<h3 id="AccessDecisionManager"><a href="#AccessDecisionManager" class="headerlink" title="AccessDecisionManager"></a>AccessDecisionManager</h3><p><img src="https://oscimg.oschina.net/oscnet/fe299820424c5ead6a7f3bc97fa8dd957a5.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>AccessDecisionManager</strong> 顾名思义，访问决策管理器。即做出最终的访问控制（授权）决定。</p>
<p>而常用的 <strong>AccessDecisionManager</strong> 有三个，这里我就使用最简单的一个<strong>AffirmativeBased</strong>中的思想，这是<strong>Spring Security</strong> 框架默认的 <strong>AccessDecisionManager</strong>：<strong>只要任一 AccessDecisionVoter 返回肯定的结果，便授予访问权限</strong>。</p>
<p>自定义<code>CustomUrlDecisionManager</code>类实现<code>AccessDecisionManager</code>接口，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUrlDecisionManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDecisionManager</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decide</span><span class="hljs-params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="hljs-keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;
        <span class="hljs-keyword">for</span> (ConfigAttribute configAttribute : configAttributes) &#123;
            <span class="hljs-comment">//当前请求需要的权限</span>
            String needRole = configAttribute.getAttribute();
            <span class="hljs-comment">//如果是匿名用户，抛异常</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ROLE_LOGIN&quot;</span>.equals(needRole)) &#123;
                <span class="hljs-keyword">if</span> (authentication <span class="hljs-keyword">instanceof</span> AnonymousAuthenticationToken)&#123;
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;尚未登录，请登录！&quot;</span>);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
            &#125;
            <span class="hljs-comment">//当前用户所具有的权限</span>
            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();
            <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;
                <span class="hljs-comment">//需要的角色能被检测到</span>
                <span class="hljs-keyword">if</span> (authority.getAuthority().equals(needRole))&#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;权限不足，请返回！&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
&#125;</code></pre></div>

<ul>
<li>decide方法接收三个参数，<strong>其中第一个参数中保存了当前登录用户的角色信息，第三个参数则是<code>CustomFilterInvocationSecurityMetadataSource</code>中的<code>getAttributes</code>方法传来的，表示当前请求需要的角色（可能有多个）</strong></li>
<li>如果当前请求需要的权限为<code>ROLE_LOGIN</code>则表示登录即可访问，和角色没有关系，此时我需要判断authentication是不是<code>AnonymousAuthenticationToken</code>的一个实例，如果是，则表示当前用户没有登录，没有登录就抛一个<code>BadCredentialsException</code>异常，登录了就直接返回，则这个请求将被成功执行。</li>
<li><strong>遍历collection，同时查看当前用户的角色列表中是否具备需要的权限</strong>，如果具备就直接返回，否则就抛异常。</li>
<li>这里涉及到一个all和any的问题：假设当前用户具备角色A、角色B，当前请求需要角色B、角色C，那么是要当前用户要包含所有请求角色才算授权成功还是只要包含一个就算授权成功？我这里采用了第二种方案，即只要包含一个即可</li>
</ul>
<p><strong>到目前为止，获取角色和判断角色是否满足匹配到部分已经分析结束，下面开始分析登录的验证和自定义登录过滤器的具体流程</strong></p>
<h2 id="🔍登录的验证"><a href="#🔍登录的验证" class="headerlink" title="🔍登录的验证"></a>🔍登录的验证</h2><p>下面就要针对于登录进行更深一步的说明，登录验证涉及到账号、密码、与验证码</p>
<h3 id="PasswordEncoder"><a href="#PasswordEncoder" class="headerlink" title="PasswordEncoder"></a>PasswordEncoder</h3><p><code>PasswordEncoder</code> 是Spring Scurity框架内处理密码加密与校验的接口。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.security.crypto.password;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PasswordEncoder</span> </span>&#123;
   <span class="hljs-function">String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span></span>;

   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span></span>;

   <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">upgradeEncoding</span><span class="hljs-params">(String encodedPassword)</span> </span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
   &#125;
&#125;</code></pre></div>

<p>这个接口有三个方法</p>
<ul>
<li><code>encode</code>方法接受的参数是原始密码字符串，返回值是经过加密之后的hash值，hash值是不能被逆向解密的。这个方法通常在为系统添加用户，或者用户注册的时候使用。</li>
<li><code>matches</code>方法是用来校验用户输入密码rawPassword，和加密后的hash值encodedPassword是否匹配。如果能够匹配返回true，表示用户输入的密码rawPassword是正确的，反之返回fasle。也就是说虽然这个hash值不能被逆向解密，但是可以判断是否和原始密码匹配。<strong>这个方法通常在用户登录的时候进行用户输入密码的正确性校验。</strong></li>
<li><code>upgradeEncoding</code>设计的用意是，判断当前的密码是否需要升级。也就是是否需要重新加密？需要的话返回true，不需要的话返回fasle。默认实现是返回false。</li>
</ul>
<p> <strong><code>BCryptPasswordEncoder</code> 作为Spring Security推荐使用的 <code>PasswordEncoder</code>实现类 ，可以实现对密码的自动加密加盐</strong>，（盐是值即使相同的明文，生成的新的加密字符串都是不一样的），这样可以避免像在Shiro中那样我们自己配置密码的盐，而 <code>BCryptPasswordEncoder</code> 就是     <code>PasswordEncoder</code> 接口的实现类，只需要提供 <code>BCryptPasswordEncoder</code> 这个 Bean 的实例即可，SpringSecurity中使用<code>BCryptPasswordEncoder</code>的具体流程如下：</p>
<blockquote>
<p>BCryptPasswordEncoder 使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。</p>
</blockquote>
<p>在用户注册时，我们需要对密码进行处理，处理方式如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hrReg</span><span class="hljs-params">(String username, String password)</span> </span>&#123;
    <span class="hljs-comment">//如果用户名存在，返回错误</span>
    <span class="hljs-keyword">if</span> (hrMapper.loadUserByUsername(username) != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;
    BCryptPasswordEncoder encoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
    String encode = encoder.encode(password);
    <span class="hljs-keyword">return</span> hrMapper.hrReg(username, encode);
&#125;</code></pre></div>

<p>用户将密码从前端传来之后，通过调用 <code>BCryptPasswordEncoder</code> 实例中的 encode 方法对密码进行加密处理，加密完成后将密文存入数据库。</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">$2a$10$zt6dUMTjNSyzINTGyiAgluna3mPm7qdgl26vj4tFpsFO6WlK5lXNm</span></code></pre></div>

<p>BCrypt加密后的密码有三个部分，由 $分隔：</p>
<ol>
<li>“2a”表示 BCrypt 算法版本</li>
<li>“10”表示算法的强度</li>
<li>“zt6dUMTjNSyzINTGyiAglu”部分实际上是随机生成的盐。通常来说前 22 个字符是盐，剩余部分是纯文本的实际哈希值。</li>
</ol>
<blockquote>
<p>BCrypt算法生成长度为 60 的字符串，因此我们需要确保密码将存储在可以容纳密码的数据库列中。</p>
</blockquote>
<p>当用户注册成功之后，存在数据库中的密码就像下面这样：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/p283.png" srcset="/img/loading.gif" lazyload alt="p283"></p>
<p>假如明文都是 123。配置完成后，使用 admin/123 或者 sang/123 就可以实现登录。</p>
<p>密码加密处理之后，登录时候也要对密码进行处理，<strong>修改SecurityConfig类的configure(AuthenticationManagerBuilder auth)方法，</strong>改为下面这样即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
&#125;

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    auth.userDetailsService(hrService);
&#125;</code></pre></div>

<h3 id="验证码的校验"><a href="#验证码的校验" class="headerlink" title="验证码的校验"></a>验证码的校验</h3><p>验证码的生成接口十分多，这里不再提供，这个工具类很常见，网上也有很多，就是画一个简单的验证码，通过流将验证码写到前端页面，提供验证码的 Controller 如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/verifyCode&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyCode</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
  	<span class="hljs-comment">//获取实例</span>
    VerificationCode code = <span class="hljs-keyword">new</span> VerificationCode();
    BufferedImage image = code.getImage();
    String text = code.getText();
    HttpSession session = request.getSession(<span class="hljs-keyword">true</span>);
    session.setAttribute(<span class="hljs-string">&quot;verify_code&quot;</span>, text);
    VerificationCode.output(image,resp.getOutputStream());
&#125;</code></pre></div>

<p>同时需要在Spring Security配置类中配置不拦截此接口</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">//防止访问登录页面死循环，不用进入Security拦截</span>
    web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/img/**&quot;</span>, <span class="hljs-string">&quot;/fonts/**&quot;</span>, <span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;/verifyCode&quot;</span>);
&#125;</code></pre></div>

<p>因为涉及到自定义登陆逻辑，所以需要自定义登陆过滤器，这里先不说明实现过滤器的详细流程，等到下面讲到JSON登陆的时候，统一处理</p>
<p>需要注意的是，过滤器自定义完成后，也需要在配置类中注入，这里才能能完成整个流程的配置。</p>
<h3 id="实现JSON格式登陆"><a href="#实现JSON格式登陆" class="headerlink" title="实现JSON格式登陆"></a>实现JSON格式登陆</h3><p>前后端分离这样的开发架构下，前后端的交互都是通过 JSON 来进行，无论登录成功还是失败，都不会有什么服务端跳转或者客户端跳转之类。</p>
<p>登录成功了，服务端就返回一段登录成功的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，就和后端没有关系了。</p>
<p>登录失败了，服务端就返回一段登录失败的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，也和后端没有关系了。</p>
<p>所以为了统一，我们需要在登录的时候，也实现JSON交互，但是我们首先得明白一个前提， 在使用 SpringSecurity 中，默认的登录数据是通过 <code>key/value</code> 的形式来传递的，<strong>默认情况下不支持 JSON格式的登录数据，如果有这种需求，就需要自己来解决，所以我们需要自定义过滤器</strong></p>
<p>首先大家知道，用户登录的用户名/密码是在 <code>UsernamePasswordAuthenticationFilter</code> 类中处理的，具体的处理代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span>
<span class="hljs-function"><span class="hljs-params">		HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;
	String username = obtainUsername(request);
	String password = obtainPassword(request);
    <span class="hljs-comment">//省略</span>
&#125;
<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainPassword</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;
	<span class="hljs-keyword">return</span> request.getParameter(passwordParameter);
&#125;
<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainUsername</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;
	<span class="hljs-keyword">return</span> request.getParameter(usernameParameter);
&#125;</code></pre></div>

<p>从这段代码中，我们就可以看出来为什么 Spring Security 默认是通过 key/value 的形式来传递登录参数，因为它处理的方式就是<code> request.getParameter</code>。</p>
<p>所以我们要定义成 JSON 的，思路很简单，就是自定义来定义一个过滤器代替 <code>UsernamePasswordAuthenticationFilter</code>，然后在获取参数的时候，换一种方式就行了。</p>
<p>所以我们需要模仿源代码中的此部分来个性化定制：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809163840081.png" srcset="/img/loading.gif" lazyload alt="image-20210809163840081"></p>
<p><strong>这里有一个额外的点需要注意，就是现在还有验证码的功能，所以如果自定义过滤器，要连同验证码一起处理掉。</strong></p>
<p>接下来我们来自定义一个过滤器代替 <code>UsernamePasswordAuthenticationFilter</code> ，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;
  	<span class="hljs-comment">//需要重写的方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;
      	<span class="hljs-comment">//此部分逻辑不变</span>
        <span class="hljs-keyword">if</span> (!request.getMethod().equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(
                    <span class="hljs-string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());
        &#125;
      	<span class="hljs-comment">//拿到正确的验证码</span>
        String verify_code = (String) request.getSession().getAttribute(<span class="hljs-string">&quot;verify_code&quot;</span>);
      <span class="hljs-comment">//判断是Key/Value还是JSON传递</span>
        <span class="hljs-keyword">if</span> (request.getContentType().contains(MediaType.APPLICATION_JSON_VALUE) || request.getContentType().contains(MediaType.APPLICATION_JSON_UTF8_VALUE)) &#123;
          	<span class="hljs-comment">//封装传来的数据</span>
            Map&lt;String, String&gt; loginData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
            <span class="hljs-keyword">try</span> &#123;
                loginData = <span class="hljs-keyword">new</span> ObjectMapper().readValue(request.getInputStream(), Map.class);
            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            &#125;<span class="hljs-keyword">finally</span> &#123;
              	<span class="hljs-comment">//浏览器传过来输入的</span>
                String code = loginData.get(<span class="hljs-string">&quot;code&quot;</span>);
                checkCode(response, code, verify_code);
            &#125;
            String username = loginData.get(getUsernameParameter());
            String password = loginData.get(getPasswordParameter());
            <span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;
                username = <span class="hljs-string">&quot;&quot;</span>;
            &#125;
            <span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;
                password = <span class="hljs-string">&quot;&quot;</span>;
            &#125;
            username = username.trim();
            UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(
                    username, password);
            setDetails(request, authRequest);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);
        &#125; 
      <span class="hljs-comment">//Key/Value直接用父类处理即可</span>
      <span class="hljs-keyword">else</span> &#123;
            checkCode(response, request.getParameter(<span class="hljs-string">&quot;code&quot;</span>), verify_code);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.attemptAuthentication(request, response);
        &#125;
    &#125;	
		<span class="hljs-comment">//校验输入的和正确生成的是否匹配</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkCode</span><span class="hljs-params">(HttpServletResponse resp, String code, String verify_code)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (code == <span class="hljs-keyword">null</span> || verify_code == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(code) || !verify_code.toLowerCase().equals(code.toLowerCase())) &#123;
            <span class="hljs-comment">//验证码不正确</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">&quot;验证码不正确&quot;</span>);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>这段逻辑我们基本上是模仿官方提供的 <code>UsernamePasswordAuthenticationFilter</code> 来写的，稍微解释下：</p>
<ol>
<li>首先登录请求肯定是 POST，如果不是 POST ，直接抛出异常，后面的也不处理了。</li>
<li>因为要在这里处理验证码，所以第二步从 session 中把已经下发过的验证码的值拿出来。</li>
<li>接下来通过 contentType 来判断当前请求是否通过 JSON 来传递参数，如果是通过 JSON 传递参数，则按照 JSON 的方式解析，如果不是，则调用 <code>super.attemptAuthentication </code>方法，进入父类的处理逻辑中，也就是说，<strong>我们自定义的这个类，既支持 JSON 形式传递参数，也支持 key/value 形式传递参数。</strong></li>
<li>如果是 JSON 形式的数据，我们就通过读取 request 中的 I/O 流，将 JSON 映射到一个 Map 上。</li>
<li>从 Map 中取出 code，先去判断验证码是否正确，如果验证码有错，则直接抛出异常</li>
<li>接下来从 Map 中取出 username 和 password，构造 UsernamePasswordAuthenticationToken 对象并作校验。</li>
</ol>
<p><strong>接下来就是在Spring Security配置类中配置此过滤器即可</strong></p>
<h3 id="Spring-Security配置类"><a href="#Spring-Security配置类" class="headerlink" title="Spring Security配置类"></a>Spring Security配置类</h3><h4 id="基础注入"><a href="#基础注入" class="headerlink" title="基础注入"></a>基础注入</h4><p>结合以上所讲的，就能在配置类中整合所有需要用到的校验类，首先在Spring Security配置类中配置基础的信息</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
		<span class="hljs-comment">//UserDetial的校验</span>
    <span class="hljs-meta">@Autowired</span>
    HrService hrService;
  
		<span class="hljs-comment">//根据请求地址获取角色的校验</span>
    <span class="hljs-meta">@Autowired</span>
    CustomFilterInvocationSecurityMetadataSource customFilterInvocationSecurityMetadataSource;
		<span class="hljs-comment">//检查角色的校验</span>
    <span class="hljs-meta">@Autowired</span>
    CustomUrlDecisionManager customUrlDecisionManager;
		<span class="hljs-comment">//密码的校验</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
    &#125;
		<span class="hljs-comment">//密码加密处理后配置</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        auth.userDetailsService(hrService);
    &#125;</code></pre></div>

<h4 id="登陆成功失败的回调"><a href="#登陆成功失败的回调" class="headerlink" title="登陆成功失败的回调"></a>登陆成功失败的回调</h4><p>接下来就需要针对刚定义好的过滤器进一步配置</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    LoginFilter loginFilter = <span class="hljs-keyword">new</span> LoginFilter();
  	<span class="hljs-comment">//成功回调</span>
    loginFilter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;
                response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                PrintWriter out = response.getWriter();
                Hr hr = (Hr) authentication.getPrincipal();
                hr.setPassword(<span class="hljs-keyword">null</span>);
                RespBean ok = RespBean.ok(<span class="hljs-string">&quot;登录成功!&quot;</span>, hr);
                String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok);
                out.write(s);
                out.flush();
                out.close();
            &#125;
    );
  <span class="hljs-comment">//失败回调</span>
    loginFilter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;
                response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                PrintWriter out = response.getWriter();
                RespBean respBean = RespBean.error(exception.getMessage());
                <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> LockedException) &#123;
                    respBean.setMsg(<span class="hljs-string">&quot;账户被锁定，请联系管理员!&quot;</span>);
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;
                    respBean.setMsg(<span class="hljs-string">&quot;密码过期，请联系管理员!&quot;</span>);
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;
                    respBean.setMsg(<span class="hljs-string">&quot;账户过期，请联系管理员!&quot;</span>);
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> DisabledException) &#123;
                    respBean.setMsg(<span class="hljs-string">&quot;账户被禁用，请联系管理员!&quot;</span>);
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;
                    respBean.setMsg(<span class="hljs-string">&quot;用户名或者密码输入错误，请重新输入!&quot;</span>);
                &#125;
                out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));
                out.flush();
                out.close();
            &#125;
    );</code></pre></div>

<p><code>AuthenticationSuccessHandler</code>方法有三个参数，分别是：</p>
<ul>
<li><code>HttpServletRequest</code></li>
<li><code>HttpServletResponse</code></li>
<li><code>Authentication</code></li>
</ul>
<p>有了前两个参数，我们就可以在这里随心所欲的返回数据了。利用 <code>HttpServletRequest</code> 我们可以做服务端跳转，利用 <code>HttpServletResponse </code>我们可以做客户端跳转，当然，也可以返回 JSON 数据。</p>
<p>第三个 <code>Authentication</code> 参数则保存了我们刚刚登录成功的用户信息。</p>
<p>同理，失败的回调也是三个参数，前两个就不用说了，第三个是一个 Exception，对于登录失败，会有不同的原因，Exception 中则保存了登录失败的原因，我们可以将之通过 JSON 返回到前端。</p>
<h4 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h4><p>这里我还挨个去识别了一下异常的类型，根据不同的异常类型，我们可以给用户一个更加明确的提示，但是有一个需要注意的点：</p>
<p>当用户登录时，用户名或者密码输入错误，我们一般只给一个模糊的提示，即<strong>用户名或者密码输入错误，请重新输入</strong>，而不会给一个明确的诸如“用户名输入错误”或“密码输入错误”这样精确的提示，但是对于很多不懂行的新手小伙伴，他可能就会给一个明确的错误提示，这会给系统带来风险。</p>
<p>但是使用了 Spring Security 这样的安全管理框架之后，即使你是一个新手，也不会犯这样的错误。</p>
<p>在 Spring Security 中，用户名查找失败对应的异常是：</p>
<ul>
<li><code>UsernameNotFoundException</code></li>
</ul>
<p>密码匹配失败对应的异常是：</p>
<ul>
<li><code>BadCredentialsException</code></li>
</ul>
<p>但是我们在登录失败的回调中，却总是看不到 <code>UsernameNotFoundException </code>异常，无论用户名还是密码输入错误，抛出的异常都是 <code>BadCredentialsException</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span>
<span class="hljs-function">		<span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;
	<span class="hljs-keyword">try</span> &#123;
		user = retrieveUser(username,
				(UsernamePasswordAuthenticationToken) authentication);
	&#125;
	<span class="hljs-keyword">catch</span> (UsernameNotFoundException notFound) &#123;
		logger.debug(<span class="hljs-string">&quot;User &#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27; not found&quot;</span>);
		<span class="hljs-keyword">if</span> (hideUserNotFoundExceptions) &#123;
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(
					<span class="hljs-string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>,
					<span class="hljs-string">&quot;Bad credentials&quot;</span>));
		&#125;
		<span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">throw</span> notFound;
		&#125;
	&#125;
&#125;</code></pre></div>

<p>从这段代码中，我们看出，在查找用户时，如果抛出了 <code>UsernameNotFoundException</code>，这个异常会被捕获，捕获之后，如果 <code>hideUserNotFoundExceptions</code> 属性的值为 true，就抛出一个 <code>BadCredentialsException</code>。相当于将 <code>UsernameNotFoundException </code>异常隐藏了，而默认情况下，<code>hideUserNotFoundExceptions</code> 的值就为 true。</p>
<h4 id="登陆未验证"><a href="#登陆未验证" class="headerlink" title="登陆未验证"></a>登陆未验证</h4><p>在前后端分离中，如果用户没有登录就访问一个需要认证后才能访问的页面，这个时候，我们不应该让用户重定向到登录页面，而是给用户一个尚未登录的提示，前端收到提示之后，再自行决定页面跳转。</p>
<p>要解决这个问题，就涉及到 Spring Security 中的一个接口 <code>AuthenticationEntryPoint</code> ，该接口有一个实现类：<code>LoginUrlAuthenticationEntryPoint</code> ，该类中有一个方法 <code>commence</code>，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Performs the redirect (or forward) to the login form URL.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span>
<span class="hljs-function"><span class="hljs-params">		AuthenticationException authException)</span> </span>&#123;
	String redirectUrl = <span class="hljs-keyword">null</span>;
	<span class="hljs-keyword">if</span> (useForward) &#123;
		<span class="hljs-keyword">if</span> (forceHttps &amp;&amp; <span class="hljs-string">&quot;http&quot;</span>.equals(request.getScheme())) &#123;
			redirectUrl = buildHttpsRedirectUrlForRequest(request);
		&#125;
		<span class="hljs-keyword">if</span> (redirectUrl == <span class="hljs-keyword">null</span>) &#123;
			String loginForm = determineUrlToUseForThisRequest(request, response,
					authException);
			<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;
				logger.debug(<span class="hljs-string">&quot;Server side forward to: &quot;</span> + loginForm);
			&#125;
			RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);
			dispatcher.forward(request, response);
			<span class="hljs-keyword">return</span>;
		&#125;
	&#125;
	<span class="hljs-keyword">else</span> &#123;
		redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);
	&#125;
	redirectStrategy.sendRedirect(request, response, redirectUrl);
&#125;</code></pre></div>

<p>首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。</p>
<p>那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
				.csrf().disable().exceptionHandling()
				<span class="hljs-comment">//没有认证时，在这里处理结果，不要重定向</span>
				.authenticationEntryPoint((req, resp, authException) -&gt; &#123;
            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
            resp.setStatus(<span class="hljs-number">401</span>);
            PrintWriter out = resp.getWriter();
            RespBean respBean = RespBean.error(<span class="hljs-string">&quot;访问失败!&quot;</span>);
            <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;
                respBean.setMsg(<span class="hljs-string">&quot;请求失败，请联系管理员!&quot;</span>);
            &#125;
            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));
            out.flush();
            out.close();
        &#125;
);</code></pre></div>

<p>在 Spring Security 的配置中加上自定义的 <code>AuthenticationEntryPoint</code> 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。</p>
<h4 id="注销登录"><a href="#注销登录" class="headerlink" title="注销登录"></a>注销登录</h4><p>注销登录我们前面说过，按照前面的配置，注销登录之后，系统自动跳转到登录页面，这也是不合适的，如果是前后端分离项目，注销登录成功后返回 JSON 即可，配置如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        .logout()
        .logoutSuccessHandler((req, resp, authentication) -&gt; &#123;
         resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
         PrintWriter out = resp.getWriter();
         out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.ok(<span class="hljs-string">&quot;注销成功!&quot;</span>)));
         out.flush();
         out.close();
         &#125;
         )
         .permitAll()
&#125;</code></pre></div>

<h4 id="LoginFilter的配置"><a href="#LoginFilter的配置" class="headerlink" title="LoginFilter的配置"></a>LoginFilter的配置</h4><p>在自定义JSON过滤器后，LoginFilter也需要相应的配置到安全配置类中</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
	...
loginFilter.setAuthenticationManager(authenticationManagerBean());
loginFilter.setFilterProcessesUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>);
&#125;</code></pre></div>

<p>当我们代替了 <code>UsernamePasswordAuthenticationFilter</code> 之后，原本在 <code>SecurityConfig#configure</code>方法中关于 form 表单的配置就会失效，那些失效的属性，都可以在配置 <code>LoginFilter</code> 实例的时候配置。另外记得配置一个 <code>AuthenticationManager</code>，根据 <code>WebSecurityConfigurerAdapter</code> 中提供的配置即可。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809192541708.png" srcset="/img/loading.gif" lazyload alt="image-20210809192541708"></p>
<p><code>FilterProcessUrl</code> 则可以根据实际情况配置，如果不配置，默认的就是 <code>/login</code>。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809192208902.png" srcset="/img/loading.gif" lazyload alt="image-20210809192208902"></p>
<p>最后，我们用自定义的 <code>LoginFilter</code> 实例代替 <code>UsernamePasswordAuthenticationFilter</code>，调用 addFilterAt 方法完成替换操作</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    http.authorizeRequests()
        ...
        <span class="hljs-comment">//省略</span>
    http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);
&#125;</code></pre></div>

<p><strong>上面基本就已经实现了基于RBAC的登陆流程，这里附上整体的配置类代码：</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java">**
 * <span class="hljs-meta">@author</span> lucifer
 */
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    HrService hrService;

    <span class="hljs-meta">@Autowired</span>
    CustomFilterInvocationSecurityMetadataSource customFilterInvocationSecurityMetadataSource;

    <span class="hljs-meta">@Autowired</span>
    CustomUrlDecisionManager customUrlDecisionManager;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        auth.userDetailsService(hrService);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//防止访问登录页面死循环，不用进入Security拦截</span>
        web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/img/**&quot;</span>, <span class="hljs-string">&quot;/fonts/**&quot;</span>, <span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;/verifyCode&quot;</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        LoginFilter loginFilter = <span class="hljs-keyword">new</span> LoginFilter();
        loginFilter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;
                    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                    PrintWriter out = response.getWriter();
                    Hr hr = (Hr) authentication.getPrincipal();
                    hr.setPassword(<span class="hljs-keyword">null</span>);
                    RespBean ok = RespBean.ok(<span class="hljs-string">&quot;登录成功!&quot;</span>, hr);
                    String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok);
                    out.write(s);
                    out.flush();
                    out.close();
                &#125;
        );
        loginFilter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;
                    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                    PrintWriter out = response.getWriter();
                    RespBean respBean = RespBean.error(exception.getMessage());
                    <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> LockedException) &#123;
                        respBean.setMsg(<span class="hljs-string">&quot;账户被锁定，请联系管理员!&quot;</span>);
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;
                        respBean.setMsg(<span class="hljs-string">&quot;密码过期，请联系管理员!&quot;</span>);
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;
                        respBean.setMsg(<span class="hljs-string">&quot;账户过期，请联系管理员!&quot;</span>);
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> DisabledException) &#123;
                        respBean.setMsg(<span class="hljs-string">&quot;账户被禁用，请联系管理员!&quot;</span>);
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;
                        respBean.setMsg(<span class="hljs-string">&quot;用户名或者密码输入错误，请重新输入!&quot;</span>);
                    &#125;
                    out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));
                    out.flush();
                    out.close();
                &#125;
        );
        loginFilter.setAuthenticationManager(authenticationManagerBean());
        loginFilter.setFilterProcessesUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>);
        <span class="hljs-keyword">return</span> loginFilter;
    &#125;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        http.authorizeRequests()
                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;
                        object.setAccessDecisionManager(customUrlDecisionManager);
                        object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);
                        <span class="hljs-keyword">return</span> object;
                    &#125;
                &#125;)
                .and()
                .logout()
                .logoutSuccessHandler((req, resp, authentication) -&gt; &#123;
                            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                            PrintWriter out = resp.getWriter();
                            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.ok(<span class="hljs-string">&quot;注销成功!&quot;</span>)));
                            out.flush();
                            out.close();
                        &#125;
                )
                .permitAll()
                .and()
                .csrf().disable().exceptionHandling()
                <span class="hljs-comment">//没有认证时，在这里处理结果，不要重定向</span>
                .authenticationEntryPoint((req, resp, authException) -&gt; &#123;
                            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                            resp.setStatus(<span class="hljs-number">401</span>);
                            PrintWriter out = resp.getWriter();
                            RespBean respBean = RespBean.error(<span class="hljs-string">&quot;访问失败!&quot;</span>);
                            <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;
                                respBean.setMsg(<span class="hljs-string">&quot;请求失败，请联系管理员!&quot;</span>);
                            &#125;
                            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));
                            out.flush();
                            out.close();
                        &#125;
                );
        http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);
    &#125;
&#125;</code></pre></div>

<h3 id="http-authorizeRequests"><a href="#http-authorizeRequests" class="headerlink" title="http.authorizeRequests()"></a>http.authorizeRequests()</h3><p>可以发现在配置中的开头有这样的配置，这个是干什么的？</p>
<p>这就涉及到 Spring Security 中过滤器链的配置问题了</p>
<blockquote>
<p>结合动态处理角色和资源的关系一起看</p>
</blockquote>
<h4 id="从过滤器开始"><a href="#从过滤器开始" class="headerlink" title="从过滤器开始"></a>从过滤器开始</h4><p>Spring Security 中一共提供了 32 个过滤器，其中默认使用的有 15 个，</p>
<p>在一个 Web 项目中，请求流程大概如下图所示：</p>
<img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220745044.png" srcset="/img/loading.gif" lazyload alt="image-20210809220745044" style="zoom:50%;" />

<p>请求从客户端发起（例如浏览器），然后穿过层层 Filter，最终来到 Servlet 上，被 Servlet 所处理。</p>
<p>那么，Spring Security 中默认的 15 个过滤器就是这样嵌套在 Client 和 Servlet 之间吗？</p>
<p>不是的！</p>
<p>上图中的 Filter 我们可以称之为 Web Filter，Spring Security 中的 Filter 我们可以称之为 Security Filter，它们之间的关系如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220801972.png" srcset="/img/loading.gif" lazyload alt="image-20210809220801972"></p>
<p>可以看到，Spring Security Filter 并不是直接嵌入到 Web Filter 中的，而是通过 <code>FilterChainProxy</code> 来统一管理 Spring Security Filter，<code>FilterChainProxy</code> 本身则通过 Spring 提供的 <code>DelegatingFilterProxy </code>代理过滤器嵌入到 Web Filter 之中。</p>
<blockquote>
<p>DelegatingFilterProxy 很多小伙伴应该比较熟悉，在 Spring 中手工整合 Spring Session、Shiro 等工具时都离不开它，现在用了 Spring Boot，很多事情 Spring Boot 帮我们做了，所以有时候会感觉 DelegatingFilterProxy 的存在感有所降低，实际上它一直都在。</p>
</blockquote>
<h4 id="多个过滤器链"><a href="#多个过滤器链" class="headerlink" title="多个过滤器链"></a>多个过滤器链</h4><p>上面和大家介绍的是单个过滤器链，实际上，在 Spring Security 中，可能存在多个过滤器链。</p>
<p>有人会问，下面这种配置是不是就是多个过滤器链？</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    http.authorizeRequests()
            .antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)
            .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasRole(<span class="hljs-string">&quot;user&quot;</span>)
            .anyRequest().authenticated()
            ...
            .csrf().disable();
&#125;</code></pre></div>

<p>这样的配置相信大家都见过，但是这并不是多个过滤器链，这是一个过滤器链。因为不管是 <code>/admin/**</code> 还是 <code>/user/**</code> ，走过的过滤器都是一样的，只是不同的路径判断条件不一样而已。</p>
<p>如果系统存在多个过滤器链，多个过滤器链会在 FilterChainProxy 中进行划分，如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220817060.png" srcset="/img/loading.gif" lazyload alt="image-20210809220817060"></p>
<p>可以看到，当请求到达 <code>FilterChainProxy</code> 之后，<code>FilterChainProxy</code> 会根据请求的路径，将请求转发到不同的 Spring Security Filters 上面去，不同的 Spring Security Filters 对应了不同的过滤器，也就是不同的请求将经过不同的过滤器。</p>
<h4 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h4><p>最后，我们在回到一开始的问题。</p>
<p>首先，<code>http.authorizeRequests()</code> 配置并非总在第一行出现，如果只有一个过滤器链，他总是在第一行出现，表示该过滤器链的拦截规则是 <code>/**</code>（<strong>请求只有先被过滤器链拦截下来，接下来才会进入到不同的 Security Filters 中进行处理</strong>），如果存在多个过滤器链，就不一定了。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-meta">@Configuration</span>
    <span class="hljs-meta">@Order(1)</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultWebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
            http.antMatcher(<span class="hljs-string">&quot;/foo/**&quot;</span>)
                    .authorizeRequests()
                    .anyRequest().hasRole(<span class="hljs-string">&quot;admin&quot;</span>)
                    .and()
                    .csrf().disable();
        &#125;
    &#125;

    <span class="hljs-meta">@Configuration</span>
    <span class="hljs-meta">@Order(2)</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultWebSecurityConfig2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
            http.antMatcher(<span class="hljs-string">&quot;/bar/**&quot;</span>)
                    .authorizeRequests()
                    .anyRequest().hasRole(<span class="hljs-string">&quot;user&quot;</span>)
                    .and()
                    .formLogin()
                    .permitAll()
                    .and()
                    .csrf().disable();
        &#125;
    &#125;
&#125;</code></pre></div>

<ol>
<li>注意在静态内部类里边，我没有使用 <code>http.authorizeRequests()</code> 开始，<code>http.authorizeRequests()</code> 配置表示该过滤器链过滤的路径是 <code>/**</code>。在静态内部类里边，我是用了 <code>http.antMatcher(&quot;/bar/**&quot;)</code> 开启配置，表示将当前过滤器链的拦截范围限定在 <code>/bar/**</code>。</li>
<li>当存在多个过滤器链的时候，必然会有一个优先级的问题，所以每一个过滤器链的配置类上通过 @Order(2) 注解来标记优先级。</li>
</ol>
<p>仅仅从字面意思来理解，<code>authorizeRequests()</code> 方法的返回值是 <code>ExpressionUrlAuthorizationConfigurer.ExpressionInterceptUrlRegistry，ExpressionUrlAuthorizationConfigurer</code> 可以为多组不同的 RequestMatcher 配置不同的权限规则，就是大家看到的 <code>.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;).antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;)</code>。</p>
<p><strong>对于配置中的一些细节（为什么要用这些来实现），将在下面用源码来进行分析，感兴趣的可以了解下</strong></p>
<h2 id="🔧加餐：源码剖析Spring-Security"><a href="#🔧加餐：源码剖析Spring-Security" class="headerlink" title="🔧加餐：源码剖析Spring Security"></a>🔧加餐：源码剖析Spring Security</h2><blockquote>
<p>本文基本上参考搬运了松哥的文章，松哥对Spring Security理解的十分透彻，推荐去学习，附上网站：<a target="_blank" rel="noopener" href="http://www.javaboy.org/">http://www.javaboy.org</a></p>
</blockquote>
<p>本部分主要针对<code>HttpSecurity、SecurityConfigurer、AuthenticationManagerBuilder、WebSecurityConfigurerAdapter</code>四部分进行源码分析，其他关键的类已在前面的部分做了必要的阐述</p>
<h3 id="👀HttpSecurity"><a href="#👀HttpSecurity" class="headerlink" title="👀HttpSecurity"></a>👀HttpSecurity</h3><blockquote>
<p>此节建议结合登陆的验证中的配置类来看</p>
</blockquote>
<p><code>HttpSecurity</code> 也是 Spring Security 中的重要一环。我们平时所做的大部分 Spring Security 配置也都是基于 <code>HttpSecurity </code>来配置的。比如，刚才我们配置类中的<code>configure</code>就使用到了</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception</span></code></pre></div>

<p>首先我们来看下 HttpSecurity 的继承关系图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809220933162.png" srcset="/img/loading.gif" lazyload alt="image-20210809220933162"></p>
<p>可以看到，<code>HttpSecurity</code> 继承自 <code>AbstractConfiguredSecurityBuilder</code>，同时实现了 <code>SecurityBuilder </code>和 <code>HttpSecurityBuilder</code> 两个接口。</p>
<p>我们来看下 <code>HttpSecurity</code> 的定义：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpSecurity</span> <span class="hljs-keyword">extends</span></span>
<span class="hljs-class">  <span class="hljs-title">AbstractConfiguredSecurityBuilder</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">HttpSecurity</span>&gt;</span>
<span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>&gt;,</span>
<span class="hljs-class">  <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">HttpSecurity</span>&gt; </span>&#123;
        <span class="hljs-comment">//...</span>
&#125;</code></pre></div>

<p>这里每一个类都带有泛型，看得人有点眼花缭乱。</p>
<p>我把这个泛型类拿出来和大家讲一下，小伙伴们就明白了。</p>
<p>泛型主要是两个，<code>DefaultSecurityFilterChain</code> 和 <code>HttpSecurity</code>，<code>HttpSecurity</code> 就不用说了，这是我们今天的主角，那么 <code>DefaultSecurityFilterChain</code> 是干嘛的？</p>
<p>这我们就得从 <code>SecurityFilterChain</code> 说起了。</p>
<h4 id="SecurityFilterChain"><a href="#SecurityFilterChain" class="headerlink" title="SecurityFilterChain"></a>SecurityFilterChain</h4><p>先来看定义：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityFilterChain</span> </span>&#123;
 <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(HttpServletRequest request)</span></span>;
 <span class="hljs-function">List&lt;Filter&gt; <span class="hljs-title">getFilters</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p><code>SecurityFilterChain</code> 其实就是我们平时所说的 Spring Security 中的过滤器链，它里边定义了两个方法，一个是 matches 方法用来匹配请求，另外一个 getFilters 方法返回一个 List 集合，集合中放着 Filter 对象，当一个请求到来时，用 matches 方法去比较请求是否和当前链吻合，如果吻合，就返回 getFilters 方法中的过滤器，那么当前请求会逐个经过 List 集合中的过滤器。</p>
<p><code>SecurityFilterChain </code>接口只有一个实现类，那就是 <code>DefaultSecurityFilterChain</code>，<strong>那么从上面的介绍中，大家可以看到，<code>DefaultSecurityFilterChain</code> 其实就相当于是 Spring Security 中的过滤器链，一个 <code>DefaultSecurityFilterChain</code> 代表一个过滤器链，如果系统中存在多个过滤器链，则会存在多个 <code>DefaultSecurityFilterChain</code> 对象。</strong></p>
<p>接下来我们把 <code>HttpSecurity</code> 的这几个父类捋一捋。</p>
<h4 id="⚠️SecurityBuilder"><a href="#⚠️SecurityBuilder" class="headerlink" title="⚠️SecurityBuilder"></a>⚠️SecurityBuilder</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt; </span>&#123;
 <span class="hljs-function">O <span class="hljs-title">build</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;
&#125;</code></pre></div>

<p><code>SecurityBuilder </code>就是用来构建过滤器链的，在 <code>HttpSecurity</code> 实现 <code>SecurityBuilder</code> 时，传入的泛型就是 <code>DefaultSecurityFilterChain</code>，所以 <code>SecurityBuilder#build</code> 方法的功能很明确，就是用来构建一个过滤器链出来。</p>
<h4 id="HttpSecurityBuilder"><a href="#HttpSecurityBuilder" class="headerlink" title="HttpSecurityBuilder"></a>HttpSecurityBuilder</h4><p><code>HttpSecurityBuilder</code> 看名字就是用来构建 <code>HttpSecurity</code> 的。不过它也只是一个接口，具体的实现在 <code>HttpSecurity </code>中，接口定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">H</span>&gt;&gt; <span class="hljs-keyword">extends</span></span>
<span class="hljs-class">  <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>&gt; </span>&#123;
 &lt;C extends SecurityConfigurer&lt;DefaultSecurityFilterChain, H&gt;&gt; <span class="hljs-function">C <span class="hljs-title">getConfigurer</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">   Class&lt;C&gt; clazz)</span></span>;
 &lt;C extends SecurityConfigurer&lt;DefaultSecurityFilterChain, H&gt;&gt; <span class="hljs-function">C <span class="hljs-title">removeConfigurer</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">   Class&lt;C&gt; clazz)</span></span>;
 &lt;C&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setSharedObject</span><span class="hljs-params">(Class&lt;C&gt; sharedType, C object)</span></span>;
 &lt;C&gt; <span class="hljs-function">C <span class="hljs-title">getSharedObject</span><span class="hljs-params">(Class&lt;C&gt; sharedType)</span></span>;
 <span class="hljs-function">H <span class="hljs-title">authenticationProvider</span><span class="hljs-params">(AuthenticationProvider authenticationProvider)</span></span>;
 <span class="hljs-function">H <span class="hljs-title">userDetailsService</span><span class="hljs-params">(UserDetailsService userDetailsService)</span> <span class="hljs-keyword">throws</span> Exception</span>;
 <span class="hljs-function">H <span class="hljs-title">addFilterAfter</span><span class="hljs-params">(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</span></span>;
 <span class="hljs-function">H <span class="hljs-title">addFilterBefore</span><span class="hljs-params">(Filter filter, Class&lt;? extends Filter&gt; beforeFilter)</span></span>;
 <span class="hljs-function">H <span class="hljs-title">addFilter</span><span class="hljs-params">(Filter filter)</span></span>;
&#125;</code></pre></div>

<p>这里的方法比较简单：</p>
<ol>
<li><code>getConfigurer</code> 获取一个配置对象。Spring Security 过滤器链中的所有过滤器对象都是由 xxxConfigure 来进行配置的，这里就是获取这个 xxxConfigure 对象。</li>
<li><code>removeConfigurer</code> 移除一个配置对象。</li>
<li><code>setSharedObject/getSharedObject</code> 配置/获取由多个 <code>SecurityConfigurer</code> 共享的对象。</li>
<li><code>authenticationProvider</code> 方法表示配置验证器。</li>
<li><code>userDetailsService</code> 配置数据源接口。</li>
<li><code>addFilterAfter</code> 在某一个过滤器之前添加过滤器。</li>
<li><code>addFilterBefore</code> 在某一个过滤器之后添加过滤器。</li>
<li><code>addFilter</code> 添加一个过滤器，该过滤器必须是现有过滤器链中某一个过滤器或者其扩展。</li>
</ol>
<p>这便是 <code>HttpSecurityBuilder</code> 中的功能，这些接口在<code>HttpSecurity</code>中都将得到实现。</p>
<h4 id="AbstractSecurityBuilder"><a href="#AbstractSecurityBuilder" class="headerlink" title="AbstractSecurityBuilder"></a>AbstractSecurityBuilder</h4><p><code>AbstractSecurityBuilder </code>类实现了 <code>SecurityBuilder</code> 接口，该类中主要做了一件事，就是确保整个构建只被构建一次。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt; </span>&#123;
 <span class="hljs-keyword">private</span> AtomicBoolean building = <span class="hljs-keyword">new</span> AtomicBoolean();
 <span class="hljs-keyword">private</span> O object;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> O <span class="hljs-title">build</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.building.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;
   <span class="hljs-keyword">this</span>.object = doBuild();
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object;
  &#125;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AlreadyBuiltException(<span class="hljs-string">&quot;This object has already been built&quot;</span>);
 &#125;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> O <span class="hljs-title">getObject</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.building.get()) &#123;
   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;This object has not been built&quot;</span>);
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object;
 &#125;
 <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> O <span class="hljs-title">doBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;
&#125;</code></pre></div>

<p>可以看到，这里重新定义了 build 方法，并设置 build 方法为 final 类型，无法被重写，在 build 方法中，通过 <code>AtomicBoolean</code> 实现该方法只被调用一次。具体的构建逻辑则定义了新的抽象方法 doBuild，将来在实现类中通过 doBuild 方法定义构建逻辑。</p>
<h4 id="AbstractConfiguredSecurityBuilder"><a href="#AbstractConfiguredSecurityBuilder" class="headerlink" title="AbstractConfiguredSecurityBuilder"></a>AbstractConfiguredSecurityBuilder</h4><p><code>AbstractSecurityBuilder</code> 方法的实现类就是 <code>AbstractConfiguredSecurityBuilder</code>。</p>
<p><code>AbstractConfiguredSecurityBuilder</code> 中所做的事情就比较多了，我们分别来看。</p>
<p>首先 <code>AbstractConfiguredSecurityBuilder</code> 中定义了一个枚举类，将整个构建过程分为 5 种状态，也可以理解为构建过程生命周期的五个阶段，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BuildState</span> </span>&#123;
 UNBUILT(<span class="hljs-number">0</span>),
 INITIALIZING(<span class="hljs-number">1</span>),
 CONFIGURING(<span class="hljs-number">2</span>),
 BUILDING(<span class="hljs-number">3</span>),
 BUILT(<span class="hljs-number">4</span>);
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> order;
 BuildState(<span class="hljs-keyword">int</span> order) &#123;
  <span class="hljs-keyword">this</span>.order = order;
 &#125;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInitializing</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">return</span> INITIALIZING.order == order;
 &#125;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConfigured</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">return</span> order &gt;= CONFIGURING.order;
 &#125;
&#125;</code></pre></div>

<p>五种状态分别是 UNBUILT、INITIALIZING、CONFIGURING、BUILDING 以及 BUILT。另外还提供了两个判断方法，isInitializing 判断是否正在初始化，isConfigured 表示是否已经配置完毕。</p>
<p><code>AbstractConfiguredSecurityBuilder</code> 中的方法比较多，在这里列出来两个关键的方法和大家分析：</p>
<ul>
<li>第一个就是这个 add 方法，这相当于是在收集所有的配置类。将所有的 xxxConfigure 收集起来存储到 configurers 中，将来再统一初始化并配置，configurers 本身是一个 LinkedHashMap ，key 是配置类的 class，value 是一个集合，集合里边放着 xxxConfigure 配置类。当需要对这些配置类进行集中配置的时候，会通过 getConfigurers 方法获取配置类，这个获取过程就是把 LinkedHashMap 中的 value 拿出来，放到一个集合中返回。</li>
<li>在 <code>AbstractSecurityBuilder</code> 类中，过滤器的构建被转移到 doBuild 方法上面了，不过在 <code>AbstractSecurityBuilder</code> 中只是定义了抽象的 doBuild 方法，具体的实现在<code>AbstractConfiguredSecurityBuilder</code>。doBuild 方法就是一边更新状态，进行进行初始化。</li>
</ul>
<h4 id="回到主题HttpSecurity"><a href="#回到主题HttpSecurity" class="headerlink" title="回到主题HttpSecurity"></a>回到主题HttpSecurity</h4><p><code>HttpSecurity</code> 做的事情，就是进行各种各样的 xxxConfigurer 配置。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CorsConfigurer&lt;HttpSecurity&gt; <span class="hljs-title">cors</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 <span class="hljs-keyword">return</span> getOrApply(<span class="hljs-keyword">new</span> CorsConfigurer&lt;&gt;());
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> CsrfConfigurer&lt;HttpSecurity&gt; <span class="hljs-title">csrf</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 ApplicationContext context = getContext();
 <span class="hljs-keyword">return</span> getOrApply(<span class="hljs-keyword">new</span> CsrfConfigurer&lt;&gt;(context));
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> ExceptionHandlingConfigurer&lt;HttpSecurity&gt; <span class="hljs-title">exceptionHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 <span class="hljs-keyword">return</span> getOrApply(<span class="hljs-keyword">new</span> ExceptionHandlingConfigurer&lt;&gt;());
&#125;</code></pre></div>

<p><code>HttpSecurity</code> 中有大量类似的方法，过滤器链中的过滤器就是这样一个一个配置的。我就不一一介绍了。</p>
<p>每个配置方法的结尾都会来一句 getOrApply，这个是干嘛的？</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;C extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt;&gt; <span class="hljs-function">C <span class="hljs-title">getOrApply</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">  C configurer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 C existingConfig = (C) getConfigurer(configurer.getClass());
 <span class="hljs-keyword">if</span> (existingConfig != <span class="hljs-keyword">null</span>) &#123;
  <span class="hljs-keyword">return</span> existingConfig;
 &#125;
 <span class="hljs-keyword">return</span> apply(configurer);
&#125;</code></pre></div>

<p><code>getConfigurer</code> 方法是在它的父类 <code>AbstractConfiguredSecurityBuilder</code> 中定义的，目的就是去查看当前这个 xxxConfigurer 是否已经配置过了。</p>
<p>如果当前 xxxConfigurer 已经配置过了，则直接返回，否则调用 apply 方法，这个 apply 方法最终会调用到 <code>AbstractConfiguredSecurityBuilder#add</code> 方法，将当前配置 configurer 收集起来。</p>
<p><code>HttpSecurity</code> 中还有一个 <code>addFilter</code> 方法（上面也用到的）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpSecurity <span class="hljs-title">addFilter</span><span class="hljs-params">(Filter filter)</span> </span>&#123;
 Class&lt;? extends Filter&gt; filterClass = filter.getClass();
 <span class="hljs-keyword">if</span> (!comparator.isRegistered(filterClass)) &#123;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(
    <span class="hljs-string">&quot;The Filter class &quot;</span>
      + filterClass.getName()
      + <span class="hljs-string">&quot; does not have a registered order and cannot be added without a specified order. Consider using addFilterBefore or addFilterAfter instead.&quot;</span>);
 &#125;
 <span class="hljs-keyword">this</span>.filters.add(filter);
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre></div>

<p>这个 <code>addFilter</code> 方法的作用，主要是在各个 xxxConfigurer 进行配置的时候，会调用到这个方法，（xxxConfigurer 就是用来配置过滤器的），把 Filter 都添加到 fitlers 变量中。</p>
<p>最终在 <code>HttpSecurity</code> 的 <code>performBuild</code> 方法中，构建出来一个过滤器链：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> DefaultSecurityFilterChain <span class="hljs-title">performBuild</span><span class="hljs-params">()</span> </span>&#123;
 filters.sort(comparator);
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSecurityFilterChain(requestMatcher, filters);
&#125;</code></pre></div>

<p>先给过滤器排序，然后构造 <code>DefaultSecurityFilterChain</code> 对象。</p>
<h3 id="👀SecurityConfigurer"><a href="#👀SecurityConfigurer" class="headerlink" title="👀SecurityConfigurer"></a>👀SecurityConfigurer</h3><blockquote>
<p>此节建议结合登陆的验证中的配置类来看</p>
</blockquote>
<p><code>SecurityConfigurer</code> 在 Spring Security 中是一个非常重要的角色。Spring Security 过滤器链中的每一个过滤器，都是通过 xxxConfigurer 来进行配置的（上面配置类中重写的configure就是这里的<code>SecurityConfigurer</code>），而这些 xxxConfigurer 实际上都是 <code>SecurityConfigurer </code>的实现。</p>
<p><code>SecurityConfigurer</code> 本身是一个接口，我们来看下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt;&gt; </span>&#123;

 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception</span>;

 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception</span>;
&#125;</code></pre></div>

<p>可以看到，<code>SecurityConfigurer</code> 中主要是两个方法，init 和 configure。</p>
<p>init 就是一个初始化方法。而 configure 则是一个配置方法。这里只是规范了方法的定义，具体的实现则在不同的实现类中。</p>
<p>需要注意的是这两个方法的参数类型都是一个泛型 B，也就是 <code>SecurityBuilder</code> 的子类，关于 <code>SecurityBuilder</code> ，它是用来构建过滤器链的。</p>
<p><code>SecurityConfigurer</code> 有三个实现类：</p>
<ul>
<li><code>SecurityConfigurerAdapter</code></li>
<li><code>GlobalAuthenticationConfigurerAdapter</code></li>
<li><code>WebSecurityConfigurer</code></li>
</ul>
<h4 id="SecurityConfigurerAdapter"><a href="#SecurityConfigurerAdapter" class="headerlink" title="SecurityConfigurerAdapter"></a>SecurityConfigurerAdapter</h4><p><code>SecurityConfigurerAdapter</code> 实现了 <code>SecurityConfigurer</code> 接口，我们所使用的大部分的 xxxConfigurer 也都是 <code>SecurityConfigurerAdapter</code> 的子类。</p>
<p><code>SecurityConfigurerAdapter</code> 在<code> SecurityConfigurer</code> 的基础上，还扩展出来了几个非常好用的方法，我们一起来看下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt;&gt;</span>
<span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span>&gt; </span>&#123;
 <span class="hljs-keyword">private</span> B securityBuilder;

 <span class="hljs-keyword">private</span> CompositeObjectPostProcessor objectPostProcessor = <span class="hljs-keyword">new</span> CompositeObjectPostProcessor();

 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 &#125;

 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 &#125;

 <span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">and</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">return</span> getBuilder();
 &#125;
 <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> B <span class="hljs-title">getBuilder</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">if</span> (securityBuilder == <span class="hljs-keyword">null</span>) &#123;
   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;securityBuilder cannot be null&quot;</span>);
  &#125;
  <span class="hljs-keyword">return</span> securityBuilder;
 &#125;
 <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
 <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">postProcess</span><span class="hljs-params">(T object)</span> </span>&#123;
  <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">this</span>.objectPostProcessor.postProcess(object);
 &#125;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObjectPostProcessor</span><span class="hljs-params">(ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> </span>&#123;
  <span class="hljs-keyword">this</span>.objectPostProcessor.addObjectPostProcessor(objectPostProcessor);
 &#125;
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBuilder</span><span class="hljs-params">(B builder)</span> </span>&#123;
  <span class="hljs-keyword">this</span>.securityBuilder = builder;
 &#125;
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositeObjectPostProcessor</span> <span class="hljs-keyword">implements</span></span>
<span class="hljs-class">   <span class="hljs-title">ObjectPostProcessor</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;
  <span class="hljs-keyword">private</span> List&lt;ObjectPostProcessor&lt;?&gt;&gt; postProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

  <span class="hljs-meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcess</span><span class="hljs-params">(Object object)</span> </span>&#123;
   <span class="hljs-keyword">for</span> (ObjectPostProcessor opp : postProcessors) &#123;
    Class&lt;?&gt; oppClass = opp.getClass();
    Class&lt;?&gt; oppType = GenericTypeResolver.resolveTypeArgument(oppClass,
      ObjectPostProcessor.class);
    <span class="hljs-keyword">if</span> (oppType == <span class="hljs-keyword">null</span> || oppType.isAssignableFrom(object.getClass())) &#123;
     object = opp.postProcess(object);
    &#125;
   &#125;
   <span class="hljs-keyword">return</span> object;
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addObjectPostProcessor</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> </span>&#123;
   <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">this</span>.postProcessors.add(objectPostProcessor);
   postProcessors.sort(AnnotationAwareOrderComparator.INSTANCE);
   <span class="hljs-keyword">return</span> result;
  &#125;
 &#125;
&#125;</code></pre></div>

<ul>
<li><code>CompositeObjectPostProcessor</code> 首先一开始声明了一个 <code>CompositeObjectPostProcessor</code> 实例，<code>CompositeObjectPostProcessor</code> 是 <code>ObjectPostProcessor</code> 的一个实现，<code>ObjectPostProcessor</code> 本身是一个后置处理器，该后置处理器默认有两个实现，<code>AutowireBeanFactoryObjectPostProcessor</code> 和 <code>CompositeObjectPostProcessor</code>:<ul>
<li>其中 <code>AutowireBeanFactoryObjectPostProcessor </code>主要是利用了 <code>AutowireCapableBeanFactory</code> 对 Bean 进行手动注册，因为在 Spring Security 中，很多对象都是手动 new 出来的，这些 new 出来的对象和容器没有任何关系，利用 AutowireCapableBeanFactory 可以将这些手动 new 出来的对象注入到容器中，而 <code>AutowireBeanFactoryObjectPostProcessor</code> 的主要作用就是完成这件事</li>
<li><code>CompositeObjectPostProcessor</code> 则是一个复合的对象处理器，里边维护了一个 List 集合，这个 List 集合中，大部分情况下只存储一条数据，那就是 <code>AutowireBeanFactoryObjectPostProcessor</code>，用来完成对象注入到容器的操作，如果用户自己手动调用了 <code>addObjectPostProcessor</code> 方法，那么 <code>CompositeObjectPostProcessor</code> 集合中维护的数据就会多出来一条，在 <code>CompositeObjectPostProcessor#postProcess</code> 方法中，会遍历集合中的所有 ObjectPostProcessor，挨个调用其 postProcess 方法对对象进行后置处理。</li>
</ul>
</li>
<li>and 方法，该方法返回值是一个 <code>securityBuilder</code>，<code>securityBuilder</code> 实际上就是 <code>HttpSecurity</code>，我们在 <code>HttpSecurity</code> 中去配置不同的过滤器时，可以使用 and 方法进行链式配置，就是因为这里定义了 and 方法并返回了 <code>securityBuilder</code> 实例。</li>
</ul>
<p>这便是 <code>SecurityConfigurerAdapter</code> 的主要功能，后面大部分的 xxxConfigurer 都是基于此类来实现的。</p>
<p><code>SecurityConfigurerAdapter</code> 的实现主要也是三大类：</p>
<ul>
<li><code>UserDetailsAwareConfigurer</code></li>
<li><code>AbstractHttpConfigurer</code></li>
<li><code>LdapAuthenticationProviderConfigurer</code></li>
</ul>
<p>考虑到 LDAP 现在使用很少，所以这里我来和大家重点介绍下前两个。</p>
<h5 id="UserDetailsAwareConfigurer"><a href="#UserDetailsAwareConfigurer" class="headerlink" title="UserDetailsAwareConfigurer"></a>UserDetailsAwareConfigurer</h5><p>这个配置类看名字大概就知道这是用来配置用户类的。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809221022916.png" srcset="/img/loading.gif" lazyload alt="image-20210809221022916"></p>
<blockquote>
<p><strong>AbstractDaoAuthenticationConfigurer</strong></p>
<p>AbstractDaoAuthenticationConfigurer 中所做的事情比较简单，主要是构造了一个默认的 DaoAuthenticationProvider，并为其配置 PasswordEncoder 和 UserDetailsService。</p>
<p><strong>UserDetailsServiceConfigurer</strong></p>
<p>UserDetailsServiceConfigurer 重写了 AbstractDaoAuthenticationConfigurer 中的 configure 方法，在 configure 方法执行之前加入了 initUserDetailsService 方法，以方便开发展按照自己的方式去初始化 UserDetailsService。不过这里的 initUserDetailsService 方法是空方法。</p>
<p><strong>UserDetailsManagerConfigurer</strong></p>
<p>UserDetailsManagerConfigurer 中实现了 UserDetailsServiceConfigurer 中定义的 initUserDetailsService 方法，具体的实现逻辑就是将 UserDetailsBuilder 所构建出来的 UserDetails 以及提前准备好的 UserDetails 中的用户存储到 UserDetailsService 中。</p>
<p>该类同时添加了 withUser 方法用来添加用户，同时还增加了一个 UserDetailsBuilder 用来构建用户，这些逻辑都比较简单，可以自行查看。</p>
<p><strong>JdbcUserDetailsManagerConfigurer</strong></p>
<p>JdbcUserDetailsManagerConfigurer 在父类的基础上补充了 DataSource 对象，同时还提供了相应的数据库查询方法。</p>
<p><strong>InMemoryUserDetailsManagerConfigurer</strong></p>
<p>InMemoryUserDetailsManagerConfigurer 在父类的基础上重写了构造方法，将父类中的 UserDetailsService 实例定义为 InMemoryUserDetailsManager。</p>
<p><strong>DaoAuthenticationConfigurer</strong></p>
<p>DaoAuthenticationConfigurer 继承自 AbstractDaoAuthenticationConfigurer，只是在构造方法中修改了一下 userDetailsService 而已。</p>
</blockquote>
<h5 id="⚠️AbstractHttpConfigurer"><a href="#⚠️AbstractHttpConfigurer" class="headerlink" title="⚠️AbstractHttpConfigurer"></a>⚠️AbstractHttpConfigurer</h5><p><code>AbstractHttpConfigurer </code>这一派中的东西非常多，我们所有的过滤器配置，都是它的子类，我们来看下都有哪些类？</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809221037144.png" srcset="/img/loading.gif" lazyload alt="image-20210809221037144"></p>
<p><code>AbstractHttpConfigurer</code> 继承自 <code>SecurityConfigurerAdapter</code>，并增加了两个方法，disable 和 withObjectPostProcessor：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHttpConfigurer</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractHttpConfigurer</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">B</span>&gt;, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">B</span>&gt;&gt;</span>
<span class="hljs-class">  <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">B</span>&gt; </span>&#123;

 <span class="hljs-comment">/**</span>
<span class="hljs-comment">  * Disables the &#123;<span class="hljs-doctag">@link</span> AbstractHttpConfigurer&#125; by removing it. After doing so a fresh</span>
<span class="hljs-comment">  * version of the configuration can be applied.</span>
<span class="hljs-comment">  *</span>
<span class="hljs-comment">  * <span class="hljs-doctag">@return</span> the &#123;<span class="hljs-doctag">@link</span> HttpSecurityBuilder&#125; for additional customizations</span>
<span class="hljs-comment">  */</span>
 <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">disable</span><span class="hljs-params">()</span> </span>&#123;
  getBuilder().removeConfigurer(getClass());
  <span class="hljs-keyword">return</span> getBuilder();
 &#125;

 <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">withObjectPostProcessor</span><span class="hljs-params">(ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> </span>&#123;
  addObjectPostProcessor(objectPostProcessor);
  <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">this</span>;
 &#125;
&#125;</code></pre></div>

<p>这两个方法之前都有给大家介绍过，disable 基本上是大家的老熟人了，我们常用的 <code>.csrf().disable()</code> 就是出自这里，那么从这里我们也可以看到 disable 的实现原理，就是从 getBuilder 中移除相关的 xxxConfigurer，getBuilder 方法获取到的实际上就是 HttpSecurity，所以移除掉 xxxConfigurer 实际上就是从过滤器链中移除掉某一个过滤器，例如 <code>.csrf().disable()</code> 就是移除掉处理 csrf 的过滤器。</p>
<p>另一个增加的方法是 <code>withObjectPostProcessor</code>，这是为配置类添加手动添加后置处理器的。在 <code>AbstractHttpConfigurer</code> 的父类中其实有一个类似的方法就是 <code>addObjectPostProcessor</code>，但是 <code>addObjectPostProcessor</code> 只是一个添加方法，返回值为 void，而 withObjectPostProcessor 的返回值是当前配置类，也就是 xxxConfigurer，所以如果使用 withObjectPostProcessor 的话，可以使用链式配置，事实上，上面的项目配置使用的也都是 <code>withObjectPostProcessor</code> 方法（当然，你也可以使用 addObjectPostProcessor，最终效果是一样的）。</p>
<h5 id="⚠️AbstractAuthenticationFilterConfigurer"><a href="#⚠️AbstractAuthenticationFilterConfigurer" class="headerlink" title="⚠️AbstractAuthenticationFilterConfigurer"></a>⚠️AbstractAuthenticationFilterConfigurer</h5><p><code>AbstractAuthenticationFilterConfigurer</code> 类的功能比较多，源码也是相当相当长。不过我们只需要抓住两点即可，<strong>init 方法和 configure 方法，因为这两个方法是所有 xxxConfigurer 的灵魂。</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 updateAuthenticationDefaults();
 updateAccessDefaults(http);
 registerDefaultAuthenticationEntryPoint(http);
&#125;</code></pre></div>

<p>init 方法主要干了三件事：</p>
<ol>
<li><code>updateAuthenticationDefaults</code> 主要是配置了登录处理地址，失败跳转地址，注销成功跳转地址。</li>
<li><code>updateAccessDefaults</code> 方法主要是对 loginPage、loginProcessingUrl、failureUrl 进行 permitAll 设置（如果用户配置了 permitAll 的话）。</li>
<li><code>registerDefaultAuthenticationEntryPoint</code> 则是注册异常的处理器。</li>
</ol>
<p>再来看 configure 方法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 PortMapper portMapper = http.getSharedObject(PortMapper.class);
 <span class="hljs-keyword">if</span> (portMapper != <span class="hljs-keyword">null</span>) &#123;
  authenticationEntryPoint.setPortMapper(portMapper);
 &#125;
 RequestCache requestCache = http.getSharedObject(RequestCache.class);
 <span class="hljs-keyword">if</span> (requestCache != <span class="hljs-keyword">null</span>) &#123;
  <span class="hljs-keyword">this</span>.defaultSuccessHandler.setRequestCache(requestCache);
 &#125;
 authFilter.setAuthenticationManager(http
   .getSharedObject(AuthenticationManager.class));
 authFilter.setAuthenticationSuccessHandler(successHandler);
 authFilter.setAuthenticationFailureHandler(failureHandler);
 <span class="hljs-keyword">if</span> (authenticationDetailsSource != <span class="hljs-keyword">null</span>) &#123;
  authFilter.setAuthenticationDetailsSource(authenticationDetailsSource);
 &#125;
 SessionAuthenticationStrategy sessionAuthenticationStrategy = http
   .getSharedObject(SessionAuthenticationStrategy.class);
 <span class="hljs-keyword">if</span> (sessionAuthenticationStrategy != <span class="hljs-keyword">null</span>) &#123;
  authFilter.setSessionAuthenticationStrategy(sessionAuthenticationStrategy);
 &#125;
 RememberMeServices rememberMeServices = http
   .getSharedObject(RememberMeServices.class);
 <span class="hljs-keyword">if</span> (rememberMeServices != <span class="hljs-keyword">null</span>) &#123;
  authFilter.setRememberMeServices(rememberMeServices);
 &#125;
 F filter = postProcess(authFilter);
 http.addFilter(filter);
&#125;</code></pre></div>

<p>configure 中的逻辑就很简答了，构建各种各样的回调函数设置给 authFilter，authFilter 再去 postProcess 中走一圈注册到 Spring 容器中，最后再把 authFilter 添加到过滤器链中。</p>
<p>这便是 <code>AbstractAuthenticationFilterConfigurer</code> 的主要功能。需要提醒大家的是，我们日常配置的，如：</p>
<ul>
<li>loginPage</li>
<li>loginProcessingUrl</li>
<li>permitAll</li>
<li>defaultSuccessUrl</li>
<li>failureUrl</li>
</ul>
<p>等方法都是在这里定义的。</p>
<h5 id="⚠️FormLoginConfigurer"><a href="#⚠️FormLoginConfigurer" class="headerlink" title="⚠️FormLoginConfigurer"></a>⚠️FormLoginConfigurer</h5><p><code>FormLoginConfigurer</code> 在定义是，明确了<code> AbstractAuthenticationFilterConfigurer</code> 中的泛型是 <code>UsernamePasswordAuthenticationFilter</code>，也就是我们这里最终要配置的过滤是 <code>UsernamePasswordAuthenticationFilter</code></p>
<p>FormLoginConfigurer 重写了 init 方法，配置了一下默认的登录页面。其他的基本上都是从父类来的，未做太多改变。</p>
<p>另外我们日常配置的很多东西也是来自这里：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809221049974.png" srcset="/img/loading.gif" lazyload alt="image-20210809221049974"></p>
<p>这就是 <code>FormLoginConfigurer</code> 这个配置类，<code>FormLoginConfigurer</code> 对应的过滤器是 <code>UsernamePasswordAuthenticationFilter</code>，可以自行分析其他的 xxxConfigurer，每一个 xxxConfigurer 都对应了一个 不同的 Filter。</p>
<h4 id="GlobalAuthenticationConfigurerAdapter"><a href="#GlobalAuthenticationConfigurerAdapter" class="headerlink" title="GlobalAuthenticationConfigurerAdapter"></a>GlobalAuthenticationConfigurerAdapter</h4><p><code>GlobalAuthenticationConfigurerAdapter</code> 看名字就知道是一个跟全局配置有关的东西，它本身实现了 <code>SecurityConfigurerAdapter</code> 接口，但是并未对方法做具体的实现，只是将泛型具体化了：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Order(100)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalAuthenticationConfigurerAdapter</span> <span class="hljs-keyword">implements</span></span>
<span class="hljs-class">  <span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">AuthenticationManager</span>, <span class="hljs-title">AuthenticationManagerBuilder</span>&gt; </span>&#123;

 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 &#125;

 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 &#125;
&#125;</code></pre></div>

<p>可以看到，<code>SecurityConfigurer</code> 中的泛型，现在明确成了 <code>AuthenticationManager</code> 和 <code>AuthenticationManagerBuilder</code>。所以 <code>GlobalAuthenticationConfigurerAdapter</code> 的实现类将来主要是和配置 <code>AuthenticationManager</code> 有关。当然也包括默认的用户名密码也是由它的实现类来进行配置的。</p>
<p><strong>我们在 Spring Security 中使用的 <code>AuthenticationManager</code> 其实可以分为两种，一种是局部的，另一种是全局的，这里主要是全局的配置。</strong></p>
<h4 id="WebSecurityConfigurer"><a href="#WebSecurityConfigurer" class="headerlink" title="WebSecurityConfigurer"></a>WebSecurityConfigurer</h4><p>还有一个实现类就是 <code>WebSecurityConfigurer</code>，这个可能有的小伙伴比较陌生，其实他就是我们天天用的 <code>WebSecurityConfigurerAdapter</code> 的父接口。</p>
<p>所以 <code>WebSecurityConfigurer</code> 的作用就很明确了，用户扩展用户自定义的配置。</p>
<p><code>SecurityConfigurer</code> 默认主要是这三个实现，考虑到大多数的过滤器配置都是通过 <code>SecurityConfigurerAdapter</code> 进行扩展的，因此我们今天就通过这条线进行展开。</p>
<h3 id="👀AuthenticationManagerBuilder"><a href="#👀AuthenticationManagerBuilder" class="headerlink" title="👀AuthenticationManagerBuilder"></a>👀AuthenticationManagerBuilder</h3><blockquote>
<p>此节建议结合检查角色是否满足匹配来看</p>
</blockquote>
<p>前面和大家分享了 <code>SecurityBuilder</code> 以及它的一个重要实现 <code>HttpSecurity</code>，在 <code>SecurityBuilder</code> 的实现类里边，还有一个重要的分支，那就是 <code>AuthenticationManagerBuilder</code>，<code>AuthenticationManagerBuilder</code> 看名字就知道是用来构建 <code>AuthenticationManager</code> 的，所以我们就来看一看 <code>AuthenticationManager</code> 到底是怎么构建的。</p>
<h4 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h4><p>在 Spring Security 中，用来处理身份认证的类是 <code>AuthenticationManager</code>，我们也称之为认证管理器。<strong>也是我们上面检查角色是否满足匹配的重要一环</strong></p>
<p><code>AuthenticationManager</code> 中规范了 Spring Security 的过滤器要如何执行身份认证，并在身份认证成功后返回一个经过认证的 <code>Authentication </code>对象。<code>AuthenticationManager</code> 是一个接口，我们可以自定义它的实现，但是通常我们使用更多的是系统提供的 <code>ProviderManager</code></p>
<h4 id="ProviderManager"><a href="#ProviderManager" class="headerlink" title="ProviderManager"></a>ProviderManager</h4><p><code>ProviderManager</code> 是的最常用的<code> AuthenticationManager</code> 实现类。</p>
<p><code>ProviderManager</code> 管理了一个 <code>AuthenticationProvider</code> 列表，每个 <code>AuthenticationProvider</code> 都是一个认证器，不同的 <code>AuthenticationProvider</code> 用来处理不同的 <code>Authentication</code> 对象的认证。一次完整的身份认证流程可能会经过多个 <code>AuthenticationProvider</code></p>
<p><code>ProviderManager </code>相当于代理了多个 <code>AuthenticationProvider</code>，他们的关系如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809210416369.png" srcset="/img/loading.gif" lazyload alt="image-20210809210416369"></p>
<h4 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h4><p><code>AuthenticationProvider</code> 定义了 Spring Security 中的验证逻辑，我们来看下 <code>AuthenticationProvider</code> 的定义：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;
	<span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span>
<span class="hljs-function">			<span class="hljs-keyword">throws</span> AuthenticationException</span>;
	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span></span>;
&#125;</code></pre></div>

<p>可以看到，<code>AuthenticationProvider</code> 中就两个方法：</p>
<ul>
<li>authenticate 方法用来做验证，就是验证用户身份。</li>
<li>supports 则用来判断当前的 <code>AuthenticationProvider</code> 是否支持对应的 <code>Authentication</code>。</li>
</ul>
<p>在一次完整的认证中，可能包含多个 <code>AuthenticationProvider</code>，而这多个 <code>AuthenticationProvider</code> 则由 <code>ProviderManager </code>进行统一管理，具体我会再出一篇文章来分析Spring Security 登录流程。</p>
<p>最常用的 <code>AuthenticationProvider</code> 实现类是 <code>DaoAuthenticationProvider</code>。</p>
<h4 id="Parent"><a href="#Parent" class="headerlink" title="Parent"></a>Parent</h4><p>每一个 <code>ProviderManager</code> 管理多个 <code>AuthenticationProvider</code>，同时每一个 <code>ProviderManager</code> 都可以配置一个 parent，如果当前的 <code>ProviderManager</code> 中认证失败了，还可以去它的 parent 中继续执行认证，所谓的 parent 实例，一般也是 <code>ProviderManager</code>，也就是 <code>ProviderManager</code> 的 parent 还是 <code>ProviderManager</code>。可以参考如下架构图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210809210931119.png" srcset="/img/loading.gif" lazyload alt="image-20210809210931119"></p>
<p><strong>从上面的分析中大家可以看出，<code>AuthenticationManager</code> 的初始化会分为两块，一个全局的 <code>AuthenticationManager</code>，也就是 parent，另一个则是局部的 <code>AuthenticationManager</code>。先给大家一个结论，一个系统中，我们可以配置多个 <code>HttpSecurity</code>，而每一个<code>HttpSecurity</code>都有一个对应的 <code>AuthenticationManager</code> 实例（局部 <code>AuthenticationManager</code>），这些局部的 <code>AuthenticationManager</code> 实例都有一个共同的 parent，那就是全局的 <code>AuthenticationManager</code>。</strong></p>
<h4 id="为什么每一个-HttpSecurity-都要绑定一个-AuthenticationManager？"><a href="#为什么每一个-HttpSecurity-都要绑定一个-AuthenticationManager？" class="headerlink" title="为什么每一个 HttpSecurity 都要绑定一个 AuthenticationManager？"></a>为什么每一个 HttpSecurity 都要绑定一个 AuthenticationManager？</h4><p>因为在同一个系统中，我们可以回配置多个 <code>HttpSecurity</code>，也就是多个不同的过滤器链，既然有多个过滤器链，每一个请求到来的时候，它需要进入到某一个过滤器链中去处理，每一个过滤器链中又会涉及到 <code>AuthenticationProvider </code>的管理，不同过滤器链中的 <code>AuthenticationProvider</code> 肯定是各自管理最为合适，也就是不同的过滤器链中都有一个绑定的 <code>AuthenticationManager</code>，即每一个 <code>HttpSecurity</code> 都要绑定一个 <code>AuthenticationManager</code></p>
<h3 id="👀WebSecurityConfigurerAdapter"><a href="#👀WebSecurityConfigurerAdapter" class="headerlink" title="👀WebSecurityConfigurerAdapter"></a>👀WebSecurityConfigurerAdapter</h3><blockquote>
<p>我们配置中继承的就是WebSecurityConfigurerAdapter，需要重点关注</p>
</blockquote>
<p>我们的自定义的<code>SecurityConfig</code>都是继承自 <code>WebSecurityConfigurerAdapter</code> 来实现的，首先看一张 <code>WebSecurityConfigurerAdapter</code> 的继承关系图：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/07/WebSecurityConfigurerAdapter.png"><img src="http://img.itboyhub.com/2020/07/WebSecurityConfigurerAdapter.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" /></a></p>
<p>在这层继承关系中，有两个非常重要的类：</p>
<ul>
<li><p><strong>SecurityBuilder</strong></p>
</li>
<li><p><strong>SecurityConfigurer</strong></p>
</li>
</ul>
<p>上面已经分析了这两个类，下面着重分析其他的</p>
<h4 id="WebSecurityConfigurer-1"><a href="#WebSecurityConfigurer-1" class="headerlink" title="WebSecurityConfigurer"></a>WebSecurityConfigurer</h4><p>WebSecurityConfigurer 其实是一个空接口，但是它里边约束了一些泛型，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WebSecurityConfigurer</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>&gt;&gt; <span class="hljs-keyword">extends</span></span>
<span class="hljs-class">		<span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">Filter</span>, <span class="hljs-title">T</span>&gt; </span>&#123;

&#125;</code></pre></div>

<p>这里边的泛型很关键，这关乎到 <code>WebSecurityConfigurer</code> 的目的是啥！</p>
<ol>
<li><code>SecurityBuilder</code> 中的泛型 Filter，表示<code>SecurityBuilder</code>最终的目的是为了构建一个 Filter 对象出来。</li>
<li><code>SecurityConfigurer</code> 中两个泛型，第一个表示的含义也是 <code>SecurityBuilder</code> 最终构建的对象。</li>
</ol>
<p>同时这里还定义了新的泛型 T，T 需要继承自 <code>SecurityBuilder</code>，根据 <code>WebSecurityConfigurerAdapter</code> 中的定义，我们可以知道，T 就是 <code>WebSecurity</code>，我们也大概能猜出 <code>WebSecurity</code> 就是 <code>SecurityBuilder</code> 的子类。</p>
<p>所以 <code>WebSecurityConfigurer</code> 的目的我们可以理解为就是为了配置 <code>WebSecurity</code></p>
<h4 id="WebSecurity"><a href="#WebSecurity" class="headerlink" title="WebSecurity"></a>WebSecurity</h4><p>我们来看下 <code>WebSecurity</code> 的定义：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurity</span> <span class="hljs-keyword">extends</span></span>
<span class="hljs-class">		<span class="hljs-title">AbstractConfiguredSecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>, <span class="hljs-title">WebSecurity</span>&gt; <span class="hljs-keyword">implements</span></span>
<span class="hljs-class">		<span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>&gt;, <span class="hljs-title">ApplicationContextAware</span> </span>&#123;
&#125;</code></pre></div>

<p>没错，确实是这样！<code>WebSecurity</code> 继承自 <code>AbstractConfiguredSecurityBuilder&lt;Filter, WebSecurity&gt;</code> 同时实现了 <code>SecurityBuilder</code> 接口。</p>
<p><code>WebSecurity</code> 的这些接口和继承类，上面的<code>HttpSecurity</code>中有分析，这里就不重复分析了</p>
<p><strong>SecurityBuilder</strong></p>
<p><code>SecurityBuilder </code>就是用来构建过滤器链的，在 <code>HttpSecurity</code> 实现 <code>SecurityBuilder</code> 时，传入的泛型就是 <code>DefaultSecurityFilterChain</code>，所以 <code>SecurityBuilder#build </code>方法的功能很明确，就是用来构建一个过滤器链出来，但是那个过滤器链是 Spring Security 中的。在 <code>WebSecurityConfigurerAdapter </code>中定义的泛型是 <code>SecurityBuilder</code>，所以最终构建的是一个普通 Filter，其实就是 <code>FilterChainProxy</code>，关于 <code>FilterChainProxy</code> ，可以参考<code>http.authorizeRequests()</code>中的说明。</p>
<p><code>WebSecurity</code> 的核心逻辑集中在 <code>performBuild</code> 构建方法上，我们一起来看下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> Filter <span class="hljs-title">performBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
	Assert.state(
			!securityFilterChainBuilders.isEmpty(),
			() -&gt; <span class="hljs-string">&quot;At least one SecurityBuilder&lt;? extends SecurityFilterChain&gt; needs to be specified. &quot;</span>
					+ <span class="hljs-string">&quot;Typically this done by adding a @Configuration that extends WebSecurityConfigurerAdapter. &quot;</span>
					+ <span class="hljs-string">&quot;More advanced users can invoke &quot;</span>
					+ WebSecurity.class.getSimpleName()
					+ <span class="hljs-string">&quot;.addSecurityFilterChainBuilder directly&quot;</span>);
	<span class="hljs-keyword">int</span> chainSize = ignoredRequests.size() + securityFilterChainBuilders.size();
	List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(
			chainSize);
	<span class="hljs-keyword">for</span> (RequestMatcher ignoredRequest : ignoredRequests) &#123;
		securityFilterChains.add(<span class="hljs-keyword">new</span> DefaultSecurityFilterChain(ignoredRequest));
	&#125;
	<span class="hljs-keyword">for</span> (SecurityBuilder&lt;? extends SecurityFilterChain&gt; securityFilterChainBuilder : securityFilterChainBuilders) &#123;
		securityFilterChains.add(securityFilterChainBuilder.build());
	&#125;
	FilterChainProxy filterChainProxy = <span class="hljs-keyword">new</span> FilterChainProxy(securityFilterChains);
	<span class="hljs-keyword">if</span> (httpFirewall != <span class="hljs-keyword">null</span>) &#123;
		filterChainProxy.setFirewall(httpFirewall);
	&#125;
	filterChainProxy.afterPropertiesSet();
	Filter result = filterChainProxy;
	<span class="hljs-keyword">if</span> (debugEnabled) &#123;
		logger.warn(<span class="hljs-string">&quot;\n\n&quot;</span>
				+ <span class="hljs-string">&quot;********************************************************************\n&quot;</span>
				+ <span class="hljs-string">&quot;**********        Security debugging is enabled.       *************\n&quot;</span>
				+ <span class="hljs-string">&quot;**********    This may include sensitive information.  *************\n&quot;</span>
				+ <span class="hljs-string">&quot;**********      Do not use in a production system!     *************\n&quot;</span>
				+ <span class="hljs-string">&quot;********************************************************************\n\n&quot;</span>);
		result = <span class="hljs-keyword">new</span> DebugFilter(filterChainProxy);
	&#125;
	postBuildAction.run();
	<span class="hljs-keyword">return</span> result;
&#125;</code></pre></div>

<p>先来说一句，这里的 performBuild 方法只有一个功能，那就是构建 <code>FilterChainProxy</code></p>
<p>把握住了这条主线，我们再来看方法的实现就很容易了。</p>
<ol>
<li><p>首先统计过滤器链的总条数，总条数包括两个方面，一个是 <code>ignoredRequests</code>，这是忽略的请求，通过 WebSecurity 配置的忽略请求，另一个则是 <code>securityFilterChainBuilders</code>，也就是我们通过 <code>HttpSecurity</code> 配置的过滤器链，有几个就算几个。</p>
<blockquote>
<p>前端静态资源放行时，可以直接不走 Spring Security 过滤器链，像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Override</span>
&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
 web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>,<span class="hljs-string">&quot;/js/**&quot;</span>,<span class="hljs-string">&quot;/index.html&quot;</span>,<span class="hljs-string">&quot;/img/**&quot;</span>,<span class="hljs-string">&quot;/fonts/**&quot;</span>,<span class="hljs-string">&quot;/favicon.ico&quot;</span>);
&gt;&#125;</code></pre></div>

<p>后端的接口要额外放行，就需要仔细考虑场景了，不过一般来说，不建议使用上面这种方式，建议下面这种方式</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">&gt;http.authorizeRequests()
     .antMatchers(<span class="hljs-string">&quot;/hello&quot;</span>).permitAll()
     .anyRequest().authenticated()</code></pre></div>

<p>因为，如果我们暴露登录接口的时候，使用了前面提到的第一种方式，没有走 Spring Security，过滤器链，则在登录成功后，就不会将登录用户信息存入 session 中，进而导致后来的请求都无法获取到登录用户信息（后来的请求在系统眼里也都是未认证的请求）</p>
<p>或者如果你的登录请求正常，走了 Spring Security 过滤器链，但是后来的 A 请求没走过滤器链（采用前面提到的第一种方式放行），那么 A 请求中，也是无法通过 SecurityContextHolder 获取到登录用户信息的，因为它一开始没经过 SecurityContextPersistenceFilter 过滤器链。</p>
</blockquote>
</li>
<li><p>创建 <code>securityFilterChains</code> 集合，并且遍历上面提到的两种类型的过滤器链，并将过滤器链放入 <code>securityFilterChains</code> 集合中。</p>
</li>
<li><p>在<code>HttpSecurity</code>介绍过，<code>HttpSecurity</code> 构建出来的过滤器链对象就是 <code>DefaultSecurityFilterChain</code>，所以可以直接将 build 结果放入 <code>securityFilterChains </code>中，而 <code>ignoredRequests</code> 中保存的则需要重构一下才可以存入 <code>securityFilterChains</code></p>
</li>
<li><p><code>securityFilterChains</code> 中有数据之后，接下来创建一个 <code>FilterChainProxy</code></p>
</li>
<li><p>给新建的<code>FilterChainProxy</code>配置上防火墙</p>
</li>
<li><p>最后我们返回的就是<code> FilterChainProxy</code> 的实例。</p>
</li>
</ol>
<p><strong>从这段分析中，我们可以看出来 <code>WebSecurity </code>和 <code>HttpSecurity </code>的区别：</strong></p>
<ol>
<li><code>HttpSecurity</code> 目的是构建过滤器链，一个 <code>HttpSecurity</code> 对象构建一条过滤器链，一个过滤器链中有 N 个过滤器，<code>HttpSecurity</code>所做的事情实际上就是在配置这 N 个过滤器。</li>
<li><code>WebSecurity</code> 目的是构建 <code>FilterChainProxy</code>，一个 <code>FilterChainProxy</code> 中包含有多个过滤器链和一个 Firewall。</li>
</ol>
<h4 id="回到WebSecurityConfigurerAdapter"><a href="#回到WebSecurityConfigurerAdapter" class="headerlink" title="回到WebSecurityConfigurerAdapter"></a>回到WebSecurityConfigurerAdapter</h4><p>最后我们再来看 <code>WebSecurityConfigurerAdapter</code>，由于 <code>WebSecurityConfigurer </code>只是一个空接口，<code>WebSecurityConfigurerAdapter</code> 就是针对这个空接口提供一个具体的实现，最终目的还是为了方便你配置 <code>WebSecurity</code>。</p>
<p><code>WebSecurityConfigurerAdapter</code> 中的方法比较多，但是根据我们前面的分析，提纲挈领的方法就两个，一个是 init，还有一个 configure(WebSecurity web)，其他方法都是为这两个方法服务的。那我们就来看下这两个方法，先看 init 方法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">final</span> WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
	<span class="hljs-keyword">final</span> HttpSecurity http = getHttp();
	web.addSecurityFilterChainBuilder(http).postBuildAction(() -&gt; &#123;
		FilterSecurityInterceptor securityInterceptor = http
				.getSharedObject(FilterSecurityInterceptor.class);
		web.securityInterceptor(securityInterceptor);
	&#125;);
&#125;
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> HttpSecurity <span class="hljs-title">getHttp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
	<span class="hljs-keyword">if</span> (http != <span class="hljs-keyword">null</span>) &#123;
		<span class="hljs-keyword">return</span> http;
	&#125;
	AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();
	localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);
	AuthenticationManager authenticationManager = authenticationManager();
	authenticationBuilder.parentAuthenticationManager(authenticationManager);
	Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = createSharedObjects();
	http = <span class="hljs-keyword">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,
			sharedObjects);
	<span class="hljs-keyword">if</span> (!disableDefaults) &#123;
		<span class="hljs-comment">// @formatter:off</span>
		http
			.csrf().and()
			.addFilter(<span class="hljs-keyword">new</span> WebAsyncManagerIntegrationFilter())
			.exceptionHandling().and()
			.headers().and()
			.sessionManagement().and()
			.securityContext().and()
			.requestCache().and()
			.anonymous().and()
			.servletApi().and()
			.apply(<span class="hljs-keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()
			.logout();
		<span class="hljs-comment">// @formatter:on</span>
		ClassLoader classLoader = <span class="hljs-keyword">this</span>.context.getClassLoader();
		List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers =
				SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);
		<span class="hljs-keyword">for</span> (AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123;
			http.apply(configurer);
		&#125;
	&#125;
	configure(http);
	<span class="hljs-keyword">return</span> http;
&#125;
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
	logger.debug(<span class="hljs-string">&quot;Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity).&quot;</span>);
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.and()
		.formLogin().and()
		.httpBasic();
&#125;</code></pre></div>

<p>init 方法可以算是这里的入口方法了：首先调用 getHttp 方法进行 <code>HttpSecurity </code>的初始化。<code>HttpSecurity</code> 的初始化，实际上就是配置了一堆默认的过滤器，配置完成后，最终还调用了 configure(http) 方法，该方法又配置了一些拦截器，不过在实际开发中，我们经常会重写 configure(http) 方法，<code>HttpSecurity</code> 配置完成后，再将 <code>HttpSecurity</code> 放入 <code>WebSecurity</code> 中，保存在 <code>WebSecurity</code> 的 <code>securityFilterChainBuilders</code> 集合里，具体参见上面的<code>HttpSecurity</code>部分</p>
<p>configure(WebSecurity web) 方法实际上是一个空方法，我们在实际开发中可能会重写该方法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">//防止访问登录页面死循环，不用进入Security拦截</span>
    web.ignoring().antMatchers(<span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/img/**&quot;</span>, <span class="hljs-string">&quot;/fonts/**&quot;</span>, <span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;/verifyCode&quot;</span>);
&#125;</code></pre></div>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Spring/">Spring</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring-Security/">Spring Security</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/05/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">
                        <span class="hidden-mobile">后台管理系统开发记录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#valine",
          app_id: "Q8utolFFXQsi71pQY6bCltkI-gzGzoHsz",
          app_key: "x4RAlPOpmFX9HdGyI6MLoCGn",
          placeholder: "说点什么....",
          path: window.location.pathname,
          avatar: "monsterid",
          meta: ["nick","mail","link"],
          pageSize: "12",
          lang: "zh-CN",
          highlight: true,
          recordIP: true,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>





  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
