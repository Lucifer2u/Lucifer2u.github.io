

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bat.png">
  <link rel="icon" href="/img/bat.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Lucifer">
  <meta name="keywords" content="">
  
  <title>Spring - Lucifer&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/monokai.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lucifer2u.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Q8utolFFXQsi71pQY6bCltkI-gzGzoHsz","app_key":"x4RAlPOpmFX9HdGyI6MLoCGn","server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Lucifer</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Flower.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Spring">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-01 22:37" pubdate>
        2021年8月1日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      49.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      697
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Spring</h1>
            
            <div class="markdown-body">
              <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h1 id="第一章、Spring工厂"><a href="#第一章、Spring工厂" class="headerlink" title="第一章、Spring工厂"></a>第一章、Spring工厂</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><h3 id="1-1-EJB存在的问题"><a href="#1-1-EJB存在的问题" class="headerlink" title="1.1 EJB存在的问题"></a>1.1 EJB存在的问题</h3><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200411104428457.png" srcset="/img/loading.gif" lazyload alt="image-20200411104428457"></p>
<h3 id="1-2-什么是Spring"><a href="#1-2-什么是Spring" class="headerlink" title="1.2 什么是Spring"></a>1.2 什么是Spring</h3><blockquote>
<p>Spring是一个轻量级的JavaEE解决方案，整合众多优秀的设计模式</p>
</blockquote>
<p><strong>轻量级</strong></p>
<ul>
<li>对于运行环境是没有额外要求的<ul>
<li>开源 tomcat resion jetty<br>收费 weblogic  websphere </li>
</ul>
</li>
<li>代码移植性高<ul>
<li>不需要实现额外接口</li>
</ul>
</li>
</ul>
<p><strong>JavaEE的解决方案</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200411111041836.png" srcset="/img/loading.gif" lazyload alt="image-20200411111041836"></p>
<p><strong>整合设计模式</strong></p>
<ul>
<li>工厂</li>
<li>代理</li>
<li>模板</li>
<li>策略</li>
</ul>
<h3 id="1-3-设计模式"><a href="#1-3-设计模式" class="headerlink" title="1.3 设计模式"></a>1.3 设计模式</h3><p><strong>广义概念</strong></p>
<blockquote>
<p>面向对象设计中，解决特定问题的经典代码</p>
</blockquote>
<p><strong>狭义概念</strong></p>
<blockquote>
<p>GOF4人帮定义的23种设计模式：工厂、适配器、装饰器、门面、代理、模板…</p>
</blockquote>
<h3 id="1-4-工厂设计模式"><a href="#1-4-工厂设计模式" class="headerlink" title="1.4 工厂设计模式"></a>1.4 工厂设计模式</h3><h4 id="1-4-1-什么是工厂设计模式"><a href="#1-4-1-什么是工厂设计模式" class="headerlink" title="1.4.1 什么是工厂设计模式"></a>1.4.1 什么是工厂设计模式</h4><ul>
<li><p>概念：通过工厂类，创建对象</p>
  <div class="hljs code-wrapper"><pre><code class="hljs java">User user = <span class="hljs-keyword">new</span> User();
UserDAO userDAO = <span class="hljs-keyword">new</span> UserDAOImpl();</code></pre></div></li>
<li><p>好处：解耦合</p>
<ul>
<li><p>耦合：指定是代码间的强关联关系，一方的改变会影响到另一方</p>
</li>
<li><p>问题：不利于代码维护</p>
</li>
<li><p>简单：把接口的实现类，硬编码在程序中</p>
 <div class="hljs code-wrapper"><pre><code class="hljs java">UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();</code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="1-4-2-简单工厂的设计"><a href="#1-4-2-简单工厂的设计" class="headerlink" title="1.4.2 简单工厂的设计"></a>1.4.2 简单工厂的设计</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;
<span class="hljs-comment">/* 对象的创建方式：</span>
<span class="hljs-comment">		1. 直接调用构造方法 创建对象  UserService userService = new UserServiceImpl();</span>
<span class="hljs-comment">		2. 通过反射的形式 创建对象 解耦合</span>
<span class="hljs-comment">		//com.baizhiedu.basic.UserServiceImpl,类名改变也会改变</span>
<span class="hljs-comment"> 		Class clazz = Class.forName(&quot;com.baizhiedu.basic.UserServiceImpl&quot;);</span>
<span class="hljs-comment">    UserService userService = (UserService)clazz.newInstance();*/</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserService <span class="hljs-title">getUserService</span><span class="hljs-params">()</span> </span>&#123;

    UserService userService = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;                              						    					   
		<span class="hljs-comment">//com.baizhiedu.basic.UserServiceImpl,类名改变也会改变</span>
 		Class clazz = Class.forName(<span class="hljs-string">&quot;com.baizhiedu.basic.UserServiceImpl&quot;</span>);
    UserService userService = (UserService)clazz.newInstance();
    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
        e.printStackTrace();
    &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;
        e.printStackTrace();
    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;
        e.printStackTrace();
    &#125;
    <span class="hljs-keyword">return</span> userService;
	&#125;
&#125;</code></pre></div>

<p>通过反射的形式创建对象来解耦合，但<code>com.baizhiedu.basic.UserServiceImpl</code>改变<code>Class.forName(&quot;com.baizhiedu.basic.UserServiceImpl&quot;)</code>也会改变，并没有完全解耦，可以利用Properties文件来进行管理，配置文件<code>applicationContext.properties</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># Properties 集合 存储 Properties文件的内容</span>
<span class="hljs-comment"># 特殊Map key=String value=String</span>
<span class="hljs-comment"># Properties [userService = com.baizhiedu.xxx.UserServiceImpl]</span>
<span class="hljs-comment"># Properties.getProperty(&quot;userService&quot;)</span>

<span class="hljs-attr">userService</span> = <span class="hljs-string">com.baizhiedu.basic.UserServiceImpl</span>
<span class="hljs-attr">userDAO</span> = <span class="hljs-string">com.baizhiedu.basic.UserDAOImpl</span></code></pre></div>

<p><strong>下面利用Properties来调用</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;
  
  	<span class="hljs-comment">//创建对象</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Properties env = <span class="hljs-keyword">new</span> Properties();
    <span class="hljs-keyword">static</span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//第一步 获得IO输入流</span>
            InputStream inputStream = BeanFactory.class.getResourceAsStream(<span class="hljs-string">&quot;/applicationContext.properties&quot;</span>);
            <span class="hljs-comment">//第二步 文件内容 封装 Properties集合中 key = userService value = com.baizhixx.UserServiceImpl</span>
            env.load(inputStream);
          	<span class="hljs-comment">//关闭流</span>
            inputStream.close();
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
  
  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserService <span class="hljs-title">getUserService</span><span class="hljs-params">()</span> </span>&#123;

    UserService userService = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;
      	<span class="hljs-comment">//利用getProperty调用applicationContext.properties中的userService</span>
        Class clazz = Class.forName(env.getProperty(<span class="hljs-string">&quot;userService&quot;</span>));
        userService = (UserService) clazz.newInstance();
    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
        e.printStackTrace();
    &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;
        e.printStackTrace();
    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;
        e.printStackTrace();
    &#125;
    <span class="hljs-keyword">return</span> userService;
	&#125;
&#125;
 		
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDAO <span class="hljs-title">getUserDAO</span><span class="hljs-params">()</span></span>&#123;

        UserDAO userDAO = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
          	<span class="hljs-comment">//同理</span>
            Class clazz = Class.forName(env.getProperty(<span class="hljs-string">&quot;userDAO&quot;</span>));
            userDAO = (UserDAO) clazz.newInstance();
        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;
            e.printStackTrace();
        &#125;

        <span class="hljs-keyword">return</span> userDAO;

    &#125;
&#125;</code></pre></div>

<h4 id="1-4-3-通用工厂的设计"><a href="#1-4-3-通用工厂的设计" class="headerlink" title="1.4.3 通用工厂的设计"></a>1.4.3 通用工厂的设计</h4><ul>
<li>简单工厂会存在大量的代码冗余</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200411181701143.png" srcset="/img/loading.gif" lazyload alt="image-20200411181701143"></p>
<ul>
<li><p>通用工厂的代码</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建一切想要的对象</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span></span>&#123;
  	<span class="hljs-comment">//传参</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String key)</span></span>&#123;
         Object ret = <span class="hljs-keyword">null</span>;
         <span class="hljs-keyword">try</span> &#123;
           		<span class="hljs-comment">//传入参数key，不再手写</span>
             Class clazz = Class.forName(env.getProperty(key));
             ret = clazz.newInstance();
         &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
         &#125;
         <span class="hljs-keyword">return</span> ret;
     &#125;
&#125;</code></pre></div></li>
</ul>
<h4 id="1-4-4-通用工厂的使用方式"><a href="#1-4-4-通用工厂的使用方式" class="headerlink" title="1.4.4 通用工厂的使用方式"></a>1.4.4 通用工厂的使用方式</h4><ul>
<li>定义类型 (类)</li>
<li>通过配置文件的配置告知工厂<code>applicationContext.properties</code><br> <code>key = value</code></li>
<li>通过工厂获得类的对象<br> <code>Object ret = BeanFactory.getBean(&quot;key&quot;)</code></li>
</ul>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p><strong>Spring本质</strong></p>
<p>工厂 <code>ApplicationContext (applicationContext.xml)</code></p>
<h2 id="2-第一个Spring程序"><a href="#2-第一个Spring程序" class="headerlink" title="2. 第一个Spring程序"></a>2. 第一个Spring程序</h2><h3 id="2-1-软件版本"><a href="#2-1-软件版本" class="headerlink" title="2.1 软件版本"></a>2.1 软件版本</h3><ul>
<li><strong>JDK1.8+</strong></li>
<li><strong>Maven3.5+</strong></li>
<li><strong>IDEA2018+</strong></li>
<li><strong>SpringFramework 5.1.4</strong> </li>
</ul>
<h3 id="2-2-环境搭建"><a href="#2-2-环境搭建" class="headerlink" title="2.2 环境搭建"></a>2.2 环境搭建</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>Spring的配置文件</p>
<ul>
<li>配置文件的放置位置：任意位置</li>
<li>配置文件的命名 <ul>
<li>建议：<code>applicationContext.xml</code></li>
</ul>
</li>
</ul>
<p>日后应用Spring框架时，需要进行配置文件路径的设置</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200413114751707.png" srcset="/img/loading.gif" lazyload alt="image-20200413114751707"></p>
<h3 id="2-3-Spring的核心API"><a href="#2-3-Spring的核心API" class="headerlink" title="2.3 Spring的核心API"></a>2.3 Spring的核心API</h3><p><code>ApplicationContext</code></p>
<ul>
<li>作用：Spring提供的ApplicationContext这个工厂，用于对象的创建</li>
<li>好处：解耦合</li>
</ul>
<p><strong>ApplicationContext接口类型</strong></p>
<ul>
<li>接口：屏蔽实现的差异</li>
<li>非web环境 ： <code>ClassPathXmlApplicationContext (main junit)</code></li>
<li>web环境  ： <code> XmlWebApplicationContext</code></li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200413142452724.png" srcset="/img/loading.gif" lazyload alt="image-20200413142452724"></p>
<p><strong>重量级资源</strong></p>
<ul>
<li>ApplicationContext工厂的对象占用大量内存</li>
<li>不会频繁的创建对象 ： 一个应用只会创建一个工厂对象</li>
<li>ApplicationContext工厂：一定是线程安全的(多线程并发访问)</li>
</ul>
<h3 id="2-4-程序开发"><a href="#2-4-程序开发" class="headerlink" title="2.4 程序开发"></a>2.4 程序开发</h3><p>创建类型，配置文件的配置 <code>applicationContext.xml</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.basic.Person&quot;</span>/&gt;</span></code></pre></div>
<p> 通过工厂类，获得对象<code>ApplicationContext</code>与<code>ClassPathXmlApplicationContext</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);
Person person = (Person)ctx.getBean(<span class="hljs-string">&quot;person&quot;</span>);</code></pre></div>

<h3 id="2-5-细节分析"><a href="#2-5-细节分析" class="headerlink" title="2.5 细节分析"></a>2.5 细节分析</h3><p><strong>名词解释</strong></p>
<blockquote>
<p>Spring工厂创建的对象，叫做bean或者组件(componet)        </p>
</blockquote>
<p><strong>Spring工厂的相关的方法</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//通过这种方式获得对象，就不需要强制类型转换</span>
Person person = ctx.getBean(<span class="hljs-string">&quot;person&quot;</span>, Person.class);
System.out.println(<span class="hljs-string">&quot;person = &quot;</span> + person);
        

<span class="hljs-comment">//当前Spring的配置文件中 只能有一个&lt;bean class是Person类型</span>
Person person = ctx.getBean(Person.class);
System.out.println(<span class="hljs-string">&quot;person = &quot;</span> + person);
        

<span class="hljs-comment">//获取的是 Spring工厂配置文件中所有bean标签的id值  person person1</span>
String[] beanDefinitionNames = ctx.getBeanDefinitionNames();
<span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;
  System.out.println(<span class="hljs-string">&quot;beanDefinitionName = &quot;</span> + beanDefinitionName);
&#125;
        

<span class="hljs-comment">//根据类型获得Spring配置文件中对应的id值</span>
String[] beanNamesForType = ctx.getBeanNamesForType(Person.class);
<span class="hljs-keyword">for</span> (String id : beanNamesForType) &#123;
  System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);
&#125;
        

<span class="hljs-comment">//用于判断是否存在指定id值得bean</span>
<span class="hljs-keyword">if</span> (ctx.containsBeanDefinition(<span class="hljs-string">&quot;a&quot;</span>)) &#123;
  System.out.println(<span class="hljs-string">&quot;true = &quot;</span> + <span class="hljs-keyword">true</span>);
&#125;<span class="hljs-keyword">else</span>&#123;
  System.out.println(<span class="hljs-string">&quot;false = &quot;</span> + <span class="hljs-keyword">false</span>);
&#125;
      

<span class="hljs-comment">//用于判断是否存在指定id值得bean</span>
<span class="hljs-keyword">if</span> (ctx.containsBean(<span class="hljs-string">&quot;person&quot;</span>)) &#123;
  System.out.println(<span class="hljs-string">&quot;true = &quot;</span> + <span class="hljs-keyword">true</span>);
&#125;<span class="hljs-keyword">else</span>&#123;
  System.out.println(<span class="hljs-string">&quot;false = &quot;</span> + <span class="hljs-keyword">false</span>);
&#125;</code></pre></div>

<p><strong>配置文件中需要注意的细节</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1. 只配置class属性</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.basic.Person&quot;</span>/&gt;</span></span>
<span class="hljs-bullet">1.</span> 上述这种配置 有id值com.baizhiedu.basic.Person#0

<span class="hljs-bullet">2.</span> 如果这个bean只需要使用一次，那么就可以省略id值
<span class="hljs-code">	 如果这个bean会使用多次，或者被其他bean引用则需要设置id值</span>
<span class="hljs-code"></span>
<span class="hljs-code"># 2. name属性</span>
<span class="hljs-code">作用：用于在Spring的配置文件中，为bean对象定义别名(小名)</span>
<span class="hljs-code">相同：</span>
<span class="hljs-code">   1. ctx.getBean(&quot;id|name&quot;)--&gt;object</span>
<span class="hljs-code">   </span>
<span class="hljs-code">   2. &lt;bean id=&quot;&quot; class=&quot;&quot;</span>
<span class="hljs-code">      等效</span>
<span class="hljs-code">      &lt;bean name=&quot;&quot; class=&quot;&quot;</span>
<span class="hljs-code">区别：</span>
<span class="hljs-code">   1. 别名可以定义多个,但是id属性只能有一个值</span>
<span class="hljs-code">   </span>
<span class="hljs-code">   2. XML的id属性的值，以前命名要求：必须以字母开头，字母 数字 下划线 连字符 不能以特殊字符开头 如/person</span>
<span class="hljs-code">      name属性的值，命名没有要求 如/person</span>
<span class="hljs-code">      name属性会应用在特殊命名的场景下</span>
<span class="hljs-code">      XML发展到了今天：ID属性的限制，不存在 可以使用/person</span>
<span class="hljs-code">   </span>
<span class="hljs-code">   3. 代码</span></code></pre></div>


<div class="hljs code-wrapper"><pre><code class="hljs java">  <span class="hljs-comment">//用于判断是否存在指定id值得bean,不能判断name值    </span>
<span class="hljs-keyword">if</span> (ctx.containsBeanDefinition(<span class="hljs-string">&quot;person&quot;</span>)) &#123;
          System.out.println(<span class="hljs-string">&quot;true = &quot;</span> + <span class="hljs-keyword">true</span>);
      &#125;<span class="hljs-keyword">else</span>&#123;
          System.out.println(<span class="hljs-string">&quot;false = &quot;</span> + <span class="hljs-keyword">false</span>);
      &#125;
  <span class="hljs-comment">//用于判断是否存在指定id值得bean,也可以判断name值</span>
  <span class="hljs-keyword">if</span> (ctx.containsBean(<span class="hljs-string">&quot;p&quot;</span>)) &#123;
      System.out.println(<span class="hljs-string">&quot;true = &quot;</span> + <span class="hljs-keyword">true</span>);
  &#125;<span class="hljs-keyword">else</span>&#123;
      System.out.println(<span class="hljs-string">&quot;false = &quot;</span> + <span class="hljs-keyword">false</span>);
  &#125;</code></pre></div>

<h3 id="2-6-Spring工厂的底层实现原理-简易版"><a href="#2-6-Spring工厂的底层实现原理-简易版" class="headerlink" title="2.6 Spring工厂的底层实现原理(简易版)"></a>2.6 Spring工厂的底层实现原理(简易版)</h3><p>Spring工厂是可以<strong>调用对象私有的构造方法</strong>创建对象</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200415113032782.png" srcset="/img/loading.gif" lazyload alt="image-20200415113032782"></p>
<h3 id="2-7-思考"><a href="#2-7-思考" class="headerlink" title="2.7 思考"></a>2.7 思考</h3><p>问题：未来在开发过程中，是不是所有的对象，都会交给Spring工厂来创建呢？<br>回答：理论上 是的，但是有特例 ：<strong>实体对象(entity)是不会交给Spring创建</strong>，它是由持久层框架进行创建</p>
<h2 id="3-Spring5-x与日志框架的整合"><a href="#3-Spring5-x与日志框架的整合" class="headerlink" title="3. Spring5.x与日志框架的整合"></a>3. Spring5.x与日志框架的整合</h2><blockquote>
<p>Spring与日志框架进行整合，日志框架就可以在控制台中，输出Spring框架运行过程中的一些重要的信息。<br>好处：便于了解Spring框架的运行过程，利于程序的调试</p>
</blockquote>
<p><strong>默认</strong></p>
<p>  Spring1.2.3早期都是于<code>commons-logging.jar</code><br>  Spring5.x默认整合的日志框架 <code>logback log4j2</code></p>
<p><strong>Spring5.x整合log4j</strong> </p>
<ul>
<li>引入<code>log4j jar</code>包</li>
<li>引入<code>log4.properties</code>配置文件</li>
</ul>
<p><code>pom</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><code>log4j.properties</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># resources文件夹根目录下</span>
<span class="hljs-comment">### 配置根</span>
<span class="hljs-meta">log4j.rootLogger</span> = <span class="hljs-string">debug,console</span>

<span class="hljs-comment">### 日志输出到控制台显示</span>
<span class="hljs-meta">log4j.appender.console</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span>
<span class="hljs-meta">log4j.appender.console.Target</span>=<span class="hljs-string">System.out</span>
<span class="hljs-meta">log4j.appender.console.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span>
<span class="hljs-meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span></code></pre></div>

<h2 id="4-注入-Injection"><a href="#4-注入-Injection" class="headerlink" title="4. 注入(Injection)"></a>4. 注入(Injection)</h2><h3 id="4-1-什么是注入"><a href="#4-1-什么是注入" class="headerlink" title="4.1 什么是注入"></a>4.1 什么是注入</h3><blockquote>
<p>通过Spring工厂及配置文件，为所创建对象的成员变量赋值</p>
</blockquote>
<h4 id="4-1-1-为什么需要注入"><a href="#4-1-1-为什么需要注入" class="headerlink" title="4.1.1 为什么需要注入"></a>4.1.1 为什么需要注入</h4><p><strong>通过编码的方式，为成员变量进行赋值，存在耦合</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200415185212664.png" srcset="/img/loading.gif" lazyload alt="image-20200415185212664"></p>
<h4 id="4-1-2-如何进行注入-开发步骤"><a href="#4-1-2-如何进行注入-开发步骤" class="headerlink" title="4.1.2 如何进行注入[开发步骤]"></a>4.1.2 如何进行注入[开发步骤]</h4><p>类的成员变量提供set get方法</p>
<p>配置spring的配置文件</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.basic.Person&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>xiaojr<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>通过注入，达到<strong>解耦合</strong>的目的</p>
<h3 id="4-2-Spring注入的原理分析-简易版"><a href="#4-2-Spring注入的原理分析-简易版" class="headerlink" title="4.2 Spring注入的原理分析(简易版)"></a>4.2 Spring注入的原理分析(简易版)</h3><p><strong>Spring通过底层调用对象属性对应的set方法，完成成员变量的赋值，这种方式我们也称之为set注入</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200415191157364.png" srcset="/img/loading.gif" lazyload alt="image-20200415191157364"></p>
<h2 id="5-Set注入详解"><a href="#5-Set注入详解" class="headerlink" title="5. Set注入详解"></a>5. Set注入详解</h2><p>针对于不同类型的成员变量，在<code>&lt;property&gt;</code>标签，需要嵌套其他标签</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    xxxxx
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416090518713.png" srcset="/img/loading.gif" lazyload alt="image-20200416090518713"></p>
<h3 id="5-1-JDK内置类型"><a href="#5-1-JDK内置类型" class="headerlink" title="5.1 JDK内置类型"></a>5.1 JDK内置类型</h3><p>在<code>&lt;property&gt;</code>标签里添加</p>
<h4 id="5-1-1-String-8种基本类型"><a href="#5-1-1-String-8种基本类型" class="headerlink" title="5.1.1 String+8种基本类型"></a>5.1.1 String+8种基本类型</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></code></pre></div>

<h4 id="5-1-2-数组"><a href="#5-1-2-数组" class="headerlink" title="5.1.2 数组"></a>5.1.2 数组</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns@zparkhr.com.cn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>liucy@zparkhr.com.cn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>chenyn@zparkhr.com.cn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span></code></pre></div>

<h4 id="5-1-3-Set集合"><a href="#5-1-3-Set集合" class="headerlink" title="5.1.3 Set集合"></a>5.1.3 Set集合</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>112222<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>

# Set如果不加范性，可以存任何的标签
<span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span></span>
   &lt;set 
<span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre></div>

<h4 id="5-1-4-List集合"><a href="#5-1-4-List集合" class="headerlink" title="5.1.4 List集合"></a>5.1.4 List集合</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>

# 同理于set
<span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span></span>
   &lt;set 
<span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span></code></pre></div>

<h4 id="5-1-5-Map集合"><a href="#5-1-5-Map集合" class="headerlink" title="5.1.5 Map集合"></a>5.1.5 Map集合</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">注意： map -- entry  -- key有特定的标签  <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
                       值根据对应类型选择对应类型的标签
<span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3434334343<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>chenyn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span></span>
  &lt;/entry&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span></code></pre></div>

<h4 id="5-1-6-Properites"><a href="#5-1-6-Properites" class="headerlink" title="5.1.6 Properites"></a>5.1.6 Properites</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">Properties类型 特殊的Map key=String value=String 
<span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;key1&quot;</span>&gt;</span>value1<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;key2&quot;</span>&gt;</span>value2<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span></code></pre></div>

<h4 id="5-1-7-复杂的JDK类型-Date"><a href="#5-1-7-复杂的JDK类型-Date" class="headerlink" title="5.1.7 复杂的JDK类型 (Date)"></a>5.1.7 复杂的JDK类型 (Date)</h4><p>需要程序员自定义类型转换器，处理</p>
<h3 id="5-2-用户自定义类型"><a href="#5-2-用户自定义类型" class="headerlink" title="5.2 用户自定义类型"></a>5.2 用户自定义类型</h3><h4 id="5-2-1-第一种方式"><a href="#5-2-1-第一种方式" class="headerlink" title="5.2.1 第一种方式"></a>5.2.1 第一种方式</h4><p>为成员变量提供<code>set get</code>方法</p>
<p>配置文件中进行注入(赋值)</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxxx.UserServiceImpl&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.UserDAOImpl&quot;</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<h4 id="5-2-2-第二种方式"><a href="#5-2-2-第二种方式" class="headerlink" title="5.2.2 第二种方式"></a>5.2.2 第二种方式</h4><p>第一种赋值方式存在的问题</p>
<ul>
<li>配置文件代码冗余</li>
<li>被注入的对象<code>&lt;bean class=&quot;xxx.UserDAOImpl&quot;/&gt;</code>,多次创建，浪费内存资源</li>
</ul>
<p>为成员变量提供<code>set get</code>方法</p>
<p>配置文件中进行配置</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.UserDAOImpl&quot;</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.UserServiceImpl&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

#Spring4.x 废除了 <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">local</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span> 基本等效 <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span></code></pre></div>

<h3 id="5-3-Set注入的简化写法"><a href="#5-3-Set注入的简化写法" class="headerlink" title="5.3 Set注入的简化写法"></a>5.3 Set注入的简化写法</h3><h4 id="5-3-1-基于属性简化"><a href="#5-3-1-基于属性简化" class="headerlink" title="5.3.1 基于属性简化"></a>5.3.1 基于属性简化</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">JDK类型注入 
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
替换为
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;suns&quot;</span>/&gt;</span>
注意：value属性 只能简化 8种基本类型+String 注入标签

用户自定义类型
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
替换为
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span></code></pre></div>

<h4 id="5-3-2-基于p命名空间简化"><a href="#5-3-2-基于p命名空间简化" class="headerlink" title="5.3.2 基于p命名空间简化"></a>5.3.2 基于p命名空间简化</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">JDK类型注入 
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxxx.Person&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
替换为
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.Person&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;suns&quot;</span> <span class="hljs-attr">p:id</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span>
注意：value属性 只能简化 8种基本类型+String 注入标签

用户自定义类型
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xx.UserServiceImpl&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
替换为
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.UserServiceImpl&quot;</span> <span class="hljs-attr">p:userDAO-ref</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span></code></pre></div>

<h2 id="6-构造注入"><a href="#6-构造注入" class="headerlink" title="6 构造注入"></a>6 构造注入</h2><ul>
<li>注入：通过Spring的配置文件，为成员变量赋值</li>
<li>Set注入：Spring调用Set方法 通过配置文件 为成员变量赋值</li>
<li>构造注入：Spring调用构造方法 通过配置文件 为成员变量赋值</li>
</ul>
<h3 id="6-1-开发步骤"><a href="#6-1-开发步骤" class="headerlink" title="6.1 开发步骤"></a>6.1 开发步骤</h3><p>提供有参构造方法</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;
&#125;</code></pre></div>

<p>Spring的配置文件</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.basic.constructer.Customer&quot;</span>&gt;</span>
 	有两个参数，需要两个构造标签
  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>suns<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>
  
  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>102<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<h3 id="6-2-构造方法重载"><a href="#6-2-构造方法重载" class="headerlink" title="6.2 构造方法重载"></a>6.2 构造方法重载</h3><h4 id="6-2-1-参数个数不同时"><a href="#6-2-1-参数个数不同时" class="headerlink" title="6.2.1 参数个数不同时"></a>6.2.1 参数个数不同时</h4><p>通过控制<code>&lt;constructor-arg&gt;</code>标签的数量进行区分 </p>
<h4 id="6-2-2-构造参数个数相同时"><a href="#6-2-2-构造参数个数相同时" class="headerlink" title="6.2.2 构造参数个数相同时"></a>6.2.2 构造参数个数相同时</h4><p>通过在标签引入 type属性 进行类型的区分<code> &lt;constructor-arg type=&quot;&quot;&gt;</code></p>
<h3 id="6-3-注入的总结"><a href="#6-3-注入的总结" class="headerlink" title="6.3 注入的总结"></a>6.3 注入的总结</h3><p>未来的实战中，应用set注入还是构造注入？</p>
<p>答案：<strong>set注入更多</strong><br>       1. 构造注入麻烦 (重载)<br>              2. Spring框架底层 大量应用了 set注入</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416155620897.png" srcset="/img/loading.gif" lazyload alt="image-20200416155620897"></p>
<h2 id="7-反转控制与依赖注入"><a href="#7-反转控制与依赖注入" class="headerlink" title="7. 反转控制与依赖注入"></a>7. 反转控制与依赖注入</h2><h3 id="7-1-反转-转移-控制-IOC-Inverse-of-Control"><a href="#7-1-反转-转移-控制-IOC-Inverse-of-Control" class="headerlink" title="7.1 反转(转移)控制(IOC Inverse of Control)"></a>7.1 反转(转移)控制(IOC Inverse of Control)</h3><ul>
<li>控制：对于成员<strong>变量赋值</strong>的控制权</li>
<li>反转控制：把对于成员变量赋值的控制权，从代码中<strong>反转(转移)到Spring工厂和配置文件</strong>中完成<ul>
<li>好处：解耦合</li>
</ul>
</li>
<li>底层实现：工厂设计模式</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416161127972.png" srcset="/img/loading.gif" lazyload alt="image-20200416161127972"></p>
<h3 id="7-2-依赖注入-Dependency-Injection-DI"><a href="#7-2-依赖注入-Dependency-Injection-DI" class="headerlink" title="7.2 依赖注入 (Dependency Injection  DI)"></a>7.2 依赖注入 (Dependency Injection  DI)</h3><ul>
<li><p>注入：通过Spring的工厂及配置文件，为对象（bean，组件）的成员变量赋值</p>
</li>
<li><p>依赖注入：当一个类需要另一个类时，就意味着依赖，一旦出现依赖，就可以把另一个类作为本类的成员变量，最终通过Spring配置文件进行注入(赋值)</p>
<ul>
<li> 好处：解耦合</li>
</ul>
</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416162615816.png" srcset="/img/loading.gif" lazyload alt="image-20200416162615816"></p>
<h2 id="8-Spring工厂创建复杂对象"><a href="#8-Spring工厂创建复杂对象" class="headerlink" title="8. Spring工厂创建复杂对象"></a>8. Spring工厂创建复杂对象</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416164044047.png" srcset="/img/loading.gif" lazyload alt="image-20200416164044047"></p>
<h3 id="8-1-什么是复杂对象"><a href="#8-1-什么是复杂对象" class="headerlink" title="8.1 什么是复杂对象"></a>8.1 什么是复杂对象</h3><blockquote>
<p>复杂对象：指的就是不能直接通过new构造方法创建的对象</p>
</blockquote>
<ul>
<li>Connection</li>
<li>SqlSessionFactory</li>
</ul>
<h3 id="8-2-Spring工厂创建复杂对象的3种方式"><a href="#8-2-Spring工厂创建复杂对象的3种方式" class="headerlink" title="8.2 Spring工厂创建复杂对象的3种方式"></a>8.2 Spring工厂创建复杂对象的3种方式</h3><h4 id="8-2-1-FactoryBean接口"><a href="#8-2-1-FactoryBean接口" class="headerlink" title="8.2.1 FactoryBean接口"></a>8.2.1 FactoryBean接口</h4><p><strong>开发步骤</strong></p>
<ul>
<li><p>实现FactoryBean接口 <img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200416204458451.png" srcset="/img/loading.gif" lazyload alt="image-20200416204458451"></p>
</li>
<li><p>Spring配置文件的配置</p>
<p>如果Class中指定的类型是<code>FactoryBean</code>接口的实现类，那么通过id值获得的是这个类所创建的复杂对象  <code>Connection</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conn&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.factorybean.ConnectionFactoryBean&quot;</span>/&gt;</span></code></pre></div></li>
<li><p>细节</p>
<ul>
<li><p>如果就想获得<code>FactoryBean</code>类型的对象<code>ctx.getBean(&quot;&amp;conn&quot;)</code>获得就是<code>ConnectionFactoryBean</code>对象</p>
</li>
<li><p><code>isSingleton</code>方法 返回  true 只会创建一个复杂对象</p>
<ul>
<li>返回 false 每一次都会创建新的对象 问题：根据这个对象的特点 ，决定是返回<code>true (SqlSessionFactory) </code>还是<code> false  (Connection)</code></li>
<li>如果是连接对象<code>Connection</code>，需要返回false，因为会出现并发问题</li>
</ul>
</li>
<li><p>mysql高版本连接创建时，需要制定SSL证书，解决问题的方式</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">url</span> = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/suns?useSSL=false&quot;</span></code></pre></div></li>
<li><p>依赖注入的体会(DI)</p>
<p>把<code>ConnectionFactoryBean</code>中依赖的4个字符串信息 ，进行配置文件的注入<br>好处：解耦合</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conn&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.factorybean.ConnectionFactoryBean&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/suns?useSSL=false&quot;</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div></li>
</ul>
</li>
</ul>
<p><strong>FactoryBean的实现原理[简易版]</strong></p>
<p>接口回调</p>
<ul>
<li>为什么Spring规定<code>FactoryBean</code>接口 实现 并且<code> getObject()</code>?</li>
<li><code>ctx.getBean(&quot;conn&quot;) </code>获得是复杂对象 <code>Connection</code> 而没有获得 <code>ConnectionFactoryBean(&amp;)</code></li>
</ul>
<p>Spring内部运行流程</p>
<ul>
<li>通过conn获得 <code>ConnectionFactoryBean</code>类的对象 ，进而通过<code>instanceof </code>判断出是<code>FactoryBean</code>接口的实现类</li>
<li>Spring按照规定 <code>getObject() ---&gt; Connection</code></li>
<li>返回<code>Connection </code></li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200417114723005.png" srcset="/img/loading.gif" lazyload alt="image-20200417114723005"></p>
<p><strong>FactoryBean总结</strong></p>
<p>Spring中用于创建复杂对象的一种方式，也是Spring原生提供的，后续讲解Spring整合其他框架，大量应用<code>FactoryBean</code></p>
<h4 id="8-2-2-实例工厂"><a href="#8-2-2-实例工厂" class="headerlink" title="8.2.2 实例工厂"></a>8.2.2 实例工厂</h4><ul>
<li>避免Spring框架的侵入，如果以后用其他框架，会被Spring框架所束缚</li>
<li>整合遗留系统 </li>
</ul>
<p><strong>开发步骤</strong></p>
<p>遗留的ConnectionFactory类</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionFactory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;
        Connection conn = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);
            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring?useSSL=false&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>);
        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> conn;
    &#125;
&#125;</code></pre></div>

<p>直接用配置文件整合</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;connFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.factorybean.ConnectionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conn&quot;</span>  <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;connFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getConnection&quot;</span>/&gt;</span></code></pre></div>

<h4 id="8-2-3-静态工厂"><a href="#8-2-3-静态工厂" class="headerlink" title="8.2.3 静态工厂"></a>8.2.3 静态工厂</h4><p>原先是</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">ConnectionFactory cf = <span class="hljs-keyword">new</span> ConnectionFactory();
cf.getConnection();</code></pre></div>

<p>静态工厂是</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">staticFactoryBean.getConnection();</code></pre></div>

<p><strong>开发步骤</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticFactoryBean</span> </span>&#123;
	<span class="hljs-comment">// 静态方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;
        Connection conn = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);
            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring?useSSL=false&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>);
        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> conn;
    &#125;
&#125;</code></pre></div>

<p>配置文件</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conn&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.factorybean.StaticConnectionFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getConnection&quot;</span>/&gt;</span></code></pre></div>

<h3 id="8-3-Spring工厂创建对象的总结"><a href="#8-3-Spring工厂创建对象的总结" class="headerlink" title="8.3 Spring工厂创建对象的总结"></a>8.3 Spring工厂创建对象的总结</h3><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200417152030222.png" srcset="/img/loading.gif" lazyload alt="image-20200417152030222"></p>
<h2 id="9-控制Spring工厂创建对象的次数"><a href="#9-控制Spring工厂创建对象的次数" class="headerlink" title="9. 控制Spring工厂创建对象的次数"></a>9. 控制Spring工厂创建对象的次数</h2><h3 id="9-1-如何控制简单对象的创建次数"><a href="#9-1-如何控制简单对象的创建次数" class="headerlink" title="9.1 如何控制简单对象的创建次数"></a>9.1 如何控制简单对象的创建次数</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton|prototype&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxxx.Account&quot;</span>/&gt;</span>

&lt;sigleton:只会创建一次简单对象默认值&gt;默认
&lt;prototype:每一次都会创建新的对象&gt;</code></pre></div>

<h3 id="9-2-如何控制复杂对象的创建次数"><a href="#9-2-如何控制复杂对象的创建次数" class="headerlink" title="9.2 如何控制复杂对象的创建次数"></a>9.2 如何控制复杂对象的创建次数</h3><div class="hljs code-wrapper"><pre><code class="hljs java">FactoryBean&#123;
   isSingleton()&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>  只会创建一次
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span> 每一次都会创建新的
   &#125;
&#125;</code></pre></div>

<p>如没有isSingleton方法 还是通过scope属性 进行对象创建次数的控制</p>
<h3 id="9-3-为什么要控制对象的创建次数？"><a href="#9-3-为什么要控制对象的创建次数？" class="headerlink" title="9.3 为什么要控制对象的创建次数？"></a>9.3 为什么要控制对象的创建次数？</h3><blockquote>
<p>好处：节省不别要的内存浪费 </p>
</blockquote>
<ul>
<li><p>什么样的对象只创建一次？</p>
<ul>
<li>SqlSessionFactory</li>
<li>DAO</li>
<li>Service</li>
</ul>
</li>
<li><p>什么样的对象 每一次都要创建新的？</p>
<ul>
<li>Connection</li>
<li>SqlSession | Session</li>
<li>Struts2 Action</li>
</ul>
</li>
</ul>
<h1 id="第二章、Spring工厂高级特性"><a href="#第二章、Spring工厂高级特性" class="headerlink" title="第二章、Spring工厂高级特性"></a>第二章、Spring工厂高级特性</h1><h2 id="1、对象的生命周期"><a href="#1、对象的生命周期" class="headerlink" title="1、对象的生命周期"></a>1、对象的生命周期</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200418155427918.png" srcset="/img/loading.gif" lazyload alt="image-20200418155427918"></p>
<h3 id="1-1-什么是对象的生命周期"><a href="#1-1-什么是对象的生命周期" class="headerlink" title="1.1 什么是对象的生命周期"></a>1.1 什么是对象的生命周期</h3><blockquote>
<p>指的是一个对象创建、存活、消亡的一个完整过程</p>
</blockquote>
<h3 id="1-2-为什么要学习对象的生命周期"><a href="#1-2-为什么要学习对象的生命周期" class="headerlink" title="1.2 为什么要学习对象的生命周期"></a>1.2 为什么要学习对象的生命周期</h3><blockquote>
<p>由Spring负责对象的创建、存活、销毁，了解生命周期，有利于我们使用好Spring为我们创建的对象</p>
</blockquote>
<h3 id="1-3-生命周期的3个阶段"><a href="#1-3-生命周期的3个阶段" class="headerlink" title="1.3 生命周期的3个阶段"></a>1.3 生命周期的3个阶段</h3><h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><p>Spring工厂何时创建对象</p>
<ul>
<li><p>scope=”singleton”</p>
<ul>
<li>Spring工厂创建的同时，对象的创建</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java">注意：设置scope=singleton 这种情况下 也需要在获取对象的同时，创建对象，加上标签 
&lt;bean lazy-init=<span class="hljs-string">&quot;true&quot;</span>/&gt;</code></pre></div></li>
<li><p>scope=”prototype”</p>
<ul>
<li>Spring工厂会在获取对象的同时，创建对象</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java">ctx.getBean(<span class="hljs-string">&quot;&quot;</span>)</code></pre></div></li>
</ul>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a><strong>初始化阶段</strong></h4><p>Spring工厂在创建完对象后，调用对象的初始化方法，完成对应的初始化操作</p>
<ol>
<li>初始化方法提供：程序员根据需求，提供初始化方法，最终完成初始化操作</li>
<li>初始化方法调用：Spring工厂进行调用</li>
</ol>
<ul>
<li><p>InitializingBean接口</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//程序员根据需求，实现的方法，完成初始化操作</span>
implements InitializingBean
  
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterProperitesSet</span><span class="hljs-params">()</span></span>&#123;
  
&#125;</code></pre></div></li>
<li><p>对象中提供一个普通的方法</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myInit</span><span class="hljs-params">()</span></span>&#123;
  
&#125;

&lt;bean id=<span class="hljs-string">&quot;product&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;xxx.Product&quot;</span> init-method=<span class="hljs-string">&quot;myInit&quot;</span>/&gt;</code></pre></div></li>
<li><p>细节分析</p>
<ul>
<li><p>如果一个对象即实现InitializingBean 同时又提供的 普通的初始化方法  顺序</p>
<ul>
<li>InitializingBean </li>
<li>普通初始化方法</li>
</ul>
</li>
<li><p><strong>注入一定发生在初始化操作的前面</strong></p>
<ul>
<li><p>什么叫做初始化操作</p>
<blockquote>
<p>资源的初始化：数据库 IO 网络 …..</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a><strong>销毁阶段</strong></h4><blockquote>
<p>Spring销毁对象前，会调用对象的销毁方法，完成销毁操作</p>
</blockquote>
<ol>
<li>Spring什么时候销毁所创建的对象？<br><code>ctx.close();</code></li>
<li>销毁方法：程序员根据自己的需求，定义销毁方法，完成销毁操作<br>   调用：Spring工厂完成调用</li>
</ol>
<ul>
<li><p>DisposableBean</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;
  
&#125;</code></pre></div></li>
<li><p>定义一个普通的销毁方法</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myDestroy</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;

&#125;
&lt;bean id=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;&quot;</span> init-method=<span class="hljs-string">&quot;&quot;</span> destroy-method=<span class="hljs-string">&quot;myDestroy&quot;</span>/&gt;</code></pre></div></li>
<li><p>细节分析</p>
<ul>
<li><p>销毁方法的操作只适用于<code> scope=&quot;singleton&quot;</code></p>
</li>
<li><p>什么叫做销毁操作</p>
<blockquote>
<p>主要指的就是 资源的释放操作  io.close()     connection.close();</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="2-配置文件参数化"><a href="#2-配置文件参数化" class="headerlink" title="2. 配置文件参数化"></a>2. 配置文件参数化</h2><blockquote>
<p>把Spring配置文件中需要经常修改的字符串信息，转移到一个更小的配置文件中</p>
</blockquote>
<ul>
<li>Spring的配置文件中存在需要经常修改的字符串？<br> 存在 以数据库连接相关的参数 代表</li>
<li>经常变化字符串，在Spring的配置文件中，直接修改<br> 不利于项目维护(修改)</li>
<li>转移到一个小的配置文件(.properties)<br> 利于维护(修改)</li>
</ul>
<p>配置文件参数化：利于Spring配置文件的维护(修改)</p>
<h3 id="配置文件参数的开发步骤"><a href="#配置文件参数的开发步骤" class="headerlink" title="配置文件参数的开发步骤"></a>配置文件参数的开发步骤</h3><p>提供一个小的配置文件<code>(.properities)</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">名字：随便</span>
<span class="hljs-attr">放置位置：随便</span>

<span class="hljs-meta">jdbc.driverClassName</span> = <span class="hljs-string">com.mysql.jdbc.Driver</span>
<span class="hljs-meta">jdbc.url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/suns?useSSL=false</span>
<span class="hljs-meta">jdbc.username</span> = <span class="hljs-string">root</span>
<span class="hljs-meta">jdbc.password</span> = <span class="hljs-string">123456</span></code></pre></div>

<p>Spring的配置文件与小配置文件进行整合</p>
<p><code>applicationContext.xml</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:/db.properties&quot;</span>/&gt;</span></code></pre></div>

<p>在Spring配置文件中通过<code>$&#123;key&#125;</code>获取小配置文件中对应的值<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200418171133796.png" srcset="/img/loading.gif" lazyload alt="image-20200418171133796"></p>
<h2 id="3-自定义类型转换器"><a href="#3-自定义类型转换器" class="headerlink" title="3. 自定义类型转换器"></a>3. 自定义类型转换器</h2><h3 id="3-1-类型转换器"><a href="#3-1-类型转换器" class="headerlink" title="3.1 类型转换器"></a>3.1 类型转换器</h3><blockquote>
<p>作用：Spring通过类型转换器把配置文件中字符串类型的数据，转换成了对象中成员变量对应类型的数据，进而完成了注入</p>
</blockquote>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200418201732220.png" srcset="/img/loading.gif" lazyload alt="image-20200418201732220"></p>
<h3 id="3-2-自定义类型转换器"><a href="#3-2-自定义类型转换器" class="headerlink" title="3.2 自定义类型转换器"></a>3.2 自定义类型转换器</h3><blockquote>
<p>原因：当Spring内部没有提供特定类型转换器时，而程序员在应用的过程中还需要使用，那么就需要程序员自己定义类型转换器</p>
</blockquote>
<p><strong>类 implements Converter接口</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;
   <span class="hljs-comment">/*</span>
<span class="hljs-comment">       convert方法作用：String ---&gt;  Date</span>
<span class="hljs-comment">                      SimpleDateFormat sdf = new SimpleDateFormat();</span>
<span class="hljs-comment">                      sdf.parset(String) ---&gt; Date</span>
<span class="hljs-comment">       param:source 代表的是配置文件中 日期字符串 &lt;value&gt;2020-10-11&lt;/value&gt;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">       return : 当把转换好的Date作为convert方法的返回值后，Spring自动的为birthday属性进行注入（赋值）</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">     */</span>

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String source)</span> </span>&#123;

    Date date = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;
      SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);
      date = sdf.parse(source);
    &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;
      e.printStackTrace();
    &#125;
    <span class="hljs-keyword">return</span> date;
  &#125;
&#125;</code></pre></div>

<p><strong>在Spring的配置文件中进行配置</strong></p>
<ul>
<li>MyDateConverter对象创建出来</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDateConverter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxxx.MyDateConverter&quot;</span>/&gt;</span></code></pre></div>

<ul>
<li><p>类型转换器的注册</p>
<p>目的：告知Spring框架，我们所创建的MyDateConverter是一个类型转换器</p>
</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--用于注册类型转换器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversionService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;converters&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;myDateConverter&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<h3 id="3-3-细节"><a href="#3-3-细节" class="headerlink" title="3.3 细节"></a>3.3 细节</h3><p>MyDateConverter中的日期的格式，通过依赖注入的方式，由配置文件完成赋值</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> String pattern;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPattern</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> pattern;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPattern</span><span class="hljs-params">(String pattern)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.pattern = pattern;
    &#125;

    <span class="hljs-comment">/*</span>
<span class="hljs-comment">       convert方法作用：String ---&gt;  Date</span>
<span class="hljs-comment">                      SimpleDateFormat sdf = new SimpleDateFormat();</span>
<span class="hljs-comment">                      sdf.parset(String) ---&gt; Date</span>
<span class="hljs-comment">       param:source 代表的是配置文件中 日期字符串 &lt;value&gt;2020-10-11&lt;/value&gt;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">       return : 当把转换好的Date作为convert方法的返回值后，Spring自动的为birthday属性进行注入（赋值）</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">     */</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String source)</span> </span>&#123;

        Date date = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(pattern);
            date = sdf.parse(source);
        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> date;
    &#125;
&#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Spring创建MyDateConverter类型对象--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDateConverter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.converter.MyDateConverter&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p><code>ConversionSeviceFactoryBean </code><strong>定义 id属性 值必须</strong> <code>conversionService </code></p>
<p>Spring框架内置日期类型的转换器</p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown">日期格式：2020/05/01 (不支持 ：2020-05-01)</code></pre></div>

<h2 id="4-后置处理Bean"><a href="#4-后置处理Bean" class="headerlink" title="4. 后置处理Bean"></a>4. 后置处理Bean</h2><blockquote>
<p>BeanPostProcessor作用：对Spring工厂所创建的对象，进行再加工</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs markdown">AOP底层实现：
注意：BeanPostProcessor接口
<span class="hljs-code">          xxxx()&#123;</span>
<span class="hljs-code">                 </span>
<span class="hljs-code">          &#125;</span></code></pre></div>

<p><strong>后置处理Bean的运行原理分析</strong><br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200420155053027.png" srcset="/img/loading.gif" lazyload alt="image-20200420155053027"></p>
<p>程序员实现BeanPostProcessor规定接口中的方法：</p>
<ul>
<li><p><code>Object postProcessBeforeInitiallization(Object bean String beanName)</code><br>作用：Spring创建完对象，并进行注入后，可以运行Before方法进行加工<br>获得Spring创建好的对象 ：通过方法的参数<br>最终通过返回值交给Spring框架 </p>
</li>
<li><p><code>Object postProcessAfterInitiallization(Object bean String beanName)</code><br>作用：Spring执行完对象的初始化操作后，可以运行After方法进行加工<br>获得Spring创建好的对象 ：通过方法的参数<br>最终通过返回值交给Spring框架 </p>
</li>
</ul>
<p>实战中：</p>
<ul>
<li><strong>很少处理Spring的初始化操作</strong>：没有必要区分Before After。<strong>只需要实现其中的一个After方法</strong>即可<br>注意：<div class="hljs code-wrapper"><pre><code>`postProcessBeforeInitiallization`
`return bean`对象
</code></pre></div>
</li>
</ul>
<p><strong>BeanPostProcessor的开发步骤</strong></p>
<ul>
<li>类 实现 BeanPostProcessor接口</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;
        <span class="hljs-keyword">return</span> bean;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;

        Categroy categroy = (Categroy) bean;
        categroy.setName(<span class="hljs-string">&quot;xiaowb&quot;</span>);


        <span class="hljs-keyword">return</span> categroy;
    &#125;
&#125;</code></pre></div>

<ul>
<li>Spring的配置文件中进行配置</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBeanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx.MyBeanPostProcessor&quot;</span>/&gt;</span></code></pre></div>

<ul>
<li>BeanPostProcessor细节</li>
</ul>
<p> BeanPostProcessor会对Spring工厂中所有创建的对象进行加工，如果工厂创建了多个不同的对象，要注意区别传入的对象：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;
    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span>  Category) &#123;
        Category category = (Category) bean;
        category.setName(<span class="hljs-string">&quot;xwb&quot;</span>);
        <span class="hljs-keyword">return</span> category;
    &#125;
    <span class="hljs-keyword">return</span> bean;
&#125;</code></pre></div>

<h1 id="第三章、Spring-AOP"><a href="#第三章、Spring-AOP" class="headerlink" title="第三章、Spring AOP"></a>第三章、Spring AOP</h1><h2 id="1-静态代理设计模式"><a href="#1-静态代理设计模式" class="headerlink" title="1. 静态代理设计模式"></a>1. 静态代理设计模式</h2><h3 id="1-1-为什么需要代理设计模式"><a href="#1-1-为什么需要代理设计模式" class="headerlink" title="1.1 为什么需要代理设计模式"></a>1.1 为什么需要代理设计模式</h3><p>在JavaEE分层开发开发中，那个层次对于我们来讲最重要?</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">DAO</span> <span class="hljs-string">---&gt; Service --&gt; Controller </span>

<span class="hljs-attr">JavaEE分层开发中，最为重要的是Service层</span></code></pre></div>

<p>Service 层中包含了哪些代码？</p>
<ul>
<li><strong>核心功能</strong>（代码量较多）：业务运算，DAO 调用</li>
<li><strong>额外功能</strong>（附加功能，不属于业务，可有可无，代码量小）：事务、日志、性能 …</li>
</ul>
<p>额外功能书写在 Service 层好不好?</p>
<ul>
<li>Service 层的调用者的角度（Controller)：需要在 Service 层书写额外功能</li>
<li>软件设计者：Service 层不需要额外功能</li>
</ul>
<p> 拿现实生活中的例子来做对比，解决方案是 <strong>引入一个代理</strong><br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200422110206172.png" srcset="/img/loading.gif" lazyload alt="image-20200422110206172"></p>
<h3 id="1-2-代理设计模式"><a href="#1-2-代理设计模式" class="headerlink" title="1.2 代理设计模式"></a>1.2 代理设计模式</h3><h4 id="1-2-1-概念"><a href="#1-2-1-概念" class="headerlink" title="1.2.1 概念"></a>1.2.1 概念</h4><blockquote>
<p>通过代理类，为原始类（目标）增加额外的功能<br>好处：利于原始类(目标)的维护</p>
</blockquote>
<h4 id="1-2-2-名词解释"><a href="#1-2-2-名词解释" class="headerlink" title="1.2.2 名词解释"></a>1.2.2 名词解释</h4><p><strong>目标类 / 原始类</strong>：指的是 <strong>业务类</strong> (核心功能 –&gt; 业务运算、DAO调用)<br><strong>目标方法 / 原始方法</strong>：目标类（原始类）中的方法就是目标方法（原始方法）<br><strong>额外功能 / 附加功能</strong>：日志、事务、性能 …</p>
<h4 id="1-2-3-代理开发的核心要素"><a href="#1-2-3-代理开发的核心要素" class="headerlink" title="1.2.3 代理开发的核心要素"></a>1.2.3 代理开发的核心要素</h4><div class="hljs code-wrapper"><pre><code class="hljs java">代理类 = 目标类(原始类) + 额外功能 + 原始类(目标类)实现相同的接口

房东 ---&gt; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span></span>&#123;
               m1
               m2
          &#125;
          UserServiceImpl implements UserService&#123;
               m1 ---&gt; 业务运算 DAO调用
               m2 
          &#125;
中介 --- 代理类：要实现目标类相同的接口
          UserServiceProxy implements UserService
               m1
               m2</code></pre></div>

<h4 id="1-2-4-编码"><a href="#1-2-4-编码" class="headerlink" title="1.2.4 编码"></a>1.2.4 编码</h4><p><strong>静态代理</strong>：为每一个原始类，手工编写一个代理类 (.java .class)</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span></span>;
	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.register 业务运算 + DAO&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.login 业务运算 + DAO&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre></div>

<p><strong>代理类中必须有原始类</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200422114654195.png" srcset="/img/loading.gif" lazyload alt="image-20200422114654195"></p>
<h4 id="1-2-5-静态代理存在的问题"><a href="#1-2-5-静态代理存在的问题" class="headerlink" title="1.2.5 静态代理存在的问题"></a>1.2.5 静态代理存在的问题</h4><ul>
<li><strong>静态类文件数量过多，不利于项目管理</strong><br><code>UserServiceImpl</code>、<code>UserServiceProxy</code><br><code>OrderServiceImpl</code>、<code>OrderServiceProxy</code><br>…</li>
<li><strong>额外功能维护性差</strong>：在代理类中修改额外功能较为麻烦</li>
</ul>
<h2 id="2-Spring的动态代理开发"><a href="#2-Spring的动态代理开发" class="headerlink" title="2. Spring的动态代理开发"></a>2. Spring的动态代理开发</h2><h3 id="2-1-Spring动态代理的概念"><a href="#2-1-Spring动态代理的概念" class="headerlink" title="2.1 Spring动态代理的概念"></a>2.1 Spring动态代理的概念</h3><blockquote>
<p>概念：通过代理类为原始类(目标类)增加额外功能<br>好处：利于原始类(目标类)的维护</p>
</blockquote>
<h3 id="2-2-搭建开发环境"><a href="#2-2-搭建开发环境" class="headerlink" title="2.2 搭建开发环境"></a>2.2 搭建开发环境</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjrt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h3 id="2-3-Spring动态代理的开发步骤"><a href="#2-3-Spring动态代理的开发步骤" class="headerlink" title="2.3 Spring动态代理的开发步骤"></a>2.3 Spring动态代理的开发步骤</h3><ul>
<li>创建原始对象(目标对象)</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span></span>;
&#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.register 业务运算 + DAO&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.login 业务运算 + DAO&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.proxy.UserServiceImpl&quot;</span>/&gt;</span></code></pre></div>

<ul>
<li>额外功能<br>MethodBeforeAdvice接口</li>
</ul>
<p>额外的功能书写在接口的实现中，运行在原始方法执行之前运行额外功能</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Before</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 作用: 把需要运行在原始方法执行之前运行的额外功能, 书写在 before 方法中</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        System.out.println(<span class="hljs-string">&quot;---method before advice log---&quot;</span>);
    &#125;
&#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.dynamic.Before&quot;</span>/&gt;</span></code></pre></div>

<ul>
<li>定义切入点</li>
</ul>
<blockquote>
<p>切入点：额外功能加入的位置</p>
<p>目的：由程序员根据自己的需要，决定额外功能加入给那个原始方法register、login</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 简单的测试：所有方法都做为切入点，都加入额外的功能 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>   
  <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *(..))&quot;</span>/&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></div>

<ul>
<li>组装 (2 3整合)</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/aop</span></span>
<span class="hljs-tag"><span class="hljs-string">                           https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.aop.UserServiceImpl&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!-- 额外功能 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.aop.Before&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--切入点:额外功能的加入--&gt;</span>
    <span class="hljs-comment">&lt;!--⽬的：由程序员根据⾃⼰的需要，决定额外功能加入给哪个原始方法(register、login)--&gt;</span>
   <span class="hljs-comment">&lt;!-- 简单的测试：所有方法都做为切入点，都加入额外的功能--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* * (..))&quot;</span>/&gt;</span>
        <span class="hljs-comment">&lt;!--表达的含义: 所有的方法 都加入before的额外功能--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pc&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<ul>
<li>调用</li>
</ul>
<p>目的：获得 Spring 工厂创建的动态代理对象，并进行调用<br>注意： </p>
<ol>
<li>Spring 的工厂通过原始对象的 id 值获得的是代理对象</li>
<li>获得代理对象后，可以通过声明接口类型，进行对象的存储</li>
</ol>
<div class="hljs code-wrapper"><pre><code class="hljs java">目的：获得Spring工厂创建的动态代理对象，并进行调用
  ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);
注意：   
  <span class="hljs-number">1.</span> Spring的工厂通过原始对象的id值获得的是代理对象   
  <span class="hljs-number">2.</span> 获得代理对象后，可以通过声明接口类型，进行对象的存储   
  UserService userService=(UserService)ctx.getBean(<span class="hljs-string">&quot;userService&quot;</span>);
	userService.login(<span class="hljs-string">&quot;&quot;</span>);
	userService.register()</code></pre></div>

<h3 id="2-4-动态代理细节分析"><a href="#2-4-动态代理细节分析" class="headerlink" title="2.4 动态代理细节分析"></a>2.4 动态代理细节分析</h3><ul>
<li><strong>Spring创建的动态代理类在哪里？</strong></li>
</ul>
<blockquote>
<p>Spring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失</p>
<p>什么叫动态字节码技术:通过第三方动态字节码框架，在JVM中创建对应类的字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失</p>
<p>结论：动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理，类文件数量过多，影响项目管理的问题</p>
</blockquote>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200423165547079.png" srcset="/img/loading.gif" lazyload alt="image-20200423165547079"></p>
<ul>
<li><strong>动态代理编程简化代理的开发</strong></li>
</ul>
<blockquote>
<p>在额外功能不改变的前提下，创建其他目标类（原始类）的代理对象时，只需要指定原始(目标)对象即可</p>
</blockquote>
<ul>
<li>动态代理额外功能的维护性大大增强</li>
</ul>
<h2 id="3-Spring动态代理详解"><a href="#3-Spring动态代理详解" class="headerlink" title="3. Spring动态代理详解"></a>3. Spring动态代理详解</h2><h3 id="3-1-额外功能的详解"><a href="#3-1-额外功能的详解" class="headerlink" title="3.1 额外功能的详解"></a>3.1 额外功能的详解</h3><ul>
<li><p>MethodBeforeAdvice分析</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Before</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 作用: 把需要运行在原始方法执行之前运行的额外功能, 书写在 before 方法中</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * Method: 额外功能所增加给的那个原始方法</span>
<span class="hljs-comment">     *                          login</span>
<span class="hljs-comment">     *                          register</span>
<span class="hljs-comment">     *                          --------</span>
<span class="hljs-comment">     *                          showOrder</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * Object[]:  额外功能所增加给的那个原始方法的参数</span>
<span class="hljs-comment">     *                          String name,String password</span>
<span class="hljs-comment">     *                          User</span>
<span class="hljs-comment">     *                          --------</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * Object: 额外功能所增加给的那个原始对象</span>
<span class="hljs-comment">     *                          UserServiceImpl</span>
<span class="hljs-comment">     *                          ---------------</span>
<span class="hljs-comment">     *                          OrderServiceImpl</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        System.out.println(<span class="hljs-string">&quot;---new method before advice log---&quot;</span>);
    &#125;
&#125;</code></pre></div></li>
<li><p>MethodInterceptor(方法拦截器)</p>
<blockquote>
<p>methodinterceptor接口：额外功能可以根据需要运行在原始方法执行 前、后、前后</p>
</blockquote>
<ul>
<li>参数：<code>MethodInvocation</code>：额外功能所增加给的那个原始方法 (login, register)</li>
<li>返回值：<code>Object</code>：原始方法的返回值 (没有就返回 null)</li>
<li><code>invocation.proceed()</code>：原始方法运行</li>
</ul>
<p>额外功能运行在原始方法 <strong>之前</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Around</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        System.out.println(<span class="hljs-string">&quot;---额外功能运行在原始方法执行之前---&quot;</span>);
        Object ret = methodInvocation.proceed(); <span class="hljs-comment">// 原始方法运行, 获取原始方法的返回值</span>
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre></div>

<p>额外功能运行在原始方法执行 <strong>之后</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Around</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        Object ret = methodInvocation.proceed(); <span class="hljs-comment">// 原始方法运行, 获取原始方法的返回值</span>
        System.out.println(<span class="hljs-string">&quot;---额外功能运行在原始方法执行之后---&quot;</span>);
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre></div>

<p>额外功能运行在原始方法执行 <strong>之前，之后</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//常用于事务</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Around</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
    	System.out.println(<span class="hljs-string">&quot;---额外功能运行在原始方法执行之前---&quot;</span>);
        Object ret = methodInvocation.proceed(); <span class="hljs-comment">// 原始方法运行, 获取原始方法的返回值</span>
        System.out.println(<span class="hljs-string">&quot;---额外功能运行在原始方法执行之后---&quot;</span>);
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre></div>

<p>额外功能运行在原始方法抛出异常的时候</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Around</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        Object ret = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            ret = methodInvocation.proceed(); <span class="hljs-comment">// 原始方法运行, 获取原始方法的返回值</span>
        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;
            System.out.println(<span class="hljs-string">&quot;---额外功能运行在原始方法抛异常的时候---&quot;</span>);
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre></div>

<p>MethodInterceptor影响原始方法的返回值</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Around</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        System.out.println(<span class="hljs-string">&quot;---log---&quot;</span>);
        Object ret = methodInvocation.proceed();
      	<span class="hljs-comment">//原始方法返回为true，这里设为false会影响</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
&#125;</code></pre></div></li>
</ul>
<h3 id="3-2-切入点详解"><a href="#3-2-切入点详解" class="headerlink" title="3.2 切入点详解"></a>3.2 切入点详解</h3><p>切入点决定额外功能加入位置（方法）</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--execution(* * (..)) 匹配了所有方法--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* * (..))&quot;</span>/&gt;</span></code></pre></div>

<ul>
<li><code>execution()</code>：<strong>切入点函数</strong></li>
<li><code>* *(..)</code>：<strong>切入点表达式</strong></li>
</ul>
<h4 id="3-2-1-切入点表达式"><a href="#3-2-1-切入点表达式" class="headerlink" title="3.2.1 切入点表达式"></a>3.2.1 切入点表达式</h4><p>方法切入点表达式<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200425105040237.png" srcset="/img/loading.gif" lazyload alt="image-20200425105040237"></p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> <span class="hljs-emphasis">* (..)    --&gt; 所有方法</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">*</span>  ---&gt;  修饰符 返回值
<span class="hljs-bullet">*</span>  ---&gt;  方法名
() ---&gt;  参数表
.. ---&gt;  对于参数没有要求 (参数有没有，参数有⼏个都行，参数是什么类型的都行)</code></pre></div>

<ul>
<li><p>定义login方法作为切入点</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 定义login作为切入点 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login (..))&quot;</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 定义register作为切入点 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* register (..))&quot;</span>/&gt;</span></code></pre></div></li>
<li><p>定义login方法且login方法有两个字符串类型的参数 作为切入点</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login (String,String))&quot;</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- ⾮ java.lang java.lang 包中的类型, 必须要写全限定名 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* register (com.yusael.proxy.User))&quot;</span>/&gt;</span>

<span class="hljs-comment">&lt;!--  ..可以和具体的参数类型连用 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login(String, ..))&quot;</span>/&gt;</span>
<span class="hljs-comment">&lt;!-- === login(String), login(String,String), login(String,com.baizhi.edu.proxy.User) --&gt;</span></code></pre></div></li>
</ul>
<p>上诉表达式的切入点不够精准</p>
<p><strong>精准方法切入点限定</strong></p>
<p>修饰符 返回值         包.类.方法(参数)    *   </p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy.UserServiceImpl.login(..))&quot;</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy.UserServiceImpl.login(String, String))&quot;</span>/&gt;</span></code></pre></div>

<p><strong>类切入点</strong></p>
<blockquote>
<p>指定 **特定类作为切入点(额外功能加入的位置)**，这个类中的所有方法，都会加上对应的额外功能</p>
</blockquote>
<ul>
<li><p>语法1</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"># 类中所有的方法加入了额外功能
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy.UserServiceImpl.*(..))&quot;</span>/&gt;</span></code></pre></div></li>
<li><p>语法2 </p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"># 忽略包
1. 类只存在一级包
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *.UserServiceImpl.*(..))&quot;</span>/&gt;</span>
2. 类存在多级包
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *..UserServiceImpl.*(..))&quot;</span>/&gt;</span></code></pre></div></li>
</ul>
<p><strong>包切入点表达式（实战用的多）</strong></p>
<blockquote>
<p>指定包作为额外功能加入的位置，自然包中的所有类及其方法都会加入额外的功能</p>
</blockquote>
<ul>
<li><p>语法1</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"># 切入点包中的所有类，必须在proxy中，不能在proxy包的⼦包中
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy.*.*(..))&quot;</span>/&gt;</span></code></pre></div></li>
<li><p>语法2</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"># 切入点当前包及其⼦包都生效
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy..*.*(..))&quot;</span>/&gt;</span></code></pre></div></li>
</ul>
<h4 id="3-2-2-切入点函数"><a href="#3-2-2-切入点函数" class="headerlink" title="3.2.2 切入点函数"></a>3.2.2 切入点函数</h4><blockquote>
<p>切入点函数：用于执行切入点表达式</p>
</blockquote>
<ul>
<li>execution</li>
</ul>
<p><code>execution</code> 是最为重要的切入点函数，功能最全；可以执行执行 <strong>方法切入点表达式</strong>、<strong>类切入点表达式</strong>、<strong>包切入点表达式</strong><br>弊端：<code>execution</code> 执⾏切入点表达式 ，书写麻烦</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">execution(* com.yusael.proxy..*.*(..))</code></pre></div>

<p>注意：其他的 切入点函数 简化的是 <code>execution</code> 的书写复杂度，功能上完全⼀致</p>
<ul>
<li>args</li>
</ul>
<p><code>args</code> 作用：主要用于 <strong>函数(方法) 参数的匹配</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">切入点：方法参数必须得是 2 个字符串类型的参数

# 使用 execution
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *(String, String))&quot;</span>/&gt;</span>

# 使用 args
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;args(String, String)&quot;</span>/&gt;</span></code></pre></div>

<ul>
<li>within</li>
</ul>
<p><code>within</code> 作用：主要用于进行 <strong>类、包切入点表达式</strong> 的匹配</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">切入点: UserServiceImpl 这个类

# 使用 execution
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;expression(* *..UserServiceImpl.*(..))&quot;</span>/&gt;</span>

# 使用 within
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;within(*..UserServiceImpl)&quot;</span>/&gt;</span>

切入点: com.yusael.proxy 这个包

# 使用 execution
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.proxy..*.*(..)&quot;</span>/&gt;</span>

# 使用 within
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;within(com.yusael.proxy..*)&quot;</span>/&gt;</span></code></pre></div>

<ul>
<li>@annotation</li>
</ul>
<p>作用：为具有特殊注解的 <strong>方法</strong> 加入额外功能。</p>
<p>例如我们自定义了一个注解：<code>Log</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Log &#123;
&#125;</code></pre></div>

<p>然后我们要为使用了 <code>Log</code> 注解的方法加入额外功能</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;@annotation(com.yusael.Log)&quot;</span>/&gt;</span></code></pre></div>

<p><strong>切入点函数的逻辑运算</strong></p>
<blockquote>
<p>指的是 整合多个切入点函数一起配合工作，进而完成更为复杂的需求</p>
</blockquote>
<ul>
<li><p>and与操作</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">案例: 方法名叫 login 同时 参数是 2个字符串
# execution
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login(String, String))&quot;</span>/&gt;</span>
# execution and args
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login(..)) and args(String, String))&quot;</span>/&gt;</span></code></pre></div></li>
<li><p>or或操作</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">案例: 方法名叫 register 或 login 的⽅法作为切⼊点
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* login(..)) or execution(* register(..))&quot;</span>/&gt;</span></code></pre></div></li>
</ul>
<h2 id="4-AOP编程"><a href="#4-AOP编程" class="headerlink" title="4. AOP编程"></a>4. AOP编程</h2><h3 id="4-1-AOP概念"><a href="#4-1-AOP概念" class="headerlink" title="4.1 AOP概念"></a>4.1 AOP概念</h3><blockquote>
<p>POP (Producer Oriented Programing）</p>
<ul>
<li>面向过程（方法、函数）编程 —— C</li>
<li>以过程为基本单位的程序开发，通过过程间的彼此协同，相互调用，完成程序的构建</li>
</ul>
<p>OOP (Object Oritened Programing)</p>
<ul>
<li>面向对象编程 —— Java</li>
<li>以对象为基本单位的程序开发，通过对象间的彼此协同，相互调用，完成程序的构建</li>
</ul>
<p>AOP (Aspect Oriented Programing)</p>
<ul>
<li>面向切面编程 = Spring动态代理开发</li>
<li>以切面为基本单位的程序开发，通过切面间的彼此协同，相互调用，完成程序的构建</li>
<li>切面 = 切入点 + 额外功能</li>
</ul>
</blockquote>
<ul>
<li>本质就是 Spring 的动态代理开发，通过代理类为原始类增加额外功能</li>
<li>好处：利于原始类的维护</li>
<li>注意：AOP 编程不可能取代 OOP，AOP 是 OOP 编程的补充</li>
</ul>
<h3 id="4-2-AOP编程的开发步骤"><a href="#4-2-AOP编程的开发步骤" class="headerlink" title="4.2 AOP编程的开发步骤"></a>4.2 AOP编程的开发步骤</h3><ol>
<li>原始对象</li>
<li>额外功能 (<code>MethodInterceptor</code>)</li>
<li>切入点</li>
<li>组装切面 (额外功能+切入点)</li>
</ol>
<h3 id="4-3-切面的名词解释"><a href="#4-3-切面的名词解释" class="headerlink" title="4.3 切面的名词解释"></a>4.3 切面的名词解释</h3><p>切面 = 切入点 + 额外功能 几何学<br>面 = 点 + 相同的性质</p>
<p><strong>由各个类具有的相同额外功能，构成了一个切面</strong></p>
<p><strong>不同的额外功能，构成了多个切面</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200427134740273.png" srcset="/img/loading.gif" lazyload alt="image-20200427134740273"></p>
<h2 id="5-AOP的底层实现原理"><a href="#5-AOP的底层实现原理" class="headerlink" title="5. AOP的底层实现原理"></a>5. AOP的底层实现原理</h2><h3 id="5-1-核心问题"><a href="#5-1-核心问题" class="headerlink" title="5.1 核心问题"></a>5.1 核心问题</h3><ul>
<li>AOP 如何创建动态代理类？<br><strong>动态字节码技术</strong></li>
<li>Spring 工厂如何加工创建代理对象？<br><strong>通过原始对象的 id 值，获得的是代理对象</strong></li>
</ul>
<h3 id="5-2-动态代理类的创建（重点）"><a href="#5-2-动态代理类的创建（重点）" class="headerlink" title="5.2 动态代理类的创建（重点）"></a>5.2 动态代理类的创建（重点）</h3><h4 id="5-2-1-JDK的动态代理"><a href="#5-2-1-JDK的动态代理" class="headerlink" title="5.2.1 JDK的动态代理"></a>5.2.1 JDK的动态代理</h4><ul>
<li><code>Proxy.newProxyInstance</code>方法参数详解<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200428175248912.png" srcset="/img/loading.gif" lazyload alt="image-20200428175248912"></li>
</ul>
<p><strong>类加载器</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200428175316276.png" srcset="/img/loading.gif" lazyload alt="image-20200428175316276"></p>
<ul>
<li><p>编码</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJDKProxy</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以</span>
<span class="hljs-comment">     2. JDK8.x 前必须加 final</span>
<span class="hljs-comment">     final UserService userService = new UserServiceImpl();</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 1. 创建原始对象</span>
        UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();

        <span class="hljs-comment">// 2. JDK 动态代理</span>
        InvocationHandler handler = <span class="hljs-keyword">new</span> InvocationHandler() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
                System.out.println(<span class="hljs-string">&quot;---- proxy log ----&quot;</span>);
                <span class="hljs-comment">// 原始方法运行</span>
                Object ret = method.invoke(userService, args);
                <span class="hljs-keyword">return</span> ret;
            &#125;
        &#125;;
        <span class="hljs-comment">//借用ClassLoader</span>
        UserService userServiceProxy = (UserService) Proxy.
                newProxyInstance(TestJDKProxy.class.getClassLoader(),
                                userService.getClass().getInterfaces(),
                                handler);
        userServiceProxy.login(<span class="hljs-string">&quot;luci&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);

        userServiceProxy.register(<span class="hljs-keyword">new</span> User());
    &#125;
&#125;</code></pre></div></li>
</ul>
<h4 id="5-2-2-CGlib的动态代理"><a href="#5-2-2-CGlib的动态代理" class="headerlink" title="5.2.2 CGlib的动态代理"></a>5.2.2 CGlib的动态代理</h4><blockquote>
<p>CGlib创建动态代理的原理：父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证2者方法一致，同时在代理类中提供新的实现(额外功能+原始方法)</p>
</blockquote>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200429111709226.png" srcset="/img/loading.gif" lazyload alt="image-20200429111709226"></p>
<ul>
<li><p>CGlib编码 </p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCglib</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 1. 创建原始对象</span>
        UserService userService = <span class="hljs-keyword">new</span> UserService();

        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         2. 通过 cglib 方式创建动态代理对象</span>
<span class="hljs-comment">         对比 jdk 动态代理 ---&gt; Proxy.newProxyInstance(classLoader, interface, invocationHandler);</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">         Enhancer.setClassLoader()</span>
<span class="hljs-comment">         Enhancer.setSuperClass()</span>
<span class="hljs-comment">         Enhancer.setCallBack() ---&gt; MethodInterceptor(cglib)</span>
<span class="hljs-comment">         Enhancer.createProxy() ---&gt; 创建代理对象</span>
<span class="hljs-comment">         */</span>
        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();

        enhancer.setClassLoader(TestCglib.class.getClassLoader());
        enhancer.setSuperclass(userService.getClass());

        MethodInterceptor interceptor = <span class="hljs-keyword">new</span> MethodInterceptor() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
                System.out.println(<span class="hljs-string">&quot;--- cglib log ----&quot;</span>);
                Object ret = method.invoke(userService, args); <span class="hljs-comment">// 执行原始方法</span>
                <span class="hljs-keyword">return</span> ret;
            &#125;
        &#125;;
				<span class="hljs-comment">//额外功能</span>
        enhancer.setCallback(interceptor);
      	<span class="hljs-comment">//创建代理</span>
        UserService userServiceProxy = (UserService) enhancer.create();
        userServiceProxy.login(<span class="hljs-string">&quot;zhenyu&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);
        userServiceProxy.register(<span class="hljs-keyword">new</span> User());
    &#125;
&#125;</code></pre></div></li>
<li><p>总结</p>
<ol>
<li>JDK 动态代理<br><code>Proxy.newProxyInstance</code>：通过接口创建代理的实现类</li>
<li>Cglib 动态代理<br><code>Enhancer</code>：通过继承⽗类创建的代理类</li>
</ol>
</li>
</ul>
<h3 id="5-3-Spring工厂如何加工原始对象"><a href="#5-3-Spring工厂如何加工原始对象" class="headerlink" title="5.3 Spring工厂如何加工原始对象"></a>5.3 Spring工厂如何加工原始对象</h3><ul>
<li><p>思路分析：主要通过 <code>BeanPostProcessor</code> 将原始对象加工为代理对象<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200430113353205.png" srcset="/img/loading.gif" lazyload alt="image-20200430113353205"></p>
</li>
<li><p>编码</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;
        <span class="hljs-keyword">return</span> bean;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;

        InvocationHandler handler = <span class="hljs-keyword">new</span> InvocationHandler() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
                System.out.println(<span class="hljs-string">&quot;--- new log ---&quot;</span>);
                Object ret = method.invoke(bean, args);
                <span class="hljs-keyword">return</span> ret;
            &#125;
        &#125;;
        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(ProxyBeanPostProcessor.class.getClassLoader(), bean.getClass().getInterfaces(), handler);
    &#125;
&#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.factory.UserServiceImpl&quot;</span>/&gt;</span>
<span class="hljs-comment">&lt;!--1. 实现 BeanPostProcessor 进行加工--&gt;</span>
<span class="hljs-comment">&lt;!--2. 配置文件中对 BeanPostProcessor 进行配置--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;proxyBeanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.factory.ProxyBeanPostProcessor&quot;</span>/&gt;</span></code></pre></div></li>
</ul>
<h2 id="6-基于注解的AOP编程"><a href="#6-基于注解的AOP编程" class="headerlink" title="6. 基于注解的AOP编程"></a>6. 基于注解的AOP编程</h2><h3 id="6-1-基于注解的AOP编程的开发步骤"><a href="#6-1-基于注解的AOP编程的开发步骤" class="headerlink" title="6.1 基于注解的AOP编程的开发步骤"></a>6.1 基于注解的AOP编程的开发步骤</h3><ul>
<li>原始对象</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.register 业务运算 + DAO&quot;</span>);
        <span class="hljs-comment">// throw new RuntimeException(&quot;测试异常&quot;);</span>
    &#125;

    <span class="hljs-meta">@Log</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.login 业务运算 + DAO&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre></div>

<ul>
<li><p>额外功能</p>
</li>
<li><p>切入点</p>
</li>
<li><p>组装切面</p>
 <div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span>
<span class="hljs-comment">    1. 额外功能</span>
<span class="hljs-comment">        public class MyAround implements MethodInterceptor &#123;</span>
<span class="hljs-comment">            public Object invoke(MethodInvocation invocation) &#123;</span>
<span class="hljs-comment">                Object ret = invocation.invoke();</span>
<span class="hljs-comment">                return ret;</span>
<span class="hljs-comment">            &#125;</span>
<span class="hljs-comment">        &#125;</span>
<span class="hljs-comment">        &lt;bean id=&quot;around&quot; class=&quot;com.yusael.dynamic.Around&quot;/&gt;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">    2. 切入点</span>
<span class="hljs-comment">        &lt;aop:config&gt;</span>
<span class="hljs-comment">            &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* login(..)))&quot;/&gt;</span>
<span class="hljs-comment">            &lt;aop:advisor advice-ref=&quot;around&quot; pointcut-ref=&quot;pc&quot;/&gt;</span>
<span class="hljs-comment">        &lt;/aop:config&gt;</span>
<span class="hljs-comment"> */</span>

<span class="hljs-comment">//通过切面类定义了额外功能 @Around </span>
<span class="hljs-comment">//切入点 @Around(&quot;execution(* login(..))&quot;)</span>
<span class="hljs-comment">//切面类 @Aspect</span>

<span class="hljs-meta">@Aspect</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;
    <span class="hljs-meta">@Around(&quot;execution(* login(..))&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        System.out.println(<span class="hljs-string">&quot;---- aspect log ----&quot;</span>);
        Object ret = joinPoint.proceed();
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre></div>

 <div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.aspect.UserServiceImpl&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">        切面:</span>
<span class="hljs-comment">            1. 额外功能</span>
<span class="hljs-comment">            2. 切入点啊</span>
<span class="hljs-comment">            3. 组装切面</span>
<span class="hljs-comment">    --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;around&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.aspect.MyAspect&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--告知 Spring 基于注解进行 AOP 编程--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div></li>
</ul>
<h3 id="6-2-细节"><a href="#6-2-细节" class="headerlink" title="6.2 细节"></a>6.2 细节</h3><p><strong>切入点复用</strong>：在切面类中定义⼀个函数，上面用 <code>@Pointcut</code> 注解<br>通过这种方式定义切入点表达式，后续更加有利于切入点复用</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;

    <span class="hljs-meta">@Pointcut(&quot;execution(* login(..))&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myPoincut</span><span class="hljs-params">()</span> </span>&#123;&#125;

    <span class="hljs-meta">@Around(value = &quot;myPoincut()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        System.out.println(<span class="hljs-string">&quot;---- aspect log ----&quot;</span>);
        Object ret = joinPoint.proceed();
        <span class="hljs-keyword">return</span> ret;
    &#125;
    <span class="hljs-meta">@Around(value = &quot;myPoincut()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around1</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        System.out.println(<span class="hljs-string">&quot;---- aspect transaction ----&quot;</span>);
        Object ret = joinPoint.proceed();
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre></div>

<p><strong>动态代理的创建方式</strong> </p>
<p>AOP 底层实现 2 种代理创建方式：</p>
<ol>
<li>JDK：通过 <strong>实现接口，做新的实现类</strong> 创建代理对象</li>
<li>Cglib：通过 <strong>继承父类，做新的子类</strong> 创建代理对象</li>
</ol>
<p><strong>默认情况 AOP 编程 底层应用 JDK动态代理创建方式</strong>。</p>
<p>基于注解的 AOP 开发 中切换为 Cglib：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></code></pre></div>

<p>传统的 AOP 开发 中切换为 Cglib：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
	...
<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></div>

<h2 id="7-AOP开发中的一个坑"><a href="#7-AOP开发中的一个坑" class="headerlink" title="7. AOP开发中的一个坑"></a>7. AOP开发中的一个坑</h2><p><strong>坑！</strong>：在同⼀个业务类中，进⾏业务方法间的相互调用，只有最外层的方法，才是加入了额外功能(内部的方法，通过普通的方式调用，都调用的是原始方法)。如果想让内层的方法也调用代理对象的方法，就要实现 <code>AppicationContextAware</code> 获得⼯厂，进而获得代理对象</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span>, <span class="hljs-title">ApplicationContextAware</span> </span>&#123;
    <span class="hljs-keyword">private</span> ApplicationContext ctx;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;
        <span class="hljs-keyword">this</span>.ctx = applicationContext;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.register 业务运算 + DAO&quot;</span>);

        <span class="hljs-comment">// this.login(&quot;zhenyu&quot;, &quot;123456&quot;); // 这么写调用的是本类的 login 方法, 即原始对象的 login 方法</span>
        <span class="hljs-comment">// 为什么不在这里创建一个工厂获取代理对象呢？</span>
        <span class="hljs-comment">// Spring的工厂是重量级资源, 一个应用中应该只创建一个工厂.</span>
        <span class="hljs-comment">// 因此我们必须通过 ApplicationContextAware 拿到已经创建好的工厂</span>
        UserService userService = (UserService) ctx.getBean(<span class="hljs-string">&quot;userService&quot;</span>);
        userService.login(<span class="hljs-string">&quot;yusael&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String name, String password)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;UserServiceImpl.login 业务运算 + DAO&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre></div>

<h2 id="8-AOP阶段知识总结"><a href="#8-AOP阶段知识总结" class="headerlink" title="8. AOP阶段知识总结"></a>8. AOP阶段知识总结</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200503162625116.png" srcset="/img/loading.gif" lazyload alt="image-20200503162625116"></p>
<h1 id="第四章、Spring持久层"><a href="#第四章、Spring持久层" class="headerlink" title="第四章、Spring持久层"></a>第四章、Spring持久层</h1><hr>
<h2 id="1-持久层整合"><a href="#1-持久层整合" class="headerlink" title="1. 持久层整合"></a>1. 持久层整合</h2><h3 id="1-1Spring框架为什么要与持久层技术进行整合"><a href="#1-1Spring框架为什么要与持久层技术进行整合" class="headerlink" title="1.1Spring框架为什么要与持久层技术进行整合"></a>1.1Spring框架为什么要与持久层技术进行整合</h3><ul>
<li>JavaEE开发需要持久层进行数据库的访问操作</li>
<li>JDBC、Hibernate、MyBatis 进行持久开发过程存在大量的代码冗余</li>
<li>Spring 基于模板设计模式对于上述的持久层技术进行了封装</li>
</ul>
<h3 id="1-2-Spring可以与那些持久层技术进行整合？"><a href="#1-2-Spring可以与那些持久层技术进行整合？" class="headerlink" title="1.2 Spring可以与那些持久层技术进行整合？"></a>1.2 Spring可以与那些持久层技术进行整合？</h3><ul>
<li>JDBC —— <code>JDBCTemplate</code></li>
<li>Hibernate（JPA）—— <code>HibernateTemplate</code></li>
<li><strong>MyBatis</strong> —— <code>SqlSessionFactoryBean</code>、<code>MapperScannerConfigure</code></li>
</ul>
<h2 id="2-Spring与MyBatis整合"><a href="#2-Spring与MyBatis整合" class="headerlink" title="2. Spring与MyBatis整合"></a>2. Spring与MyBatis整合</h2><h3 id="2-1-MyBatis开发步骤的回顾"><a href="#2-1-MyBatis开发步骤的回顾" class="headerlink" title="2.1 MyBatis开发步骤的回顾"></a>2.1 MyBatis开发步骤的回顾</h3><ul>
<li>实体类 <code>User</code></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String password;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id, String name, String password)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.password = password;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> password;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.password = password;
    &#125;
&#125;</code></pre></div>

<ul>
<li>实体别名 <code>mybatis-config.xml</code> 配置繁琐</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span>
<span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Confi 3.0//EN&quot;</span></span>
<span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.yusael.mybatis.User&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/yus?useSSL=false&quot;</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div>

<ul>
<li>表 t_users</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs mysql">create table t_users values (
	id int(11) primary key auto_increment,
	name varchar(12),
	password varchar(12)
);</code></pre></div>

<ul>
<li>创建 DAO 接口：<code>UserDAO</code></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDAO</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(User user)</span></span>;
&#125;</code></pre></div>

<ul>
<li>实现Mapper文件：<code>UserDAOMapper.xml</code> 配置繁琐 </li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span>
<span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.yusael.mybatis.UserDAO&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;save&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>
        insert into t_users(name, password) values (#&#123;name&#125;, #&#123;password&#125;)
    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>

<ul>
<li>注册 Mapper 文件 <code>mybatis-config.xml</code></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserDAOMapper.xml&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div>

<ul>
<li>MybatisAPI调用  代码冗余 </li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMybatis</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);
        SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);
        SqlSession session = sqlSessionFactory.openSession();
        UserDAO userDAO = session.getMapper(UserDAO.class);

        User user = <span class="hljs-keyword">new</span> User();
        user.setName(<span class="hljs-string">&quot;yusael&quot;</span>);
        user.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);
        userDAO.save(user);

        session.commit();
    &#125;
&#125;</code></pre></div>

<h3 id="2-2-Mybatis在开发过程中存在问题"><a href="#2-2-Mybatis在开发过程中存在问题" class="headerlink" title="2.2 Mybatis在开发过程中存在问题"></a>2.2 Mybatis在开发过程中存在问题</h3><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 配置繁琐  代码冗余 </span>
<span class="hljs-bullet">1.</span> 实体
<span class="hljs-bullet">2.</span> 实体别名         配置繁琐 
<span class="hljs-bullet">3.</span> 表
<span class="hljs-bullet">4.</span> 创建DAO接口
<span class="hljs-bullet">5.</span> 实现Mapper文件
<span class="hljs-bullet">6.</span> 注册Mapper文件   配置繁琐 
<span class="hljs-bullet">7.</span> MybatisAPI调用  代码冗余</code></pre></div>

<h3 id="2-3-Spring与Mybatis整合思路分析"><a href="#2-3-Spring与Mybatis整合思路分析" class="headerlink" title="2.3 Spring与Mybatis整合思路分析"></a>2.3 Spring与Mybatis整合思路分析</h3><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200504141407141.png" srcset="/img/loading.gif" lazyload alt="image-20200504141407141"></p>
<h3 id="2-4-Spring与Mybatis整合的开发步骤"><a href="#2-4-Spring与Mybatis整合的开发步骤" class="headerlink" title="2.4 Spring与Mybatis整合的开发步骤"></a>2.4 Spring与Mybatis整合的开发步骤</h3><ul>
<li><p>配置文件（<code>ApplicationContext.xml</code>) 进行相关配置</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">#配置 是需要配置一次 
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span> 

<span class="hljs-comment">&lt;!--创建SqlSessionFactory--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ssfb&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;SqlSessionFactoryBean&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span>&gt;</span>
         指定 实体类所在的包  com.baizhiedu.entity  User
                                                 Product
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span>&gt;</span>
          指定 配置文件(映射文件)的路径 还有通用配置 
          com.baizhiedu.mapper/*Mapper.xml 
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!--DAO接口的实现类</span>
<span class="hljs-comment">    session ---&gt;</span> session.getMapper() --- xxxDAO实现类对象 
    XXXDAO  ---&gt; xXXDAO
--&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scanner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;MapperScannerConfigure&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ssfb&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePacakge&quot;</span>&gt;</span>
        指定 DAO接口放置的包  com.baizhiedu.dao 
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div></li>
<li><p>编码</p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 实战经常根据需求 写的代码</span>
<span class="hljs-bullet">1.</span> 实体
<span class="hljs-bullet">2.</span> 表
<span class="hljs-bullet">3.</span> 创建DAO接口
<span class="hljs-bullet">4.</span> 实现Mapper文件</code></pre></div></li>
</ul>
<h3 id="2-5-Spring与Mybatis整合编码"><a href="#2-5-Spring与Mybatis整合编码" class="headerlink" title="2.5 Spring与Mybatis整合编码"></a>2.5 Spring与Mybatis整合编码</h3><ul>
<li><p><strong>搭建开发环境(jar)</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li>
<li><p><strong>Spring配置文件的配置</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--连接池--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/suns?useSSL=false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.baizhiedu.entity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:com.baizhiedu.mapper/*Mapper.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scanner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.baizhiedu.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div></li>
<li><p><strong>编码</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 实体
<span class="hljs-bullet">2.</span> 表
<span class="hljs-bullet">3.</span> DAO接口
<span class="hljs-bullet">4.</span> Mapper文件配置</code></pre></div></li>
<li><p>实体 <code>com.yusael.entity.User</code></p>
</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String password;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> password;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.password = password;
    &#125;
&#125;</code></pre></div>

<ul>
<li>表 <code>t_user</code></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs mysql">create table t_users values (
	id int(11) primary key auto_increment,
	name varchar(12),
	password varchar(12)
);</code></pre></div>

<ul>
<li>DAO接口 <code>com.yusael.dao.UserDAO</code></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDAO</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(User user)</span></span>;
&#125;</code></pre></div>

<ul>
<li>Mapper文件配置 <code>resources/applicationContext.xml</code></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>
        <span class="hljs-comment">&lt;!--连接池--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/yus?useSSL=false&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

        <span class="hljs-comment">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.yusael.entity&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:com.yusael.dao/*Mapper.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

        <span class="hljs-comment">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scanner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.yusael.dao&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<ul>
<li><code>UserDAOMapper.xml</code></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;save&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>
	insert into t_users (name,password) values (#&#123;name&#125;,#&#123;password&#125;)
<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div>

<ul>
<li>测试</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 用于测试: Spring 与 Mybatis 的整合</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
    ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);
    UserDAO userDAO = (UserDAO) ctx.getBean(<span class="hljs-string">&quot;userDAO&quot;</span>);

    User user = <span class="hljs-keyword">new</span> User();
    user.setName(<span class="hljs-string">&quot;xiaojr&quot;</span>);
    user.setPassword(<span class="hljs-string">&quot;999999&quot;</span>);

    userDAO.save(user);
&#125;</code></pre></div>

<h3 id="2-6-Spring与Mybatis整合细节"><a href="#2-6-Spring与Mybatis整合细节" class="headerlink" title="2.6 Spring与Mybatis整合细节"></a>2.6 Spring与Mybatis整合细节</h3><p>问题：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？</p>
<ul>
<li>Mybatis 提供的连接池对象 —&gt; 创建<code> Connection Connection.setAutoCommit(false)</code> 手工的控制了事务，操作完成后，需要手工提交</li>
<li>Druid（C3P0、DBCP）作为连接池 —&gt; 创建<code>Connection Connection.setAutoCommit(true)</code>默认值为 true，保持自动控制事务，一条 sql 自动提交</li>
</ul>
<p>答案：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制<code>Connection.setAutoCommit(true)</code>，不需要手工进行事务的操作，也能进行事务的提交</p>
<p>注意：实战中，还是会手工控制事务（多条SQL一起成功，一起失败），后续Spring通过事务控制解决这个问题</p>
<h2 id="3-Spring的事务处理"><a href="#3-Spring的事务处理" class="headerlink" title="3. Spring的事务处理"></a>3. Spring的事务处理</h2><h3 id="3-1-什么是事务？"><a href="#3-1-什么是事务？" class="headerlink" title="3.1 什么是事务？"></a>3.1 什么是事务？</h3><blockquote>
<p>保证业务操作完整性的一种数据库机制</p>
<p>事务的4特点： <strong>A C I D</strong></p>
<ul>
<li>A 原子性</li>
<li>C 一致性</li>
<li>I 隔离性</li>
<li>D 持久性</li>
</ul>
</blockquote>
<h3 id="3-2-如何控制事务"><a href="#3-2-如何控制事务" class="headerlink" title="3.2 如何控制事务"></a>3.2 如何控制事务</h3><div class="hljs code-wrapper"><pre><code class="hljs markdown">JDBC:
<span class="hljs-code">    Connection.setAutoCommit(false);</span>
<span class="hljs-code">    Connection.commit();</span>
<span class="hljs-code">    Connection.rollback();</span>
<span class="hljs-code">Mybatis：</span>
<span class="hljs-code">    Mybatis自动开启事务</span>
<span class="hljs-code">    </span>
<span class="hljs-code">    sqlSession(Connection).commit();</span>
<span class="hljs-code">    sqlSession(Connection).rollback();</span>
<span class="hljs-code"></span>
<span class="hljs-code">结论：控制事务的底层 都是Connection对象完成的</span></code></pre></div>

<h3 id="3-3-Spring控制事务的开发"><a href="#3-3-Spring控制事务的开发" class="headerlink" title="3.3 Spring控制事务的开发"></a>3.3 Spring控制事务的开发</h3><blockquote>
<p>Spring是通过AOP的方式进行事务开发</p>
</blockquote>
<h4 id="3-3-1-原始对象"><a href="#3-3-1-原始对象" class="headerlink" title="3.3.1 原始对象"></a>3.3.1 原始对象</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXXUserServiceImpl</span></span>&#123;
   <span class="hljs-keyword">private</span> xxxDAO xxxDAO
   set get

   <span class="hljs-number">1.</span> 原始对象 ---&gt; 原始方法 ---&gt; 核心功能 (业务处理+DAO调用)
   <span class="hljs-number">2.</span> DAO作为Service的成员变量，依赖注入的方式进行赋值
&#125;</code></pre></div>

<h4 id="3-3-2-额外功能"><a href="#3-3-2-额外功能" class="headerlink" title="3.3.2 额外功能"></a>3.3.2 额外功能</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//以下代码Spring已经封装好，通过</span>
<span class="hljs-comment">//org.springframework.jdbc.datasource.DataSourceTransactionManager</span>
<span class="hljs-comment">//需要注入连接池DataSource </span>

<span class="hljs-number">1.</span> <span class="hljs-comment">//实现MethodInterceptor</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span></span>&#123;
      <span class="hljs-keyword">try</span>&#123;
        Connection.setAutoCommit(<span class="hljs-keyword">false</span>);
        Object ret = invocation.proceed();
        Connection.commit();
      &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
        Connection.rollback();
      &#125;
        <span class="hljs-keyword">return</span> ret;
   &#125;
<span class="hljs-number">2.</span> <span class="hljs-comment">//使用注解@Aspect</span>
   <span class="hljs-comment">//@Around </span></code></pre></div>

<h4 id="3-3-3-切入点"><a href="#3-3-3-切入点" class="headerlink" title="3.3.3 切入点"></a>3.3.3 切入点</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span> 
事务的额外功能加入给那些业务方法。

<span class="hljs-number">1.</span> 类上：类中所有的方法都会加入事务
<span class="hljs-number">2.</span> 方法上：这个方法会加入事务</code></pre></div>

<h4 id="3-3-4-组装切面"><a href="#3-3-4-组装切面" class="headerlink" title="3.3.4 组装切面"></a>3.3.4 组装切面</h4><div class="hljs code-wrapper"><pre><code class="hljs xml">1. 切入点
2. 额外功能

<span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span></code></pre></div>

<h3 id="3-4-Spring控制事务的编码"><a href="#3-4-Spring控制事务的编码" class="headerlink" title="3.4 Spring控制事务的编码"></a>3.4 Spring控制事务的编码</h3><ul>
<li><p>搭建开发环境 (jar)</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li>
<li><p>编码</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.service.UserServiceImpl&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!--DataSourceTransactionManager--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>


@Transactional
public class UserServiceImpl implements UserService &#123;
    private UserDAO userDAO;

<span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></code></pre></div></li>
<li><p>细节</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--tx:annotation-driven要以tx结尾--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>
进行动态代理底层实现的切换   proxy-target-class
    默认 false JDK
        true  Cglib</code></pre></div></li>
</ul>
<h2 id="4-Spring中的事务属性-Transaction-Attribute"><a href="#4-Spring中的事务属性-Transaction-Attribute" class="headerlink" title="4.  Spring中的事务属性(Transaction Attribute)"></a>4.  Spring中的事务属性(Transaction Attribute)</h2><h3 id="4-1-什么是事务属性"><a href="#4-1-什么是事务属性" class="headerlink" title="4.1 什么是事务属性"></a>4.1 什么是事务属性</h3><blockquote>
<p>属性：描述物体特征的一系列值<br>性别 身高 体重 …<br>事务属性：描述事务特征的一系列值 </p>
<ul>
<li>隔离属性</li>
<li>传播属性</li>
<li>只读属性</li>
<li>超时属性</li>
<li>异常属性 </li>
</ul>
</blockquote>
<h3 id="4-2-如何添加事务属性"><a href="#4-2-如何添加事务属性" class="headerlink" title="4.2 如何添加事务属性"></a>4.2 如何添加事务属性</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>
(isloation=,propagation=,readOnly=,timeout=,rollbackFor=,noRollbackFor=,)</code></pre></div>

<h3 id="4-3-事务属性详解"><a href="#4-3-事务属性详解" class="headerlink" title="4.3 事务属性详解"></a>4.3 事务属性详解</h3><h4 id="4-3-1-隔离属性-ISOLATION"><a href="#4-3-1-隔离属性-ISOLATION" class="headerlink" title="4.3.1 隔离属性 (ISOLATION)"></a>4.3.1 隔离属性 (ISOLATION)</h4><ul>
<li><p>隔离属性的概念</p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown">概念：他描述了事务解决并发问题的特征
<span class="hljs-bullet">1.</span> 什么是并发
<span class="hljs-code">       多个事务(用户)在同一时间，访问操作了相同的数据</span>
<span class="hljs-code">       </span>
<span class="hljs-code">       同一时间：0.000几秒 微小前 微小后</span>
<span class="hljs-code">2. 并发会产生那些问题</span>
<span class="hljs-code">       1. 脏读</span>
<span class="hljs-code">       2. 不可重复读</span>
<span class="hljs-code">       3. 幻影读</span>
<span class="hljs-code">3. 并发问题如何解决</span>
<span class="hljs-code">       通过隔离属性解决，隔离属性中设置不同的值，解决并发处理过程中的问题。</span></code></pre></div></li>
<li><p>事务并发产生的问题</p>
<ul>
<li><p>脏读</p>
<blockquote>
<p>一个事务，读取了另一个事务中没有提交的数据。会在本事务中产生数据不一致的问题解决方案  @Transactional(isolation=Isolation.READ_COMMITTED)</p>
</blockquote>
</li>
<li><p>不可重复读</p>
<blockquote>
<p>一个事务中，多次读取相同的数据，但是读取结果不一样。会在本事务中产生数据不一致的问题注意：1 不是脏读 2 一个事务中解决方案 @Transactional(isolation=Isolation.REPEATABLE_READ)<br>本质： 一把行锁</p>
</blockquote>
</li>
<li><p>幻影读</p>
<blockquote>
<p>一个事务中，多次对整表进行查询统计，但是结果不一样，会在本事务中产生数据不一致的问题解决方案 @Transactional(isolation=Isolation.SERIALIZABLE)<br>本质：表锁 </p>
</blockquote>
</li>
<li><p>总结</p>
<blockquote>
<p>一个事务中，多次对整表进行查询统计，但是结果不一样，会在本事务中产生数据不一致的问题解决方案 @Transactional(isolation=Isolation.SERIALIZABLE)<br>本质：表锁 </p>
</blockquote>
</li>
</ul>
</li>
<li><p>数据库对于隔离属性的支持</p>
<table>
<thead>
<tr>
<th>隔离属性的值</th>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>IOSLATION_REPEATABLE_READ</td>
<td>✅</td>
<td>❎</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<p>Oracle不支持REPEATABLE_READ值 如何解决不可重复读</p>
<p>采用的是多版本比对的方式 解决不可重复读的问题</p>
</li>
<li><p>默认隔离属性</p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown">ISOLATION<span class="hljs-emphasis">_DEFAULT：会调用不同数据库所设置的默认隔离属性</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">MySQL : REPEATABLE_</span>READ 
Oracle: READ<span class="hljs-emphasis">_COMMITTED  </span></code></pre></div>

<ul>
<li><p>查看数据库默认隔离属性</p>
<ul>
<li><p>MySQL</p>
<div class="hljs code-wrapper"><pre><code class="hljs mysql">select @@tx_isolation;</code></pre></div></li>
<li><p>Oracle</p>
<div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT s.sid, s.serial#,
   CASE BITAND(t.flag, POWER(2, 28))
      WHEN 0 THEN &#39;READ COMMITTED&#39;
      ELSE &#39;SERIALIZABLE&#39;
   END AS isolation_level
FROM v$transaction t 
JOIN v$session s ON t.addr &#x3D; s.taddr
AND s.sid &#x3D; sys_context(&#39;USERENV&#39;, &#39;SID&#39;);</code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li><p>隔离属性在实战中的建议</p>
<ul>
<li>推荐使用 Spring 默认指定的 <code>ISOLATION_DEFAULT</code></li>
<li>未来的实战中，遇到并发访问的情况，很少见</li>
<li>如果真的遇到并发问题，解决方案：<strong>乐观锁</strong><br>Hibernate(JPA)：version<br>MyBatis：通过拦截器自定义开发</li>
</ul>
</li>
</ul>
<h4 id="4-3-2-传播属性-PROPAGATION"><a href="#4-3-2-传播属性-PROPAGATION" class="headerlink" title="4.3.2 传播属性(PROPAGATION)"></a>4.3.2 传播属性(PROPAGATION)</h4><p><strong>传播属性的概念</strong></p>
<blockquote>
<p>概念：他描述了事务解决嵌套问题的特征</p>
<p>什么叫做事务的嵌套：他指的是一个大的事务中，包含了若干个小的事务</p>
<p>问题：大事务中融入了很多小的事务，他们彼此影响，最终就会导致外部大的事务，丧失了事务的原子性</p>
</blockquote>
<p><strong>传播属性的值及其用法</strong></p>
<table>
<thead>
<tr>
<th>传播属性的值</th>
<th>外部不存在事务</th>
<th>外部存在事务</th>
<th>用法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>开启新的事务</td>
<td>融合到外部事务中</td>
<td>@Transactional(propagation = Propagation.REQUIRED)</td>
<td>增删改方法</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>不开启事务</td>
<td>融合到外部事务中</td>
<td>@Transactional(propagation = Propagation.SUPPORTS)</td>
<td>查询方法</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>开启新的事务</td>
<td>挂起外部事务，创建新的事务</td>
<td>@Transactional(propagation = Propagation.REQUIRES_NEW)</td>
<td>日志记录方法中</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>不开启事务</td>
<td>挂起外部事务</td>
<td>@Transactional(propagation = Propagation.NOT_SUPPORTED)</td>
<td>及其不常用</td>
</tr>
<tr>
<td>NEVER</td>
<td>不开启事务</td>
<td>抛出异常</td>
<td>@Transactional(propagation = Propagation.NEVER)</td>
<td>及其不常用</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>抛出异常</td>
<td>融合到外部事务中</td>
<td>@Transactional(propagation = Propagation.MANDATORY)</td>
<td>及其不常用</td>
</tr>
</tbody></table>
<ul>
<li><p>默认的传播属性</p>
<blockquote>
<p>REQUIRED是传播属性的默认值</p>
</blockquote>
</li>
<li><p>推荐传播属性的使用方式</p>
<blockquote>
<p>增删改 方法：直接使用默认值REQUIRED 查询   </p>
<p>查询 方法：显示指定传播属性的值为SUPPORTS  </p>
</blockquote>
</li>
</ul>
<h4 id="4-3-3-只读属性-readOnly"><a href="#4-3-3-只读属性-readOnly" class="headerlink" title="4.3.3 只读属性(readOnly)"></a>4.3.3 只读属性(readOnly)</h4><blockquote>
<p>针对于只进行查询操作的业务方法，可以加入只读属性，提供运行效率<br>默认值：false </p>
<p>@Transactional(readOnly = true)</p>
</blockquote>
<h4 id="4-3-4-超时属性-timeout"><a href="#4-3-4-超时属性-timeout" class="headerlink" title="4.3.4 超时属性(timeout)"></a>4.3.4 超时属性(timeout)</h4><p>指定了事务等待的最长时间</p>
<ul>
<li>为什么事务会进行等待？<br>当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。</li>
<li>等待时间，单位是 秒</li>
<li>如何使用：@Transactional(timeout = 2)</li>
<li>超时属性的默认值：-1<br>-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）</li>
</ul>
<h4 id="4-3-5-异常属性"><a href="#4-3-5-异常属性" class="headerlink" title="4.3.5 异常属性"></a>4.3.5 异常属性</h4><p>Spring 事务处理过程中：</p>
<ul>
<li>默认对于 <code>RuntimeException</code> 及其子类，采用 <strong>回滚</strong> 的策略</li>
<li>默认对于 <code>Exception</code> 及其子类，采用 <strong>提交</strong> 的策略</li>
</ul>
<p>使用方法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)</span>

<span class="hljs-meta">@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)</span></code></pre></div>

<h3 id="4-4-事务属性常见配置总结"><a href="#4-4-事务属性常见配置总结" class="headerlink" title="4.4 事务属性常见配置总结"></a>4.4 事务属性常见配置总结</h3><ul>
<li>隔离属性 默认值</li>
<li>传播属性 Required（默认值）增删改、Supports 查询操作</li>
<li>只读属性 readOnly=false 增删改，true 查询操作</li>
<li>超时属性 默认值 -1</li>
<li>异常属性 默认值</li>
</ul>
<p>增删改操作：<code>@Transactional</code><br>查询操作：<code>@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)</code></p>
<h3 id="4-5-基于标签的事务配置方式-事务开发的第二种形式"><a href="#4-5-基于标签的事务配置方式-事务开发的第二种形式" class="headerlink" title="4.5 基于标签的事务配置方式(事务开发的第二种形式)"></a>4.5 基于标签的事务配置方式(事务开发的第二种形式)</h3><p>基于注解 <code>@Transaction</code> 的事务配置回顾：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!--DataSourceTransactionManager--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

@Transactional
public class UserServiceImpl implements UserService &#123;
    private UserDAO userDAO;

<span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></code></pre></div>

<p>基于标签的事务配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--DataSourceTransactionManager--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!--不同点--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;register&quot;</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">&quot;DEFAULT&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span>
          <span class="hljs-comment">&lt;!--等效于 </span>
<span class="hljs-comment">          @Transactional(isolation=,propagation=,)</span>
<span class="hljs-comment">          public void register()&#123;</span>
<span class="hljs-comment">        </span>
<span class="hljs-comment">          &#125;--&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.service.UserServiceImpl.register(..))&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pc&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></div>

<p>基于标签的事务配置在 <strong>实战</strong> 中的应用方式：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>
       	编程时候, service中负责进行增删改操作的方法 都以 modify 开头
       	查询操作 命名无所谓
      	tx的顺序表示匹配的顺序
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;register&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;modify*&quot;</span>/&gt;</span>
				除了modify*，*表示剩下的都满足...
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.yusael.service..*.*(..))&quot;</span>/&gt;</span>
   	应用的过程中, 将 service 都放到 service 包下
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pc&quot;</span>/&gt;</span>
&lt;/aop:config</code></pre></div>

<h2 id="5-Spring开发过程中多配置文件的处理"><a href="#5-Spring开发过程中多配置文件的处理" class="headerlink" title="5. Spring开发过程中多配置文件的处理"></a>5. Spring开发过程中多配置文件的处理</h2><div class="hljs code-wrapper"><pre><code class="hljs markdown">Spring会根据需要，把配置信息分门别类的放置在多个配置文件中，便于后续的管理及维护。

DAO  ------  applicationContext-dao.xml 
Service ---  applicationContext-service.xml
Action  ---  applicationContext-action.xml

注意：虽然提供了多个配置文件，但是后续应用的过程中，还要进行整合</code></pre></div>

<p>通配符方式</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">1. 非web环境
   ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;/applicationContext-*.xml&quot;);
2. web环境
   <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext-*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span></code></pre></div>

<p>&lt;import标签</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">applicationContext.xml 目的 整合其他配置内容
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext-dao.xml &quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext-service.xml &quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext-action.xml &quot;</span> /&gt;</span>
    
1. 非web环境
   ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;/applicationContext.xml&quot;);
2. web环境
   <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span></code></pre></div>

<h1 id="第五章、Spring注解编程"><a href="#第五章、Spring注解编程" class="headerlink" title="第五章、Spring注解编程"></a>第五章、Spring注解编程</h1><h2 id="1-注解基础概念"><a href="#1-注解基础概念" class="headerlink" title="1. 注解基础概念"></a>1. 注解基础概念</h2><h3 id="1-1-什么是注解编程"><a href="#1-1-什么是注解编程" class="headerlink" title="1.1 什么是注解编程"></a>1.1 什么是注解编程</h3><ul>
<li>在 类 或者 方法 上加入特定的注解（<code>@xxx</code>），完成特定功能的开发</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXX</span></span>&#123;&#125;</code></pre></div>

<h3 id="1-2-为什么要讲解注解编程"><a href="#1-2-为什么要讲解注解编程" class="headerlink" title="1.2 为什么要讲解注解编程"></a>1.2 为什么要讲解注解编程</h3><ul>
<li>注解开发方便，代码简单，开发速度大大提高</li>
<li>注解开发是 Spring 开发潮流<br>Spring 2.x 引入注解，Spring 3.x 完善注解，SpringBoot 普及、推广注解编程</li>
</ul>
<h3 id="1-3-注解的作用"><a href="#1-3-注解的作用" class="headerlink" title="1.3 注解的作用"></a>1.3 注解的作用</h3><ul>
<li><p>替换XML这种配置形式，简化配置</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200527164703807.png" srcset="/img/loading.gif" lazyload alt="image-20200527164703807"></p>
</li>
<li><p>替换接口，实现调用双方的契约性 </p>
<blockquote>
<p>通过注解的方式，在功能调用者和功能提供者之间达成约定，进而进行功能的调用。因为注解应用更为方便灵活，所以在现在的开发中，更推荐通过注解的形式，完成</p>
</blockquote>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200527171704953.png" srcset="/img/loading.gif" lazyload alt="image-20200527171704953"></p>
</li>
</ul>
<h3 id="1-4-Spring注解的发展历程"><a href="#1-4-Spring注解的发展历程" class="headerlink" title="1.4 Spring注解的发展历程"></a>1.4 Spring注解的发展历程</h3><ul>
<li>Spring 2.x： 开始支持注解编程 <code>@Component</code>、<code>@Service</code>、<code>@Scope</code>…<br>目的：提供的这些注解只是为了某些 XML 的配置，作为 XML 开发的有益补充。</li>
<li>Spring 3.x： <code>@Configuration</code>、<code>@Bean</code>…<br>目的：彻底替换 XML，基于纯注解</li>
<li>Spring 4.x： <strong>SpringBoot</strong> 提倡使用注解进行开发</li>
</ul>
<h3 id="1-5-Spring注解开发的一个问题"><a href="#1-5-Spring注解开发的一个问题" class="headerlink" title="1.5 Spring注解开发的一个问题"></a>1.5 Spring注解开发的一个问题</h3><blockquote>
<p>Spring基于注解进行配置后，还能否解耦合呢？</p>
<p>在Spring框架应用注解时，如果对注解配置的内容不满意，可以通过Spring配置文件进行覆盖的</p>
</blockquote>
<h2 id="2-Spring的基础注解（Spring2-x）"><a href="#2-Spring的基础注解（Spring2-x）" class="headerlink" title="2. Spring的基础注解（Spring2.x）"></a>2. Spring的基础注解（Spring2.x）</h2><blockquote>
<p>这个阶段的注解，仅仅是简化XML的配置，并不能完全替代XML</p>
</blockquote>
<h3 id="2-1-对象创建相关注解"><a href="#2-1-对象创建相关注解" class="headerlink" title="2.1 对象创建相关注解"></a>2.1 对象创建相关注解</h3><p><strong>搭建开发环境</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.baizhiedu&quot;</span>/&gt;</span>

作用：让Spring框架在设置包及其子包中扫描对应的注解，使其生效。</code></pre></div>

<p><strong>对象创建相关注解</strong></p>
<h4 id="Component注解"><a href="#Component注解" class="headerlink" title="@Component注解"></a><code>@Component</code>注解</h4><p>作用：替换原有Spring配置文件中的 <code>&lt;bean&gt;</code> 标签</p>
<ul>
<li><code>id</code> 属性：在 <code>@Component</code> 中提供了默认的设置方式：首单词首字母小写（UserDAO –&gt; userDAO）</li>
<li><code>class</code> 属性：通过反射获得的 <code>class</code> 的内容</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200528112232356.png" srcset="/img/loading.gif" lazyload alt="image-20200528112232356"></p>
<p><code>@Component </code>细节</p>
<ul>
<li><p>如何显示指定工厂创建对象的id值</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;u&quot;)</span></code></pre></div></li>
<li><p>Spring配置文件覆盖注解配置内容</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">applicationContext.xml

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.bean.User&quot;</span>/&gt;</span>

id值 class的值 要和 注解中的设置保持一值</code></pre></div></li>
<li><p>@Component的衍生注解</p>
<ul>
<li><code>@Repository</code>、<code>@Service</code>、<code>@Controller</code> 都是 <code>@Component</code> 的 <strong>衍生注解</strong></li>
<li>本质上这些衍生注解就是 <code>@Component</code>，通过源码可以看见他们都使用了<code>@Component</code>，它们的存在是为了：<strong>更加准确的表达一个类型的作用</strong></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDAO</span> </span>&#123;&#125;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;&#125;

<span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;&#125;</code></pre></div>

<p>注意：Spring 整合 Mybatis 开发过程中，不使用 <code>@Repository</code>、<code>@Component</code></p>
</li>
<li><p>```JAVA<br>@Repository  —&gt;  XXXDAO<br>  @Repository<br>  public class UserDAO{</p>
<p>  }<br>@Service<br>  @Service<br>  public class UserService{</p>
<p>  }<br>@Controller<br>  @Controller<br>  public class RegAction{</p>
<p>  }<br>注意：本质上这些衍生注解就是@Component </p>
<div class="hljs code-wrapper"><pre><code> 作用 &lt;bean  
 细节 @Service(&quot;s&quot;)
</code></pre></div>
<p>目的：更加准确的表达一个类型的作用</p>
<p>注意：Spring整合Mybatis开发过程中 不使用@Repository @Component</p>
<div class="hljs code-wrapper"><pre><code class="hljs autohotkey">
#### `@Scope`注解

作用：控制简单对象创建次数
注意：不添加 `@Scope`，Spring 提供默认值 `singleton`

```xml
&lt;bean id=<span class="hljs-string">&quot;&quot;</span> class=<span class="hljs-string">&quot;&quot;</span> scope=<span class="hljs-string">&quot;singleton|prototype&quot;</span>/&gt;</code></pre></div></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建单例对象</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Scope(&quot;singleton&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;&#125;

<span class="hljs-comment">// 创建多例对象</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Scope(&quot;prototype&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;&#125;</code></pre></div>

<h4 id="Lazy注解"><a href="#Lazy注解" class="headerlink" title="@Lazy注解"></a><code>@Lazy</code>注解</h4><p>作用：延迟创建单实例对象<br>注意：一旦使用 <code>@Lazy</code> 注解后，Spring 会在使用这个对象的时候，才创建这个对象</p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span></span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Lazy</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;Account.Account&quot;</span>);
    &#125;
&#125;</code></pre></div>

<h4 id="生命周期方法相关注解"><a href="#生命周期方法相关注解" class="headerlink" title="生命周期方法相关注解"></a>生命周期方法相关注解</h4><p>初始化相关方法： <code>@PostConstruct</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">InitializingBean
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span></code></pre></div>

<p>销毁方法：<code>@PreDestory</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">DisposableBean
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">destory-method</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span></code></pre></div>

<p>注意：</p>
<ul>
<li>上述的两个注解并不是 Spring 提供的，由 <strong>JSR(JavaEE规范)520</strong> 提供</li>
<li>再次验证，通过注解实现了接口的契约性</li>
</ul>
<h3 id="2-2-注入相关注解"><a href="#2-2-注入相关注解" class="headerlink" title="2.2 注入相关注解"></a>2.2 注入相关注解</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a><code>@Autowired</code></h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200601114751016.png" srcset="/img/loading.gif" lazyload alt="image-20200601114751016"></p>
<p><code>@Autowired</code> 注解 <strong>基于类型进行注入</strong> [推荐]：</p>
<ul>
<li>注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> UserDAO userDAO;</code></pre></div>

<p><code>@Autowired</code>、<code>@Qualifier</code> 注解联合实现 <strong>基于名字进行注入</strong> [了解]</p>
<ul>
<li>注入对象的 id 值，必须与 <code>@Qualifier</code> 注解中设置的名字相同</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-meta">@Qualifier(&quot;userDAOImpl&quot;)</span>
<span class="hljs-keyword">private</span> UserDAO userDAO;</code></pre></div>

<p><code>@Autowired</code> 注解放置位置：</p>
<ul>
<li>放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）</li>
<li><strong>直接放置在成员变量上</strong>，Spring 通过<strong>反射直接对成员变量进行赋值 [推荐]</strong></li>
</ul>
<p>JavaEE 规范中类似功能的注解：</p>
<ul>
<li>JSR250 提供的 <code>@Resource(name=&quot;xxx&quot;)</code> <strong>基于名字进行注入</strong><br>等价于 <code>@Autowired</code> 与 <code>@Qualifier</code> 联合实现的效果<br>注意：<code>@Resource</code> 注解如果名字没有配对成功，会继续 <strong>按照类型进行注入</strong></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name=&quot;userDAOImpl&quot;)</span>
<span class="hljs-keyword">private</span> UserDAO userDAO;</code></pre></div>

<ul>
<li>JSR330 提供的 <code>@Injection</code> 作用与 <code>@Autowired</code> 完全一样，一般用在 EJB3.0 中</li>
</ul>
<h4 id="JDK类型-value、-PropertySource"><a href="#JDK类型-value、-PropertySource" class="headerlink" title="JDK类型@value、@PropertySource"></a>JDK类型<code>@value</code>、<code>@PropertySource</code></h4><p>方法一：<code>@value</code> 注解的基本使用：</p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 设置xxx.properties 
   id = 10
   name = suns
<span class="hljs-bullet">2.</span> Spring的工厂读取这个配置文件 
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:/xxx.properties&quot;</span>/&gt;</span></span>
<span class="hljs-bullet">3.</span> 代码中进行注入
   属性 @Value(&quot;$&#123;key&#125;&quot;)</code></pre></div>

<p>方法二：使用 <code>@PropertySource</code> 取代 xml配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 设置xxx.properties 
   id = 10
   name = suns
<span class="hljs-bullet">2.</span> 在实体类上应用@PropertySource(&quot;classpath:/xx.properties&quot;)
<span class="hljs-bullet">3.</span> 代码
   属性 @Value(&quot;$&#123;key&#125;&quot;)</code></pre></div>

<p><code>@value</code> 注解使用细节：</p>
<ul>
<li><code>@Value</code> 注解不能应用在静态成员变量上，如果使用，获取的值为 null</li>
<li><code>@Value</code> 注解 + Properties 这种方式，不能注入集合类型<ul>
<li>Spring 提供新的配置形式 <strong>YAML(YML)</strong> (更多的用于SpringBoot中)</li>
</ul>
</li>
</ul>
<h3 id="2-3-注解扫描详解"><a href="#2-3-注解扫描详解" class="headerlink" title="2.3 注解扫描详解"></a>2.3 注解扫描详解</h3><p>这样配置，会扫描当前包及其子包 </p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.baizhiedu&quot;</span>/&gt;</span></code></pre></div>

<h4 id="2-3-1-排除方式"><a href="#2-3-1-排除方式" class="headerlink" title="2.3.1 排除方式"></a>2.3.1 排除方式</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div>

<p><code>type=&quot;xxx&quot;</code>，<code>xxx</code> 有以下几个可选项：</p>
<ul>
<li><code>assignable</code>：排除特定的类型</li>
<li><code>annotation</code>：排除特定的注解</li>
<li><code>aspectj</code>：切入点表达式，比较常用<br>包切入点： <code>com.yusael.bean..*</code><br>类切入点： <code>*..User</code></li>
<li><code>regex</code>：正则表达式，不常用，与切入点类似</li>
<li><code>custom</code>：自定义排除策略，常用于框架底层开发（在 SpringBoot 源码中大量使用）</li>
</ul>
<p>排除策略可以叠加使用：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;assignable&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.yusael.bean.User&quot;</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;aspectj&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.yusael.injection..*&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div>

<h4 id="2-3-1-包含方式"><a href="#2-3-1-包含方式" class="headerlink" title="2.3.1 包含方式"></a>2.3.1 包含方式</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div>

<p>与排除方式使用的区别：</p>
<ul>
<li><code>use-default-filters=&quot;false&quot;</code> 让 Spring 默认的注解扫描方式失效</li>
<li><code>&lt;context:include-filter type=&quot;&quot; expression=&quot;&quot;/&gt;</code> 用于指定扫描哪些注解<br><code>type=&quot;xxx&quot;</code> 与排除方式完全一样，可以参考上面</li>
</ul>
<p>包含策略也可以叠加使用：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.baizhiedu&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div>

<h3 id="2-4-对于注解开发的思考"><a href="#2-4-对于注解开发的思考" class="headerlink" title="2.4 对于注解开发的思考"></a>2.4 对于注解开发的思考</h3><p>Spring 通过注解配置，与通过xml文件进行配置是互通的</p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown">// 通过注解配置UserDAOImpl
@Repository
public class UserDAOImpl&#123;
&#125;

public class UserServiceImpl&#123;
   private UserDAO userDAO;
   set 
   get
&#125;
// 通过xml配置创建userDAO对象
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.UserServiceImpl&quot;</span>&gt;</span></span>
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDAOImpl&quot;</span>/&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span></code></pre></div>

<p><strong>什么情况下使用注解 什么情况下使用配置文件</strong></p>
<p>基础注解（<code>@Component</code>、<code>@Autowired</code>、<code>@Value</code>）用于程序员开发类型的配置：</p>
<ul>
<li>在程序员开发的类型上，可以加入对应注解进行对象的创建<ul>
<li>User、UserService、UserDAO、UserAction… 这些类都很适合用注解</li>
</ul>
</li>
<li>应用其他非程序员开发的类型时（框架自带的类），需要使用<code>&lt;bean&gt;</code>标签进行配置<ul>
<li>SqlSessionFactoryBean、MapperScannerConfigure 等 Spring 创建的类，无法使用注解</li>
</ul>
</li>
</ul>
<h2 id="3-Spring的高级注解（Spring3-x-及以上"><a href="#3-Spring的高级注解（Spring3-x-及以上" class="headerlink" title="3. Spring的高级注解（Spring3.x 及以上)"></a>3. Spring的高级注解（Spring3.x 及以上)</h2><h3 id="3-1-配置Bean"><a href="#3-1-配置Bean" class="headerlink" title="3.1 配置Bean"></a>3.1 配置Bean</h3><p>Spring 在 3.x 提供的新的注解<code>@Configuration</code>，用于替换 XML 配置文件</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;
&#125;</code></pre></div>

<ul>
<li>配置Bean在应用的过程中 替换了XML具体什么内容呢？</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200703100033265.png" srcset="/img/loading.gif" lazyload alt="image-20200703100033265"></p>
<ul>
<li><strong>使用了 <code>@Configuration</code> 后，用 <code>AnnotationConfigApplicationContext</code> 创建工厂：</strong></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java">方法<span class="hljs-number">1</span>: 指定配置bean的Class
ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);

方法<span class="hljs-number">2</span>: 指定配置bean所在的路径(某个包及其子包)
ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<span class="hljs-string">&quot;com.yusael&quot;</span>);</code></pre></div>

<p><code>@Configuration</code> <strong>注解的本质</strong>：查看源码可知，它也是 <code>@Component</code> 注解的衍生注解<br>因此我们可以用 <code>&lt;context:component-scan</code> 进行扫描，但我们不会这么做，因为注解就是为了取代 xml</p>
<ul>
<li><p><strong>配置Bean开发的细节分析</strong></p>
<ul>
<li><p>基于注解开发使用日志</p>
<blockquote>
<p>Spring基于注解的开发不能集成Log4j，推荐使用集成logback，需要自己引入 </p>
</blockquote>
<ul>
<li><p>引入相关jar</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.logback-extensions<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-ext-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li>
<li><p>引入logback配置文件 <code>(logback.xml)</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 控制台输出 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
            <span class="hljs-comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div></li>
</ul>
</li>
<li><p>@Configuration注解的本质</p>
<blockquote>
<p>本质：也是@Component注解的衍生注解</p>
<p>可以应用&lt;context:component-scan进行扫描，但是实际开发不常用</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-Bean注解"><a href="#3-2-Bean注解" class="headerlink" title="3.2 @Bean注解"></a>3.2 @Bean注解</h3><blockquote>
<p>@Bean注解在配置bean中进行使用，等同于XML配置文件中的&lt;bean标签</p>
</blockquote>
<h4 id="3-2-1-Bean注解的基本使用"><a href="#3-2-1-Bean注解的基本使用" class="headerlink" title="3.2.1 @Bean注解的基本使用"></a>3.2.1 @Bean注解的基本使用</h4><p>对象的创建</p>
<p><strong>简单对象</strong>：直接能够通过 new 方式创建的对象</p>
<ul>
<li>User、UserService、UserDAO</li>
</ul>
<p><strong>复杂对象</strong>：不能通过 new 的方式直接创建的对象</p>
<ul>
<li>Connection、SqlSessionFactory</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200703150632630.png" srcset="/img/loading.gif" lazyload alt="image-20200703150632630"></p>
<p><code>@Bean</code> 注解<strong>创建复杂对象</strong>的注意事项：遗留系统整合</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">conn1</span><span class="hljs-params">()</span> </span>&#123;
	Connection conn = <span class="hljs-keyword">null</span>;
	<span class="hljs-keyword">try</span> &#123;
		ConnectionFactoryBean factoryBean = <span class="hljs-keyword">new</span> ConnectionFactoryBean();
		conn = factoryBean.getObject();
	&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
		e.printStackTrace();
	&#125;
	<span class="hljs-keyword">return</span> conn;
&#125;</code></pre></div>

<p><code>@Bean</code> 注解创建对象，<strong>自定义 id 值</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;id&quot;)</span></code></pre></div>

<p><code>@Bean</code> 注解创建对象，<strong>控制对象创建次数</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@Scope(&quot;singleton|prototype&quot;)</span> <span class="hljs-comment">//默认值 singleton</span></code></pre></div>

<h4 id="3-2-2-Bean注解的注入"><a href="#3-2-2-Bean注解的注入" class="headerlink" title="3.2.2  @Bean注解的注入"></a>3.2.2  @Bean注解的注入</h4><ul>
<li><p>用户自定义类型</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span></span>&#123;

<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> UserDAO <span class="hljs-title">userDAO</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserDAOImpl();
&#125;

<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">userService</span><span class="hljs-params">(UserDAO userDAO)</span> </span>&#123;
	UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();
	userService.setUserDAO(userDAO);
	<span class="hljs-keyword">return</span> userService;
	
<span class="hljs-comment">//简化写法</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">userService</span><span class="hljs-params">()</span> </span>&#123;
	UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();
	userService.setUserDAO(userDAO());
	<span class="hljs-keyword">return</span> userService;
&#125;
  
&#125;</code></pre></div></li>
<li><p>JDK类型的注入</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Customer <span class="hljs-title">customer</span><span class="hljs-params">()</span> </span>&#123;
	Customer customer = <span class="hljs-keyword">new</span> Customer();
	customer.setId(<span class="hljs-number">1</span>);
	customer.setName(<span class="hljs-string">&quot;xiaohei&quot;</span>);
	
	<span class="hljs-keyword">return</span> customer;
&#125;</code></pre></div>

<ul>
<li><p>JDK类型注入的细节分析</p>
<p>如果直接在代码中进行 set 方法的调用，会存在耦合的问题，通过配置文件解决：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@PropertySource(&quot;classpath:/init.properties&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig1</span> </span>&#123;

	<span class="hljs-meta">@Value(&quot;$&#123;id&#125;&quot;)</span>
	<span class="hljs-keyword">private</span> Integer id;
	<span class="hljs-meta">@Value(&quot;$&#123;name&#125;&quot;)</span>
	<span class="hljs-keyword">private</span> String name;
	
	<span class="hljs-meta">@Bean</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Customer <span class="hljs-title">customer</span><span class="hljs-params">()</span> </span>&#123;
		Customer customer = <span class="hljs-keyword">new</span> Customer();
		customer.setId(id);
		customer.setName(name);
		
		<span class="hljs-keyword">return</span> customer;
	&#125;
&#125;</code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="3-3-ComponentScan注解"><a href="#3-3-ComponentScan注解" class="headerlink" title="3.3  @ComponentScan注解"></a>3.3  @ComponentScan注解</h3><p><code>@ComponentScan</code> 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <code>&lt;context:component-scan&gt;</code> 标签</p>
<p>目的：进行相关注解的扫描（<code>@Component</code>、<code>@Value</code>、<code>@Autowired</code> …)</p>
<h4 id="3-3-1-基本使用"><a href="#3-3-1-基本使用" class="headerlink" title="3.3.1 基本使用"></a>3.3.1 基本使用</h4><ul>
<li>XML 方式：</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael.scan&quot;</span>/&gt;</span></code></pre></div>

<ul>
<li>注解方式</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = &quot;com.yusael.scan&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig2</span> </span>&#123;
&#125;</code></pre></div>

<h4 id="3-3-2-排除、包含的使用"><a href="#3-3-2-排除、包含的使用" class="headerlink" title="3.3.2 排除、包含的使用"></a>3.3.2 排除、包含的使用</h4><p><strong>排除</strong></p>
<ul>
<li>XML 方式：</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;assignable&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.yusael.bean.User&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div>

<ul>
<li><strong>注解方式</strong>：<br>排除特定的注解：<code>type = FilterType.ANNOTATION, value=&#123;&#125;</code><br>排除特定的类型：<code>type = FilterType.ASSIGNABLE_TYPE , value=&#123;]</code><br>切入点表达式：<code>type = FilterType.ASPECTJ, pattern=&quot;&quot;</code><br>正则表达式：<code>type = FilterType.REGEX, pattern=&quot;&quot;</code><br>自定义排除策略：<code>type = FilterType.CUSTOM, pattern=&quot;&quot;</code></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.yusael.scan&quot;,</span>
<span class="hljs-meta"> excludeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION, value=&#123;Service.class&#125;),</span>
<span class="hljs-meta">                   @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = &quot;*..User1&quot;)&#125;)</span></code></pre></div>

<p><strong>包含</strong></p>
<ul>
<li>XML 方式：</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.yusael&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div>

<ul>
<li>注解方式：参数与排除策略中一样</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.yusaael.scan&quot;,</span>
<span class="hljs-meta">useDefaultFilters = false,</span>
<span class="hljs-meta">includeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION,value=&#123;Service.class&#125;)&#125;)</span></code></pre></div>

<h3 id="3-4-Spring工厂创建对象的多种配置方式"><a href="#3-4-Spring工厂创建对象的多种配置方式" class="headerlink" title="3.4 Spring工厂创建对象的多种配置方式"></a>3.4 Spring工厂创建对象的多种配置方式</h3><h4 id="3-4-1-多种配置方式的应用场景"><a href="#3-4-1-多种配置方式的应用场景" class="headerlink" title="3.4.1 多种配置方式的应用场景"></a>3.4.1 多种配置方式的应用场景</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200706174301418.png" srcset="/img/loading.gif" lazyload alt="image-20200706174301418"></p>
<h4 id="3-4-2-配置优先级"><a href="#3-4-2-配置优先级" class="headerlink" title="3.4.2 配置优先级"></a>3.4.2 配置优先级</h4><p>配置优先级：<code>@Component</code> 及其衍生注解   **&lt;**   <code>@Bean</code>    **&lt;**    配置文件<code>&lt;bean&gt;</code>标签</p>
<ul>
<li>优先级高的配置，会覆盖优先级低配置</li>
<li>配置覆盖：id 值需要保持一致</li>
</ul>
<p>通过配置优先级，可以解决基于注解进行配置的耦合问题：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-comment">//@ImportResource(&quot;applicationContext.xml&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig4</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDAO <span class="hljs-title">userDAO</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserDAOImpl();
    &#125;
&#125;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ImportResource(&quot;applicationContext.xml&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig5</span></span>&#123;
  
&#125;

<span class="hljs-comment">//applicationContext.xml覆盖旧实现</span>
&lt;bean id=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.baizhiedu.injection.UserDAOImplNew&quot;</span>/&gt;</code></pre></div>

<h3 id="3-5-整合多个配置信息"><a href="#3-5-整合多个配置信息" class="headerlink" title="3.5 整合多个配置信息"></a>3.5 整合多个配置信息</h3><p>为什么会有多个配置信息</p>
<blockquote>
<p>拆分多个配置bean的开发，是一种模块化开发的形式，也体现了面向对象各司其职的设计思想</p>
</blockquote>
<p>多配置信息整合的方式</p>
<ul>
<li>多个配置Bean的整合</li>
<li>配置Bean与<code>@Component</code>相关注解的整合</li>
<li>配置Bean与SpringXML配置文件的整合</li>
</ul>
<p>整合多种配置需要关注那些要点</p>
<ul>
<li>如何使多配置的信息汇总成一个整体</li>
<li>如何实现跨配置的注入</li>
</ul>
<h4 id="3-5-1-多个配置Bean的整合"><a href="#3-5-1-多个配置Bean的整合" class="headerlink" title="3.5.1. 多个配置Bean的整合"></a>3.5.1. 多个配置Bean的整合</h4><p><strong>多配置的信息汇总</strong></p>
<ul>
<li><p>base-package进行多个配置Bean的整合</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200707170421669.png" srcset="/img/loading.gif" lazyload alt="image-20200707170421669"></p>
</li>
<li><p><code>@Import</code></p>
<ul>
<li>可以创建对象</li>
<li>多配置bean的整合</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200707170745814.png" srcset="/img/loading.gif" lazyload alt="image-20200707170745814"></p>
</li>
<li><p>在工厂创建时，指定多个配置Bean的Class对象 【了解】</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig1.class,AppConfig2.class);</code></pre></div></li>
<li><p>跨配置进行注入</p>
<p>在应用配置 Bean 的过程中，不管使用哪种方式进行配置信息的汇总，其操作方式都是通过成员变量加入 <code>@Autowired</code> 注解完成</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import(AppConfig2.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig1</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserDAO userDAO;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">userService</span><span class="hljs-params">()</span> </span>&#123;
        UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();
        userService.setUserDAO(userDAO);
        <span class="hljs-keyword">return</span> userService;
    &#125;
&#125;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig2</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDAO <span class="hljs-title">userDAO</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserDAOImpl();
    &#125;
&#125;</code></pre></div></li>
</ul>
<h4 id="3-5-2-配置Bean与-Component相关注解的整合"><a href="#3-5-2-配置Bean与-Component相关注解的整合" class="headerlink" title="3.5.2 配置Bean与@Component相关注解的整合"></a>3.5.2 配置Bean与@Component相关注解的整合</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>/<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDAOImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDAO</span></span>&#123;
&#125;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(&quot;UserDao所在的包&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig3</span> </span>&#123;
   
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserDAO userDAO;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">userService</span><span class="hljs-params">()</span> </span>&#123;
        UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();
        userService.setUserDAO(userDAO);
        <span class="hljs-keyword">return</span> userService;
    &#125;
&#125;

ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig3.class);</code></pre></div>

<h4 id="3-5-3-配置Bean与配置文件整合"><a href="#3-5-3-配置Bean与配置文件整合" class="headerlink" title="3.5.3  配置Bean与配置文件整合"></a>3.5.3  配置Bean与配置文件整合</h4><p>主要用于：</p>
<ul>
<li>遗留系统的整合</li>
<li>配置覆盖</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDAOImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDAO</span></span>&#123;
&#125;
&lt;bean id=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.baizhiedu.injection.UserDAOImpl&quot;</span>/&gt;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ImportResource(&quot;applicationContext.xml&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig4</span> </span>&#123;
  
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserDAO userDAO;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">userService</span><span class="hljs-params">()</span> </span>&#123;
        UserServiceImpl userService = <span class="hljs-keyword">new</span> UserServiceImpl();
        userService.setUserDAO(userDAO);
        <span class="hljs-keyword">return</span> userService;
    &#125;
&#125;

ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig4.class);</code></pre></div>

<h3 id="3-6-配置Bean底层实现原理"><a href="#3-6-配置Bean底层实现原理" class="headerlink" title="3.6 配置Bean底层实现原理"></a>3.6 配置Bean底层实现原理</h3><blockquote>
<p>Spring 在配置 Bean 中加入了 <code>@Configuration</code> 注解后，Spring底层就会通过AOP的方式来控制对象的创建次数，即 Cglib 的代理方式，来进行对象相关的配置、处理</p>
</blockquote>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200709114200371.png" srcset="/img/loading.gif" lazyload alt="image-20200709114200371"> </p>
<h2 id="4-四维一体的开发思想"><a href="#4-四维一体的开发思想" class="headerlink" title="4. 四维一体的开发思想"></a>4. 四维一体的开发思想</h2><h3 id="4-1-什么是四维一体"><a href="#4-1-什么是四维一体" class="headerlink" title="4.1 什么是四维一体"></a>4.1 什么是四维一体</h3><blockquote>
<p>Spring开发一个功能的4种形式，虽然开发方式不同，但是最终效果是一样的</p>
<ul>
<li>基于schema </li>
<li>基于特定功能注解 </li>
<li>基于原始&lt;bean </li>
<li>基于@Bean注解</li>
</ul>
</blockquote>
<h3 id="4-2-四维一体的开发案例"><a href="#4-2-四维一体的开发案例" class="headerlink" title="4.2 四维一体的开发案例"></a>4.2 四维一体的开发案例</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>&lt;context:property-placehoder
<span class="hljs-number">2.</span><span class="hljs-meta">@PropertySource</span>  【推荐】
<span class="hljs-number">3.</span>&lt;bean id=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;PropertySourcePlaceholderConfigure&quot;</span>/&gt;
  &lt;property name=<span class="hljs-string">&quot;location&quot;</span> value=<span class="hljs-string">&quot;classpath:xx.properties&quot;</span>/&gt;
<span class="hljs-number">4.</span><span class="hljs-meta">@Bean</span>            【推荐】</code></pre></div>

<h2 id="5-纯注解版AOP编程"><a href="#5-纯注解版AOP编程" class="headerlink" title="5. 纯注解版AOP编程"></a>5. 纯注解版AOP编程</h2><h3 id="5-1-搭建环境"><a href="#5-1-搭建环境" class="headerlink" title="5.1 搭建环境"></a>5.1 搭建环境</h3><ul>
<li>应用配置Bean </li>
<li>注解扫描</li>
</ul>
<h3 id="5-2-开发步骤"><a href="#5-2-开发步骤" class="headerlink" title="5.2 开发步骤"></a>5.2 开发步骤</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span> 原始对象
   <span class="hljs-meta">@Service</span>/<span class="hljs-meta">@Component</span>
   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;

   &#125;
<span class="hljs-number">2.</span> 创建切面类 （额外功能 切入点 组装切面）
    <span class="hljs-meta">@Aspect</span>
    <span class="hljs-meta">@Component</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;

        <span class="hljs-meta">@Around(&quot;execution(* login(..))&quot;)</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">arround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
            System.out.println(<span class="hljs-string">&quot;----aspect log ------&quot;</span>);
            Object ret = joinPoint.proceed();
            <span class="hljs-keyword">return</span> ret;
        &#125;
    &#125;
<span class="hljs-number">3.</span> Spring的配置文件中
   &lt;aop:aspectj-autoproxy /&gt;
   <span class="hljs-meta">@EnableAspectjAutoProxy</span> ---&gt; 配置Bean</code></pre></div>

<h3 id="5-3-注解AOP细节分析"><a href="#5-3-注解AOP细节分析" class="headerlink" title="5.3 注解AOP细节分析"></a>5.3 注解AOP细节分析</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span> 代理创建方式的切换 JDK Cglib 
   &lt;aop:aspectj-autoproxy proxy-target-<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-keyword">true</span>|<span class="hljs-keyword">false</span> /&gt;
   <span class="hljs-meta">@EnableAspectjAutoProxy(proxyTargetClass = &quot;true|false&quot;)</span>
<span class="hljs-number">2.</span> SpringBoot AOP的开发方式
     <span class="hljs-meta">@EnableAspectjAutoProxy</span> 已经设置好了 

    <span class="hljs-number">1.</span> 原始对象
     <span class="hljs-meta">@Service(@Component)</span>
     <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;

     &#125;
    <span class="hljs-number">2.</span> 创建切面类 （额外功能 切入点 组装切面）
      <span class="hljs-meta">@Aspect</span>
      <span class="hljs-meta">@Component</span>
      <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;

        <span class="hljs-meta">@Around(&quot;execution(* login(..))&quot;)</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">arround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
          System.out.println(<span class="hljs-string">&quot;----aspect log ------&quot;</span>);
          Object ret = joinPoint.proceed();
          <span class="hljs-keyword">return</span> ret;
        &#125;
      &#125;
<span class="hljs-comment">//Spring AOP 代理默认实现 JDK  SpringBOOT AOP 代理默认实现 Cglib </span></code></pre></div>

<h3 id="5-4-纯注解版Spring-MyBatis整合"><a href="#5-4-纯注解版Spring-MyBatis整合" class="headerlink" title="5.4 纯注解版Spring+MyBatis整合"></a>5.4 纯注解版Spring+MyBatis整合</h3><p><strong>基础配置 （配置Bean）</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">1. 连接池
  <span class="hljs-comment">&lt;!--连接池--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/suns?useSSL=false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

   @Bean
   public DataSource dataSource()&#123;
      DruidDataSource dataSource = new DruidDataSource();
      dataSource.setDriverClassName(&quot;&quot;);
      dataSource.setUrl();
      ...
      return dataSource;
   &#125;

2. SqlSessionFactoryBean
    <span class="hljs-comment">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.baizhiedu.entity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:com.baizhiedu.mapper/*Mapper.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;
         SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
         sqlSessionFactoryBean.setDataSource(dataSource);
         sqlSessionFactoryBean.setTypeAliasesPackage(&quot;&quot;);
         ...
         return sqlSessionFactoryBean;
    &#125;

3. MapperScannerConfigure 
   <span class="hljs-comment">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scanner&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactoryBean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.baizhiedu.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

  @MapperScan(basePackages=&#123;&quot;com.baizhiedu.dao&quot;&#125;) ---&gt; 配置bean完成</code></pre></div>

<p><strong>编码</strong></p>
<ul>
<li>实体</li>
<li>表</li>
<li>DAO接口</li>
<li>Mapper文件 </li>
</ul>
<h4 id="5-4-1-MapperLocations编码时通配的写法"><a href="#5-4-1-MapperLocations编码时通配的写法" class="headerlink" title="5.4.1 MapperLocations编码时通配的写法"></a>5.4.1 MapperLocations编码时通配的写法</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//设置Mapper文件的路径</span>
sqlSessionFactoryBean.setMapperLocations(Resource..);
Resource resouce = <span class="hljs-keyword">new</span> ClassPathResouce(<span class="hljs-string">&quot;UserDAOMapper.xml&quot;</span>)

sqlSessionFactoryBean.setMapperLocations(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;UserDAOMapper.xml&quot;</span>));

&lt;property name=<span class="hljs-string">&quot;mapperLocations&quot;</span>&gt;
   &lt;list&gt;
     &lt;value&gt;classpath:com.baizhiedu.mapper<span class="hljs-comment">/*Mapper.xml&lt;/value&gt;</span>
<span class="hljs-comment">   &lt;/list&gt;</span>
<span class="hljs-comment">&lt;/property&gt;</span>
<span class="hljs-comment">//传入的是一组Mapper文件，不适用上面setMapperLocations的方式</span></code></pre></div>

<p><strong>更好的写法</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java">ResourcePatternResolver resolver = <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver();
Resource[] resources = resolver.getResources(<span class="hljs-string">&quot;com.baizhi.mapper/*Mapper.xml&quot;</span>);
sqlSessionFactoryBean.setMapperLocations(resources)</code></pre></div>

<h4 id="5-4-2-配置Bean数据耦合的问题"><a href="#5-4-2-配置Bean数据耦合的问题" class="headerlink" title="5.4.2 配置Bean数据耦合的问题"></a>5.4.2 配置Bean数据耦合的问题</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">mybatis.driverClassName</span> = <span class="hljs-string">com.mysql.jdbc.Driver</span>
<span class="hljs-meta">mybatis.url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/suns?useSSL=false</span>
<span class="hljs-meta">mybatis.username</span> = <span class="hljs-string">root</span>
<span class="hljs-meta">mybatis.password</span> = <span class="hljs-string">123456</span>
<span class="hljs-meta">mybatis.typeAliasesPackages</span> = <span class="hljs-string">com.baizhiedu.mybatis</span>
<span class="hljs-meta">mybatis.mapperLocations</span> = <span class="hljs-string">com.baizhiedu.mapper/*Mapper.xml</span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@PropertySource(&quot;classpath:mybatis.properties&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisProperties</span> </span>&#123;
    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.driverClassName&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String driverClassName;
    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.url&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String url;
    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.username&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.password&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String password;
    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.typeAliasesPackages&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String typeAliasesPackages;
    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String mapperLocations;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisAutoConfiguration</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> MybatisProperties mybatisProperties;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;
        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();
        dataSource.setDriverClassName(mybatisProperties.getDriverClassName());
        dataSource.setUrl(mybatisProperties.getUrl());
        dataSource.setUsername(mybatisProperties.getUsername());
        dataSource.setPassword(mybatisProperties.getPassword());
        <span class="hljs-keyword">return</span> dataSource;
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactoryBean <span class="hljs-title">sqlSessionFactoryBean</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;
        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        sqlSessionFactoryBean.setTypeAliasesPackage(mybatisProperties.getTypeAliasesPackages(<span class="hljs-string">&quot;&quot;</span>));
        <span class="hljs-comment">//sqlSessionFactoryBean.setMapperLocations(new ClassPathResource(&quot;UserDAOMapper.xml&quot;));</span>

        <span class="hljs-keyword">try</span> &#123;
            ResourcePatternResolver resolver = <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver();
            Resource[] resources = resolver.getResources(mybatisProperties.getMapperLocations());
            sqlSessionFactoryBean.setMapperLocations(resources);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;

        <span class="hljs-keyword">return</span> sqlSessionFactoryBean;
    &#125;
&#125;</code></pre></div>

<h2 id="6-纯注解版事务编程"><a href="#6-纯注解版事务编程" class="headerlink" title="6. 纯注解版事务编程"></a>6. 纯注解版事务编程</h2><div class="hljs code-wrapper"><pre><code class="hljs xml">1. 原始对象 XXXService
   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baizhiedu.service.UserServiceImpl&quot;</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDAO&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDAO&quot;</span>/&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

   @Service
   public class UserServiceImpl implements UserService&#123;
         @Autowired
         private UserDAO userDAO;
   &#125;

2. 额外功能
   <span class="hljs-comment">&lt;!--DataSourceTransactionManager--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    @Bean
    public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource)&#123;
          DataSourceTransactionManager dstm = new DataSourceTransactionManager();
          dstm.setDataSource(dataSource);
          return dstm; 
    &#125;

3. 事务属性
    @Transactional
    @Service
    public class UserServiceImpl implements UserService &#123;
        @Autowired
        private UserDAO userDAO;

4. 基于Schema的事务配置 
   <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span>
   @EnableTransactionManager ---&gt; 配置Bean</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.baizhiedu.mybatis&quot;);
   SpringBoot 实现思想
<span class="hljs-bullet">2.</span> 注解版MVC整合，SpringMVC中进行详细讲解
   SpringMyBatis ---&gt;DAO  事务基于注解 --&gt; Service   Controller 
   org.springframework.web.context.ContextLoaderListener ---&gt; XML工厂 无法提供 new AnnotationConfigApplicationContext</code></pre></div>

<h2 id="7-Spring框架中YML的使用"><a href="#7-Spring框架中YML的使用" class="headerlink" title="7. Spring框架中YML的使用"></a>7. Spring框架中YML的使用</h2><h3 id="7-1-什么是YML"><a href="#7-1-什么是YML" class="headerlink" title="7.1 什么是YML"></a>7.1 什么是YML</h3><blockquote>
<p>YML(YAML) 是一种新形式的配置文件，比 XML 更简单，比 Properties 更强大</p>
</blockquote>
<h3 id="7-2-Properties进行配置问题"><a href="#7-2-Properties进行配置问题" class="headerlink" title="7.2 Properties进行配置问题"></a>7.2 Properties进行配置问题</h3><blockquote>
<ul>
<li>Properties 表达过于繁琐，无法表达数据的内在联系</li>
<li>Properties 无法表达对象、集合类型</li>
</ul>
</blockquote>
<h3 id="7-3-YML语法简介"><a href="#7-3-YML语法简介" class="headerlink" title="7.3 YML语法简介"></a>7.3 YML语法简介</h3><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">定义yml文件</span> 
   <span class="hljs-string">xxx.yml</span> <span class="hljs-string">xxx.yaml</span>
<span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">语法</span>
   <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">基本语法</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">suns</span>
      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>
   <span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">对象概念</span> 
      <span class="hljs-attr">account:</span> 
         <span class="hljs-attr">id:</span> <span class="hljs-number">1</span>
         <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>
   <span class="hljs-number">3</span><span class="hljs-string">.</span> <span class="hljs-string">定义集合</span> 
      <span class="hljs-attr">service:</span> 
         <span class="hljs-bullet">-</span> <span class="hljs-number">11111</span>
         <span class="hljs-bullet">-</span> <span class="hljs-number">22222</span></code></pre></div>

<h3 id="7-4-Spring与YML集成思路的分析"><a href="#7-4-Spring与YML集成思路的分析" class="headerlink" title="7.4 Spring与YML集成思路的分析"></a>7.4 Spring与YML集成思路的分析</h3><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 准备yml配置文件 
   init.yml
   name: suns
   password: 123456
<span class="hljs-bullet">2.</span> 读取yml 转换成 Properties
   YamlPropertiesFactoryBean.setResources( yml配置文件的路径 new ClassPathResource();) 
   YamlPropertiesFactoryBean.getObject() ---&gt; Properties 
<span class="hljs-bullet">3.</span> 应用PropertySourcesPlaceholderConfigurer
   PropertySourcesPlaceholderConfigurer.setProperties();
<span class="hljs-bullet">4.</span> 类中 @Value注解 注入</code></pre></div>

<h3 id="7-5-Spring与YML集成编码"><a href="#7-5-Spring与YML集成编码" class="headerlink" title="7.5 Spring与YML集成编码"></a>7.5 Spring与YML集成编码</h3><p><strong>环境搭建</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>snakeyaml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
最低版本 1.18</code></pre></div>

<p><strong>编码</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1. 准备yml配置文件</span>
<span class="hljs-comment">//2. 配置Bean中操作 完成YAML读取 与 PropertySourcePlaceholderConfigure的创建 </span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> PropertySourcesPlaceholderConfigurer <span class="hljs-title">configurer</span><span class="hljs-params">()</span> </span>&#123;
YamlPropertiesFactoryBean yamlPropertiesFactoryBean = <span class="hljs-keyword">new</span> YamlPropertiesFactoryBean();
      	<span class="hljs-comment">//读取</span>
        yamlPropertiesFactoryBean.setResources(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;init.yml&quot;</span>));
        Properties properties = yamlPropertiesFactoryBean.getObject();
      	<span class="hljs-comment">//创建好集合</span>
PropertySourcesPlaceholderConfigurer configurer = <span class="hljs-keyword">new</span> PropertySourcesPlaceholderConfigurer();
        configurer.setProperties(properties);
        <span class="hljs-keyword">return</span> configurer;
    &#125;
<span class="hljs-comment">//3. 类 加入 @Value注解 </span></code></pre></div>

<h3 id="7-6-Spring与YML集成的问题"><a href="#7-6-Spring与YML集成的问题" class="headerlink" title="7.6 Spring与YML集成的问题"></a>7.6 Spring与YML集成的问题</h3><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 集合处理的问题
   SpringEL表达式解决
   list:111,222,333
   @Value(&quot;#&#123;&#x27;$&#123;list&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)
<span class="hljs-bullet">2.</span> 对象类型的YAML进行配置时 过于繁琐 
   @Value(&quot;$&#123;account.name&#125;&quot;)

<span class="hljs-section"># SpringBoot解决了以上两个问题，利用@ConfigurationProperties</span></code></pre></div>

<h1 id="第六章、SpringMVC"><a href="#第六章、SpringMVC" class="headerlink" title="第六章、SpringMVC"></a>第六章、SpringMVC</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><blockquote>
<p>Spring Web MVC 是一种基于 Java 的实现了 Web MVC 设计模式的请求驱动类型的轻量级 Web 框架，即使用了 MVC 架构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC 也是要简化我们日常 Web 开发的。在 传统的 Jsp/Servlet 技术体系中，如果要开发接口，一个接口对应一个 Servlet，会导致我们开发出许多 Servlet，使用 SpringMVC 可以有效的简化这一步骤</p>
</blockquote>
<blockquote>
<p>Spring Web MVC 也是服务到工作者模式的实现，但进行可优化。前端控制器是 <code>DispatcherServlet</code>；应用控制器可以拆为处理器映射器<code>(Handler Mapping</code>)进行处理器管理和视图解析器(<code>View Resolver</code>)进行视图管理；页面控制器/动作/处理器为 Controller 接口（仅包含 <code>ModelAndView handleRequest</code>(request, response) 方法，也有人称作 Handler）的实现（也可以是任何的 POJO 类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持</p>
</blockquote>
<p><strong>Spring Web MVC能帮我们做什么</strong></p>
<ul>
<li>让我们能非常简单的设计出干净的 Web 层和薄薄的 Web 层；</li>
<li>进行更简洁的 Web 层的开发；</li>
<li>天生与 Spring 框架集成（如 IoC 容器、AOP 等）；</li>
<li>提供强大的约定大于配置的契约式编程支持；</li>
<li>能简单的进行 Web 层的单元测试；</li>
<li>支持灵活的 URL 到页面控制器的映射；</li>
<li>非常容易与其他视图技术集成，如 Velocity、FreeMarker 等等，因为模型数据不放在特定的 API 里，而是放在一个 Model 里（Map 数据结构实现，因此很容易被其他框架使用）；</li>
<li>非常灵活的数据验证、格式化和数据绑定机制，能使用任何对象进行数据绑定，不必实现特定框架的 API；</li>
<li>提供一套强大的 JSP 标签库，简化 JSP 开发；</li>
<li>支持灵活的本地化、主题等解析；</li>
<li>更加简单的异常处理；</li>
<li>对静态资源的支持；</li>
<li>支持 RESTful 风格</li>
</ul>
<h2 id="2-HelloWorld"><a href="#2-HelloWorld" class="headerlink" title="2. HelloWorld"></a>2. HelloWorld</h2><ul>
<li>在<code> pom.xml</code> 文件中，添加 spring-webmvc 的依赖：</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<p>添加 <code>spring-webmvc</code> 依赖之后，<code>spring-web、spring-aop、spring-context</code>等等就全部都加入进来了</p>
<ul>
<li>准备一个 Controller，即一个处理浏览器请求的接口。</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 这就是一个请求处理接口</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req 这就是前端发送来的请求</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp 这就是服务端给前端的响应</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回值是一个 ModelAndView，Model 相当于是我们的数据模型，View 是我们的视图</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);
        mv.addObject(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);
        <span class="hljs-keyword">return</span> mv;
    &#125;
&#125;</code></pre></div>

<p>这里我们我们创建出来的 Controller 就是前端请求处理接口</p>
<ul>
<li>创建视图</li>
</ul>
<p>这里我们就采用 jsp 作为视图，在 webapp 目录下创建<code>hello.jsp</code>文件，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;hello $&#123;name&#125;!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>

<ul>
<li>在 <code>resources</code> 目录下，创建一个名为<code> spring-servlet.xml</code> 的 springmvc 的配置文件，这里，我们先写一个简单的 demo ，因此可以先不用添加 spring 的配置</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>
		 <span class="hljs-comment">&lt;!--MyController实例--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.javaboy.helloworld.MyController&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;/hello&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--这个是处理器映射器，这种方式，请求地址其实就是一个 Bean 的名字，然后根据这个 bean 的名字查找对应的处理器--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerMapping&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/hello&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
   <span class="hljs-comment">&lt;!--处理适配器--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerAdapter&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--视图解析器--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/jsp/&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<ul>
<li>加载 springmvc 配置文件</li>
</ul>
<p>在 web 项目启动时，加载 springmvc 配置文件，这个配置是在 <code>web.xml</code>中完成的。</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre></div>

<p>所有请求都将自动拦截下来，拦截下来后，请求交给 <code>DispatcherServlet</code> 去处理，在加载 <code>DispatcherServlet</code> 时，还需要指定配置文件路径。这里有一个默认的规则，如果配置文件放在 <code>webapp/WEB-INF/ </code>目录下，并且配置文件的名字等于 <code>DispatcherServlet</code> 的名字+ <code>-servlet</code>（即这里的配置文件路径是 <code>webapp/WEB-INF/springmvc-servlet.xml</code>），如果是这样的话，可以不用添加<code> init-param</code> 参数，即不用手动配置 springmvc 的配置文件，框架会自动加载</p>
<ul>
<li><p>配置并启动项目</p>
</li>
<li><p>项目启动成功后，浏览器输入 <a target="_blank" rel="noopener" href="http://localhost:8080/hello">http://localhost:8080/hello</a> 就可以看到如下页面：</p>
</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/2-1.png" srcset="/img/loading.gif" lazyload alt="2-1.png"></p>
<h2 id="3-SpringMVC-工作流程"><a href="#3-SpringMVC-工作流程" class="headerlink" title="3. SpringMVC 工作流程"></a>3. SpringMVC 工作流程</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-1.png" srcset="/img/loading.gif" lazyload alt="3-1.png"></p>
<ul>
<li><code>DispatcherServlet</code>：前端控制器</li>
</ul>
<p>用户请求到达前端控制器，它就相当于 mvc 模式中的c，DispatcherServlet 是整个流程控制的中心，相当于是 SpringMVC 的大脑，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p>
<ul>
<li><code>HandlerMapping</code>：处理器映射器</li>
</ul>
<p>HandlerMapping 负责根据用户请求找到 Handler 即处理器（也就是我们所说的 Controller），SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等，在实际开发中，我们常用的方式是注解方式。</p>
<ul>
<li><code>Handler</code>：处理器</li>
</ul>
<p>Handler 是继 DispatcherServlet 前端控制器的后端控制器，在DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。由于 Handler 涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发 Handler。（这里所说的 Handler 就是指我们的 Controller）</p>
<ul>
<li><code>HandlAdapter</code>：处理器适配器</li>
</ul>
<p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<ul>
<li><code>ViewResolver</code>：视图解析器</li>
</ul>
<p>ViewResolver 负责将处理结果生成 View 视图，ViewResolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p>
<h2 id="4-DispatcherServlet"><a href="#4-DispatcherServlet" class="headerlink" title="4. DispatcherServlet"></a>4. DispatcherServlet</h2><h3 id="4-1-DispatcherServlet作用"><a href="#4-1-DispatcherServlet作用" class="headerlink" title="4.1 DispatcherServlet作用"></a>4.1 DispatcherServlet作用</h3><p><code>DispatcherServlet </code>是前端控制器设计模式的实现，提供 Spring Web MVC 的集中访问点，而且负责职责的分派，而且与 Spring IoC 容器无缝集成，从而可以获得 Spring 的所有好处。<code>DispatcherServlet</code> 主要用作职责调度工作，本身主要用于控制流程，主要职责如下：</p>
<ul>
<li>文件上传解析，如果请求类型是 <code>multipart</code> 将通过 <code>MultipartResolver</code> 进行文件上传解析；</li>
<li>通过<code> HandlerMapping</code>，将请求映射到处理器（返回一个 <code>HandlerExecutionChain</code>，它包括一个处理器、多个 <code>HandlerInterceptor</code> 拦截器）；</li>
<li>通过 <code>HandlerAdapter</code> 支持多种类型的处理器(<code>HandlerExecutionChain </code>中的处理器)；</li>
<li>通过 <code>ViewResolver </code>解析逻辑视图名到具体视图实现；</li>
<li>本地化解析；</li>
<li>渲染具体的视图等；</li>
<li>如果执行过程中遇到异常将交给 <code>HandlerExceptionResolver </code>来解析</li>
</ul>
<h3 id="4-2-DispathcherServlet配置详解"><a href="#4-2-DispathcherServlet配置详解" class="headerlink" title="4.2 DispathcherServlet配置详解"></a>4.2 DispathcherServlet配置详解</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>

<ul>
<li><code>load-on-startup</code>：表示启动容器时初始化该 Servlet；</li>
<li><code>url-pattern</code>：表示哪些请求交给 Spring Web MVC 处理， “/” 是用来定义默认 servlet 映射的。也可以如 <code>*.html</code>表示拦截所有以 html 为扩展名的请求</li>
<li><code>contextConfigLocation</code>：表示 SpringMVC 配置文件的路径</li>
</ul>
<p>其他的参数配置：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">contextClass</td>
<td align="left">实现WebApplicationContext接口的类，当前的servlet用它来创建上下文。如果这个参数没有指定， 默认使用XmlWebApplicationContext。</td>
</tr>
<tr>
<td align="left">contextConfigLocation</td>
<td align="left">传给上下文实例（由contextClass指定）的字符串，用来指定上下文的位置。这个字符串可以被分成多个字符串（使用逗号作为分隔符） 来支持多个上下文（在多上下文的情况下，如果同一个bean被定义两次，后面一个优先）。</td>
</tr>
<tr>
<td align="left">namespace</td>
<td align="left">WebApplicationContext命名空间。默认值是[server-name]-servlet。</td>
</tr>
</tbody></table>
<h3 id="4-3-Spring-配置"><a href="#4-3-Spring-配置" class="headerlink" title="4.3 Spring 配置"></a>4.3 Spring 配置</h3><p>之前的案例中，只有 SpringMVC，没有 Spring，Web 项目也是可以运行的。在实际开发中，Spring 和 SpringMVC 是分开配置的，所以我们对上面的项目继续进行完善，添加 Spring 相关配置。</p>
<p>首先，项目添加一个 service 包，提供一个 HelloService 类，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;
    &#125;
&#125;</code></pre></div>

<p>现在，假设我需要将 HelloService 注入到 Spring 容器中并使用它，这个是属于 Spring 层的 Bean，所以我们一般将除了 Controller 之外的所有 Bean 注册到 Spring 容器中，而将 Controller 注册到 SpringMVC 容器中，现在，在 resources 目录下添加 <code>applicationContext.xml </code>作为 spring 的配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.javaboy&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>但是，这个配置文件，默认情况下，并不会被自动加载，所以，需要我们在 web.xml 中对其进行配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre></div>

<p>首先通过 <code>context-param</code> 指定 Spring 配置文件的位置，这个配置文件也有一些默认规则，它的配置文件名默认就叫 <code>applicationContext.xml </code>，并且，如果你将这个配置文件放在 WEB-INF 目录下，那么这里就可以不用指定配置文件位置了，只需要指定监听器就可以了。这段配置是 Spring 集成 Web 环境的通用配置；一般用于加载除 Web 层的 Bean（如DAO、Service 等），以便于与其他任何Web框架集成。</p>
<ul>
<li><code>contextConfigLocation</code>：表示用于加载 Bean 的配置文件；</li>
<li><code>contextClass</code>：表示用于加载 Bean 的 <code>ApplicationContext </code>实现类，默认<code> WebApplicationContext</code></li>
</ul>
<p>配置完成之后，还需要修改 MyController，在 MyController 中注入 HelloSerivce:</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.springframework.stereotype.Controller(<span class="hljs-string">&quot;/hello&quot;</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    HelloService helloService;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 这就是一个请求处理接口</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req 这就是前端发送来的请求</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp 这就是服务端给前端的响应</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回值是一个 ModelAndView，Model 相当于是我们的数据模型，View 是我们的视图</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(helloService.hello(<span class="hljs-string">&quot;javaboy&quot;</span>));
        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);
        mv.addObject(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);
        <span class="hljs-keyword">return</span> mv;
    &#125;
&#125;</code></pre></div>

<p><strong>注意</strong></p>
<p>为了在 SpringMVC 容器中能够扫描到<code> MyController</code> ，这里给 <code>MyController</code> 添加了 <code>@Controller</code> 注解，同时，由于我们目前采用的<code>HandlerMapping</code>是 <code>BeanNameUrlHandlerMapping</code>（意味着请求地址就是处理器 Bean 的名字），所以，还需要手动指定<code>MyController</code>的名字。</p>
<p>最后，修改 SpringMVC 的配置文件，将 Bean 配置为扫描形式：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--只扫描Controller--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.javaboy.helloworld&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>


<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerMapping&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/hello&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerAdapter&quot;</span>/&gt;</span>
<span class="hljs-comment">&lt;!--视图解析器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/jsp/&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>配置完成后，再次启动项目，Spring 容器也将会被创建。访问 /hello 接口，<code>HelloService</code> 中的 hello 方法就会自动被调用</p>
<h3 id="4-4-两个容器"><a href="#4-4-两个容器" class="headerlink" title="4.4 两个容器"></a>4.4 两个容器</h3><p>当 Spring 和 SpringMVC 同时出现，我们的项目中将存在两个容器，一个是 Spring 容器，另一个是 SpringMVC 容器，Spring 容器通过 <code>ContextLoaderListener</code> 来加载，SpringMVC 容器则通过<code> DispatcherServlet</code> 来加载，这两个容器不一样：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5-4-1.png" srcset="/img/loading.gif" lazyload alt="5-4-1.png"></p>
<p>从图中可以看出：</p>
<ul>
<li><code>ContextLoaderListener</code> 初始化的上下文加载的 Bean 是对于整个应用程序共享的，不管是使用什么表现层技术，一般如 DAO 层、Service 层 Bean；</li>
<li><code>DispatcherServlet</code> 初始化的上下文加载的 Bean 是只对 Spring Web MVC 有效的 Bean，如 Controller、HandlerMapping、HandlerAdapter 等等，该初始化上下文应该只加载 Web相关组件</li>
<li>所以Controller里面能<code>@Autowired</code>Service，而Service里不能<code>@Autowired</code>Controller</li>
</ul>
<p><strong>为什么不在 Spring 容器中扫描所有 Bean？</strong></p>
<p>这个是不可能的。因为请求达到服务端后，找 <code>DispatcherServlet</code> 去处理，只会去 SpringMVC 容器中找，这就意味着 Controller 必须在 SpringMVC 容器中扫描。</p>
<p><strong>为什么不在 SpringMVC 容器中扫描所有 Bean？</strong></p>
<p>这个是可以的，可以在 SpringMVC 容器中扫描所有 Bean。不写在一起，有两个方面的原因：</p>
<ul>
<li>为了方便配置文件的管理</li>
<li>在 Spring+SpringMVC+Hibernate 组合中，实际上也不支持这种写法</li>
</ul>
<h2 id="5-处理器详解"><a href="#5-处理器详解" class="headerlink" title="5. 处理器详解"></a>5. 处理器详解</h2><h3 id="5-1-HandlerMapping"><a href="#5-1-HandlerMapping" class="headerlink" title="5.1 HandlerMapping"></a>5.1 HandlerMapping</h3><blockquote>
<p>注意，下文所说的处理器即我们平时所见到的 Controller</p>
</blockquote>
<p><code>HandlerMapping</code> ，中文译作处理器映射器，在 SpringMVC 中，系统提供了很多 <code>HandlerMapping</code>：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/6-1.png" srcset="/img/loading.gif" lazyload alt="6-1.png"></p>
<p><code>HandlerMapping</code> 是负责根据 request 请求找到对应的 Handler 处理器及 Interceptor 拦截器，将它们封装在 <code>HandlerExecutionChain </code>对象中返回给前端控制器。</p>
<ul>
<li><code>BeanNameUrlHandlerMapping</code></li>
</ul>
<p><code>BeanNameUrl</code> 处理器映射器，根据请求的 url 与 Spring 容器中定义的 bean 的 name 进行匹配，从而从 Spring 容器中找到 bean 实例，就是说，请求的 Url 地址就是处理器 Bean 的名字。</p>
<p>这个 <code>HandlerMapping</code> 配置如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerMapping&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/hello&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<ul>
<li><code>SimpleUrlHandlerMapping</code></li>
</ul>
<p><code>SimpleUrlHandlerMapping</code> 是 <code>BeanNameUrlHandlerMapping </code>的增强版本，它可以将 url 和处理器 bean 的 id 进行统一映射配置:</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerMapping&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mappings&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;/hello&quot;</span>&gt;</span>myController<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;/hello2&quot;</span>&gt;</span>myController2<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>注意，在 props 中，可以配置多个请求路径和处理器实例的映射关系</p>
<h3 id="5-2-HandlerAdapter"><a href="#5-2-HandlerAdapter" class="headerlink" title="5.2 HandlerAdapter"></a>5.2 HandlerAdapter</h3><p><code>HandlerAdapter</code>，中文译作处理器适配器</p>
<p><code>HandlerAdapter</code> 会根据适配器接口对后端控制器进行包装（适配），包装后即可对处理器进行执行，通过扩展处理器适配器可以执行多种类型的处理器，这里使用了适配器设计模式</p>
<p>在 SpringMVC 中，<code>HandlerAdapter</code> 也有诸多实现类：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/6-2.png" srcset="/img/loading.gif" lazyload alt="6-2.png"></p>
<ul>
<li><code>SimpleControllerHandlerAdapter</code></li>
</ul>
<p><code>SimpleControllerHandlerAdapter</code> 简单控制器处理器适配器，所有实现了 <code>org.springframework.web.servlet.mvc.Controller</code> 接口的 Bean 通过此适配器进行适配、执行，也就是说，如果我们开发的接口是通过实现 Controller 接口来完成的（不是通过注解开发的接口），那么 HandlerAdapter 必须是 <code>SimpleControllerHandlerAdapter</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span> /&gt;</span></code></pre></div>

<ul>
<li><code>HttpRequestHandlerAdapter</code></li>
</ul>
<p><code>HttpRequestHandlerAdapter</code>，http 请求处理器适配器，所有实现了 <code>org.springframework.web.HttpRequestHandler</code> 接口的 Bean 通过此适配器进行适配、执行。</p>
<p>例如存在如下接口：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpRequestHandler</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        System.out.println(<span class="hljs-string">&quot;-----MyController2-----&quot;</span>);
    &#125;
&#125;


&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span> id=<span class="hljs-string">&quot;handlerMapping&quot;</span>&gt;
    &lt;property name=<span class="hljs-string">&quot;mappings&quot;</span>&gt;
        &lt;props&gt;
            &lt;prop key=&quot;/hello2&quot;&gt;myController2&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;</span> id=<span class="hljs-string">&quot;handlerAdapter&quot;</span>/&gt;</code></pre></div>

<h3 id="5-3-最佳实践"><a href="#5-3-最佳实践" class="headerlink" title="5.3 最佳实践"></a>5.3 最佳实践</h3><p>各种情况都大概了解了，我们看下项目中的具体实践。</p>
<ul>
<li>组件自动扫描</li>
</ul>
<p>web 开发中，我们基本上不再通过 XML 或者 Java 配置来创建一个 Bean 的实例，而是直接通过组件扫描来实现 Bean 的配置，如果要扫描多个包，多个包之间用 , 隔开即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.sang&quot;</span>/&gt;</span></code></pre></div>

<ul>
<li><code>HandlerMapping</code></li>
</ul>
<p>正常情况下，我们在项目中使用的是<code> RequestMappingHandlerMapping</code>，这个是根据处理器中的注解，来匹配请求（即<code> @RequestMapping</code> 注解中的 url 属性）。因为在上面我们都是通过实现类来开发接口的，相当于还是一个类一个接口，所以，我们可以通过<code>RequestMappingHandlerMapping</code>来做处理器映射器，这样我们可以在一个类中开发出多个接口</p>
<ul>
<li><code>HandlerAdapter</code></li>
</ul>
<p>对于上面提到的通过 <code>@RequestMapping </code>注解所定义出来的接口方法，这些方法的调用都是要通过 <code>RequestMappingHandlerAdapter </code>这个适配器来实现</p>
<p>例如我们开发一个接口：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController3</span> </span>&#123;
    <span class="hljs-meta">@RequestMapping(&quot;/hello3&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello3&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>要能够访问到这个接口，我们需要 <code>RequestMappingHandlerMapping</code> 才能定位到需要执行的方法，需要 <code>RequestMappingHandlerAdapter</code>，才能执行定位到的方法，修改<code> spring-servlet.xml</code> 的配置文件如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.javaboy.helloworld&quot;</span>/&gt;</span>

<span class="hljs-comment">&lt;!--找到方法--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerMapping&quot;</span>/&gt;</span>
<span class="hljs-comment">&lt;!--执行方法--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;handlerAdapter&quot;</span>/&gt;</span>
  
    <span class="hljs-comment">&lt;!--视图解析器--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/jsp/&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>然后，启动项目，访问 /hello3 接口，就可以看到相应的页面了。</p>
<ul>
<li><strong>继续优化</strong></li>
</ul>
<p>由于开发中，我们常用的是 <code>RequestMappingHandlerMapping </code>和 <code>RequestMappingHandlerAdapter </code>，这两个有一个简化的写法，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></code></pre></div>

<p>可以用这一行配置，代替 <code>RequestMappingHandlerMapping</code> 和 <code>RequestMappingHandlerAdapter</code> 的两行配置。</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.javaboy.helloworld&quot;</span>/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--视图解析器--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/jsp/&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>访问效果和上一步的效果一样。<strong>这是我们实际开发中，最终配置的形态</strong></p>
<h2 id="6-Controller"><a href="#6-Controller" class="headerlink" title="6. Controller"></a>6. Controller</h2><h3 id="6-1-RequestMapping"><a href="#6-1-RequestMapping" class="headerlink" title="6.1 @RequestMapping"></a>6.1 @RequestMapping</h3><p>这个注解用来标记一个接口，这算是我们在接口开发中，使用最多的注解之一</p>
<h4 id="6-1-1-请求-URL"><a href="#6-1-1-请求-URL" class="headerlink" title="6.1.1 请求 URL"></a>6.1.1 请求 URL</h4><p>标记请求 URL 很简单，只需要在相应的方法上添加该注解即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>这里<code>@RequestMapping(“/hello”)</code>表示当请求地址为 /hello 的时候，这个方法会被触发。其中，地址可以是多个，就是可以多个地址映射到同一个方法。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@RequestMapping(&#123;&quot;/hello&quot;,&quot;/hello2&quot;&#125;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>这个配置，表示 /hello 和 /hello2 都可以访问到该方法</p>
<h4 id="6-1-2-请求窄化"><a href="#6-1-2-请求窄化" class="headerlink" title="6.1.2 请求窄化"></a>6.1.2 请求窄化</h4><p>同一个项目中，会存在多个接口，例如订单相关的接口都是 /order/xxx 格式的，用户相关的接口都是 /user/xxx 格式的。为了方便处理，这里的前缀（就是 /order、/user）可以统一在 Controller 上面处理。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@RequestMapping(&#123;&quot;/hello&quot;,&quot;/hello2&quot;&#125;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>当类上加了 <code>@RequestMapping</code> 注解之后，此时，要想访问到 hello ，地址就应该是 <code>/user/hello</code> 或者 <code>/user/hello2</code></p>
<h4 id="6-1-3-请求方法限定"><a href="#6-1-3-请求方法限定" class="headerlink" title="6.1.3 请求方法限定"></a>6.1.3 请求方法限定</h4><p>默认情况下，使用<code>@RequestMapping</code>注解定义好的方法，可以被 GET 请求访问到，也可以被 POST 请求访问到，但是 DELETE 请求以及 PUT 请求不可以访问到</p>
<p>当然，我们也可以指定具体的访问方法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>通过 <code>@RequestMapping</code> 注解，指定了该接口只能被 GET 请求访问到，此时，该接口就不可以被 POST 以及请求请求访问到了。强行访问会报如下错误：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/7-1-1.png" srcset="/img/loading.gif" lazyload alt="7-1-1.png"></p>
<p>当然，限定的方法也可以有多个：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST,RequestMethod.PUT,RequestMethod.DELETE&#125;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>此时，这个接口就可以被 GET、POST、PUT、以及 DELETE 访问到了。但是，由于 JSP 支支持 GET、POST 以及 HEAD ，所以这个测试，不能使用 JSP 做页面模板。可以讲视图换成其他的，或者返回 JSON，这里就不影响了。</p>
<h3 id="6-2-Controller-方法的返回值"><a href="#6-2-Controller-方法的返回值" class="headerlink" title="6.2 Controller 方法的返回值"></a>6.2 Controller 方法的返回值</h3><h4 id="6-2-1-返回-ModelAndView"><a href="#6-2-1-返回-ModelAndView" class="headerlink" title="6.2.1 返回 ModelAndView"></a>6.2.1 返回 ModelAndView</h4><p>如果是前后端不分的开发，大部分情况下，我们返回 <code>ModelAndView</code>，即数据模型+视图：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;hello&quot;</span>);
        mv.addObject(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);
        <span class="hljs-keyword">return</span> mv;
    &#125;
&#125;</code></pre></div>

<p>Model 中，放我们的数据，然后在<code> ModelAndView</code> 中指定视图名称。</p>
<h4 id="6-2-2-返回-Void"><a href="#6-2-2-返回-Void" class="headerlink" title="6.2.2 返回 Void"></a>6.2.2 返回 Void</h4><p>没有返回值。没有返回值，并不一定真的没有返回值，只是方法的返回值为 void，我们可以通过其他方式给前端返回。<strong>实际上，这种方式也可以理解为 Servlet 中的那一套方案。</strong></p>
<blockquote>
<p>注意，由于默认的 Maven 项目没有 Servlet，因此这里需要额外添加一个依赖：</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<ul>
<li>通过 <code>HttpServletRequest </code>做服务端跳转</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello2&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
    req.getRequestDispatcher(<span class="hljs-string">&quot;/jsp/hello.jsp&quot;</span>).forward(req,resp);<span class="hljs-comment">//服务器端跳转</span>
&#125;</code></pre></div>

<ul>
<li>通过 <code>HttpServletResponse</code> 做重定向</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello3&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello3</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    resp.sendRedirect(<span class="hljs-string">&quot;/hello.jsp&quot;</span>);
&#125;</code></pre></div>

<p>也可以自己手动指定响应头去实现重定向：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello3&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello3</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    resp.setStatus(<span class="hljs-number">302</span>);
    resp.addHeader(<span class="hljs-string">&quot;Location&quot;</span>, <span class="hljs-string">&quot;/jsp/hello.jsp&quot;</span>);
&#125;</code></pre></div>

<ul>
<li>通过 <code>HttpServletResponse</code> 给出响应</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello4&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello4</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);
    PrintWriter out = resp.getWriter();
    out.write(<span class="hljs-string">&quot;hello javaboy!&quot;</span>);
    out.flush();
    out.close();
&#125;</code></pre></div>

<p>这种方式，既可以返回 JSON，也可以返回普通字符串。</p>
<h4 id="6-2-3-返回字符串"><a href="#6-2-3-返回字符串" class="headerlink" title="6.2.3 返回字符串"></a>6.2.3 返回字符串</h4><ul>
<li><strong>返回逻辑视图名</strong></li>
</ul>
<p>前面的 ModelAndView 可以拆分为两部分，Model 和 View，在 SpringMVC 中，Model 我们可以直接在参数中指定，然后返回值是逻辑视图名：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello5&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello5</span><span class="hljs-params">(Model model)</span> </span>&#123;
    model.addAttribute(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;lucifer&quot;</span>);<span class="hljs-comment">//这是数据模型</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//表示去查找一个名为 hello 的视图</span>
&#125;</code></pre></div>

<ul>
<li><strong>服务端跳转</strong></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello5&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello5</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/jsp/hello.jsp&quot;</span>;
&#125;</code></pre></div>

<p>forward 后面跟上跳转的路径。</p>
<ul>
<li><strong>客户端跳转</strong></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello5&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello5</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/hello&quot;</span>;
&#125;</code></pre></div>

<p>这种，本质上就是浏览器重定向。</p>
<ul>
<li><strong>真的返回一个字符串</strong></li>
</ul>
<p>上面三个返回的字符串，都是由特殊含义的，如果一定要返回一个字符串，需要额外添加一个注意：<code>@ResponseBody</code> ，这个注解表示当前方法的返回值就是要展示出来返回值，没有特殊含义。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello5&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello5</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/hello&quot;</span>;
&#125;</code></pre></div>

<p>上面代码表示就是想返回一段内容为 <code>redirect:/user/hello</code> 的字符串，他没有特殊含义。注意，这里如果单纯的返回一个中文字符串，是会乱码的，可以在 <code>@RequestMapping</code> 中添加 produces 属性来解决：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/hello5&quot;,produces = &quot;text/html;charset=utf-8&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello5</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Java 语言程序设计&quot;</span>;
&#125;</code></pre></div>

<h3 id="6-3-参数绑定"><a href="#6-3-参数绑定" class="headerlink" title="6.3 参数绑定"></a>6.3 参数绑定</h3><h4 id="6-3-1-默认支持的参数类型"><a href="#6-3-1-默认支持的参数类型" class="headerlink" title="6.3.1 默认支持的参数类型"></a>6.3.1 默认支持的参数类型</h4><p>默认支持的参数类型，就是可以直接写在<code> @RequestMapping</code> 所注解的方法中的参数类型，一共有四类：</p>
<ul>
<li><strong>HttpServletRequest</strong></li>
<li><strong>HttpServletResponse</strong></li>
<li><strong>HttpSession</strong></li>
<li><strong>Model/ModelMap</strong></li>
</ul>
<p>这几个例子可以参考上一小节</p>
<p>在请求的方法中，默认的参数就是这几个，如果在方法中，刚好需要这几个参数，那么就可以把这几个参数加入到方法中。</p>
<h4 id="6-3-2-简单数据类型"><a href="#6-3-2-简单数据类型" class="headerlink" title="6.3.2 简单数据类型"></a>6.3.2 简单数据类型</h4><p><code>Integer、Boolean、Double </code>等等简单数据类型也都是支持的。例如添加一本书：</p>
<p>首先，在 /jsp/ 目录下创建 <code>add book.jsp</code> 作为图书添加页面：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=<span class="hljs-string">&quot;/doAdd&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;书名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;作者：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;价格：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;是否上架：&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;是
                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;false&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;否
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
           &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;
               &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加&quot;</span>&gt;
           &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>

<p>创建控制器，控制器提供两个功能，一个是访问 jsp 页面，另一个是提供添加接口：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookController</span> </span>&#123;
    <span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addBook</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;addbook&quot;</span>;
    &#125;

    <span class="hljs-meta">@RequestMapping(value = &quot;/doAdd&quot;,method = RequestMethod.POST)</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdd</span><span class="hljs-params">(String name,String author,Double price,Boolean ispublic)</span> </span>&#123;
        System.out.println(name);
        System.out.println(author);
        System.out.println(price);
        System.out.println(ispublic);
    &#125;
&#125;</code></pre></div>

<p>注意，由于 doAdd 方法确实不想返回任何值，所以需要给该方法添加 <code>@ResponseBody </code>注解，表示这个方法到此为止，不用再去查找相关视图了。另外， POST 请求传上来的中文会乱码，所以，我们在 <code>web.xml</code> 中再额外添加一个编码过滤器：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceRequestEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div>

<p>最后，浏览器中输入 <a target="_blank" rel="noopener" href="http://localhost:8080/book">http://localhost:8080/book</a> ，就可以执行添加操作，服务端会打印出来相应的日志。</p>
<p>在上面的绑定中，有一个要求，表单中字段的 name 属性要和接口中的变量名一一对应，才能映射成功，否则服务端接收不到前端传来的数据。有一些特殊情况，我们的服务端的接口变量名可能和前端不一致，这个时候我们可以通过 <code>@RequestParam </code>注解来解决。</p>
<ul>
<li><code>@RequestParam</code></li>
</ul>
<p>这个注解的的功能主要有三方面：</p>
<ol>
<li>给变量取别名</li>
<li>设置变量是否必填</li>
<li>给变量设置默认值</li>
</ol>
<p>如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/doAdd&quot;,method = RequestMethod.POST)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdd</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String bookname, String author, Double price, Boolean ispublic)</span> </span>&#123;
    System.out.println(bookname);
    System.out.println(author);
    System.out.println(price);
    System.out.println(ispublic);
&#125;</code></pre></div>

<p>注解中的 “name” 表示给 bookname 这个变量取的别名，也就是说，bookname 将接收前端传来的 name 这个变量的值。在这个注解中，还可以添加 <code>required </code>属性和 <code>defaultValue</code> 属性，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/doAdd&quot;,method = RequestMethod.POST)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdd</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;,required = true,defaultValue = &quot;三国演义&quot;)</span> String bookname, String author, Double price, Boolean ispublic)</span> </span>&#123;
    System.out.println(bookname);
    System.out.println(author);
    System.out.println(price);
    System.out.println(ispublic);
&#125;</code></pre></div>

<p>required 属性默认为 true，即只要添加了 <code>@RequestParam</code> 注解，这个参数默认就是必填的，如果不填，请求无法提交，会报 400 错误，如果这个参数不是必填项，可以手动把 required 属性设置为 false。但是，如果同时设置了 defaultValue，这个时候，前端不传该参数到后端，即使 required 属性为 true，它也不会报错。</p>
<h4 id="6-3-3-实体类"><a href="#6-3-3-实体类" class="headerlink" title="6.3.3 实体类"></a>6.3.3 实体类</h4><p>参数除了是简单数据类型之外，也可以是实体类。实际上，在开发中，大部分情况下，都是实体类。</p>
<p>还是上面的例子，我们改用一个 Book 对象来接收前端传来的数据：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String author;
    <span class="hljs-keyword">private</span> Double price;
    <span class="hljs-keyword">private</span> Boolean ispublic;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Book&#123;&quot;</span> +
                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, author=&#x27;&quot;</span> + author + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, price=&quot;</span> + price +
                <span class="hljs-string">&quot;, ispublic=&quot;</span> + ispublic +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> author;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(String author)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.author = author;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> price;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(Double price)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.price = price;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">getIspublic</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> ispublic;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIspublic</span><span class="hljs-params">(Boolean ispublic)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.ispublic = ispublic;
    &#125;
&#125;</code></pre></div>

<p>服务端接收数据方式如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/doAdd&quot;,method = RequestMethod.POST)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdd</span><span class="hljs-params">(Book book)</span> </span>&#123;
    System.out.println(book);
&#125;</code></pre></div>

<p>前端页面传值的时候和上面的一样，只需要写属性名就可以了，不需要写 book 对象名。</p>
<p>当然，对象中可能还有对象。例如如下对象：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Double price;
    <span class="hljs-keyword">private</span> Boolean ispublic;
    <span class="hljs-keyword">private</span> Author author;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(Author author)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.author = author;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Book&#123;&quot;</span> +
                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, price=&quot;</span> + price +
                <span class="hljs-string">&quot;, ispublic=&quot;</span> + ispublic +
                <span class="hljs-string">&quot;, author=&quot;</span> + author +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> price;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(Double price)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.price = price;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">getIspublic</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> ispublic;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIspublic</span><span class="hljs-params">(Boolean ispublic)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.ispublic = ispublic;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Author&#123;&quot;</span> +
                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, age=&quot;</span> + age +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> age;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;
&#125;</code></pre></div>

<p>Book 对象中，有一个 Author 属性，如何给 Author 属性传值呢？前端写法如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=<span class="hljs-string">&quot;/doAdd&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;书名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;作者姓名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author.name&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;作者年龄：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author.age&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;价格：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;是否上架：&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;是
                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;false&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;否
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
           &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;
               &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加&quot;</span>&gt;
           &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>

<p>这样在后端直接用 Book 对象就可以接收到所有数据了。</p>
<h4 id="6-3-4-自定义参数绑定"><a href="#6-3-4-自定义参数绑定" class="headerlink" title="6.3.4 自定义参数绑定"></a>6.3.4 自定义参数绑定</h4><p>前面的转换，都是系统自动转换的，这种转换仅限于基本数据类型。特殊的数据类型，系统无法自动转换，例如日期。例如前端传一个日期到后端，后端不是用字符串接收，而是使用一个 Date 对象接收，这个时候就会出现参数类型转换失败。这个时候，需要我们手动定义参数类型转换器，将日期字符串手动转为一个 Date 对象。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>&#123;

    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);
    
  	<span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String source)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">return</span> sdf.parse(source);
        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;</code></pre></div>

<p>在自定义的参数类型转换器中，将一个 String 转为 Date 对象，同时，将这个转换器注册为一个 Bean。</p>
<p>接下来，在 SpringMVC 的配置文件中，配置该 Bean，使之生效。</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">conversion-service</span>=<span class="hljs-string">&quot;conversionService&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversionService&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;converters&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;dateConverter&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>配置完成后，在服务端就可以接收前端传来的日期参数了。</p>
<h4 id="6-3-5-集合类的参数"><a href="#6-3-5-集合类的参数" class="headerlink" title="6.3.5 集合类的参数"></a>6.3.5 集合类的参数</h4><ul>
<li><strong>String 数组</strong></li>
</ul>
<p>String 数组可以直接用数组去接收，前端传递的时候，数组的传递其实就多相同的 key，这种一般用在 checkbox 中较多。</p>
<p>例如前端增加兴趣爱好一项：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/doAdd&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;书名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;作者姓名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author.name&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;作者年龄：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author.age&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;出生日期：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;date&quot; name=&quot;author.birthday&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;兴趣爱好：&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;favorites&quot;</span> value=<span class="hljs-string">&quot;足球&quot;</span>&gt;足球
                &lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;favorites&quot;</span> value=<span class="hljs-string">&quot;篮球&quot;</span>&gt;篮球
                &lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;favorites&quot;</span> value=<span class="hljs-string">&quot;乒乓球&quot;</span>&gt;乒乓球
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;价格：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;是否上架：&lt;/td&gt;
            &lt;td&gt;
                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;是
                &lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;false&quot;</span> name=<span class="hljs-string">&quot;ispublic&quot;</span>&gt;否
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
           &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;
               &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加&quot;</span>&gt;
           &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</code></pre></div>

<p>在服务端用一个数组去接收 favorites 对象：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/doAdd&quot;,method = RequestMethod.POST)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdd</span><span class="hljs-params">(Book book,String[] favorites)</span> </span>&#123;
    System.out.println(Arrays.toString(favorites));
    System.out.println(book);
&#125;</code></pre></div>

<p>注意，前端传来的数组对象，服务端不可以使用 List 集合去接收。</p>
<ul>
<li><strong>List 集合</strong></li>
</ul>
<p>如果需要使用 List 集合接收前端传来的数据，List 集合本身需要放在一个封装对象中，这个时候，List 中，可以是基本数据类型，也可以是对象。例如有一个班级类，班级里边有学生，学生有多个：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> List&lt;Student&gt; students;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyClass&#123;&quot;</span> +
                <span class="hljs-string">&quot;id=&quot;</span> + id +
                <span class="hljs-string">&quot;, students=&quot;</span> + students +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">getStudents</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> students;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStudents</span><span class="hljs-params">(List&lt;Student&gt; students)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.students = students;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +
                <span class="hljs-string">&quot;id=&quot;</span> + id +
                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;
&#125;</code></pre></div>

<p>添加班级的时候，可以传递多个 Student，前端页面写法如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/addclass&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;班级编号：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生编号：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[0].id&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生姓名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[0].name&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生编号：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[1].id&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生姓名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[1].name&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;
                &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</code></pre></div>

<p>服务端直接接收数据即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addclass&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addClass</span><span class="hljs-params">(MyClass myClass)</span> </span>&#123;
    System.out.println(myClass);
&#125;</code></pre></div>

<ul>
<li><strong>Map</strong></li>
</ul>
<p>相对于实体类而言，Map 是一种比较灵活的方案，但是，<strong>Map 可维护性比较差，因此一般不推荐使用</strong>。</p>
<p>例如给上面的班级类添加其他属性信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> List&lt;Student&gt; students;
    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; info;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyClass&#123;&quot;</span> +
                <span class="hljs-string">&quot;id=&quot;</span> + id +
                <span class="hljs-string">&quot;, students=&quot;</span> + students +
                <span class="hljs-string">&quot;, info=&quot;</span> + info +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> info;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInfo</span><span class="hljs-params">(Map&lt;String, Object&gt; info)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.info = info;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">getStudents</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> students;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStudents</span><span class="hljs-params">(List&lt;Student&gt; students)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.students = students;
    &#125;
&#125;</code></pre></div>

<p>在前端，通过如下方式给 info 这个 Map 赋值。</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/addclass&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;班级编号：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;班级名称：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;info[&#x27;name&#x27;]&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;班级位置：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;info[&#x27;pos&#x27;]&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生编号：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[0].id&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生姓名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[0].name&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生编号：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[1].id&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生姓名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;students[1].name&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;
                &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</code></pre></div>

<h3 id="6-4-ControllerAdvice"><a href="#6-4-ControllerAdvice" class="headerlink" title="6.4 @ControllerAdvice"></a>6.4 <strong>@ControllerAdvice</strong></h3><p><code>@ControllerAdvice </code>，很多初学者可能都没有听说过这个注解，实际上，这是一个非常有用的注解，顾名思义，这是一个增强的 Controller。使用这个 Controller ，可以实现三个方面的功能：</p>
<ul>
<li>全局异常处理</li>
<li>全局数据绑定</li>
<li>全局数据预处理</li>
</ul>
<blockquote>
<p>@ControllerAdvice返回的是页面，对应于@Controller；@RestControllerAdvice返回的是字符串，对应于@RestController</p>
</blockquote>
<p>灵活使用这三个功能，可以帮助我们简化很多工作，需要注意的是，这是 SpringMVC 提供的功能，在 Spring Boot 中可以直接使用，下面分别来看</p>
<h4 id="6-4-1-全局异常处理"><a href="#6-4-1-全局异常处理" class="headerlink" title="6.4.1 全局异常处理"></a>6.4.1 全局异常处理</h4><p>使用 <code>@ControllerAdvice </code>实现全局异常处理，只需要定义类，添加该注解即可定义方式如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGlobalExceptionHandler</span> </span>&#123;
    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">customException</span><span class="hljs-params">(Exception e)</span> </span>&#123;
        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();
        mv.addObject(<span class="hljs-string">&quot;message&quot;</span>, e.getMessage());
        mv.setViewName(<span class="hljs-string">&quot;myerror&quot;</span>);
        <span class="hljs-keyword">return</span> mv;
    &#125;
&#125;</code></pre></div>

<p>在该类中，可以定义多个方法，不同的方法处理不同的异常，例如专门处理空指针的方法、专门处理数组越界的方法…，也可以直接向上面代码一样，在一个方法中处理所有的异常信息。</p>
<p><code>@ExceptionHandler</code> 注解用来指明异常的处理类型，即如果这里指定为<code> NullpointerException</code>，则数组越界异常就不会进到这个方法中来。</p>
<h4 id="6-4-2-全局数据绑定"><a href="#6-4-2-全局数据绑定" class="headerlink" title="6.4.2 全局数据绑定"></a>6.4.2 全局数据绑定</h4><p>全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了<code> @ControllerAdvice</code> 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。</p>
<p>使用步骤，首先定义全局数据，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGlobalExceptionHandler</span> </span>&#123;
    <span class="hljs-meta">@ModelAttribute(name = &quot;md&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">mydata</span><span class="hljs-params">()</span> </span>&#123;
        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">99</span>);
        map.put(<span class="hljs-string">&quot;gender&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);
        <span class="hljs-keyword">return</span> map;
    &#125;
&#125;</code></pre></div>

<p>使用<code>@ModelAttribute</code>注解标记该方法的返回数据是一个全局数据，默认情况下，这个全局数据的 key 就是返回的变量名，value 就是方法返回值，当然开发者可以通过 <code>@ModelAttribute</code> 注解的 name 属性去重新指定 key。</p>
<p>定义完成后，在任何一个Controller 的接口中，都可以获取到这里定义的数据：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;
        Map&lt;String, Object&gt; map = model.asMap();
        System.out.println(map);
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello controller advice&quot;</span>;
    &#125;
&#125;</code></pre></div>

<h4 id="6-4-3-全局数据预处理"><a href="#6-4-3-全局数据预处理" class="headerlink" title="6.4.3 全局数据预处理"></a>6.4.3 全局数据预处理</h4><p>考虑我有两个实体类，Book 和 Author，分别定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Long price;
    <span class="hljs-comment">//getter/setter</span>
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-comment">//getter/setter</span>
&#125;</code></pre></div>

<p>此时，如果我定义一个数据添加接口，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/book&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book book, Author author)</span> </span>&#123;
    System.out.println(book);
    System.out.println(author);
&#125;</code></pre></div>

<p>这个时候，添加操作就会有问题，因为两个实体类都有一个 name 属性，从前端传递时 ，无法区分。此时，通过<code>@ControllerAdvice</code>的全局数据预处理可以解决这个问题</p>
<p>解决步骤如下:</p>
<p>1.给接口中的变量取别名</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/book&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;b&quot;)</span> Book book, <span class="hljs-meta">@ModelAttribute(&quot;a&quot;)</span> Author author)</span> </span>&#123;
    System.out.println(book);
    System.out.println(author);
&#125;</code></pre></div>

<p>2.进行请求数据预处理<br>在<code>@ControllerAdvice</code>标记的类中添加如下代码:</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@InitBinder(&quot;b&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">(WebDataBinder binder)</span> </span>&#123;
    binder.setFieldDefaultPrefix(<span class="hljs-string">&quot;b.&quot;</span>);
&#125;
<span class="hljs-meta">@InitBinder(&quot;a&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(WebDataBinder binder)</span> </span>&#123;
    binder.setFieldDefaultPrefix(<span class="hljs-string">&quot;a.&quot;</span>);
&#125;</code></pre></div>

<p><code>@InitBinder(“b”)</code> 注解表示该方法用来处理和Book和相关的参数,在方法中,给参数添加一个 b 前缀,即请求参数要有b前缀.</p>
<p>3.发送请求</p>
<p>请求发送时,通过给不同对象的参数添加不同的前缀,可以实现参数的区分.</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="6-3-4-总结"><a href="#6-3-4-总结" class="headerlink" title="6.3.4 总结"></a>6.3.4 总结</h4><p>这就是 <code>@ControllerAdvice </code>的几个简单用法，这些点既可以在传统的 SSM 项目中使用，也可以在 Spring Boot + Spring Cloud 微服务中使用</p>
<h2 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7. 文件上传"></a>7. 文件上传</h2><p>SpringMVC 中对文件上传做了封装，我们可以更加方便的实现文件上传。从 Spring3.1 开始，对于文件上传，提供了两个处理器：</p>
<ul>
<li><strong>CommonsMultipartResolver</strong></li>
<li><strong>StandardServletMultipartResolver</strong></li>
</ul>
<p>第一个处理器兼容性较好，可以兼容 Servlet3.0 之前的版本，但是它依赖了<code>commons-fileupload</code>这个第三方工具，所以如果使用这个，一定要添加 <code>commons-fileupload </code>依赖</p>
<p>第二个处理器兼容性较差，它适用于 Servlet3.0 之后的版本，它不依赖第三方工具，使用它，可以直接做文件上传</p>
<h3 id="7-1-CommonsMultipartResolver"><a href="#7-1-CommonsMultipartResolver" class="headerlink" title="7.1 CommonsMultipartResolver"></a>7.1 CommonsMultipartResolver</h3><p>使用<code> CommonsMultipartResolver</code> 做文件上传，需要首先添加 <code>commons-fileupload </code>依赖，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>然后，在 SpringMVC 的配置文件中，配置 <code>MultipartResolver</code>：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span>/&gt;</span></code></pre></div>

<p><strong>注意，这个 Bean 一定要有 id，并且 id 必须是 <code>multipartResolver</code></strong></p>
<p>接下来，创建 jsp 页面：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/upload&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;
    &lt;input type=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span>&gt;
    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;上传&quot;</span>&gt;
&lt;/form&gt;</code></pre></div>

<p>注意文件上传请求是 POST 请求，<code>enctype</code> 一定是<code> multipart/form-data</code>，同时<code>MultipartFile file</code>的<code>file</code>要和jsp中的一致</p>
<p>然后，开发文件上传接口：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController</span> </span>&#123;
    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;/yyyy/MM/dd/&quot;</span>);

    <span class="hljs-meta">@RequestMapping(&quot;/upload&quot;)</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;
      	<span class="hljs-comment">//1.准备文件夹</span>
        String format = sdf.format(<span class="hljs-keyword">new</span> Date());
        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">&quot;/img&quot;</span>) + format;
        File folder = <span class="hljs-keyword">new</span> File(realPath);
        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;
            folder.mkdirs();
        &#125;
      	<span class="hljs-comment">//2.准备文件名</span>
        String oldName = file.getOriginalFilename();
        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));
      	<span class="hljs-comment">//3.存储</span>
        <span class="hljs-keyword">try</span> &#123;
            file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));
        <span class="hljs-comment">//4.组装url</span>
            String url = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + <span class="hljs-string">&quot;/img&quot;</span> + format + newName;
            <span class="hljs-keyword">return</span> url;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;failed&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>这个文件上传方法中，一共做了四件事：</p>
<ul>
<li>解决文件保存路径，这里是保存在项目运行目录下的 img 目录下，然后利用日期继续宁分类</li>
<li>处理文件名问题，使用 UUID 做新的文件名，用来代替旧的文件名，可以有效防止文件名冲突</li>
<li>保存文件</li>
<li>生成文件访问路径</li>
</ul>
<blockquote>
<p>这里还有一个小问题，在 SpringMVC 中，静态资源默认都是被自动拦截的，无法访问，意味着上传成功的图片无法访问，因此，还需要我们在 SpringMVC 的配置文件中，再添加如下配置：</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/&quot;</span>/&gt;</span></code></pre></div>

<p>完成之后，就可以访问 jsp 页面，做文件上传了</p>
<p>当然，默认的配置不一定满足我们的需求，我们还可以自己手动配置文件上传大小等：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span>&gt;</span>
    <span class="hljs-comment">&lt;!--默认的编码--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--上传的总文件大小--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1048576&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--上传的单个文件大小--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSizePerFile&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1048576&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--内存中最大的数据量，超过这个数据量，数据就要开始往硬盘中写了--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxInMemorySize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4096&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--临时目录，超过 maxInMemorySize 配置的大小后，数据开始往临时目录写，等全部上传完成后，再将数据合并到正式的文件上传目录--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;uploadTempDir&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;file:///E:\\tmp&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<h3 id="7-2-StandardServletMultipartResolver"><a href="#7-2-StandardServletMultipartResolver" class="headerlink" title="7.2 StandardServletMultipartResolver"></a>7.2 StandardServletMultipartResolver</h3><p>这种文件上传方式，不需要依赖第三方 jar（主要是不需要添加<code>commons-fileupload</code>这个依赖），但是也不支持 Servlet3.0 之前的版本。</p>
<p>使用 <code>StandardServletMultipartResolver</code> ，那我们首先在 SpringMVC 的配置文件中，配置这个 Bean</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p><strong>注意，这里 Bean 的名字依然叫<code> multipartResolver</code></strong></p>
<p>配置完成后，注意，这个 Bean 无法直接配置上传文件大小等限制。需要在<code>web.xml</code>中进行配置（这里，即使不需要限制文件上传大小，也需要在 <code>web.xml </code>中配置 <code>multipart-config</code>）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">multipart-config</span>&gt;</span>
        <span class="hljs-comment">&lt;!--文件保存的临时目录，这个目录系统不会主动创建--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>E:\\temp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span>
        <span class="hljs-comment">&lt;!--上传的单个文件大小--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">max-file-size</span>&gt;</span>1048576<span class="hljs-tag">&lt;/<span class="hljs-name">max-file-size</span>&gt;</span>
        <span class="hljs-comment">&lt;!--上传的总文件大小--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">max-request-size</span>&gt;</span>1048576<span class="hljs-tag">&lt;/<span class="hljs-name">max-request-size</span>&gt;</span>
        <span class="hljs-comment">&lt;!--这个就是内存中保存的文件最大大小--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">file-size-threshold</span>&gt;</span>4096<span class="hljs-tag">&lt;/<span class="hljs-name">file-size-threshold</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">multipart-config</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>

<p>配置完成后，就可以测试文件上传了，测试方式和上面一样。</p>
<h3 id="7-3-多文件上传"><a href="#7-3-多文件上传" class="headerlink" title="7.3 多文件上传"></a>7.3 多文件上传</h3><p>多文件上传分为两种，一种是 key 相同的文件，另一种是 key 不同的文件。</p>
<h4 id="8-3-1-key-相同的文件"><a href="#8-3-1-key-相同的文件" class="headerlink" title="8.3.1 key 相同的文件"></a>8.3.1 key 相同的文件</h4><p>这种上传，前端页面一般如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload2&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;files&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div>

<p>主要是 input 节点中多了 <code>multiple</code> 属性。后端用一个数组来接收文件即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/upload2&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upload2</span><span class="hljs-params">(MultipartFile[] files, HttpServletRequest req)</span> </span>&#123;
    String format = sdf.format(<span class="hljs-keyword">new</span> Date());
    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">&quot;/img&quot;</span>) + format;
    File folder = <span class="hljs-keyword">new</span> File(realPath);
    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;
        folder.mkdirs();
    &#125;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">for</span> (MultipartFile file : files) &#123;
            String oldName = file.getOriginalFilename();
            String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));
            file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));
            String url = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + <span class="hljs-string">&quot;/img&quot;</span> + format + newName;
            System.out.println(url);
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre></div>

<h4 id="8-3-2-key-不同的文件"><a href="#8-3-2-key-不同的文件" class="headerlink" title="8.3.2 key 不同的文件"></a>8.3.2 key 不同的文件</h4><p>key 不同的，一般前端定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload3&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file2&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div>

<p>这种，在后端用不同的变量来接收就行了：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/upload3&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upload3</span><span class="hljs-params">(MultipartFile file1, MultipartFile file2, HttpServletRequest req)</span> </span>&#123;
    String format = sdf.format(<span class="hljs-keyword">new</span> Date());
    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">&quot;/img&quot;</span>) + format;
    File folder = <span class="hljs-keyword">new</span> File(realPath);
    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;
        folder.mkdirs();
    &#125;
    <span class="hljs-keyword">try</span> &#123;
        String oldName = file1.getOriginalFilename();
        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));
        file1.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));
        String url1 = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + <span class="hljs-string">&quot;/img&quot;</span> + format + newName;
        System.out.println(url1);
        String oldName2 = file2.getOriginalFilename();
        String newName2 = UUID.randomUUID().toString() + oldName2.substring(oldName2.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));
        file2.transferTo(<span class="hljs-keyword">new</span> File(folder, newName2));
        String url2 = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + <span class="hljs-string">&quot;/img&quot;</span> + format + newName2;
        System.out.println(url2);
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre></div>

<h2 id="8-全局异常处理"><a href="#8-全局异常处理" class="headerlink" title="8. 全局异常处理"></a>8. 全局异常处理</h2><p>项目中，可能会抛出多个异常，我们不可以直接将异常的堆栈信息展示给用户，有两个原因：</p>
<ul>
<li>用户体验不好</li>
<li>非常不安全</li>
</ul>
<p>所以，针对异常，我们可以自定义异常处理，SpringMVC 中，针对全局异常也提供了相应的解决方案，主要是通过 <code>@ControllerAdvice</code> 和 <code>@ExceptionHandler </code>两个注解来处理的。</p>
<p>以第八节的文件上传大小超出限制为例，自定义异常，只需要提供一个异常处理类即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-comment">//表示这是一个增强版的 Controller，主要用来做全局数据处理</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> </span>&#123;
    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">fileuploadException</span><span class="hljs-params">(Exception e)</span> </span>&#123;
        ModelAndView error = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>);
        error.addObject(<span class="hljs-string">&quot;error&quot;</span>, e.getMessage());
        <span class="hljs-keyword">return</span> error;
    &#125;
&#125;</code></pre></div>

<p>在这里：</p>
<ul>
<li><code>@ControllerAdvice</code> 表示这是一个增强版的 Controller，主要用来做全局数据处理</li>
<li><code>@ExceptionHandler</code> 表示这是一个异常处理方法，这个注解的参数，表示需要拦截的异常，参数为 Exception 表示拦截所有异常，这里也可以具体到某一个异常，如果具体到某一个异常，那么发生了其他异常则不会被拦截到。</li>
<li>异常方法的定义，和 Controller 中方法的定义一样，可以返回 <code>ModelAndview</code>，也可以返回 String 或者 void</li>
</ul>
<p>例如如下代码，指挥拦截文件上传异常，其他异常和它没关系，不会进入到自定义异常处理的方法中来。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-comment">//表示这是一个增强版的 Controller，主要用来做全局数据处理</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> </span>&#123;
    <span class="hljs-meta">@ExceptionHandler(MaxUploadSizeExceededException.class)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">fileuploadException</span><span class="hljs-params">(MaxUploadSizeExceededException e)</span> </span>&#123;
        ModelAndView error = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>);
        error.addObject(<span class="hljs-string">&quot;error&quot;</span>, e.getMessage());
        <span class="hljs-keyword">return</span> error;
    &#125;
&#125;</code></pre></div>

<h2 id="9-服务端数据校验"><a href="#9-服务端数据校验" class="headerlink" title="9. 服务端数据校验"></a>9. 服务端数据校验</h2><p>B/S 系统中对 http 请求数据的校验多数在客户端进行，这也是出于简单及用户体验性上考虑，但是在一些安全性要求高的系统中服务端校验是不可缺少的，实际上，几乎所有的系统，凡是涉及到数据校验，都需要在服务端进行二次校验。为什么要在服务端进行二次校验呢？这需要理解客户端校验和服务端校验各自的目的。</p>
<ol>
<li>客户端校验，我们主要是为了提高用户体验，例如用户输入一个邮箱地址，要校验这个邮箱地址是否合法，没有必要发送到服务端进行校验，直接在前端用 js 进行校验即可。但是大家需要明白的是，前端校验无法代替后端校验，前端校验可以有效的提高用户体验，但是无法确保数据完整性，因为在 B/S 架构中，用户可以方便的拿到请求地址，然后直接发送请求，传递非法参数。</li>
<li>服务端校验，虽然用户体验不好，但是可以有效的保证数据安全与完整性。</li>
<li>综上，实际项目中，两个一起用。</li>
</ol>
<p>Spring 支持 JSR-303 验证框架，JSR-303 是 JAVA EE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是 Hibernate Validator（与Hibernate ORM 没有关系），JSR-303 用于对 Java Bean 中的字段的值进行验证。</p>
<h3 id="9-1-普通校验"><a href="#9-1-普通校验" class="headerlink" title="9.1 普通校验"></a>9.1 普通校验</h3><p>普通校验，是这里最基本的用法。</p>
<p>首先，我们需要加入校验需要的依赖：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.0.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>接下来，在 SpringMVC 的配置文件中配置校验的 Bean：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;validatorFactoryBean&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;providerClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.hibernate.validator.HibernateValidator&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">validator</span>=<span class="hljs-string">&quot;validatorFactoryBean&quot;</span>/&gt;</span></code></pre></div>

<p>配置时，提供一个 <code>LocalValidatorFactoryBean</code> 的实例，然后 Bean 的校验使用<code> HibernateValidator</code></p>
<p>接下来，我们提供一个添加学生的页面：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/addstudent&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>学生编号：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>学生姓名：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>学生邮箱：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>学生年龄：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div>

<p>在这里需要提交的数据中，假设学生编号不能为空，学生姓名长度不能超过 10 且不能为空，邮箱地址要合法，年龄不能超过 150。那么在定义实体类的时候，就可以加入这个判断条件了。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
    <span class="hljs-meta">@NotNull</span>
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-meta">@NotNull</span>
    <span class="hljs-meta">@Size(min = 2,max = 10)</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@Email</span>
    <span class="hljs-keyword">private</span> String email;
    <span class="hljs-meta">@Max(150)</span>
    <span class="hljs-keyword">private</span> Integer age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmail</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> email;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +
                <span class="hljs-string">&quot;id=&quot;</span> + id +
                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, email=&#x27;&quot;</span> + email + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, age=&quot;</span> + age +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmail</span><span class="hljs-params">(String email)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.email = email;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> age;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;
&#125;</code></pre></div>

<p>在这里：</p>
<ul>
<li><code>@NotNull </code>表示这个字段不能为空</li>
<li><code>@Size </code>中描述了这个字符串长度的限制</li>
<li><code>@Email </code>表示这个字段的值必须是一个邮箱地址</li>
<li><code>@Max </code>表示这个字段的最大值</li>
</ul>
<p>定义完成后，接下来，在 Controller 中定义接口：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentController</span> </span>&#123;
    <span class="hljs-meta">@RequestMapping(&quot;/addstudent&quot;)</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Validated</span> Student student, BindingResult result)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">//校验未通过，获取所有的异常信息并展示出来</span>
            List&lt;ObjectError&gt; allErrors = result.getAllErrors();
            <span class="hljs-keyword">for</span> (ObjectError allError : allErrors) &#123;
                System.out.println(allError.getObjectName()+<span class="hljs-string">&quot;:&quot;</span>+allError.getDefaultMessage());
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>在这里：</p>
<ul>
<li><code>@Validated </code>表示 Student 中定义的校验规则将会生效</li>
<li><code>BindingResult</code> 表示出错信息，如果这个变量不为空，表示有错误，否则校验通过。</li>
</ul>
<p>接下来就可以启动项目了。访问 jsp 页面，然后添加 Student，查看校验规则是否生效。</p>
<p>默认情况下，打印出来的错误信息时系统默认的错误信息，这个错误信息，我们也可以自定义。自定义方式如下：</p>
<p>由于 properties 文件中的中文会乱码，所以需要我们先修改一下 IDEA 配置，点<code> File–&gt;Settings-&gt;Editor–&gt;File Encodings</code>，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/10-1-20210520170449224.png" srcset="/img/loading.gif" lazyload alt="10-1.png"></p>
<p>然后定义错误提示文本，在 resources 目录下新建一个 MyMessage.properties 文件，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">student.id.notnull</span>=<span class="hljs-string">id 不能为空</span>
<span class="hljs-meta">student.name.notnull</span>=<span class="hljs-string">name 不能为空</span>
<span class="hljs-meta">student.name.length</span>=<span class="hljs-string">name 最小长度为 2 ，最大长度为 10</span>
<span class="hljs-meta">student.email.error</span>=<span class="hljs-string">email 地址非法</span>
<span class="hljs-meta">student.age.error</span>=<span class="hljs-string">年龄不能超过 150</span></code></pre></div>

<p>接下来，在 SpringMVC 配置中，加载这个配置文件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;validatorFactoryBean&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;providerClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.hibernate.validator.HibernateValidator&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;validationMessageSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bundleMessageSource&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bundleMessageSource&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basenames&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
          	<span class="hljs-comment">&lt;!--没有后缀 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:MyMessage<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheSeconds&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;300&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">validator</span>=<span class="hljs-string">&quot;validatorFactoryBean&quot;</span>/&gt;</span></code></pre></div>

<p>最后，在实体类上的注解中，加上校验出错时的信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
    <span class="hljs-meta">@NotNull(message = &quot;&#123;student.id.notnull&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-meta">@NotNull(message = &quot;&#123;student.name.notnull&#125;&quot;)</span>
    <span class="hljs-meta">@Size(min = 2,max = 10,message = &quot;&#123;student.name.length&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@Email(message = &quot;&#123;student.email.error&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String email;
    <span class="hljs-meta">@Max(value = 150,message = &quot;&#123;student.age.error&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> Integer age;</code></pre></div>

<p>配置完成后，如果校验再出错，就会展示我们自己的出错信息了。</p>
<h3 id="9-2-分组校验"><a href="#9-2-分组校验" class="headerlink" title="9.2 分组校验"></a>9.2 分组校验</h3><p>由于校验规则都是定义在实体类上面的，但是，在不同的数据提交环境下，校验规则可能不一样。例如，用户的 id 是自增长的，添加的时候，可以不用传递用户 id，但是修改的时候则必须传递用户 id，这种情况下，就需要使用分组校验。</p>
<p>分组校验，首先需要定义校验组，所谓的校验组，其实就是<strong>空接口</strong>：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidationGroup1</span> </span>&#123;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidationGroup2</span> </span>&#123;
&#125;</code></pre></div>

<p>然后，在实体类中，指定每一个校验规则所属的组：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
    <span class="hljs-meta">@NotNull(message = &quot;&#123;student.id.notnull&#125;&quot;,groups = ValidationGroup1.class)</span>
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-meta">@NotNull(message = &quot;&#123;student.name.notnull&#125;&quot;,groups = &#123;ValidationGroup1.class, ValidationGroup2.class&#125;)</span>
    <span class="hljs-meta">@Size(min = 2,max = 10,message = &quot;&#123;student.name.length&#125;&quot;,groups = &#123;ValidationGroup1.class, ValidationGroup2.class&#125;)</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@Email(message = &quot;&#123;student.email.error&#125;&quot;,groups = &#123;ValidationGroup1.class, ValidationGroup2.class&#125;)</span>
    <span class="hljs-keyword">private</span> String email;
    <span class="hljs-meta">@Max(value = 150,message = &quot;&#123;student.age.error&#125;&quot;,groups = &#123;ValidationGroup2.class&#125;)</span>
    <span class="hljs-keyword">private</span> Integer age;</code></pre></div>

<p>在 group 中指定每一个校验规则所属的组，一个规则可以属于一个组，也可以属于多个组。</p>
<p>最后，在接收参数的地方，指定校验组：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentController</span> </span>&#123;
    <span class="hljs-meta">@RequestMapping(&quot;/addstudent&quot;)</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Validated(ValidationGroup2.class)</span> Student student, BindingResult result)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">//校验未通过，获取所有的异常信息并展示出来</span>
            List&lt;ObjectError&gt; allErrors = result.getAllErrors();
            <span class="hljs-keyword">for</span> (ObjectError allError : allErrors) &#123;
                System.out.println(allError.getObjectName()+<span class="hljs-string">&quot;:&quot;</span>+allError.getDefaultMessage());
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>配置完成后，属于<code> ValidationGroup2</code> 这个组的校验规则，才会生效。</p>
<h3 id="9-3-校验注解"><a href="#9-3-校验注解" class="headerlink" title="9.3 校验注解"></a>9.3 校验注解</h3><p>校验注解，主要有如下几种：</p>
<ul>
<li>@Null 被注解的元素必须为 null</li>
<li>@NotNull 被注解的元素必须不为 null</li>
<li>@AssertTrue 被注解的元素必须为 true</li>
<li>@AssertFalse 被注解的元素必须为 false</li>
<li>@Min(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li>@Max(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li>@DecimalMin(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li>@DecimalMax(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li>@Size(max=, min=) 被注解的元素的大小必须在指定的范围内</li>
<li>@Digits (integer, fraction) 被注解的元素必须是一个数字，其值必须在可接受的范围内</li>
<li>@Past 被注解的元素必须是一个过去的日期</li>
<li>@Future 被注解的元素必须是一个将来的日期</li>
<li>@Pattern(regex=,flag=) 被注解的元素必须符合指定的正则表达式</li>
<li>@NotBlank(message =) 验证字符串非 null，且长度必须大于0</li>
<li>@Email 被注解的元素必须是电子邮箱地址</li>
<li>@Length(min=,max=) 被注解的字符串的大小必须在指定的范围内</li>
<li>@NotEmpty 被注解的字符串的必须非空</li>
<li>@Range(min=,max=,message=) 被注解的元素必须在合适的范围内</li>
</ul>
<h2 id="10-数据回显"><a href="#10-数据回显" class="headerlink" title="10. 数据回显"></a>10. 数据回显</h2><h3 id="10-1-数据回显基本用法"><a href="#10-1-数据回显基本用法" class="headerlink" title="10.1 数据回显基本用法"></a>10.1 数据回显基本用法</h3><p>数据回显就是当用户数据提交失败时，自动填充好已经输入的数据。一般来说，如果使用 Ajax 来做数据提交，基本上是没有数据回显这个需求的，但是如果是通过表单做数据提交，那么数据回显就非常有必要了。</p>
<h4 id="10-1-1-简单数据类型"><a href="#10-1-1-简单数据类型" class="headerlink" title="10.1.1 简单数据类型"></a>10.1.1 简单数据类型</h4><p>简单数据类型，实际上框架在这里没有提供任何形式的支持，就是我们自己手动配置。我们继续在第 10 小节的例子上演示 Demo。加入提交的 Student 数据不符合要求，那么重新回到添加 Student 页面，并且预设之前已经填好的数据。</p>
<p>首先我们先来改造一下<code> student.jsp</code> 页面：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/addstudent&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;学生编号：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;$&#123;id&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生姓名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;name&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生邮箱：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;email&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生年龄：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;$&#123;age&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;
                &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</code></pre></div>

<p>在接收数据时，使用简单数据类型去接收：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addstudent&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStudent2</span><span class="hljs-params">(Integer id, String name, String email, Integer age, Model model)</span> </span>&#123;
    model.addAttribute(<span class="hljs-string">&quot;id&quot;</span>, id);
    model.addAttribute(<span class="hljs-string">&quot;name&quot;</span>, name);
    model.addAttribute(<span class="hljs-string">&quot;email&quot;</span>, email);
    model.addAttribute(<span class="hljs-string">&quot;age&quot;</span>, age);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&quot;</span>;
&#125;</code></pre></div>

<p>这种方式，相当于框架没有做任何工作，就是我们手动做数据回显的。此时访问页面，服务端会再次定位到该页面，而且数据已经预填好</p>
<h4 id="10-1-2-实体类"><a href="#10-1-2-实体类" class="headerlink" title="10.1.2 实体类"></a>10.1.2 实体类</h4><p>上面这种简单数据类型的回显，实际上非常麻烦，因为需要开发者在服务端一个一个手动设置。如果使用对象的话，就没有这么麻烦了，因为 SpringMVC 在页面跳转时，会自动将对象填充进返回的数据中</p>
<p>此时，首先修改一下<code> student.jsp</code> 页面：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/addstudent&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;学生编号：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;$&#123;student.id&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生姓名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;student.name&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生邮箱：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;student.email&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生年龄：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;$&#123;student.age&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;
                &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</code></pre></div>

<p>注意，在预填数据中，多了一个 <code>student.</code> 前缀。这 student 就是服务端接收数据的变量名，服务端的变量名和这里的 student 要保持一致。服务端定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addstudent&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@Validated(ValidationGroup2.class)</span> Student student, BindingResult result)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">//校验未通过，获取所有的异常信息并展示出来</span>
        List&lt;ObjectError&gt; allErrors = result.getAllErrors();
        <span class="hljs-keyword">for</span> (ObjectError allError : allErrors) &#123;
            System.out.println(allError.getObjectName()+<span class="hljs-string">&quot;:&quot;</span>+allError.getDefaultMessage());
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&quot;</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
&#125;</code></pre></div>

<p>注意，服务端什么都不用做，就说要返回的页面就行了，student 这个变量会被自动填充到返回的 Model 中。变量名就是填充时候的 key。如果想自定义这个 key，可以在参数中写出来 Model，然后手动加入 Student 对象，就像简单数据类型回显那样。</p>
<p>另一种定义回显变量别名的方式，就是使用<code>@ModelAttribute</code>注解</p>
<h3 id="10-2-ModelAttribute"><a href="#10-2-ModelAttribute" class="headerlink" title="10.2 @ModelAttribute"></a>10.2 @ModelAttribute</h3><p><code>@ModelAttribute</code> 这个注解，主要有两方面的功能：</p>
<ul>
<li>在数据回显时，给变量定义别名</li>
<li>定义全局数据</li>
</ul>
<h4 id="10-2-1-定义别名"><a href="#10-2-1-定义别名" class="headerlink" title="10.2.1 定义别名"></a>10.2.1 定义别名</h4><p>在数据回显时，给变量定义别名，非常容易，直接加这个注解即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addstudent&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;s&quot;)</span> <span class="hljs-meta">@Validated(ValidationGroup2.class)</span> Student student, BindingResult result)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">//校验未通过，获取所有的异常信息并展示出来</span>
        List&lt;ObjectError&gt; allErrors = result.getAllErrors();
        <span class="hljs-keyword">for</span> (ObjectError allError : allErrors) &#123;
            System.out.println(allError.getObjectName()+<span class="hljs-string">&quot;:&quot;</span>+allError.getDefaultMessage());
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&quot;</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
&#125;</code></pre></div>

<p>这样定义完成后，在前端再次访问回显的变量时，变量名称就不是 student 了，而是 s：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;/addstudent&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;学生编号：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;$&#123;s.id&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生姓名：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;$&#123;s.name&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生邮箱：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$&#123;s.email&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;学生年龄：&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;$&#123;s.age&#125;&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan=<span class="hljs-string">&quot;2&quot;</span>&gt;
                &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</code></pre></div>

<h4 id="10-2-2-定义全局数据"><a href="#10-2-2-定义全局数据" class="headerlink" title="10.2.2 定义全局数据"></a>10.2.2 定义全局数据</h4><p>假设有一个 Controller 中有很多方法，每个方法都会返回数据给前端，但是每个方法返回给前端的数据又不太一样，虽然不太一样，但是没有方法的返回值又有一些公共的部分。可以将这些公共的部分提取出来单独封装成一个方法，用 <code>@ModelAttribute </code>注解来标记。</p>
<p>例如在一个 Controller 中 ，添加如下代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute(&quot;info&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;
    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    map.put(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;lucifer&quot;</span>);
    map.put(<span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;www.github.com&quot;</span>);
    <span class="hljs-keyword">return</span> map;
&#125;</code></pre></div>

<p>当用户访问当前 Controller 中的任意一个方法，在返回数据时，都会将添加了<code>@ModelAttribute</code>注解的方法的返回值，一起返回给前端。<code>@ModelAttribute </code>注解中的 info 表示返回数据的 key</p>
<h2 id="11-JSON"><a href="#11-JSON" class="headerlink" title="11. JSON"></a>11. JSON</h2><h3 id="11-1-返回-JSON"><a href="#11-1-返回-JSON" class="headerlink" title="11.1 返回 JSON"></a>11.1 返回 JSON</h3><p>目前主流的 JSON 处理工具主要有三种：</p>
<ul>
<li><strong>jackson</strong></li>
<li><strong>gson</strong></li>
<li><strong>fastjson</strong></li>
</ul>
<p>在 SpringMVC 中，对 jackson 和 gson 都提供了相应的支持，就是如果使用这两个作为 JSON 转换器，只需要添加对应的依赖就可以了，返回的对象和返回的集合、Map 等都会自动转为 JSON，但是，如果使用 fastjson，除了添加相应的依赖之外，还需要自己手动配置 <code>HttpMessageConverter</code> 转换器。其实前两个也是使用 <code>HttpMessageConverter </code>转换器，但是是 SpringMVC 自动提供的，SpringMVC 没有给 fastjson 提供相应的转换器</p>
<h4 id="11-1-1-jackson"><a href="#11-1-1-jackson" class="headerlink" title="11.1.1 jackson"></a>11.1.1 jackson</h4><p>jackson 是一个使用比较多，时间也比较长的 JSON 处理工具，在 SpringMVC 中使用 jackson ，只需要添加 jackson 的依赖即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>依赖添加成功后，凡是在接口中直接返回的对象，集合等等，都会自动转为 JSON。如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String author;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> author;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(String author)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.author = author;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;
&#125;
<span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getBookById</span><span class="hljs-params">()</span> </span>&#123;
    Book book = <span class="hljs-keyword">new</span> Book();
    book.setId(<span class="hljs-number">1</span>);
    book.setName(<span class="hljs-string">&quot;三国演义&quot;</span>);
    book.setAuthor(<span class="hljs-string">&quot;罗贯中&quot;</span>);
    <span class="hljs-keyword">return</span> book;
&#125;</code></pre></div>

<p>这里返回一个对象，但是在前端接收到的则是一个 JSON 字符串，这个对象会通过 <code>HttpMessageConverter </code>自动转为 JSON 字符串</p>
<p>如果想返回一个 JSON 数组，写法如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title">getAllBooks</span><span class="hljs-params">()</span> </span>&#123;
    List&lt;Book&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Book&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
        Book book = <span class="hljs-keyword">new</span> Book();
        book.setId(i);
        book.setName(<span class="hljs-string">&quot;三国演义:&quot;</span> + i);
        book.setAuthor(<span class="hljs-string">&quot;罗贯中:&quot;</span> + i);
        list.add(book);
    &#125;
    <span class="hljs-keyword">return</span> list;
&#125;</code></pre></div>

<p>添加了 jackson ，就能够自动返回 JSON，这个依赖于一个名为<code> HttpMessageConverter</code> 的类，这本身是一个接口，从名字上就可以看出，它的作用是 Http 消息转换器，既然是消息转换器，它提供了两方面的功能：</p>
<ul>
<li>将返回的对象转为 JSON</li>
<li>将前端提交上来的 JSON 转为对象</li>
</ul>
<p>但是，<code>HttpMessageConverter </code>只是一个接口，由各个 JSON 工具提供相应的实现，在 jackson 中，实现的名字叫做 <code>MappingJackson2HttpMessageConverter</code>，而这个东西的初始化，则由 SpringMVC 来完成。除非自己有一些自定义配置的需求，否则一般来说不需要自己提供 <code>MappingJackson2HttpMessageConverter</code></p>
<p>举一个简单的应用场景，例如每一本书，都有一个出版日期，修改 Book 类如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String author;
    <span class="hljs-keyword">private</span> Date publish;


    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getPublish</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> publish;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPublish</span><span class="hljs-params">(Date publish)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.publish = publish;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> author;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(String author)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.author = author;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;
&#125;</code></pre></div>

<p>然后在构造 Book 时添加日期属性：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getBookById</span><span class="hljs-params">()</span> </span>&#123;
    Book book = <span class="hljs-keyword">new</span> Book();
    book.setId(<span class="hljs-number">1</span>);
    book.setName(<span class="hljs-string">&quot;三国演义&quot;</span>);
    book.setAuthor(<span class="hljs-string">&quot;罗贯中&quot;</span>);
    book.setPublish(<span class="hljs-keyword">new</span> Date());
    <span class="hljs-keyword">return</span> book;
&#125;</code></pre></div>

<p>访问 <code>/book </code>接口，返回的 json 格式如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/12-1-1.png" srcset="/img/loading.gif" lazyload alt="12-1-1.png"></p>
<p>如果我们想自己定制返回日期的格式，简单的办法，可以通过添加注解来实现：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String author;
    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;,timezone = &quot;Asia/Shanghai&quot;)</span>
    <span class="hljs-keyword">private</span> Date publish;</code></pre></div>

<p>注意这里一定要设置时区</p>
<p>这样，就可以定制返回的日期格式了</p>
<p>但是，这种方式有一个弊端，这个注解可以加在属性上，也可以加在类上，也就说，最大可以作用到一个类中的所有日期属性上。如果项目中有很多实体类都需要做日期格式化，使用这种方式就比较麻烦了，这个时候，我们可以自己提供一个 jackson 的 <code>HttpMesageConverter </code>实例，在这个实例中，自己去配置相关属性，这里的配置将是一个全局配置</p>
<p>在 SpringMVC 配置文件中，添加如下配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;objectMapper&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateFormat&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.text.SimpleDateFormat&quot;</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>/&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;timeZone&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>添加完成后，去掉 Book 实体类中日期格式化的注解，再进行测试，结果如下：</p>
<h4 id="11-1-2-gson"><a href="#11-1-2-gson" class="headerlink" title="11.1.2 gson"></a>11.1.2 gson</h4><p>gson 是 Google 推出的一个 JSON 解析器，主要在 Android 开发中使用较多，不过，Web 开发中也是支持这个的，而且 SpringMVC 还针对 Gson 提供了相关的自动化配置，以致我们在项目中只要添加 gson 依赖，就可以直接使用 gson 来做 JSON 解析</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>如果项目中，同时存在 jackson 和 gson 的话，那么默认使用的是 jackson，在 <code>org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter</code> 类的构造方法中，加载顺序就是先加载 jackson 的 <code>HttpMessageConverter</code>，后加载 gson 的<code> HttpMessageConverter</code></p>
<p>加完依赖之后，就可以直接返回 JSON 字符串了。使用 Gson 时，如果想做自定义配置，则需要自定义 <code>HttpMessageConverter</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.GsonHttpMessageConverter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gson&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.google.gson.Gson&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;gsonBuilder&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;create&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.google.gson.GsonBuilder&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;gsonBuilder&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateFormat&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<h4 id="11-1-3-fastjson"><a href="#11-1-3-fastjson" class="headerlink" title="11.1.3 fastjson"></a>11.1.3 fastjson</h4><p>fastjson 号称最快的 JSON 解析器，但是也是这三个中 BUG 最多的一个。在 SpringMVC 并没针对 fastjson 提供相应的<code> HttpMessageConverter</code>，所以，fastjson 在使用时，一定要自己手动配置 <code>HttpMessageConverter</code>（前面两个如果没有特殊需要，直接添加依赖就可以了）</p>
<p>使用 fastjson，我们首先添加 fastjson 依赖：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.60<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>然后在 SpringMVC 的配置文件中配置 <code>HttpMessageConverter</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fastJsonConfig&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateFormat&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>fastjson 默认中文乱码，添加如下配置解决</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;httpMessageConverter&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fastJsonConfig&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateFormat&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;supportedMediaTypes&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>application/json;charset=utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<h3 id="12-2-接收-JSON"><a href="#12-2-接收-JSON" class="headerlink" title="12.2 接收 JSON"></a>12.2 接收 JSON</h3><p>浏览器传来的参数，可以是 <code>key/value </code>形式的，也可以是一个 JSON 字符串。在 <code>Jsp/Servlet</code> 中，我们接收 <code>key/value</code> 形式的参数，一般是通过<code>getParameter</code>方法。如果客户端商户传入的是 JSON 数据，我们可以通过如下格式进行解析：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addbook2&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook2</span><span class="hljs-params">(HttpServletRequest req)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();
    Book book = om.readValue(req.getInputStream(), Book.class);
    System.out.println(book);
&#125;</code></pre></div>

<p>但是这种解析方式有点麻烦，在 SpringMVC 中，我们可以通过一个注解来快速的将一个 JSON 字符串转为一个对象：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addbook3&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook3</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Book book)</span> </span>&#123;
    System.out.println(book);
&#125;</code></pre></div>

<p>这样就可以直接收到前端传来的 JSON 字符串了。这也是 <code>HttpMessageConverter </code>提供的第二个功能</p>
<h2 id="12-RESTful"><a href="#12-RESTful" class="headerlink" title="12. RESTful"></a>12. RESTful</h2><p>越来越多的人开始意识到，网站即软件，而且是一种新型的软件。这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，现在我们必须考虑，如何开发在互联网环境中使用的软件。</p>
<p>RESTful 架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>
<p>RESTful 它不是一个具体的架构，不是一个软件，不是一个框架，<strong>而是一种规范</strong>。在移动互联网兴起之前，我们都很少提及 RESTful，主要是因为用的少，移动互联网兴起后，RESTful 得到了非常广泛的应用，因为在移动互联网兴起之后，我们再开发后端应用，就不仅仅只是开发一个网站了，还对应了多个前端（Android、iOS、HTML5 等等），这个时候，我们在设计后端接口是，就需要考虑接口的形式，格式，参数的传递等等诸多问题了。</p>
<h3 id="12-1-起源"><a href="#12-1-起源" class="headerlink" title="12.1 起源"></a>12.1 起源</h3><p>REST 这个词，是 Roy Thomas Fielding 在他 2000 年的博士论文中提出的。</p>
<p>Fielding 是一个非常重要的人，他是 HTTP 协议（1.0版和1.1版）的主要设计者、Apache 服务器软件的作者之一、Apache 基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p>
<p>他这样介绍论文的写作目的：</p>
<p>“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”</p>
<h3 id="12-2-名称"><a href="#12-2-名称" class="headerlink" title="12.2 名称"></a>12.2 名称</h3><p>Fielding 将他对互联网软件的架构原则，定名为REST，即 Representational State Transfer 的缩写。我对这个词组的翻译是”表现层状态转化”。</p>
<p>如果一个架构符合 REST 原则，就称它为 RESTful 架构。</p>
<p>要理解 RESTful 架构，最好的方法就是去理解 Representational State Transfer 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会 REST 是一种什么样的设计。</p>
<h3 id="12-3-资源（Resources）"><a href="#12-3-资源（Resources）" class="headerlink" title="12.3 资源（Resources）"></a>12.3 资源（Resources）</h3><p>REST 的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>
<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个 URI （统一资源定位符）指向它，每种资源对应一个特定的 URI。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的 URI。</p>
<blockquote>
<p>在 RESTful 风格的应用中，每一个 URI 都代表了一个资源。</p>
</blockquote>
<h3 id="12-4-表现层（Representation）"><a href="#12-4-表现层（Representation）" class="headerlink" title="12.4 表现层（Representation）"></a>12.4 表现层（Representation）</h3><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>
<p>比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。</p>
<p>URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的 “.html” 后缀名是不必要的，因为这个后缀名表示格式，属于 “表现层” 范畴，而 URI 应该只代表”资源”的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对”表现层”的描述。</p>
<h3 id="12-5-状态转化（State-Transfer）"><a href="#12-5-状态转化（State-Transfer）" class="headerlink" title="12.5 状态转化（State Transfer）"></a>12.5 状态转化（State Transfer）</h3><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>
<p>客户端用到的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：</p>
<ul>
<li>GET 用来获取资源</li>
<li>POST 用来新建资源（也可以用于更新资源）</li>
<li>PUT 用来更新资源</li>
<li>DELETE 用来删除资源</li>
</ul>
<h3 id="12-6-综述"><a href="#12-6-综述" class="headerlink" title="12.6 综述"></a>12.6 综述</h3><p>综合上面的解释，我们总结一下什么是 RESTful 架构：</p>
<ul>
<li><strong>每一个 URI 代表一种资源；</strong></li>
<li><strong>客户端和服务器之间，传递这种资源的某种表现层；</strong></li>
<li><strong>客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化”</strong></li>
</ul>
<h3 id="12-7-误区"><a href="#12-7-误区" class="headerlink" title="12.7 误区"></a>12.7 误区</h3><p>RESTful 架构有一些典型的设计误区。</p>
<p>最常见的一种设计错误，就是 URI 包含动词。因为”资源”表示一种实体，所以应该是名词，URI 不应该有动词，动词应该放在 HTTP 协议中。</p>
<p>举例来说，某个 URI 是 /posts/show/1，其中 show 是动词，这个 URI 就设计错了，正确的写法应该是 /posts/1，然后用 GET 方法表示 show。</p>
<p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户 1 向账户 2 汇款 500 元，错误的 URI 是：</p>
<ul>
<li>POST /accounts/1/transfer/500/to/2</li>
</ul>
<p>正确的写法是把动词 transfer 改成名词 transaction，资源不能是动词，但是可以是一种服务：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">POST</span> <span class="hljs-string">/transaction HTTP/1.1</span>
<span class="hljs-attr">Host</span>: <span class="hljs-string">127.0.0.1</span>
<span class="hljs-attr">from</span>=<span class="hljs-string">1&amp;to=2&amp;amount=500.00</span></code></pre></div>

<p>另一个设计误区，就是在URI中加入版本号：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.example.com/app/1.0/foo">http://www.example.com/app/1.0/foo</a></li>
<li><a target="_blank" rel="noopener" href="http://www.example.com/app/1.1/foo">http://www.example.com/app/1.1/foo</a></li>
<li><a target="_blank" rel="noopener" href="http://www.example.com/app/2.0/foo">http://www.example.com/app/2.0/foo</a></li>
</ul>
<p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个 URI。版本号可以在 HTTP 请求头信息的 Accept 字段中进行区分（参见 Versioning REST Services）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">Accept</span>: <span class="hljs-string">vnd.example-com.foo+json; version=1.0</span>
<span class="hljs-attr">Accept</span>: <span class="hljs-string">vnd.example-com.foo+json; version=1.1</span>
<span class="hljs-attr">Accept</span>: <span class="hljs-string">vnd.example-com.foo+json; version=2.0</span></code></pre></div>

<h3 id="12-8-命名规则"><a href="#12-8-命名规则" class="headerlink" title="12.8 命名规则"></a>12.8 命名规则</h3><p>路径又称”终点”（endpoint），表示 API 的具体网址。实际开发中常见的规范如下：</p>
<ol>
<li><strong>网址中不能有动词，只能有名词，API 中的名词也应该使用复数。</strong>因为 REST 中的资源往往和数据库中的表对应，而数据库中的表都是同种记录的”集合”（collection）。如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。比如：<code>GET /calculate?param1=11&amp;param2=33</code> 。</li>
<li><strong>不用大写字母，建议用中杠 - 不用下杠 _</strong> 。比如邀请码写成 <code>invitation-code</code>而不是 <del>invitation_code</del> 。</li>
<li><strong>善用版本化 API</strong>。当我们的 API 发生了重大改变而不兼容前期版本的时候，我们可以通过 URL 来实现版本化，比如 <code>Http://api.example.com/v1</code>、<code>http://apiv1.example.com</code> 。版本不必非要是数字，只是数字用的最多，日期、季节都可以作为版本标识符，项目团队达成共识就可。</li>
<li><strong>接口尽量使用名词，避免使用动词。</strong> RESTful API 操作（HTTP Method）的是资源（名词）而不是动作（动词）。</li>
</ol>
<blockquote>
<p>GET    /classes：列出所有班级<br>POST   /classes：新建一个班级<br>GET    /classes/classId：获取某个指定班级的信息<br>PUT    /classes/classId：更新某个指定班级的信息（一般倾向整体更新）<br>PATCH  /classes/classId：更新某个指定班级的信息（一般倾向部分更新）<br>DELETE /classes/classId：删除某个班级<br>GET    /classes/classId/teachers：列出某个指定班级的所有老师的信息<br>GET    /classes/classId/students：列出某个指定班级的所有学生的信息<br>DELETE classes/classId/teachers/ID：删除某个指定班级下的指定的老师的信息</p>
</blockquote>
<p>理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源:<code>/schools</code>，老师: <code>/schools/teachers</code>，学生: <code>/schools/students</code> 就是二级资源</p>
<p><strong>过滤信息（Filtering）</strong></p>
<p>如果我们在查询的时候需要添加特定条件的话，建议使用 url 参数的形式。比如我们要查询 state 状态为 active 并且 name 为 guidegege 的班级：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">GET</span>    <span class="hljs-string">/classes?state=active&amp;name=guidegege</span></code></pre></div>

<p>比如我们要实现分页查询：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">GET</span>    <span class="hljs-string">/classes?page=1&amp;size=10 //指定第1页，每页10个数据</span></code></pre></div>

<p><strong>状态码（Status Codes）</strong></p>
<table>
<thead>
<tr>
<th>2xx：成功</th>
<th>3xx：重定向</th>
<th>4xx：客户端错误</th>
<th>5xx：服务器错误</th>
</tr>
</thead>
<tbody><tr>
<td>200 成功</td>
<td>301 永久重定向</td>
<td>400 错误请求</td>
<td>500 服务器错误</td>
</tr>
<tr>
<td>201 创建</td>
<td>304 资源未修改</td>
<td>401 未授权</td>
<td>502 网关错误</td>
</tr>
<tr>
<td></td>
<td></td>
<td>403 禁止访问</td>
<td>504 网关超时</td>
</tr>
<tr>
<td></td>
<td></td>
<td>404 未找到</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>405 请求方法不对</td>
<td></td>
</tr>
</tbody></table>
<h3 id="12-9-SpringMVC-的支持"><a href="#12-9-SpringMVC-的支持" class="headerlink" title="12.9 SpringMVC 的支持"></a>12.9 SpringMVC 的支持</h3><p>SpringMVC 对 RESTful 提供了非常全面的支持，主要有如下几个注解：</p>
<ul>
<li><code>@RestController</code></li>
</ul>
<p>这个注解是一个组合注解：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RestController &#123;

	<span class="hljs-comment">/**</span>
<span class="hljs-comment">	 * The value may indicate a suggestion for a logical component name,</span>
<span class="hljs-comment">	 * to be turned into a Spring bean in case of an autodetected component.</span>
<span class="hljs-comment">	 * <span class="hljs-doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span>
<span class="hljs-comment">	 * <span class="hljs-doctag">@since</span> 4.0.1</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-meta">@AliasFor(annotation = Controller.class)</span>
	<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;

&#125;</code></pre></div>

<p>一般，直接用 <code>@RestController</code> 来标记 Controller，可以不使用 <code>@Controller</code></p>
<p>请求方法中，提供了常见的请求方法：</p>
<ul>
<li><code>@PostMapping</code></li>
<li><code>@GetMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
</ul>
<p>另外还有一个提取请求地址中的参数的注解 <code>@PathVariable</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/book/&#123;id&#125;&quot;)</span><span class="hljs-comment">//http://localhost:8080/book/2</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;
    Book book = <span class="hljs-keyword">new</span> Book();
    book.setId(id);
    <span class="hljs-keyword">return</span> book;
&#125;</code></pre></div>

<p>参数 2 将被传递到 id 这个变量上</p>
<h2 id="13-静态资源访问"><a href="#13-静态资源访问" class="headerlink" title="13. 静态资源访问"></a>13. 静态资源访问</h2><p>在 SpringMVC 中，静态资源，默认都是被拦截的，例如 html、js、css、jpg、png、txt、pdf 等等，都是无法直接访问的。因为所有请求都被拦截了，所以，针对静态资源，我们要做额外处理，处理方式很简单，直接在 SpringMVC 的配置文件中，添加如下内容：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/static/html/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/html/&quot;</span>/&gt;</span></code></pre></div>

<p>mapping 表示映射规则，也是拦截规则，就是说，如果请求地址是<code>/static/html</code>这样的格式的话，那么对应的资源就去<code>/static/html/</code>这个目录下查找。</p>
<p>在映射路径的定义中，最后是两个 *，这是一种 Ant 风格的路径匹配符号，一共有三个通配符：</p>
<table>
<thead>
<tr>
<th align="left">通配符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">**</td>
<td align="left">匹配多层路径</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配一层路径</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配任意单个字符</td>
</tr>
</tbody></table>
<p>一个比较原始的配置方式可能如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/static/html/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/html/&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/static/js/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/js/&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/static/css/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/css/&quot;</span>/&gt;</span></code></pre></div>

<p>但是，由于 ** 可以表示多级路径，所以，以上配置，我们可以进行简化：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/&quot;</span>/&gt;</span></code></pre></div>

<h2 id="14-拦截器"><a href="#14-拦截器" class="headerlink" title="14. 拦截器"></a>14. 拦截器</h2><p>SpringMVC 中的拦截器，相当于<code>Jsp/Servlet</code>中的过滤器，只不过拦截器的功能更为强大。</p>
<p>拦截器的定义非常容易：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyInterceptor1:preHandle&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyInterceptor1:postHandle&quot;</span>);

    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyInterceptor1:afterCompletion&quot;</span>);

    &#125;
&#125;
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyInterceptor2:preHandle&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyInterceptor2:postHandle&quot;</span>);

    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyInterceptor2:afterCompletion&quot;</span>);

    &#125;
&#125;</code></pre></div>

<p>拦截器定义好之后，需要在 SpringMVC 的配置文件中进行配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;myInterceptor1&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;myInterceptor2&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></code></pre></div>

<p>如果存在多个拦截器，拦截规则如下：</p>
<ul>
<li>preHandle 按拦截器定义顺序调用</li>
<li>postHandler 按拦截器定义逆序调用</li>
<li>afterCompletion 按拦截器定义逆序调用</li>
<li>postHandler 在拦截器链内所有拦截器返成功调用</li>
<li>afterCompletion 只有 preHandle 返回 true 才调用</li>
</ul>
<h1 id="第七章、SpringMVC整合"><a href="#第七章、SpringMVC整合" class="headerlink" title="第七章、SpringMVC整合"></a>第七章、SpringMVC整合</h1><h2 id="1-MVC框架整合思想"><a href="#1-MVC框架整合思想" class="headerlink" title="1. MVC框架整合思想"></a>1. MVC框架整合思想</h2><h3 id="1-1-搭建Web运行环境"><a href="#1-1-搭建Web运行环境" class="headerlink" title="1.1 搭建Web运行环境"></a>1.1 搭建Web运行环境</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>


<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjrt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h3 id="1-2-为什么要整合MVC框架"><a href="#1-2-为什么要整合MVC框架" class="headerlink" title="1.2 为什么要整合MVC框架"></a>1.2 为什么要整合MVC框架</h3><ul>
<li>MVC框架提供了控制器(Controller)调用Service<br>DAO —&gt; Service </li>
<li>请求响应的处理</li>
<li>接受请求参数 request.getParameter(“”)</li>
<li>控制程序的运行流程</li>
<li>视图解析 (JSP JSON Freemarker Thyemeleaf )</li>
</ul>
<h3 id="1-3-Spring可以整合那些MVC框架"><a href="#1-3-Spring可以整合那些MVC框架" class="headerlink" title="1.3 Spring可以整合那些MVC框架"></a>1.3 Spring可以整合那些MVC框架</h3><ul>
<li>struts1 </li>
<li>webwork</li>
<li>jsf</li>
<li>struts2</li>
<li>springMVC </li>
</ul>
<h3 id="1-4-Spring整合MVC框架的核心思路"><a href="#1-4-Spring整合MVC框架的核心思路" class="headerlink" title="1.4 Spring整合MVC框架的核心思路"></a>1.4 Spring整合MVC框架的核心思路</h3><h4 id="1-4-1-准备工厂"><a href="#1-4-1-准备工厂" class="headerlink" title="1.4.1 准备工厂"></a>1.4.1 准备工厂</h4><p><strong>Web 开发过程中如何创建工厂?</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationContext ctx = <span class="hljs-keyword">new</span> WebXmlApplicationContext(<span class="hljs-string">&quot;/applicationContext.xml&quot;</span>);</code></pre></div>

<p><strong>如何保证工厂唯一，同时被共用？</strong></p>
<ul>
<li>共用：工厂存储在 <code>ServletContext</code> 这个作用域中，<code>ServletContext.setAttribute(&quot;xxx&quot;, ctx);</code></li>
<li>唯一：在 <code>ServletContext</code> 对象创建的同时创建工厂<ul>
<li><code>ServletContextListener</code> 在 <code>ServletContext</code> 对象创建的同时，被调用（只会被调用一次），把创建工厂的代码写在 <code>ServletContextListener</code> 中，也会保证只调用一次，保证了工厂的唯一性</li>
</ul>
</li>
</ul>
<p><strong>Spring 封装了一个 <code>ContextLoaderListener</code>，主要做了两件事：</strong></p>
<ol>
<li>创建工厂</li>
<li>把工厂存在 <code>ServletContext</code> 中</li>
</ol>
<p><code>ContextLoaderListener</code> 使用方式：<code>web.xml</code> 中</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span> org.springframework.web.context.ContextLoaderListener <span class="hljs-tag">&lt;/<span class="hljs-name">listen-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span> contextConfigLocation <span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span> classpath:applicationContext.xml <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre></div>

<p>同时需要在<code>web.xml</code> 中也需要加上MVC相关</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
      												<span class="hljs-comment">&lt;!--MVC的配置文件--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>

<h4 id="1-4-2-代码整合"><a href="#1-4-2-代码整合" class="headerlink" title="1.4.2 代码整合"></a>1.4.2 代码整合</h4><blockquote>
<p>依赖注入：把Sevice对象注入个控制器对象</p>
</blockquote>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20200520143653347.png" srcset="/img/loading.gif" lazyload alt="image-20200520143653347"></p>
<h2 id="2-基于注解SpringMVC"><a href="#2-基于注解SpringMVC" class="headerlink" title="2 .基于注解SpringMVC"></a>2 .基于注解SpringMVC</h2><h3 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1 创建工程"></a>2.1 创建工程</h3><p>创建一个普通的 Maven 工程（注意，这里可以不必创建 Web 工程），并添加 SpringMVC 的依赖，同时，这里环境的搭建需要用到 Servlet ，所以我们还需要引入 Servlet 的依赖（一定不能使用低版本的 Servlet），最终的 pom.xml 文件如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h3 id="2-2-添加-Spring-配置"><a href="#2-2-添加-Spring-配置" class="headerlink" title="2.2 添加 Spring 配置"></a>2.2 添加 Spring 配置</h3><p>工程创建成功之后，首先添加 Spring 的配置文件，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;, useDefaultFilters = true, excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class)&#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>&#123;
&#125;</code></pre></div>

<ul>
<li><code>@Configuration</code> 注解表示这是一个配置类，在我们这里，这个配置的作用类似于<code> applicationContext.xml</code></li>
<li><code>@ComponentScan </code>注解表示配置包扫描，里边的属性和 xml 配置中的属性都是一一对应的，<code>useDefaultFilters</code> 表示使用默认的过滤器，然后又除去 Controller 注解，即在 Spring 容器中扫描除了 Controller 之外的其他所有 Bean 。</li>
</ul>
<h3 id="2-3-添加-SpringMVC-配置"><a href="#2-3-添加-SpringMVC-配置" class="headerlink" title="2.3 添加 SpringMVC 配置"></a>2.3 添加 SpringMVC 配置</h3><p>接下来再来创建 springmvc 的配置文件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;,useDefaultFilters = false,includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION,classes = Controller.class)&#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> </span>&#123;
&#125;</code></pre></div>

<p><strong>注意，如果不需要在 SpringMVC 中添加其他的额外配置，这样就可以了。即 视图解析器、JSON 解析、文件上传……等等，如果都不需要配置的话，这样就可以了</strong></p>
<h3 id="2-4-配置-web-xml"><a href="#2-4-配置-web-xml" class="headerlink" title="2.4 配置 web.xml"></a>2.4 配置 web.xml</h3><p>此时，我们并没有 web.xml 文件，这时，我们可以使用 Java 代码去代替 web.xml 文件，这里会用到 <code>WebApplicationInitializer</code> ，具体定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebInit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebApplicationInitializer</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;
        <span class="hljs-comment">//首先来加载 SpringMVC 的配置文件</span>
        AnnotationConfigWebApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigWebApplicationContext();
        ctx.register(SpringMVCConfig.class);
        <span class="hljs-comment">// 添加 DispatcherServlet</span>
        ServletRegistration.Dynamic springmvc = servletContext.addServlet(<span class="hljs-string">&quot;springmvc&quot;</span>, <span class="hljs-keyword">new</span> DispatcherServlet(ctx));
        <span class="hljs-comment">// 给 DispatcherServlet 添加路径映射</span>
        springmvc.addMapping(<span class="hljs-string">&quot;/&quot;</span>);
        <span class="hljs-comment">// 给 DispatcherServlet 添加启动时机</span>
        springmvc.setLoadOnStartup(<span class="hljs-number">1</span>);
    &#125;
&#125;</code></pre></div>

<p><code>WebInit</code> 的作用类似于 web.xml，这个类需要实现 <code>WebApplicationInitializer</code> 接口，并实现接口中的方法，当项目启动时，<code>onStartup</code> 方法会被自动执行，我们可以在这个方法中做一些项目初始化操作，例如加载 SpringMVC 容器，添加过滤器，添加 Listener、添加 Servlet 等。</p>
<p><strong>注意：</strong></p>
<p>由于我们在 WebInit 中只是添加了 SpringMVC 的配置，这样项目在启动时只会去加载 SpringMVC 容器，而不会去加载 Spring 容器，如果一定要加载 Spring 容器，需要我们修改 SpringMVC 的配置，在 SpringMVC 配置的包扫描中也去扫描<code>@Configuration</code>注解，进而加载 Spring 容器，还有一种方案可以解决这个问题，就是直接在项目中舍弃 Spring 配置，直接将所有配置放到 SpringMVC 的配置中来完成，这个在 SSM 整合时是没有问题的，在实际开发中，较多采用第二种方案，第二种方案，SpringMVC 的配置如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> </span>&#123;
&#125;</code></pre></div>

<p>这种方案中，所有的注解都在 SpringMVC 中扫描，采用这种方案的话，则 Spring 的配置文件就可以删除了</p>
<h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><p>最后，添加一个 HelloController ，然后启动项目进行测试：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>启动项目，访问接口，结果如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/10-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="2-6-其他配置"><a href="#2-6-其他配置" class="headerlink" title="2.6 其他配置"></a>2.6 其他配置</h3><h4 id="2-6-1-静态资源过滤"><a href="#2-6-1-静态资源过滤" class="headerlink" title="2.6.1 静态资源过滤"></a>2.6.1 静态资源过滤</h4><p>静态资源过滤在 SpringMVC 的 XML 中的配置如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/&quot;</span>/&gt;</span></code></pre></div>

<p>在 Java 配置的 SSM 环境中，如果要配置静态资源过滤，需要让 SpringMVC 的配置继承 <code>WebMvcConfigurationSupport </code>，进而重写 <code>WebMvcConfigurationSupport </code>中的方法，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;
        registry.addResourceHandler(<span class="hljs-string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>重写 addResourceHandlers 方法，在这个方法中配置静态资源过滤，这里我将静态资源放在 resources 目录下，所以资源位置是 <code>classpath:/</code> ，当然，资源也可以放在 webapp 目录下，此时只需要修改配置中的资源位置即可。如果采用 Java 来配置 SSM 环境，一般来说，可以不必使用 webapp 目录，除非要使用 JSP 做页面模板，否则可以忽略 webapp 目录。</p>
<h4 id="2-6-2-视图解析器"><a href="#2-6-2-视图解析器" class="headerlink" title="2.6.2 视图解析器"></a>2.6.2 视图解析器</h4><p>在 XML 文件中，通过如下方式配置视图解析器：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>如果通过 Java 类，一样也可以实现类似功能。</p>
<p>首先为我们的项目添加 webapp 目录，webapp 目录中添加一个 jsp 目录，jsp 目录中添加 jsp 文件：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/10-2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>然后引入 JSP 的依赖：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>然后，在配置类中，继续重写方法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>&#123;
        registry.jsp(<span class="hljs-string">&quot;/jsp/&quot;</span>, <span class="hljs-string">&quot;.jsp&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>接下来，在 <code>Controller</code> 中添加控制器即可访问 JSP 页面：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController2</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/hello2&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
    &#125;
&#125;</code></pre></div>

<h4 id="2-6-3-路径映射"><a href="#2-6-3-路径映射" class="headerlink" title="2.6.3 路径映射"></a>2.6.3 路径映射</h4><p>有的时候，我们的控制器的作用仅仅只是一个跳转，就像上面小节中的控制器，里边没有任何业务逻辑，像这种情况，可以不用定义方法，可以直接通过路径映射来实现页面访问。如果在 <code>XML</code> 中配置路径映射，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">status-code</span>=<span class="hljs-string">&quot;200&quot;</span>/&gt;</span></code></pre></div>

<p>这行配置，表示如果用户访问 <code>/hello</code> 这个路径，则直接将名为 <code>hello</code> 的视图返回给用户，并且响应码为 <code>200</code>，这个配置就可以替代 <code>Controller</code> 中的方法。</p>
<p>相同的需求，如果在 <code>Java</code> 代码中，写法如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;
        registry.addViewController(<span class="hljs-string">&quot;/hello3&quot;</span>).setViewName(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>此时，用户访问 <code>/hello3</code> 接口，就能看到名为 <code>hello</code> 的视图文件</p>
<h4 id="2-6-4-JSON-配置"><a href="#2-6-4-JSON-配置" class="headerlink" title="2.6.4 JSON 配置"></a>2.6.4 JSON 配置</h4><p>SpringMVC 可以接收JSON 参数，也可以返回 JSON 参数，这一切依赖于 <code>HttpMessageConverter</code></p>
<p><code>HttpMessageConverter </code>可以将一个 JSON 字符串转为 对象，也可以将一个对象转为 JSON 字符串，实际上它的底层还是依赖于具体的 JSON 库</p>
<p>所有的 JSON 库要在 SpringMVC 中自动返回或者接收 JSON，都必须提供和自己相关的 <code>HttpMessageConverter </code></p>
<p>SpringMVC 中，默认提供了<code>Jackson</code>和 <code>gson </code>的 <code>HttpMessageConverter</code> ，分别是：<code>MappingJackson2HttpMessageConverter</code> 和 <code>GsonHttpMessageConverter </code></p>
<p>正因为如此，我们在 SpringMVC 中，如果要使用 JSON ，对于 jackson 和 gson 我们只需要添加依赖，加完依赖就可以直接使用了。具体的配置是在 <code>AllEncompassingFormHttpMessageConverter</code> 类中完成的</p>
<p>如果开发者使用了<code> fastjson</code>，那么默认情况下，SpringMVC 并没有提供<code> fastjson</code> 的 <code>HttpMessageConverter </code>，这个需要我们自己提供，如果是在 XML 配置中，<code>fastjson</code> 除了加依赖，还要显式配置 <code>HttpMessageConverter</code>，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></code></pre></div>

<p>在 Java 配置的 SSM 中，我们一样也可以添加这样的配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = &quot;org.javaboy&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;
        FastJsonHttpMessageConverter converter = <span class="hljs-keyword">new</span> FastJsonHttpMessageConverter();
        converter.setDefaultCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));
        FastJsonConfig fastJsonConfig = <span class="hljs-keyword">new</span> FastJsonConfig();
        fastJsonConfig.setCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));
        converter.setFastJsonConfig(fastJsonConfig);
        converters.add(converter);
    &#125;
&#125;</code></pre></div>

<p>然后，就可以在接口中直接返回 JSON 了，此时的 JSON 数据将通过<code>fastjson</code>生成</p>
<h2 id="3-Spring-Boot-中自定义-SpringMVC"><a href="#3-Spring-Boot-中自定义-SpringMVC" class="headerlink" title="3.Spring Boot 中自定义 SpringMVC"></a>3.Spring Boot 中自定义 SpringMVC</h2><p>用过 Spring Boot 的小伙伴都知道，我们只需要在项目中引入 <code>spring-boot-starter-web</code> 依赖，SpringMVC 的一整套东西就会自动给我们配置好，但是，真实的项目环境比较复杂，系统自带的配置不一定满足我们的需求，往往我们还需要结合实际情况自定义配置。</p>
<h3 id="3-1-概览"><a href="#3-1-概览" class="headerlink" title="3.1 概览"></a>3.1 概览</h3><p>首先我们需要明确，跟自定义 SpringMVC 相关的类和注解主要有如下四个：</p>
<ul>
<li>WebMvcConfigurerAdapter</li>
<li>WebMvcConfigurer</li>
<li>WebMvcConfigurationSupport</li>
<li>@EnableWebMvc</li>
</ul>
<p>这四个中，除了第四个是注解，另外三个两个类一个接口，里边的方法看起来好像都类似，但是实际使用效果却大不相同，因此很多小伙伴容易搞混。</p>
<h3 id="3-2-WebMvcConfigurerAdapter"><a href="#3-2-WebMvcConfigurerAdapter" class="headerlink" title="3.2 WebMvcConfigurerAdapter"></a>3.2 WebMvcConfigurerAdapter</h3><p>我们先来看 WebMvcConfigurerAdapter，这个是在 Spring Boot 1.x 中我们自定义 SpringMVC 时继承的一个抽象类，这个抽象类本身是实现了 WebMvcConfigurer 接口，然后抽象类里边都是空方法，我们来看一下这个类的声明：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;
    <span class="hljs-comment">//各种 SpringMVC 配置的方法</span>
&#125;</code></pre></div>

<p>再来看看这个类的注释：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * An implementation of &#123;<span class="hljs-doctag">@link</span> WebMvcConfigurer&#125; with empty methods allowing</span>
<span class="hljs-comment"> * subclasses to override only the methods they&#x27;re interested in.</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@deprecated</span> as of 5.0 &#123;<span class="hljs-doctag">@link</span> WebMvcConfigurer&#125; has default methods (made</span>
<span class="hljs-comment"> * possible by a Java 8 baseline) and can be implemented directly without the</span>
<span class="hljs-comment"> * need for this adapter</span>
<span class="hljs-comment"> */</span></code></pre></div>

<p>这段注释关于这个类说的很明白了。同时我们也看到，从 Spring5 开始，由于我们要使用 Java8，而 Java8 中的接口允许存在 default 方法，因此官方建议我们直接实现 WebMvcConfigurer 接口，而不是继承 WebMvcConfigurerAdapter 。</p>
<p><strong>也就是说，在 Spring Boot 1.x 的时代，如果我们需要自定义 SpringMVC 配置，直接继承 WebMvcConfigurerAdapter 类即可。</strong></p>
<h3 id="3-3-WebMvcConfigurer"><a href="#3-3-WebMvcConfigurer" class="headerlink" title="3.3 WebMvcConfigurer"></a>3.3 WebMvcConfigurer</h3><p>根据上一小节的解释，小伙伴们已经明白了，WebMvcConfigurer 是我们在 Spring Boot 2.x 中实现自定义配置的方案。</p>
<p>WebMvcConfigurer 是一个接口，接口中的方法和 WebMvcConfigurerAdapter 中定义的空方法其实一样，所以用法上来说，基本上没有差别，从 Spring Boot 1.x 切换到 Spring Boot 2.x ，只需要把继承类改成实现接口即可。</p>
<p>松哥在之前的案例中(<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tm1IqiEvRZwDAb-F5yJ5Aw">40 篇原创干货，带你进入 Spring Boot 殿堂！</a>)，凡是涉及到自定义 SpringMVC 配置的地方，也都是通过实现 WebMvcConfigurer 接口来完成的。</p>
<h3 id="3-4-WebMvcConfigurationSupport"><a href="#3-4-WebMvcConfigurationSupport" class="headerlink" title="3.4 WebMvcConfigurationSupport"></a>3.4 WebMvcConfigurationSupport</h3><p>前面两个都好理解，还有一个 WebMvcConfigurationSupport ，这个又是干什么用的呢？</p>
<p>松哥之前有一篇文章中用过这个类，不知道小伙伴们有没有留意，就是下面这篇：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NC_0oaeBzRjCB34U_ZWxIQ">纯 Java 代码搭建 SSM 环境</a></li>
</ul>
<p>这篇文章我放弃了 Spring 和 SpringMVC 的 xml 配置文件，转而用 Java 代替这两个 xml 配置。那么在这里我自定义 SpringMVC 配置的时候，就是通过继承 WebMvcConfigurationSupport 类来实现的。在 WebMvcConfigurationSupport 类中，提供了用 Java 配置 SpringMVC 所需要的所有方法。我们来看一下这个方法的摘要：</p>
<p><a target="_blank" rel="noopener" href="http://www.javaboy.org/images/boot/37-1.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/37-1.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>有一点眼熟，可能有小伙伴发现了，这里的方法其实和前面两个类中的方法基本是一样的。</p>
<p>在这里首先大家需要明确的是，WebMvcConfigurationSupport 类本身是没有问题的，我们自定义 SpringMVC 的配置是可以通过继承 WebMvcConfigurationSupport 来实现的。但是继承 WebMvcConfigurationSupport 这种操作我们一般只在 Java 配置的 SSM 项目中使用，Spring Boot 中基本上不会这么写，为什么呢？</p>
<p>小伙伴们知道，Spring Boot 中，SpringMVC 相关的自动化配置是在 WebMvcAutoConfiguration 配置类中实现的，那么我们来看看这个配置类的生效条件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span>
<span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span>
<span class="hljs-meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span>
<span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span>
<span class="hljs-meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span>
<span class="hljs-meta">		ValidationAutoConfiguration.class &#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;
&#125;</code></pre></div>

<p>我们从这个类的注解中可以看到，它的生效条件有一条，就是当不存在 WebMvcConfigurationSupport 的实例时，这个自动化配置才会生生效。因此，如果我们在 Spring Boot 中自定义 SpringMVC 配置时选择了继承 WebMvcConfigurationSupport，就会导致 Spring Boot 中 SpringMVC 的自动化配置失效。</p>
<blockquote>
<p>Spring Boot 给我们提供了很多自动化配置，很多时候当我们修改这些配置的时候，并不是要全盘否定 Spring Boot 提供的自动化配置，我们可能只是针对某一个配置做出修改，其他的配置还是按照 Spring Boot 默认的自动化配置来，而继承 WebMvcConfigurationSupport 来实现对 SpringMVC 的配置会导致所有的 SpringMVC 自动化配置失效，因此，一般情况下我们不选择这种方案。</p>
</blockquote>
<p>在 Java 搭建的 SSM 项目中(<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NC_0oaeBzRjCB34U_ZWxIQ">纯 Java 代码搭建 SSM 环境</a>)，因为本身就没什么自动化配置，所以我们使用了继承 WebMvcConfigurationSupport。</p>
<h3 id="3-5-EnableWebMvc"><a href="#3-5-EnableWebMvc" class="headerlink" title="3.5 @EnableWebMvc"></a>3.5 @EnableWebMvc</h3><p>最后还有一个 @EnableWebMvc 注解，这个注解很好理解，它的作用就是启用 WebMvcConfigurationSupport。我们来看看这个注解的定义：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Adding this annotation to an &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class imports the Spring MVC</span>
<span class="hljs-comment"> * configuration from &#123;<span class="hljs-doctag">@link</span> WebMvcConfigurationSupport&#125;, e.g.:</span></code></pre></div>

<p>可以看到，加了这个注解，就会自动导入 WebMvcConfigurationSupport，所以在 Spring Boot 中，我们也不建议使用 @EnableWebMvc 注解，因为它一样会导致 Spring Boot 中的 SpringMVC 自动化配置失效。</p>
<h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><ul>
<li>Spring Boot 1.x 中，自定义 SpringMVC 配置可以通过继承 WebMvcConfigurerAdapter 来实现。</li>
<li>Spring Boot 2.x 中，自定义 SpringMVC 配置可以通过实现 WebMvcConfigurer 接口来完成。</li>
<li>如果在 Spring Boot 中使用继承 WebMvcConfigurationSupport 来实现自定义 SpringMVC 配置，或者在 Spring Boot 中使用了 @EnableWebMvc 注解，都会导致 Spring Boot 中默认的 SpringMVC 自动化配置失效。</li>
<li>在纯 Java 配置的 SSM 环境中，如果我们要自定义 SpringMVC 配置，有两种办法，第一种就是直接继承自 WebMvcConfigurationSupport 来完成 SpringMVC 配置，还有一种方案就是实现 WebMvcConfigurer 接口来完成自定义 SpringMVC 配置，如果使用第二种方式，则需要给 SpringMVC 的配置类上额外添加 @EnableWebMvc 注解，表示启用 WebMvcConfigurationSupport，这样配置才会生效。换句话说，在纯 Java 配置的 SSM 中，如果你需要自定义 SpringMVC 配置，你离不开 WebMvcConfigurationSupport ，所以在这种情况下建议通过继承 WebMvcConfigurationSupport 来实现自动化配置。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Spring/">Spring</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/01/Redis/">
                        <span class="hidden-mobile">Redis</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#valine",
          app_id: "Q8utolFFXQsi71pQY6bCltkI-gzGzoHsz",
          app_key: "x4RAlPOpmFX9HdGyI6MLoCGn",
          placeholder: "说点什么....",
          path: window.location.pathname,
          avatar: "monsterid",
          meta: ["nick","mail","link"],
          pageSize: "12",
          lang: "zh-CN",
          highlight: true,
          recordIP: true,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>





  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
