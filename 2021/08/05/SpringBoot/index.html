

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bat.png">
  <link rel="icon" href="/img/bat.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Lucifer">
  <meta name="keywords" content="">
  
  <title>SpringBoot合集 - Lucifer&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/monokai.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lucifer2u.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Q8utolFFXQsi71pQY6bCltkI-gzGzoHsz","app_key":"x4RAlPOpmFX9HdGyI6MLoCGn","server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Lucifer</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Flower.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="SpringBoot合集">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-05 20:37" pubdate>
        2021年8月5日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      87.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      1202
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">SpringBoot合集</h1>
            
            <div class="markdown-body">
              <h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><blockquote>
<p>本文整理了SpingBoot整合主流开发模块的知识，参考来自<a target="_blank" rel="noopener" href="http://www.javaboy.org/">松哥系列博客</a>，供学习</p>
</blockquote>
<h1 id="第一章、SpringBoot基础配置"><a href="#第一章、SpringBoot基础配置" class="headerlink" title="第一章、SpringBoot基础配置"></a>第一章、SpringBoot基础配置</h1><h2 id="1-Maven"><a href="#1-Maven" class="headerlink" title="1. Maven"></a>1. Maven</h2><p>我们刚开始学习 JavaWeb 的时候，使用 Servlet/JSP 做开发，一个接口搞一个 Servlet ，很头大，后来我们通过隐藏域或者反射等方式，可以减少 Servlet 的创建，但是依然不方便，再后来，我们引入 Struts2/SpringMVC 这一类的框架，来简化我们的开发 ，和 Servlet/JSP 相比，引入框架之后，生产力确实提高了不少，但是用久了，又发现了新的问题，即配置繁琐易出错，要做一个新项目，先搭建环境，环境搭建来搭建去，就是那几行配置，不同的项目，可能就是包不同，其他大部分的配置都是一样的，Java 总是被人诟病配置繁琐代码量巨大，这就是其中一个表现。那么怎么办？Spring Boot 应运而生，Spring Boot 主要提供了如下功能：</p>
<ul>
<li>为所有基于 Spring 的 Java 开发提供方便快捷的入门体验。</li>
<li>开箱即用，有自己自定义的配置就是用自己的，没有就使用官方提供的默认的。</li>
<li>提供了一系列通用的非功能性的功能，例如嵌入式服务器、安全管理、健康检测等。</li>
<li>绝对没有代码生成，也不需要XML配置。</li>
</ul>
<blockquote>
<p>在创建SpringBoot项目时，如果官方的<a target="_blank" rel="noopener" href="https://start.spring.io无法访问,可以访问https//start.aliyun.io">https://start.spring.io无法访问，可以访问https://start.aliyun.io</a></p>
</blockquote>
<p><strong>创建成功后，pom.xml 坐标</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></div>

<h3 id="1-1-基本功能"><a href="#1-1-基本功能" class="headerlink" title="1.1 基本功能"></a>1.1 基本功能</h3><p>当我们创建一个 Spring Boot 工程时，可以继承自一个 <code>spring-boot-starter-parent</code> ，也可以不继承自它，我们先来看第一种情况。先来看 parent 的基本功能有哪些？</p>
<ul>
<li>定义了 Java 编译版本为 1.8 。</li>
<li>使用 UTF-8 格式编码。</li>
<li>继承自 <code>spring-boot-dependencies</code>，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li>
<li>执行打包操作的配置。</li>
<li>自动化的资源过滤。</li>
<li>自动化的插件配置。</li>
<li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml</li>
</ul>
<blockquote>
<p>请注意，由于<code>application.properties</code>和<code>application.yml</code>文件接受Spring样式占位符 <code>$ &#123;...&#125;</code> ，因此 Maven 过滤更改为使用 <code>@ .. @</code> 占位符，当然开发者可以通过设置名为<code> resource.delimiter</code> 的Maven 属性来覆盖 <code>@ .. @</code> 占位符</p>
</blockquote>
<h3 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2 源码分析"></a>1.2 源码分析</h3><p>当我们创建一个 Spring Boot 项目后，我们可以在本地 Maven 仓库中看到这个具体的 parent 文件，以 2.1.4 这个版本为例，这里的路径是 <code>C:\Users\sang\.m2\repository\org\springframework\boot\spring-boot-starter-parent\2.1.4.RELEASE\spring-boot-starter-parent-2.1.4.RELEASE.pom</code> ,打开这个文件，快速阅读文件源码，基本上就可以证实我们前面说的功能，如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/2-1-20210521101059250.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我们可以看到，它继承自 <code>spring-boot-dependencies</code> ，这里保存了基本的依赖信息，另外我们也可以看到项目的编码格式，JDK 的版本等信息，当然也有我们前面提到的数据过滤信息。最后，我们再根据它的 parent 中指定的 <code>spring-boot-dependencies</code> 位置，来看看 <code>spring-boot-dependencies</code> 中的定义：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/2-2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在这里，我们看到了版本的定义以及<code>dependencyManagement</code>节点，明白了为啥 Spring Boot 项目中部分依赖不需要写版本号了。</p>
<h3 id="1-3-不用-parent"><a href="#1-3-不用-parent" class="headerlink" title="1.3 不用 parent"></a>1.3 不用 parent</h3><p>但是并非所有的公司都需要这个 parent ，有的时候，公司里边会有自己定义的 parent ，我们的 Spring Boot 项目要继承自公司内部的 parent ，这个时候该怎么办呢？</p>
<p>一个简单的办法就是我们自行定义<code>dependencyManagement</code>节点，然后在里边定义好版本号，再接下来在引用依赖时也就不用写版本号了，像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre></div>

<p>这样写之后，依赖的版本号问题虽然解决了，但是关于打包的插件、编译的 JDK 版本、文件的编码格式等等这些配置，在没有 parent 的时候，这些统统要自己去配置</p>
<h3 id="1-4-lt-resources-gt"><a href="#1-4-lt-resources-gt" class="headerlink" title="1.4 &lt;resources/&gt;"></a>1.4 <code>&lt;resources/&gt;</code></h3><p><code>pom.xml</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">javaboy.name</span>&gt;</span>www.lucifer.org<span class="hljs-tag">&lt;/<span class="hljs-name">javaboy.name</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>
          	<span class="hljs-comment">&lt;!-- 要处理a的，但只写这个会忽略其他的--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>a.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
          	<span class="hljs-comment">&lt;!-- 所以加上此语句，表示除了a，其他的不要处理 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>a.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div>

<p><code>a.properties</code>文件的定义</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">a.name</span>=<span class="hljs-string">$&#123;javaboy.name&#125;</span></code></pre></div>

<p>在打包的时候，<code>a.name</code>会直接从<code>&lt;properties&gt;</code>拿取值，得到<a target="_blank" rel="noopener" href="http://www.lucifer.org/">www.lucifer.org</a></p>
<h2 id="2-SpringBootApplication"><a href="#2-SpringBootApplication" class="headerlink" title="2.  @SpringBootApplication"></a>2.  @SpringBootApplication</h2><h3 id="2-1-SpringBootConfiguration"><a href="#2-1-SpringBootConfiguration" class="headerlink" title="2.1 @SpringBootConfiguration"></a>2.1 @SpringBootConfiguration</h3><p>启动类上的注解 <code>@SpringBootApplication</code>引用了<code>@SpringBootConfiguration</code></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521102815674.png" srcset="/img/loading.gif" lazyload alt="image-20210521102815674"></p>
<p>这里面又直接调用了<code>@Configuration</code>，这就引出了另一个问题，在普通的配置类MyConfig中，<code>@Configuration</code>和<code>@Component</code>看似功能相同，为什么要用<code>@Configuration</code>，通过以下配置</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Author <span class="hljs-title">author</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Author();
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Book <span class="hljs-title">book</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Book(author());
    &#125;
&#125;</code></pre></div>

<p>发现使用<code>@Configuration</code>创建出来了的Author对象通过代理对象了的，而<code>@Component</code>没有，其中<code>Book(author())</code>如果Book里的Author之前已经创建，就会直接使用，并不会重复创建，这里就不会</p>
<h3 id="2-2-EnableAutoConfiguration"><a href="#2-2-EnableAutoConfiguration" class="headerlink" title="2.2 EnableAutoConfiguration"></a>2.2 EnableAutoConfiguration</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Inherited</span>
<span class="hljs-meta">@AutoConfigurationPackage</span>
<span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;
    String ENABLED_OVERRIDE_PROPERTY = <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;

    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;

    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;
&#125;</code></pre></div>

<p>在原生的Spring框架中，组件装配有三个阶段：</p>
<ul>
<li>Spring2.5，@Component</li>
<li>Spring3.0+，使用@Configuration+@Bean</li>
<li>Spring3.1+，@EnableXXX+@Import</li>
</ul>
<p>为了说明<code>@EnableXXX+@Import</code>，先定义实体类</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Banana</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;
&#125;</code></pre></div>

<p><strong>有四种定义注解的方式</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;Apple.class.getName(), Banana.class.getName()&#125;;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitImportDefinitionRegistar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;
        registry.registerBeanDefinition(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-keyword">new</span> RootBeanDefinition(Apple.class));
        registry.registerBeanDefinition(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-keyword">new</span> RootBeanDefinition(Banana.class));
    &#125;
&#125;

<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-comment">//1.@Import(&#123;Apple.class, Banana.class&#125;)</span>
<span class="hljs-comment">//2.可以直接导入配置类</span>
<span class="hljs-comment">//3.@Import(&#123;FruitImportSelector.class&#125;)</span>
<span class="hljs-meta">@Import(&#123;FruitImportDefinitionRegistar.class&#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableFruit &#123;
&#125;</code></pre></div>

<p>从而可以发现</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521105018844.png" srcset="/img/loading.gif" lazyload alt="image-20210521105018844"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521105101247.png" srcset="/img/loading.gif" lazyload alt="image-20210521105101247"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521105547266.png" srcset="/img/loading.gif" lazyload alt="image-20210521105547266"></p>
<h2 id="3-基础配置"><a href="#3-基础配置" class="headerlink" title="3. 基础配置"></a>3. 基础配置</h2><h3 id="3-1-Tomcat配置"><a href="#3-1-Tomcat配置" class="headerlink" title="3.1 Tomcat配置"></a>3.1 Tomcat配置</h3><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>更改<code>pom.xml</code>文件排除自带的Tomcat后就能自定义自己所需的</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>可以任何容器，在配置文件中</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#不要开启web容器，以普通SE项目运行</span>
<span class="hljs-meta">spring.main.web-application-type</span>=<span class="hljs-string">none</span>
<span class="hljs-comment">#更改端口</span>
<span class="hljs-meta">server.port</span>=<span class="hljs-string">8888</span>
<span class="hljs-comment">#关闭所有的 http 端点</span>
<span class="hljs-meta">server.port</span>=<span class="hljs-string">-1</span>
<span class="hljs-comment">#随机端口</span>
<span class="hljs-meta">server.port</span>=<span class="hljs-string">0</span>
<span class="hljs-comment">#端口压缩</span>
<span class="hljs-meta">server.compression.enabled</span>=<span class="hljs-string">true</span></code></pre></div>

<p>随机端口需要通过监听器获取</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">WebServerInitializedEvent</span>&gt; </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(WebServerInitializedEvent event)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;event.getWebServer().getPort() = &quot;</span> + event.getWebServer().getPort());
    &#125;
&#125;</code></pre></div>

<h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 生成的访问日志将在该目录下</span>
<span class="hljs-meta">server.tomcat.basedir</span>=<span class="hljs-string">my-tomcat</span>
<span class="hljs-comment"># 开启访问日志，默认的日志位置在项目运行的临时目录中，默认生成的日志格式 access_log.2021-05-12.log</span>
<span class="hljs-meta">server.tomcat.accesslog.enabled</span>=<span class="hljs-string">true</span>
<span class="hljs-comment"># 生成日志文件名的前缀，默认是 access_log</span>
<span class="hljs-meta">server.tomcat.accesslog.prefix</span>=<span class="hljs-string">tomcat_log</span>
<span class="hljs-comment"># 生成的日志文件后缀</span>
<span class="hljs-meta">server.tomcat.accesslog.suffix</span>=<span class="hljs-string">.log</span>
<span class="hljs-comment"># 日志文件名中的日期格式</span>
<span class="hljs-meta">server.tomcat.accesslog.file-date-format</span>=<span class="hljs-string">.yyyyMMdd</span>

<span class="hljs-comment"># 生成的日志文件内容格式也是可以调整的</span>
<span class="hljs-comment"># %h 请求的客户端 IP</span>
<span class="hljs-comment"># %l 用户的身份</span>
<span class="hljs-comment"># %u 用户名</span>
<span class="hljs-comment"># %t 请求时间</span>
<span class="hljs-comment"># %r 请求地址</span>
<span class="hljs-comment"># %s 响应的状态码</span>
<span class="hljs-comment"># %b 响应的大小</span>
<span class="hljs-meta">server.tomcat.accesslog.pattern</span>=<span class="hljs-string">%h %l %u %t \&quot;%r\&quot; %s %b</span>

<span class="hljs-comment"># 服务器内部日志开启</span>

<span class="hljs-meta">logging.level.org.apache.tomcat</span>=<span class="hljs-string">debug</span>
<span class="hljs-meta">logging.level.org.apache.catalina</span>=<span class="hljs-string">debug</span></code></pre></div>

<h4 id="HTTPS证书"><a href="#HTTPS证书" class="headerlink" title="HTTPS证书"></a>HTTPS证书</h4><p>首先我们需要有一个 https 证书，我们可以从各个云服务厂商处申请一个免费的，不过自己做实验没有必要这么麻烦，我们可以直接借助 Java 自带的 JDK 管理工具 keytool 来生成一个免费的 https 证书。</p>
<p>进入到 <code>%JAVVA_HOME%\bin</code> 目录下，执行如下命令生成一个数字证书：</p>
<div class="hljs code-wrapper"><pre><code class="hljs shell">keytool -genkey -alias tomcathttps -keyalg RSA -keysize 2048  -keystore lucifer.p12 -validity 365</code></pre></div>

<p>命令含义如下：</p>
<ul>
<li>genkey 表示要创建一个新的密钥。</li>
<li>alias 表示 keystore 的别名。</li>
<li>keyalg 表示使用的加密算法是 RSA ，一种非对称加密算法。</li>
<li>keysize 表示密钥的长度。</li>
<li>keystore 表示生成的密钥存放位置。</li>
<li>validity 表示密钥的有效时间，单位为天。</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521155752252.png" srcset="/img/loading.gif" lazyload alt="image-20210521155752252"></p>
<p>配置<code>application.properties</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.ssl.key-alias</span>=<span class="hljs-string">myhttps</span>
<span class="hljs-meta">server.ssl.key-store</span>=<span class="hljs-string">classpath:lucifer.p12</span>
<span class="hljs-meta">server.ssl.key-store-password</span>=<span class="hljs-string">123456</span></code></pre></div>

<p><strong>配置https跳转</strong></p>
<p>考虑到 Spring Boot 不支持同时启动 HTTP 和 HTTPS ，为了解决这个问题，我们这里可以配置一个请求转发，当用户发起 HTTP 调用时，自动转发到 HTTPS 上</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">TomcatServletWebServerFactory <span class="hljs-title">tomcatServletWebServerFactory</span><span class="hljs-params">()</span> </span>&#123;
        TomcatServletWebServerFactory factory = <span class="hljs-keyword">new</span> TomcatServletWebServerFactory()&#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessContext</span><span class="hljs-params">(Context context)</span> </span>&#123;
                SecurityConstraint securityConstraint = <span class="hljs-keyword">new</span> SecurityConstraint();
                securityConstraint.setUserConstraint(<span class="hljs-string">&quot;CONFIDENTIAL&quot;</span>);
                SecurityCollection collection = <span class="hljs-keyword">new</span> SecurityCollection();
                collection.addPattern(<span class="hljs-string">&quot;/*&quot;</span>);
                securityConstraint.addCollection(collection);
                context.addConstraint(securityConstraint);
            &#125;
        &#125;;
        factory.addAdditionalTomcatConnectors(myConnectors());
        <span class="hljs-keyword">return</span> factory;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> Connector <span class="hljs-title">myConnectors</span><span class="hljs-params">()</span> </span>&#123;
        Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);
        connector.setScheme(<span class="hljs-string">&quot;http&quot;</span>);
        <span class="hljs-comment">//http和默认的8080不能占用同一个端口</span>
        connector.setPort(<span class="hljs-number">8081</span>);
        connector.setSecure(<span class="hljs-keyword">false</span>);
        connector.setRedirectPort(<span class="hljs-number">8080</span>);
        <span class="hljs-keyword">return</span> connector;
    &#125;
&#125;</code></pre></div>

<h3 id="3-2-application-properties"><a href="#3-2-application-properties" class="headerlink" title="3.2 application.properties"></a>3.2 <strong>application.properties</strong></h3><p>首先，当我们创建一个 Spring Boot 工程时，默认 resources 目录下就有一个 application.properties 文件，可以在 application.properties 文件中进行项目配置，但是这个文件并非唯一的配置文件，在 Spring Boot 中，一共有 4 个地方可以存放 application.properties 文件</p>
<ul>
<li>当前项目根目录下的 config 目录下</li>
<li>当前项目的根目录下</li>
<li>resources 目录下的 config 目录下</li>
<li>resources 目录下</li>
</ul>
<p>按如上顺序，四个配置文件的优先级依次降低。如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/11-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这四个位置是默认位置，即 Spring Boot 启动，默认会从这四个位置按顺序去查找相关属性并加载。但是，这也不是绝对的，我们也可以在项目启动时自定义配置文件位置。</p>
<p>例如，现在在 resources 目录下创建一个 javaboy 目录，目录中存放一个 application.properties 文件，那么正常情况下，当我们启动 Spring Boot 项目时，这个配置文件是不会被自动加载的。我们可以通过 spring.config.location 属性来手动的指定配置文件位置，指定完成后，系统就会自动去指定目录下查找 application.properties 文件。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/11-2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>此时启动项目，就会发现，项目以 <code>classpath:/javaboy/application.propertie</code> 配置文件启动。</p>
<p>这是在开发工具中配置了启动位置，如果项目已经打包成 jar ，在启动命令中加入位置参数即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs shell">java -jar properties-0.0.1-SNAPSHOT.jar --spring.config.location=classpath:/javaboy/</code></pre></div>

<h4 id="文件名问题"><a href="#文件名问题" class="headerlink" title="文件名问题"></a>文件名问题</h4><p>对于 application.properties 而言，它不一定非要叫 application ，但是项目默认是去加载名为 application 的配置文件，如果我们的配置文件不叫 application ，也是可以的，但是，需要明确指定配置文件的文件名。</p>
<p>方式和指定路径一致，只不过此时的 key 是 spring.config.name 。</p>
<p>首先我们在 resources 目录下创建一个 app.properties 文件，然后在 IDEA 中指定配置文件的文件名：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/11-3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>指定完配置文件名之后，再次启动项目，此时系统会自动去默认的四个位置下面分别查找名为 app.properties 的配置文件。当然，允许自定义文件名的配置文件不放在四个默认位置，而是放在自定义目录下，此时就需要明确指定 spring.config.location </p>
<p>配置文件位置和文件名称可以同时自定义。</p>
<h4 id="普通的属性注入"><a href="#普通的属性注入" class="headerlink" title="普通的属性注入"></a>普通的属性注入</h4><p>由于 Spring Boot 源自 Spring ，所以 Spring 中存在的属性注入，在 Spring Boot 中一样也存在。由于 Spring Boot 中，默认会自动加载 application.properties 文件，所以简单的属性注入可以直接在这个配置文件中写。</p>
<p>例如，现在定义一个 Book 类：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String author;
    <span class="hljs-comment">//省略 getter/setter</span>
&#125;</code></pre></div>

<p>然后，在 application.properties 文件中定义属性：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">book.name</span>=<span class="hljs-string">三国演义</span>
<span class="hljs-meta">book.author</span>=<span class="hljs-string">罗贯中</span>
<span class="hljs-meta">book.id</span>=<span class="hljs-string">1</span></code></pre></div>

<p>按照传统的方式（Spring中的方式），可以直接通过 @Value 注解将这些属性注入到 Book 对象中：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-meta">@Value(&quot;$&#123;book.id&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@Value(&quot;$&#123;book.author&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String author;
    <span class="hljs-comment">//省略getter/setter</span>
&#125;</code></pre></div>

<p><strong>注意</strong></p>
<p>Book 对象本身也要交给 Spring 容器去管理，如果 Book 没有交给 Spring 容器，那么 Book 中的属性也无法从 Spring 容器中获取到值。</p>
<p>配置完成后，在 Controller 或者单元测试中注入 Book 对象，启动项目，就可以看到属性已经注入到对象中了。</p>
<p>一般来说，我们在 application.properties 文件中主要存放系统配置，这种自定义配置不建议放在该文件中，可以自定义 properties 文件来存在自定义配置。</p>
<p>例如在 resources 目录下，自定义 book.properties 文件，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">book.name</span>=<span class="hljs-string">三国演义</span>
<span class="hljs-meta">book.author</span>=<span class="hljs-string">罗贯中</span>
<span class="hljs-meta">book.id</span>=<span class="hljs-string">1</span></code></pre></div>

<p>此时，项目启动并不会自动的加载该配置文件，如果是在 XML 配置中，可以通过如下方式引用该 properties 文件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:book.properties&quot;</span>/&gt;</span></code></pre></div>

<p>如果是在 Java 配置中，可以通过<code>@PropertySource</code>来引入配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@PropertySource(&quot;classpath:book.properties&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-meta">@Value(&quot;$&#123;book.id&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@Value(&quot;$&#123;book.author&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String author;
    <span class="hljs-comment">//getter/setter</span>
&#125;</code></pre></div>

<p>这样，当项目启动时，就会自动加载 book.properties 文件。</p>
<p>这只是 Spring 中属性注入的一个简单用法，和 Spring Boot 没有任何关系。</p>
<h4 id="类型安全的属性注入"><a href="#类型安全的属性注入" class="headerlink" title="类型安全的属性注入"></a>类型安全的属性注入</h4><p>Spring Boot 引入了类型安全的属性注入，如果采用 Spring 中的配置方式，当配置的属性非常多的时候，工作量就很大了，而且容易出错。</p>
<p>使用类型安全的属性注入，可以有效的解决这个问题。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@PropertySource(&quot;classpath:book.properties&quot;)</span>
<span class="hljs-meta">@ConfigurationProperties(prefix = &quot;book&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String author;
    <span class="hljs-comment">//省略getter/setter</span>
&#125;</code></pre></div>

<p>这里，主要是引入<code>@ConfigurationProperties(prefix = “book”)</code>注解，并且配置了属性的前缀，此时会自动将 Spring 容器中对应的数据注入到对象对应的属性中，就不用通过 <code>@Value</code> 注解挨个注入了，减少工作量并且避免出错</p>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>在实际开发配置中，要分环境开发</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210521163450670.png" srcset="/img/loading.gif" lazyload alt="image-20210521163450670"></p>
<p>配置 application.properties 选择特定的开发端口</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.profiles.active</span>=<span class="hljs-string">prod</span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># application-prod.properties</span>
<span class="hljs-meta">server.port</span>=<span class="hljs-string">8088</span>
<span class="hljs-comment"># application-dev.properties</span>
<span class="hljs-meta">server.port</span>=<span class="hljs-string">8080</span>
<span class="hljs-comment"># application-test.properties</span>
<span class="hljs-meta">server.port</span>=<span class="hljs-string">8888</span></code></pre></div>

<h3 id="3-3-Yaml配置"><a href="#3-3-Yaml配置" class="headerlink" title="3.3 Yaml配置"></a>3.3 Yaml配置</h3><p>首先application.yaml在Spring Boot中可以写在四个不同的位置，分别是如下位置：</p>
<ul>
<li>项目根目录下的config目录中</li>
<li>项目根目录下</li>
<li>classpath下的config目录中</li>
<li>classpath目录下</li>
</ul>
<p>四个位置中的application.yaml文件的优先级按照上面列出的顺序依次降低。即如果有同一个属性在四个文件中都出现了，以优先级高的为准。</p>
<p>那么application.yaml是不是必须叫application.yaml这个名字呢？当然不是必须的。开发者可以自己定义yaml名字，自己定义的话，需要在项目启动时指定配置文件的名字，像下面这样：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/9-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>当然这是在IntelliJ IDEA中直接配置的，如果项目已经打成jar包了，则在项目启动时加入如下参数：</p>
<div class="hljs code-wrapper"><pre><code class="hljs shell">java -jar myproject.jar --spring.config.name=app</code></pre></div>

<p>这样配置之后，在项目启动时，就会按照上面所说的四个位置按顺序去查找一个名为app.yaml的文件。当然这四个位置也不是一成不变的，也可以自己定义，有两种方式，一个是使用<code>spring.config.location</code>属性，另一个则是使用<code>spring.config.additional-location</code>这个属性，在第一个属性中，表示自己重新定义配置文件的位置，项目启动时就按照定义的位置去查找配置文件，这种定义方式会覆盖掉默认的四个位置，也可以使用第二种方式，第二种方式则表示在四个位置的基础上，再添加几个位置，新添加的位置的优先级大于原本的位置。</p>
<p>配置方式如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/9-2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这里要注意，配置文件位置时，值一定要以/结尾。</p>
<h4 id="数组注入"><a href="#数组注入" class="headerlink" title="数组注入"></a>数组注入</h4><p>yaml也支持数组注入，例如</p>
<div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">my:</span>
  <span class="hljs-attr">servers:</span>
	<span class="hljs-bullet">-</span> <span class="hljs-string">dev.example.com</span>
	<span class="hljs-bullet">-</span> <span class="hljs-string">another.example.com</span></code></pre></div>

<p>这段数据可以绑定到一个带Bean的数组中：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix=&quot;my&quot;)</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>&#123;

	<span class="hljs-keyword">private</span> List&lt;String&gt; servers = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();

	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getServers</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.servers;
	&#125;
&#125;</code></pre></div>

<p>项目启动后，配置中的数组会自动存储到servers集合中。当然，yaml不仅可以存储这种简单数据，也可以在集合中存储对象。例如下面这种：</p>
<div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">redis:</span>
  <span class="hljs-attr">redisConfigs:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.66</span><span class="hljs-number">.128</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.66</span><span class="hljs-number">.129</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">6380</span></code></pre></div>

<p>这个可以被注入到如下类中：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@ConfigurationProperties(prefix = &quot;redis&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCluster</span> </span>&#123;
    <span class="hljs-keyword">private</span> List&lt;SingleRedisConfig&gt; redisConfigs;
	<span class="hljs-comment">//省略getter/setter</span>
&#125;</code></pre></div>

<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>不同于properties文件的无序，yaml配置是有序的，这一点在有些配置中是非常有用的，例如在Spring Cloud Zuul的配置中，当我们配置代理规则时，顺序就显得尤为重要了。当然yaml配置也不是万能的，例如，yaml配置目前不支持<code>@PropertySource</code>注解</p>
<h2 id="4-日志详解"><a href="#4-日志详解" class="headerlink" title="4. 日志详解"></a>4. 日志详解</h2><h3 id="1-Java-日志概览"><a href="#1-Java-日志概览" class="headerlink" title="1. Java 日志概览"></a>1. Java 日志概览</h3><p>说到 Java 日志，很多初学者可能都比较懵，因为这里涉及到太多东西了：<code>Apache Commons Logging</code>、<code>Slf4j</code>、<code>Log4j</code>、<code>Log4j2</code>、<code>Logback</code>、<code>Java Util Logging</code> 等等，这些框架各自有什么作用？他们之间有什么区别？</p>
<h4 id="1-1-总体概览"><a href="#1-1-总体概览" class="headerlink" title="1.1 总体概览"></a>1.1 总体概览</h4><p>下面这张图很好的展示了 Java 中的日志体系：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201213205509.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201213205509.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看到，Java 中的日志框架主要分为两大类：<strong>日志门面</strong>和<strong>日志实现</strong>。</p>
<p><strong>日志门面</strong></p>
<p>日志门面定义了一组日志的接口规范，它并不提供底层具体的实现逻辑。<code>Apache Commons Logging</code> 和 <code>Slf4j</code> 就属于这一类。</p>
<p><strong>日志实现</strong></p>
<p>日志实现则是日志具体的实现，包括日志级别控制、日志打印格式、日志输出形式（输出到数据库、输出到文件、输出到控制台等）。<code>Log4j</code>、<code>Log4j2</code>、<code>Logback</code> 以及 <code>Java Util Logging</code> 则属于这一类。</p>
<p>将日志门面和日志实现分离其实是一种典型的门面模式，这种方式可以让具体业务在不同的日志实现框架之间自由切换，而不需要改动任何代码，开发者只需要掌握日志门面的 API 即可。</p>
<p>日志门面是不能单独使用的，它必须和一种具体的日志实现框架相结合使用。</p>
<p>那么日志框架是否可以单独使用呢？</p>
<p>技术上来说当然没问题，但是我们一般不会这样做，因为这样做可维护性很差，而且后期扩展不易。例如 A 开发了一个工具包使用 Log4j 打印日志，B 引用了这个工具包，但是 B 喜欢使用 Logback 打印日志，此时就会出现一个业务使用两个甚至多个日志框架，开发者也需要维护多个日志的配置文件。因此我们都是用日志门面打印日志。</p>
<h4 id="1-2-日志级别"><a href="#1-2-日志级别" class="headerlink" title="1.2 日志级别"></a>1.2 日志级别</h4><p>使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。不同的日志实现定义的日志级别不太一样，不过也都大同小异。</p>
<p><strong>Java Util Logging</strong></p>
<p><code>Java Util Logging</code> 定义了 7 个日志级别，从严重到普通依次是：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p>因为默认级别是 INFO，因此 INFO 级别以下的日志，不会被打印出来。</p>
<p><strong>Log4j</strong></p>
<p><code>Log4j</code> 定义了 8 个日志级别（除去 OFF 和 ALL，可以说分为 6 个级别），从严重到普通依次是：</p>
<ul>
<li>OFF：最高等级的，用于关闭所有日志记录。</li>
<li>FATAL：重大错误，这种级别可以直接停止程序了。</li>
<li>ERROR：打印错误和异常信息，如果不想输出太多的日志，可以使用这个级别。</li>
<li>WARN：警告提示。</li>
<li>INFO：用于生产环境中输出程序运行的一些重要信息，不能滥用。</li>
<li>DEBUG：用于开发过程中打印一些运行信息。</li>
<li>TRACE</li>
<li>ALL 最低等级的，用于打开所有日志记录。</li>
</ul>
<p><strong>Logback</strong></p>
<p><code>Logback</code> 日志级别比较简单，从严重到普通依次是：</p>
<ul>
<li>ERROR</li>
<li>WARN</li>
<li>INFO</li>
<li>DEBUG</li>
<li>TRACE</li>
</ul>
<h4 id="1-3-综合对比"><a href="#1-3-综合对比" class="headerlink" title="1.3 综合对比"></a>1.3 综合对比</h4><p><code>Java Util Logging</code> 系统在 <code>JVM</code> 启动时读取配置文件并完成初始化，一旦应用程序开始运行，就无法修改配置。另外，这种日志实现配置也不太方便，只能在 <code>JVM</code> 启动时传递参数，像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml">-Djava.util.logging.config.file=<span class="hljs-tag">&lt;<span class="hljs-name">config-file-name</span>&gt;</span>。</code></pre></div>

<p>由于这些局限性，导致 <code>Java Util Logging</code> 并未广泛使用。</p>
<p><code>Log4j</code> 虽然配置繁琐，但是一旦配置完成，使用起来就非常方便，只需要将相关的配置文件放到 <code>classpath</code> 下即可。在很多情况下，<code>Log4j</code> 的配置文件我们可以在不同的项目中反复使用。</p>
<p><code>Log4j</code> 可以和 <code>Apache Commons Logging</code> 搭配使用，<code>Apache Commons Logging</code> 会自动搜索并使用 <code>Log4j</code>，如果没有找到 <code>Log4j</code>，再使用 <code>Java Util Logging</code>。</p>
<p>比 <code>Log4j</code> + <code>Apache Commons Logging</code> 组合更得人心的是 <code>Slf4j</code> + <code>Logback</code> 组合。</p>
<p><code>Logback</code> 是 <code>Slf4j</code> 的原生实现框架，它也出自 <code>Log4j</code> 作者（Ceki Gülcü）之手，但是相比 <code>Log4j</code>，它拥有更多的优点、特性以及更强的性能。</p>
<h4 id="1-4-最佳实践"><a href="#1-4-最佳实践" class="headerlink" title="1.4 最佳实践"></a>1.4 最佳实践</h4><ul>
<li>如果不想添加任何依赖，使用 <code>Java Util Logging</code> 或框架容器已经提供的日志接口。</li>
<li>如果比较在意性能，推荐：<code>Slf4j</code> + <code>Logback</code>。</li>
<li>如果项目中已经使用了 <code>Log4j</code> 且没有发现性能问题，推荐组合为：<code>Slf4j</code> + <code>Log4j2</code>。</li>
</ul>
<h3 id="2-Spring-Boot-日志实现"><a href="#2-Spring-Boot-日志实现" class="headerlink" title="2. Spring Boot 日志实现"></a>2. Spring Boot 日志实现</h3><p>Spring Boot 使用 <code>Apache Commons Logging</code> 作为内部的日志框架门面，它只是一个日志接口，在实际应用中需要为该接口来指定相应的日志实现。</p>
<p>Spring Boot 默认的日志实现是 <code>Logback</code>。这个很好查看：随便启动一个 Spring Boot 项目，从控制台找一行日志，例如下面这样：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201214092816.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201214092816.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>考虑到最后的 prod 是一个可以变化的字符，我们在项目中全局搜索：<code>The following profiles are active</code>，结果如下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201214092956.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201214092956.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>在日志输出的那一行 debug。然后再次启动项目，如下图：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201214093147.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201214093147.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>此时我们就可以看到真正的日志实现是 <code>Logback</code>。</p>
<p>其他的诸如 <code>Java Util Logging</code>、<code>Log4j</code> 等框架，Spring Boot 也有很好的支持。</p>
<p>在 Spring Boot 项目中，只要添加了如下 web 依赖，日志依赖就自动添加进来了：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h4 id="2-1-Spring-Boot-日志配置"><a href="#2-1-Spring-Boot-日志配置" class="headerlink" title="2.1 Spring Boot 日志配置"></a>2.1 Spring Boot 日志配置</h4><p>Spring Boot 的日志系统会自动根据 classpath 下的内容选择合适的日志配置，在这个过程中首选 Logback。</p>
<p>如果开发者需要修改日志级别，只需要在 application.properties 文件中通过 <code>logging.level 前缀+包名</code> 的形式进行配置即可，例如下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.level.org.springframework.web</span>=<span class="hljs-string">debug</span>
<span class="hljs-meta">logging.level.org.hibernate</span>=<span class="hljs-string">error</span></code></pre></div>

<p>如果你想将日志输出到文件，可以通过如下配置指定日志文件名：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.file.name</span>=<span class="hljs-string">javaboy.log</span></code></pre></div>

<p>logging.file.name 可以只指定日志文件名，也可以指定日志文件全路径，例如下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.file.name</span>=<span class="hljs-string">/Users/sang/Documents/javaboy/javaboy.log</span></code></pre></div>

<p>如果你只是想重新定义输出日志文件的路径，也可以使用 <code>logging.file.path</code> 属性，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.file.path</span>=<span class="hljs-string">/Users/sang/Documents/javaboy</span></code></pre></div>

<p>如果想对输出到文件中的日志进行精细化管理，还有如下一些属性可以配置：</p>
<ul>
<li>logging.logback.rollingpolicy.file-name-pattern：日志归档的文件名，日志文件达到一定大小之后，自动进行压缩归档。</li>
<li>logging.logback.rollingpolicy.clean-history-on-start：是否在应用启动时进行归档管理。</li>
<li>logging.logback.rollingpolicy.max-file-size：日志文件大小上限，达到该上限后，会自动压缩。</li>
<li>logging.logback.rollingpolicy.total-size-cap：日志文件被删除之前，可以容纳的最大大小。</li>
<li>logging.logback.rollingpolicy.max-history：日志文件保存的天数。</li>
</ul>
<p>日志文件归档这块，小伙伴们感兴趣可以自己试下，可以首先将 max-file-size 属性调小，这样方便看到效果：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.logback.rollingpolicy.max-file-size</span>=<span class="hljs-string">1MB</span></code></pre></div>

<p>然后添加如下接口：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = getLogger(HelloController.class);
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;
            logger.info(<span class="hljs-string">&quot;hello javaboy&quot;</span>);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>访问该接口，可以看到最终生成的日志文件被自动压缩了：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201214115027.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201214115027.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>application.properties 中还可以配置日志分组。</p>
<p>日志分组能够把相关的 logger 放到一个组统一管理。</p>
<p>例如我们可以定义一个 tomcat 组：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.group.tomcat</span>=<span class="hljs-string">org.apache.catalina,org.apache.coyote, org.apache.tomcat</span></code></pre></div>

<p>然后统一管理 tomcat 组中的所有 logger：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">logging.level.tomcat</span>=<span class="hljs-string">TRACE</span></code></pre></div>

<p>Spring Boot 中还预定义了两个日志分组 web 和 sql，如下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201214124953.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201214124953.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>不过在 application.properties 中只能实现对日志一些非常简单的配置，如果想实现更加细粒度的日志配置，那就需要使用日志实现的原生配置，例如 <code>Logback</code> 的 <code>classpath:logback.xml</code>，<code>Log4j</code> 的 <code>classpath:log4j.xml</code> 等。如果这些日志配置文件存在于 classpath 下，那么默认情况下，Spring Boot 就会自动加载这些配置文件。</p>
<h4 id="2-2-Logback-配置"><a href="#2-2-Logback-配置" class="headerlink" title="2.2 Logback 配置"></a>2.2 Logback 配置</h4><h5 id="2-2-1-基本配置"><a href="#2-2-1-基本配置" class="headerlink" title="2.2.1 基本配置"></a>2.2.1 基本配置</h5><p>默认的 <code>Logback</code> 配置文件名有两种：</p>
<ul>
<li><code>logback.xml</code>：这种配置文件会直接被日志框架加载。</li>
<li><code>logback-spring.xml</code>：这种配置文件不会被日志框架直接加载，而是由 Spring Boot 去解析日志配置，可以使用 Spring Boot 的高级 Profile 功能。</li>
</ul>
<p>Spring Boot 中为 <code>Logback</code> 提供了四个默认的配置文件，位置在 <code>org/springframework/boot/logging/logback/</code>，分别是：</p>
<ul>
<li>defaults.xml：提供了公共的日志配置，日志输出规则等。</li>
<li>console-appender.xml：使用 CONSOLE_LOG_PATTERN 添加一个ConsoleAppender。</li>
<li>file-appender.xml：添加一个 RollingFileAppender。</li>
<li>base.xml：为了兼容旧版 Spring Boot 而提供的。</li>
</ul>
<p>如果需要自定义 <code>logback.xml</code> 文件，可以在自定义时使用这些默认的配置文件，也可以不使用。一个典型的 <code>logback.xml</code> 文件如下（resources/logback.xml）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/console-appender.xml&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.web&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div>

<p>可以通过 include 引入 Spring Boot 已经提供的配置文件，也可以自定义。</p>
<h5 id="2-2-2-输出到文件"><a href="#2-2-2-输出到文件" class="headerlink" title="2.2.2 输出到文件"></a>2.2.2 输出到文件</h5><p>如果想禁止控制台的日志输出，转而将日志内容输出到一个文件，我们可以自定义一个 <code>logback-spring.xml</code> 文件，并引入前面所说的 <code>file-appender.xml</code> 文件。</p>
<p>像下面这样（<code>resources/logback-spring.xml</code>）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_FILE&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;/&#125;spring.log&#125;&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/file-appender.xml&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div>

<h4 id="2-3-Log4j-配置"><a href="#2-3-Log4j-配置" class="headerlink" title="2.3 Log4j 配置"></a>2.3 Log4j 配置</h4><p>如果 classpath 下存在 <code>Log4j2</code> 的依赖，Spring Boot 会自动进行配置。</p>
<p>默认情况下 classpath 下当然不存在 <code>Log4j2</code> 的依赖，如果想使用 <code>Log4j2</code>，可以排除已有的 <code>Logback</code>，然后再引入 <code>Log4j2</code>，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><code>Log4j2</code> 的配置就比较容易了，在 reources 目录下新建 log4j2.xml 文件，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;warn&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;app_name&quot;</span>&gt;</span>logging<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log_path&quot;</span>&gt;</span>logs/$&#123;app_name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appenders</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d][%t][%p][%l] %m%n&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">console</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileInfo&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/info.log&quot;</span></span>
<span class="hljs-tag">                     <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Filters</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;DENY&quot;</span></span>
<span class="hljs-tag">                                 <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;NEUTRAL&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">Filters</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d][%t][%p][%c:%L] %m%n&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;2 MB&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">compressionLevel</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileWarn&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/warn.log&quot;</span></span>
<span class="hljs-tag">                     <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Filters</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;DENY&quot;</span></span>
<span class="hljs-tag">                                 <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;NEUTRAL&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">Filters</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d][%t][%p][%c:%L] %m%n&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;2 MB&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">compressionLevel</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileError&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/error.log&quot;</span></span>
<span class="hljs-tag">                     <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;log_path&#125;/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d][%t][%p][%c:%L] %m%n&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;2 MB&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">compressionLevel</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">appenders</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">loggers</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileInfo&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileWarn&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileError&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">loggers</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div>

<p>首先在 properties 节点中指定了应用名称以及日志文件位置。</p>
<p>然后通过几个不同的 RollingFile 对不同级别的日志分别处理，不同级别的日志将输出到不同的文件，并按照各自的命名方式进行压缩。</p>
<p>这段配置比较程式化，小伙伴们可以保存下来做成 IntelliJ IDEA 模版以便日常使用。</p>
<h1 id="第二章、SpringBoot整合视图层"><a href="#第二章、SpringBoot整合视图层" class="headerlink" title="第二章、SpringBoot整合视图层"></a>第二章、SpringBoot整合视图层</h1><h2 id="1-Thymeleaf"><a href="#1-Thymeleaf" class="headerlink" title="1. Thymeleaf"></a>1. Thymeleaf</h2><p>Thymeleaf 是新一代 Java 模板引擎，它类似于 Velocity、FreeMarker 等传统 Java 模板引擎，但是与传统 Java 模板引擎不同的是，Thymeleaf 支持 HTML 原型。</p>
<p>它既可以让前端工程师在浏览器中直接打开查看样式，也可以让后端工程师结合真实数据查看显示效果，同时，SpringBoot 提供了 Thymeleaf 自动化配置解决方案，因此在 SpringBoot 中使用 Thymeleaf 非常方便。</p>
<p>事实上， Thymeleaf 除了展示基本的 HTML ，进行页面渲染之外，也可以作为一个 HTML 片段进行渲染，例如我们在做邮件发送时，可以使用 Thymeleaf 作为邮件发送模板。</p>
<p>另外，由于 Thymeleaf 模板后缀为 <code>.html</code>，可以直接被浏览器打开，因此，预览时非常方便。</p>
<h3 id="1-1-整合"><a href="#1-1-整合" class="headerlink" title="1.1 整合"></a>1.1 整合</h3><ul>
<li>创建项目</li>
</ul>
<p>Spring Boot 中整合 Thymeleaf 非常容易，只需要创建项目时添加 Thymeleaf 即可：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/18-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>创建完成后，pom.xml 依赖如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>当然，Thymeleaf 不仅仅能在 Spring Boot 中使用，也可以使用在其他地方，只不过 Spring Boot 针对 Thymeleaf 提供了一整套的自动化配置方案，这一套配置类的属性在 <code>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafProperties</code> 中，部分源码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafProperties</span> </span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">&quot;.html&quot;</span>;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> checkTemplate = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> checkTemplateLocation = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">private</span> String prefix = DEFAULT_PREFIX;
        <span class="hljs-keyword">private</span> String suffix = DEFAULT_SUFFIX;
        <span class="hljs-keyword">private</span> String mode = <span class="hljs-string">&quot;HTML&quot;</span>;
        <span class="hljs-keyword">private</span> Charset encoding = DEFAULT_ENCODING;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> cache = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">//...</span>
&#125;</code></pre></div>

<ul>
<li>首先通过 <code>@ConfigurationProperties</code> 注解，将 <code>application.properties</code> 前缀为 <code>spring.thymeleaf</code> 的配置和这个类中的属性绑定。</li>
<li>前三个 <code>static</code> 变量定义了默认的编码格式、视图解析器的前缀、后缀等。</li>
<li>从前三行配置中，可以看出来，<code>Thymeleaf</code> 模板的默认位置在 <code>resources/templates</code> 目录下，默认的后缀是 <code>html</code>。</li>
<li>这些配置，如果开发者不自己提供，则使用 默认的，如果自己提供，则在 <code>application.properties</code> 中以 <code>spring.thymeleaf</code> 开始相关的配置。</li>
</ul>
<p>而我们刚刚提到的，Spring Boot 为 Thymeleaf 提供的自动化配置类，则是 <code>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration</code> ，部分源码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableConfigurationProperties(ThymeleafProperties.class)</span>
<span class="hljs-meta">@ConditionalOnClass(&#123; TemplateMode.class, SpringTemplateEngine.class &#125;)</span>
<span class="hljs-meta">@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class &#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafAutoConfiguration</span> </span>&#123;
&#125;</code></pre></div>

<p>可以看到，在这个自动化配置类中，首先导入 <code>ThymeleafProperties</code> ，然后 <code>@ConditionalOnClass</code> 注解表示当当前系统中存在 <code>TemplateMode</code> 和 <code>SpringTemplateEngine</code> 类时，当前的自动化配置类才会生效，即只要项目中引入了 <code>Thymeleaf</code> 相关的依赖，这个配置就会生效。</p>
<p>这些默认的配置我们几乎不需要做任何更改就可以直接使用了。如果开发者有特殊需求，则可以在 application.properties 中配置以 spring.thymeleaf 开头的属性即可。</p>
<ul>
<li><strong>创建 Controller</strong></li>
</ul>
<p>接下来我们就可以创建 Controller 了，实际上引入 Thymeleaf 依赖之后，我们可以不做任何配置。新建的 IndexController 如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/index&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span> </span>&#123;
        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            User u = <span class="hljs-keyword">new</span> User();
            u.setId((<span class="hljs-keyword">long</span>) i);
            u.setName(<span class="hljs-string">&quot;javaboy:&quot;</span> + i);
            u.setAddress(<span class="hljs-string">&quot;深圳:&quot;</span> + i);
            users.add(u);
        &#125;
        model.addAttribute(<span class="hljs-string">&quot;users&quot;</span>, users);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String address;
    <span class="hljs-comment">//省略 getter/setter</span>
&#125;</code></pre></div>

<p>在 <code>IndexController</code> 中返回逻辑视图名+数据，逻辑视图名为 <code>index</code> ，意思我们需要在 <code>resources/templates</code> 目录下提供一个名为 <code>index.html</code> 的 <code>Thymeleaf</code> 模板文件。</p>
<ul>
<li><strong>创建 Thymeleaf</strong></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>编号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;user : $&#123;users&#125;&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>在 <code>Thymeleaf</code> 中，通过 <code>th:each</code> 指令来遍历一个集合，数据的展示通过 <code>th:text</code> 指令来实现，</p>
<p>注意 <code>index.html</code> 最上面要引入 <code>thymeleaf</code> 名称空间。</p>
<p>配置完成后，就可以启动项目了，访问 /index 接口，就能看到集合中的数据了：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/18-2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>另外，<code>Thymeleaf</code> 支持在 <code>js</code> 中直接获取 <code>Model</code> 中的变量。例如，在 <code>IndexController</code> 中有一个变量 <code>username</code> ：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/index&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span> </span>&#123;
        model.addAttribute(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>在页面模板中，可以直接在 js 中获取到这个变量：</p>
<div class="hljs code-wrapper"><pre><code class="hljs js">&lt;script th:inline=<span class="hljs-string">&quot;javascript&quot;</span>&gt;
    <span class="hljs-keyword">var</span> username = [[$&#123;username&#125;]];
    <span class="hljs-built_in">console</span>.log(username)
&lt;/script&gt;</code></pre></div>

<p>这个功能算是 Thymeleaf 的特色之一吧。</p>
<h3 id="1-2-手动渲染"><a href="#1-2-手动渲染" class="headerlink" title="1.2 手动渲染"></a>1.2 手动渲染</h3><p>前面我们说的是返回一个 Thymeleaf 模板，我们也可以手动渲染 Thymeleaf 模板，这个一般在邮件发送时候有用，例如我在 resources/templates 目录下新建一个邮件模板，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎 <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>加入 XXX 集团，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>职位<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;position&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;salary&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.javaboy.org/images/sb/javaboy.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>这一个 HTML 模板中，有几个变量，我们要将这个 HTML 模板渲染成一个 String 字符串，再把这个字符串通过邮件发送出去，那么如何手动渲染呢？</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
TemplateEngine templateEngine;
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;
    Context context = <span class="hljs-keyword">new</span> Context();
    context.setVariable(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);
    context.setVariable(<span class="hljs-string">&quot;position&quot;</span>, <span class="hljs-string">&quot;Java工程师&quot;</span>);
    context.setVariable(<span class="hljs-string">&quot;salary&quot;</span>, <span class="hljs-number">99999</span>);
    String mail = templateEngine.process(<span class="hljs-string">&quot;mail&quot;</span>, context);
    <span class="hljs-comment">//省略邮件发送</span>
&#125;</code></pre></div>

<ul>
<li>渲染时，我们需要首先注入一个 <code>TemplateEngine </code>对象，这个对象就是在 Thymeleaf 的自动化配置类中配置的（即当我们引入 Thymeleaf 的依赖之后，这个实例就有了）。</li>
<li>然后构造一个 Context 对象用来存放变量。</li>
<li>调用 process 方法进行渲染，该方法的返回值就是渲染后的 HTML 字符串，然后我们将这个字符串发送出去。</li>
</ul>
<p>这是 Spring Boot 整合 Thymeleaf 的几个关键点，关于 Thymeleaf 这个页面模板本身更多的用法，可以参考 Thymeleaf 的文档：[<a href="https://www.thymeleaf.org]">https://www.thymeleaf.org]</a>(</p>
<h3 id="1-3-Thymeleaf-细节"><a href="#1-3-Thymeleaf-细节" class="headerlink" title="1.3 Thymeleaf 细节"></a>1.3 Thymeleaf 细节</h3><h4 id="1-3-1-标准表达式语法"><a href="#1-3-1-标准表达式语法" class="headerlink" title="1.3.1 标准表达式语法"></a>1.3.1 标准表达式语法</h4><h5 id="简单表达式"><a href="#简单表达式" class="headerlink" title="简单表达式"></a>简单表达式</h5><p><strong>${…}</strong></p>
<p>直接使用 <code>th:xx = &quot;$&#123;&#125;&quot;</code> 获取对象属性。这个在前面的案例中已经演示过了，不再赘述。</p>
<p><strong>*{…}</strong></p>
<p>可以像 <code>$&#123;...&#125;</code> 一样使用，也可以通过 <code>th:object</code> 获取对象，然后使用 <code>th:xx = &quot;*&#123;&#125;&quot;</code> 获取对象属性，这种简写风格极为清爽，推荐大家在实际项目中使用。</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$&#123;user&#125;&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div>

<p><strong>#{…}</strong></p>
<p>通常的国际化属性：<code>#&#123;...&#125;</code> 用于获取国际化语言翻译值。</p>
<p>在 resources 目录下新建两个文件：messages.properties 和 messages_zh_CN.properties，内容如下：</p>
<p>messages.properties：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">message</span> = <span class="hljs-string">javaboy</span></code></pre></div>

<p>messages_zh_CN.properties：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">message</span> = <span class="hljs-string">江南一点雨</span></code></pre></div>

<p>然后在 thymeleaf 中引用 message，系统会根据浏览器的语言环境显示不同的值：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;message&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><strong>@{…}</strong></p>
<ul>
<li><strong>引用绝对 URL：</strong></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;http://localhost:8080/hello.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p>等价于：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/hello.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<ul>
<li><strong>上下文相关的 URL：</strong></li>
</ul>
<p>首先在 application.properties 中配置 Spring Boot 的上下文，以便于测试：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/myapp</span></code></pre></div>

<p>引用路径：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/hello.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p>等价于：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/myapp/hello.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<ul>
<li><strong>相对 URL：</strong></li>
</ul>
<p>这个相对是指相对于服务器的 URL，例如如下引用：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;~/hello.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p>等价于：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/hello.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p>应用程序的上下文 <strong>/myapp</strong> 将被忽略。</p>
<ul>
<li><strong>协议相对 URL：</strong></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;//localhost:8080/hello.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p>等价于：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//localhost:8080/hello.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<ul>
<li><strong>带参数的 URL：</strong></li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;//localhost:8080/hello.js(name=&#x27;javaboy&#x27;,age=99)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p>等价于：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;//localhost:8080/hello.js?name=javaboy&amp;age=99&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p><strong>~{…}</strong></p>
<p>片段表达式是 Thymeleaf 的特色之一，细粒度可以达到标签级别，这是 JSP 无法做到的。片段表达式拥有三种语法：</p>
<ul>
<li><code>~&#123; viewName &#125;</code>：表示引入完整页面</li>
<li><code>~&#123; viewName ::selector&#125;</code>：表示在指定页面寻找片段，其中 selector 可为片段名、jquery选择器等</li>
<li><code>~&#123; ::selector&#125;</code>： 表示在当前页寻找</li>
</ul>
<p>举个简单例子。</p>
<p>在 resources/templates 目录下新建 my_fragment.html 文件，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;javaboy_link&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.javaboy.org&quot;</span>&gt;</span>www.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;itboyhub_link&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.itboyhub.com&quot;</span>&gt;</span>www.itboyhub.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>这里有两个 div，通过 th:fragment 来定义片段，两个 div 分别具有不同的名字。</p>
<p>然后在另外一个页面中引用该片段：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$&#123;user&#125;&quot;</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;aaa&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;my_fragment.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;~&#123;my_fragment.html::javaboy_link&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;~&#123;::aaa&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>通过 th:replace 来引用片段。第一个表示引用完整的 <code>my_fragment.html</code> 页面；第二个表示引用 <code>my_fragment.html</code> 中的名为 <code>javaboy_link</code> 的片段；第三个表示引用当前页面名为 aaa 的片段，也就是上面那个 table。</p>
<h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>这些是一些可以直接写在表达式中的字符，主要有如下几种：</p>
<ul>
<li>文本字面量： ‘one text’, ‘Another one!’,…</li>
<li>数字字面量： 0, 34, 3.0, 12.3,…</li>
<li>布尔字面量： true, false</li>
<li>Null字面量： null</li>
<li>字面量标记：one, sometext, main,…</li>
</ul>
<p>案例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;这是 文本字面量(有空格)&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;javaboy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;99&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>如果文本是英文，并且不包含空格、逗号等字符，可以不用加单引号。</p>
<h5 id="文本运算"><a href="#文本运算" class="headerlink" title="文本运算"></a>文本运算</h5><p>文本可以使用 <code>+</code> 进行拼接。</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;hello &#x27;+&#x27;javaboy&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;hello &#x27;+$&#123;user.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>如果字符串中包含变量，也可以使用另一种简单的方式，叫做字面量置换，用 <code>|</code> 代替 <code>&#39;...&#39; + &#39;...&#39;</code>，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;|hello $&#123;user.username&#125;|&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;hello &#x27;+$&#123;user.username&#125;+&#x27; &#x27;+|Go $&#123;user.address&#125;|&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h5 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h5><p>算术运算有：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 和 <code>%</code>。</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;age=(99*99/99+99-1)&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>th:with 定义了一个局部变量 age，在其所在的 div 中可以使用该局部变量</p>
<h5 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h5><ul>
<li>二元运算符：and, or</li>
<li>布尔非（一元运算符）：!, not</li>
</ul>
<p>案例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;age=(99*99/99+99-1)&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;9 eq 9 or 8 ne 8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;!(9 eq 9 or 8 ne 8)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;not(9 eq 9 or 8 ne 8)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h5 id="比较和相等"><a href="#比较和相等" class="headerlink" title="比较和相等"></a>比较和相等</h5><p>表达式里的值可以使用 <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> 和 <code>&lt;=</code> 符号比较。<code>==</code> 和 <code>!=</code> 运算符用于检查相等（或者不相等）。注意 <code>XML</code>规定 <code>&lt;</code> 和 <code>&gt;</code> 标签不能用于属性值，所以应当把它们转义为 <code>&lt;</code> 和 <code>&gt;</code>。</p>
<p>如果不想转义，也可以使用别名：<code>gt (&gt;)；lt (&lt;)；ge (&gt;=)；le (&lt;=)；not (!)</code>还有<code> eq (==), neq/ne (!=)</code></p>
<p>举例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;age=(99*99/99+99-1)&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; eq 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; ne 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; ge 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; gt 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; le 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;age&#125; lt 197&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h5 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h5><p>类似于我们 Java 中的三目运算符。</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;age=(99*99/99+99-1)&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;($&#123;age&#125; ne 197)?&#x27;yes&#x27;:&#x27;no&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>其中，: 后面的部分可以省略，如果省略了，又同时计算结果为 false 时，将返回 null。</p>
<h5 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h5><p>基本内置对象：</p>
<ul>
<li>#ctx：上下文对象。</li>
<li>#vars: 上下文变量。</li>
<li>#locale：上下文区域设置。</li>
<li>#request：（仅在 Web 上下文中）HttpServletRequest 对象。</li>
<li>#response：（仅在 Web 上下文中）HttpServletResponse 对象。</li>
<li>#session：（仅在 Web 上下文中）HttpSession 对象。</li>
<li>#servletContext：（仅在 Web 上下文中）ServletContext 对象。</li>
</ul>
<p>在页面可以访问到上面这些内置对象，举个简单例子：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&#x27;$&#123;#session.getAttribute(&quot;name&quot;)&#125;&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>实用内置对象：</p>
<ul>
<li>#execInfo：有关正在处理的模板的信息。</li>
<li>#messages：在变量表达式中获取外部化消息的方法，与使用＃{…}语法获得的方式相同。</li>
<li>#uris：转义URL / URI部分的方法</li>
<li>#conversions：执行配置的转换服务（如果有）的方法。</li>
<li>#dates：java.util.Date对象的方法：格式化，组件提取等</li>
<li>#calendars：类似于#dates但是java.util.Calendar对象。</li>
<li>#numbers：用于格式化数字对象的方法。</li>
<li>#strings：String对象的方法：contains，startsWith，prepending / appending等</li>
<li>#objects：一般对象的方法。</li>
<li>#bools：布尔评估的方法。</li>
<li>#arrays：数组方法。</li>
<li>#lists：列表的方法。</li>
<li>#sets：集合的方法。</li>
<li>#maps：地图方法。</li>
<li>#aggregates：在数组或集合上创建聚合的方法。</li>
<li>#ids：处理可能重复的id属性的方法（例如，作为迭代的结果）。</li>
</ul>
<p>这是一些内置对象以及工具方法，使用方式也都比较容易，如果使用的是 IntelliJ IDEA，都会自动提示对象中的方法，很方便。</p>
<p>举例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#execInfo.getProcessedTemplateName()&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#arrays.length(#request.getAttribute(&#x27;names&#x27;))&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h4 id="1-3-2-设置属性值"><a href="#1-3-2-设置属性值" class="headerlink" title="1.3.2 设置属性值"></a>1.3.2 设置属性值</h4><p>这个是给 HTML 元素设置属性值。可以一次设置多个，多个之间用 <code>,</code> 分隔开。</p>
<p>例如：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:attr</span>=<span class="hljs-string">&quot;src=@&#123;/1.png&#125;,title=$&#123;user.username&#125;,alt=$&#123;user.username&#125;&quot;</span>&gt;</span></code></pre></div>

<p>会被渲染成：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/myapp/1.png&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;javaboy&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;javaboy&quot;</span>&gt;</span></code></pre></div>

<p>当然这种设置方法不太美观，可读性也不好。Thymeleaf 还支持在每一个原生的 HTML 属性前加上 th: 前缀的方式来使用动态值，像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/1.png&#125;&quot;</span> <span class="hljs-attr">th:alt</span>=<span class="hljs-string">&quot;$&#123;user.username&#125;&quot;</span> <span class="hljs-attr">th:title</span>=<span class="hljs-string">&quot;$&#123;user.username&#125;&quot;</span>&gt;</span></code></pre></div>

<p>这种写法看起来更清晰一些，渲染效果和前面一致。</p>
<p>上面案例中的 alt 和 title 则是两个特殊的属性，可以一次性设置，像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/1.png&#125;&quot;</span> <span class="hljs-attr">th:alt-title</span>=<span class="hljs-string">&quot;$&#123;user.username&#125;&quot;</span>&gt;</span></code></pre></div>

<p>这个等价于前文的设置。</p>
<h4 id="1-3-3-遍历"><a href="#1-3-3-遍历" class="headerlink" title="1.3.3 遍历"></a>1.3.3 遍历</h4><p>数组/集合/Map/Enumeration/Iterator 等的遍历也算是一个非常常见的需求，Thymeleaf 中通过 th:each 来实现遍历，像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;u : $&#123;users&#125;&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div>

<p>users 是要遍历的集合/数组，u 则是集合中的单个元素。</p>
<p>遍历的时候，我们可能需要获取遍历的状态，Thymeleaf 也对此提供了支持：</p>
<ul>
<li>index：当前的遍历索引，从0开始。</li>
<li>count：当前的遍历索引，从1开始。</li>
<li>size：被遍历变量里的元素数量。</li>
<li>current：每次遍历的遍历变量。</li>
<li>even/odd：当前的遍历是偶数次还是奇数次。</li>
<li>first：当前是否为首次遍历。</li>
<li>last：当前是否为最后一次遍历。</li>
</ul>
<p>u 后面的 state 表示遍历状态，通过遍历状态可以引用上面的属性。</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;u,state : $&#123;users&#125;&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.index&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.count&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.size&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.current&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.even&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.first&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.last&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div>

<h4 id="1-3-4-分支语句"><a href="#1-3-4-分支语句" class="headerlink" title="1.3.4 分支语句"></a>1.3.4 分支语句</h4><p>只显示奇数次的遍历，可以使用 th:if，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;u,state : $&#123;users&#125;&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.index&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.count&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.size&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.current&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.even&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.first&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.last&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div>

<p>th:if 不仅仅只接受布尔值，也接受其他类型的值，例如如下值都会判定为 true：</p>
<ul>
<li>如果值是布尔值，并且为 true。</li>
<li>如果值是数字，并且不为 0。</li>
<li>如果值是字符，并且不为 0。</li>
<li>如果值是字符串，并且不为 “false”， “off” 或者 “no”。</li>
<li>如果值不是布尔值，数字，字符或者字符串。</li>
</ul>
<p>但是如果值为 null，th:if 会求值为 false。</p>
<p>th:unless 的判定条件则与 th:if 完全相反。</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;u,state : $&#123;users&#125;&quot;</span> <span class="hljs-attr">th:unless</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.index&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.count&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.size&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.current&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.even&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.first&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.last&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div>

<p>这个显示效果则与上面的完全相反。</p>
<p>当可能性比较多的时候，也可以使用 switch：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;u,state : $&#123;users&#125;&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;u.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.index&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.count&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.size&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.current&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.even&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.first&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;state.last&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">&quot;$&#123;state.odd&#125;&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>odd<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;*&quot;</span>&gt;</span>even<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div>

<p><code>th:case=&quot;*&quot;</code> 则表示默认选项。</p>
<h4 id="1-3-5-本地变量"><a href="#1-3-5-本地变量" class="headerlink" title="1.3.5 本地变量"></a>1.3.5 本地变量</h4><p>这个我们前面已经涉及到了，使用 th:with 可以定义一个本地变量。</p>
<h4 id="1-3-6-内联"><a href="#1-3-6-内联" class="headerlink" title="1.3.6 内联"></a>1.3.6 内联</h4><p>我们可以使用属性将数据放入页面模版中，但是很多时候，内联的方式看起来更加直观一些，像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello [[$&#123;user.username&#125;]]<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>用内联的方式去做拼接也显得更加自然。</p>
<p><code>[[...]]</code> 对应于 th:text （结果会是转义的 HTML），<code>[(...)]</code>对应于 th:utext，它不会执行任何的 HTML 转义。</p>
<p>像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;str=&#x27;hello &lt;strong&gt;javaboy&lt;/strong&gt;&#x27;&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>[[$&#123;str&#125;]]<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>[($&#123;str&#125;)]<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>最终的显示效果如下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201215210604.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201215210604.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>不过内联方式有一个问题。我们使用 Thymeleaf 的一大优势在于不用动态渲染就可以直接在浏览器中看到显示效果，当我们使用属性配置的时候确实是这样，但是如果我们使用内联的方式，各种表达式就会直接展示在静态网页中。</p>
<p>也可以在 js 或者 css 中使用内联，以 js 为例，js 中需要通过 <code>th:inline=&quot;javascript&quot;</code> 开启内联</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> username=[[$&#123;user.username&#125;]]</span>
<span class="javascript">    <span class="hljs-built_in">console</span>.log(username)</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>



<p>大家在网上可能都看到过一些代码生成工具，很酷！MyBatis、Service、Controller、Model 全部都可以自动生成。</p>
<p>这些工具的实现其实非常 Easy，只要熟悉 JDBC API 和任意一种页面模版就可以实现。今天松哥就尝试使用 Freemarker 做一个简单的案例，带大家揭开代码生成工具的神秘面纱。</p>
<p>我们先来看看 Spring Boot 整合 Freemarker，然后再来看看如何实现自动生成代码。</p>
<h2 id="2-Freemarker"><a href="#2-Freemarker" class="headerlink" title="2. Freemarker"></a>2. Freemarker</h2><p>这是一个相当老牌的开源的免费的模版引擎，基于Apache许可证2.0版本发布。</p>
<p>通过 Freemarker 模版，我们可以将数据渲染成 HTML 网页、电子邮件、配置文件以及源代码等。Freemarker 不是面向最终用户的，而是一个 Java 类库，我们可以将之作为一个普通的组件嵌入到我们的产品中。</p>
<p>来看一张来自 Freemarker 官网的图片：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/10-1.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/10-1-20210521175030210.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看到，Freemarker 可以将模版和数据渲染成 HTML 。</p>
<p>Freemarker 模版后缀为 <code>.ftlh</code>(FreeMarker Template Language)。FTL 是一种简单的、专用的语言，它不是像 Java 那样成熟的编程语言。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。</p>
<h3 id="2-1-整合-Spring-Boot"><a href="#2-1-整合-Spring-Boot" class="headerlink" title="2.1  整合 Spring Boot"></a>2.1  整合 Spring Boot</h3><p>在 SSM 中整合 Freemarker ，所有的配置文件加起来，前前后后大约在 50 行左右，Spring Boot 中要几行配置呢？ 0 行！</p>
<h4 id="2-1-1-创建工程"><a href="#2-1-1-创建工程" class="headerlink" title="2.1.1 创建工程"></a>2.1.1 创建工程</h4><p>首先创建一个 Spring Boot 工程，引入 Freemarker 依赖，如下图：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201217125112.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217125112.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>工程创建完成后，在 <code>org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration</code> 类中，可以看到关于 Freemarker 的自动化配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span>
<span class="hljs-meta">@ConditionalOnClass(&#123; freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class &#125;)</span>
<span class="hljs-meta">@EnableConfigurationProperties(FreeMarkerProperties.class)</span>
<span class="hljs-meta">@Import(&#123; FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class,</span>
<span class="hljs-meta">		FreeMarkerNonWebConfiguration.class &#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerAutoConfiguration</span> </span>&#123;
&#125;</code></pre></div>

<p>从这里可以看出，当 <code>classpath</code> 下存在 <code>freemarker.template.Configuration</code> 以及 <code>FreeMarkerConfigurationFactory</code> 时，配置才会生效，也就是说当我们引入了 <code>Freemarker</code> 之后，配置就会生效。但是这里的自动化配置只做了模板位置检查，其他配置则是在导入的 <code>FreeMarkerServletWebConfiguration</code> 配置中完成的。那么我们再来看看 <code>FreeMarkerServletWebConfiguration</code> 类，部分源码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span>
<span class="hljs-meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span>
<span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, FreeMarkerConfigurer.class &#125;)</span>
<span class="hljs-meta">@AutoConfigureAfter(WebMvcAutoConfiguration.class)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerServletWebConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFreeMarkerConfiguration</span> </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">FreeMarkerServletWebConfiguration</span><span class="hljs-params">(FreeMarkerProperties properties)</span> </span>&#123;
		<span class="hljs-keyword">super</span>(properties);
	&#125;

	<span class="hljs-meta">@Bean</span>
	<span class="hljs-meta">@ConditionalOnMissingBean(FreeMarkerConfig.class)</span>
	<span class="hljs-function">FreeMarkerConfigurer <span class="hljs-title">freeMarkerConfigurer</span><span class="hljs-params">()</span> </span>&#123;
		FreeMarkerConfigurer configurer = <span class="hljs-keyword">new</span> FreeMarkerConfigurer();
		applyProperties(configurer);
		<span class="hljs-keyword">return</span> configurer;
	&#125;

	<span class="hljs-meta">@Bean</span>
	freemarker.template.<span class="hljs-function">Configuration <span class="hljs-title">freeMarkerConfiguration</span><span class="hljs-params">(FreeMarkerConfig configurer)</span> </span>&#123;
		<span class="hljs-keyword">return</span> configurer.getConfiguration();
	&#125;

	<span class="hljs-meta">@Bean</span>
	<span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;freeMarkerViewResolver&quot;)</span>
	<span class="hljs-meta">@ConditionalOnProperty(name = &quot;spring.freemarker.enabled&quot;, matchIfMissing = true)</span>
	<span class="hljs-function">FreeMarkerViewResolver <span class="hljs-title">freeMarkerViewResolver</span><span class="hljs-params">()</span> </span>&#123;
		FreeMarkerViewResolver resolver = <span class="hljs-keyword">new</span> FreeMarkerViewResolver();
		getProperties().applyToMvcViewResolver(resolver);
		<span class="hljs-keyword">return</span> resolver;
	&#125;

	<span class="hljs-meta">@Bean</span>
	<span class="hljs-meta">@ConditionalOnEnabledResourceChain</span>
	<span class="hljs-meta">@ConditionalOnMissingFilterBean(ResourceUrlEncodingFilter.class)</span>
	<span class="hljs-function">FilterRegistrationBean&lt;ResourceUrlEncodingFilter&gt; <span class="hljs-title">resourceUrlEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;
		FilterRegistrationBean&lt;ResourceUrlEncodingFilter&gt; registration = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;(
				<span class="hljs-keyword">new</span> ResourceUrlEncodingFilter());
		registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ERROR);
		<span class="hljs-keyword">return</span> registration;
	&#125;

&#125;</code></pre></div>

<p>我们来简单看下这段源码：</p>
<ul>
<li>@ConditionalOnWebApplication 表示当前配置在 web 环境下才会生效。</li>
<li>ConditionalOnClass 表示当前配置在存在 Servlet 和 FreeMarkerConfigurer 时才会生效。</li>
<li>@AutoConfigureAfter 表示当前自动化配置在 WebMvcAutoConfiguration 之后完成。</li>
<li>代码中，主要提供了 FreeMarkerConfigurer 和 FreeMarkerViewResolver。</li>
<li>FreeMarkerConfigurer 是 Freemarker 的一些基本配置，例如 templateLoaderPath、defaultEncoding 等</li>
<li>FreeMarkerViewResolver 则是视图解析器的基本配置，包含了viewClass、suffix、allowRequestOverride、allowSessionOverride 等属性。</li>
</ul>
<p>另外还有一点，在这个类的构造方法中，注入了 FreeMarkerProperties：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.freemarker&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">&quot;&quot;</span>;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">&quot;.ftlh&quot;</span>;
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * Well-known FreeMarker keys which are passed to FreeMarker&#x27;s Configuration.</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
&#125;</code></pre></div>

<p>FreeMarkerProperties 中则配置了 Freemarker 的基本信息，例如模板位置在 <code>classpath:/templates/</code> ，再例如模板后缀为 <code>.ftlh</code>，那么这些配置我们以后都可以在 application.properties 中进行修改。</p>
<p>如果我们在 SSM 的 XML 文件中自己配置 Freemarker ，也不过就是配置这些东西。现在，这些配置由 FreeMarkerServletWebConfiguration 帮我们完成了。</p>
<h4 id="2-1-2-创建类"><a href="#2-1-2-创建类" class="headerlink" title="2.1.2 创建类"></a>2.1.2 创建类</h4><p>首先我们来创建一个 User 类，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> String address;
    <span class="hljs-comment">//省略 getter/setter</span>
&#125;</code></pre></div>

<p>再来创建 <code>UserController</code>：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/index&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span> </span>&#123;
        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            User user = <span class="hljs-keyword">new</span> User();
            user.setId((<span class="hljs-keyword">long</span>) i);
            user.setUsername(<span class="hljs-string">&quot;javaboy&gt;&gt;&gt;&gt;&quot;</span> + i);
            user.setAddress(<span class="hljs-string">&quot;www.javaboy.org&gt;&gt;&gt;&gt;&quot;</span> + i);
            users.add(user);
        &#125;
        model.addAttribute(<span class="hljs-string">&quot;users&quot;</span>, users);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>最后在 freemarker 中渲染数据，创建<code>index.ftlh</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户编号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    &lt;#list users as user&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    &lt;/#list&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>运行效果如下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/10-3.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/10-3.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h4 id="2-1-3-其他配置"><a href="#2-1-3-其他配置" class="headerlink" title="2.1.3 其他配置"></a>2.1.3 其他配置</h4><p>如果我们要修改模版文件位置等，可以在 application.properties 中进行配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.freemarker.allow-request-override</span>=<span class="hljs-string">false</span>
<span class="hljs-meta">spring.freemarker.allow-session-override</span>=<span class="hljs-string">false</span>
<span class="hljs-meta">spring.freemarker.cache</span>=<span class="hljs-string">false</span>
<span class="hljs-meta">spring.freemarker.charset</span>=<span class="hljs-string">UTF-8</span>
<span class="hljs-meta">spring.freemarker.check-template-location</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">spring.freemarker.content-type</span>=<span class="hljs-string">text/html</span>
<span class="hljs-meta">spring.freemarker.expose-request-attributes</span>=<span class="hljs-string">false</span>
<span class="hljs-meta">spring.freemarker.expose-session-attributes</span>=<span class="hljs-string">false</span>
<span class="hljs-meta">spring.freemarker.suffix</span>=<span class="hljs-string">.ftl</span>
<span class="hljs-meta">spring.freemarker.template-loader-path</span>=<span class="hljs-string">classpath:/templates/</span></code></pre></div>

<p>配置文件按照顺序依次解释如下：</p>
<ul>
<li>HttpServletRequest的属性是否可以覆盖controller中model的同名项</li>
<li>HttpSession的属性是否可以覆盖controller中model的同名项</li>
<li>是否开启缓存</li>
<li>模板文件编码</li>
<li>是否检查模板位置</li>
<li>Content-Type的值</li>
<li>是否将HttpServletRequest中的属性添加到Model中</li>
<li>是否将HttpSession中的属性添加到Model中</li>
<li>模板文件后缀</li>
<li>模板文件位置</li>
</ul>
<p>好了，整合完成之后，Freemarker 的更多用法，就和在 SSM 中使用 Freemarker 一样了</p>
<h3 id="2-2-Freemarker-使用细节"><a href="#2-2-Freemarker-使用细节" class="headerlink" title="2.2 Freemarker 使用细节"></a>2.2 Freemarker 使用细节</h3><h4 id="2-2-1-插值与表达式"><a href="#2-2-1-插值与表达式" class="headerlink" title="2.2.1 插值与表达式"></a>2.2.1 插值与表达式</h4><h5 id="直接输出值"><a href="#直接输出值" class="headerlink" title="直接输出值"></a>直接输出值</h5><p><strong>字符串</strong></p>
<p>可以直接输出一个字符串：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;hello，我是直接输出的字符串&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;我的文件保存在C:\\盘&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>\ 需要进行转义。</p>
<p>如果感觉转义太麻烦，可以在目标字符串的引号前增加 r 标记,在 r 标记后的文本内容将会直接输出，像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;r&quot;我的文件保存在C:\盘&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><strong>数字</strong></p>
<p>在 FreeMarker 中使用数值需要注意以下几点:</p>
<ol>
<li>数值不能省略小数点前面的0，所以”.5”是错误的写法。</li>
<li>数值 8 , +8 , 8.00 都是相同的。</li>
</ol>
<p>数字还有一些其他的玩法：</p>
<ul>
<li>将数字以钱的形式展示：</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#assign num=99&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;num?string.currency&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><code>&lt;#assign num=99&gt;</code> 表示定义了一个变量 num，值为 99。最终的展示形式是在数字前面出现了一个人民币符号：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201217155655.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217155655.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>将数字以百分数的形式展示：</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;num?string.percent&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>展示效果如下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201217160444.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217160444.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>布尔</strong></p>
<p>布尔类型可以直接定义，不需要引号，像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#assign flag=true&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;flag?string(&quot;a&quot;,&quot;b&quot;)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>首先使用 <code>&lt;#assign flag=true&gt;</code> 定义了一个 Boolean 类型的变量，然后在 div 中展示，如果 flag 为 true，则输出 a，否则输出 b。</p>
<p><strong>集合</strong></p>
<p>集合也可以现场定义现场输出，例如如下方式定义一个 List 集合并显示出来：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;
    $&#123;x&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
&lt;/#list&gt;</code></pre></div>

<p>x 代表集合中的每一个元素，最终显示效果如下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201217161426.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217161426.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>集合中的元素也可以是一个表达式：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#list [2+2,&quot;javaboy&quot;] as x&gt;
    $&#123;x&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
&lt;/#list&gt;</code></pre></div>

<p>集合中的第一个元素就是 2+2 的结果，即 4。</p>
<p>也可以用 <code>1..5</code> 表示 1 到 5，<code>5..1</code> 表示 5 到 1，例如：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#list 5..1 as x&gt;
    $&#123;x&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
&lt;/#list&gt;
&lt;#list 1..5 as x&gt;
    $&#123;x&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
&lt;/#list&gt;</code></pre></div>

<p>也可以定义 Map 集合，Map 集合用一个 <code>&#123;&#125;</code> 来描述：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#list &#123;&quot;name&quot;:&quot;javaboy&quot;,&quot;address&quot;:&quot;www.javaboy.org&quot;&#125;?keys as x&gt;
$&#123;x&#125;
&lt;/#list&gt;
&lt;#list &#123;&quot;name&quot;:&quot;javaboy&quot;,&quot;address&quot;:&quot;www.javaboy.org&quot;&#125;?values as x&gt;
$&#123;x&#125;
&lt;/#list&gt;</code></pre></div>

<p>上面两个循环分别表示遍历 Map 中的 key 和 values。</p>
<h5 id="输出变量"><a href="#输出变量" class="headerlink" title="输出变量"></a>输出变量</h5><p>创建一个 HelloController，然后添加如下方法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;
        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            User u = <span class="hljs-keyword">new</span> User();
            u.setUsername(<span class="hljs-string">&quot;javaboy:&quot;</span> + i);
            u.setAddress(<span class="hljs-string">&quot;www.javaboy.org:&quot;</span> + i);
            users.add(u);
        &#125;
        Map&lt;String, Object&gt; info = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        info.put(<span class="hljs-string">&quot;site&quot;</span>, <span class="hljs-string">&quot;http://www.itboyhub.com&quot;</span>);
        info.put(<span class="hljs-string">&quot;wechat&quot;</span>, <span class="hljs-string">&quot;a_java_boy&quot;</span>);
        info.put(<span class="hljs-string">&quot;github&quot;</span>, <span class="hljs-string">&quot;https://github.com/lenve&quot;</span>);
        model.addAttribute(<span class="hljs-string">&quot;users&quot;</span>, users);
        model.addAttribute(<span class="hljs-string">&quot;info&quot;</span>, info);
        model.addAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;江南一点雨&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>接下来我们在模版文件中对这里的普通变量、List 集合以及 Map 分别进行展示。</p>
<p><strong>普通变量</strong></p>
<p>普通变量的展示很容易，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><strong>集合</strong></p>
<p>集合的展示就有很多不同的玩法了。</p>
<p>直接遍历：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
        &lt;#list users as u&gt;
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        &lt;/#list&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>输出集合中第三个元素：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    $&#123;users[3].username&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>输出集合中第 4-6 个元素，即子集合：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
        &lt;#list users[3..5] as u&gt;
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        &lt;/#list&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>遍历时，可以通过 <code>变量_index</code> 获取遍历的下标：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
        &lt;#list users[3..5] as u&gt;
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u_index&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        &lt;/#list&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><strong>Map</strong></p>
<p>直接获取 Map 中的值有不同的写法，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;info.wechat&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;info[&#x27;site&#x27;]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>获取 Map 中的所有 key，并根据 key 获取 value：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    &lt;#list info?keys as key&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;key&#125;--$&#123;info[key]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    &lt;/#list&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>获取 Map 中的所有 value：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    &lt;#list info?values as value&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    &lt;/#list&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><p>字符串的拼接有两种方式：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;hello $&#123;name&#125;&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;hello &quot;+ name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>也可以从字符串中截取子串：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;name[0]&#125;$&#123;name[1]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;name[0..2]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>最终显示效果如下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201217200637.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217200637.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h5 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h5><p>集合或者 Map 都可以相加。</p>
<p>集合相加：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    &lt;#list [&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;] + [&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;] as x&gt;
        $&#123;x&#125;
    &lt;/#list&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>Map 相加：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    &lt;#list (info+&#123;&quot;gitee&quot;:&quot;https://gitee.com/lenve&quot;&#125;)?keys as key&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;key&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    &lt;/#list&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p><code>+</code>、<code>—</code>、<code>*</code>、<code>/</code>、<code>%</code> 运算都是支持的。</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    &lt;#assign age=99&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;age*99/99+99-1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h5 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h5><p>比较运算和 Thymeleaf 比较类似:</p>
<ul>
<li>= 或者 == 判断两个值是否相等。</li>
<li>!= 判断两个值是否不等。</li>
<li><code>&gt;</code> 或者 gt 判断左边值是否大于右边值。</li>
<li><code>&gt;=</code> 或者 gte 判断左边值是否大于等于右边值。</li>
<li><code>&lt;</code> 或者 lt 判断左边值是否小于右边值。</li>
<li><code>&lt;=</code> 或者 lte 判断左边值是否小于等于右边值。</li>
</ul>
<p>可以看到，带 <code>&lt;</code> 或者 <code>&gt;</code> 的符号，也都有别名，建议使用别名。</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    &lt;#assign age=99&gt;
    &lt;#if age=99&gt;age=99&lt;/#if&gt;
    &lt;#if age gt 99&gt;age gt 99&lt;/#if&gt;
    &lt;#if age gte 99&gt;age gte 99&lt;/#if&gt;
    &lt;#if age lt 99&gt;age lt 99&lt;/#if&gt;
    &lt;#if age lte 99&gt;age lte 99&lt;/#if&gt;
    &lt;#if age!=99&gt;age!=99&lt;/#if&gt;
    &lt;#if age==99&gt;age==99&lt;/#if&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>逻辑运算符有三个:</p>
<ul>
<li>逻辑与 <code>&amp;&amp;</code></li>
<li>逻辑或 <code>||</code></li>
<li>逻辑非 <code>!</code></li>
</ul>
<p>逻辑运算符只能作用于布尔值,否则将产生错误。</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    &lt;#assign age=99&gt;
    &lt;#if age=99 &amp;&amp; 1==1&gt;age=99 &amp;&amp; 1==1&lt;/#if&gt;
    &lt;#if age=99 || 1==0&gt;age=99 || 1==0&lt;/#if&gt;
    &lt;#if !(age gt 99)&gt;!(age gt 99)&lt;/#if&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h5 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h5><p>为了处理缺失变量,Freemarker 提供了两个运算符:</p>
<ol>
<li><code>!</code>：指定缺失变量的默认值</li>
<li><code>??</code>：判断某个变量是否存在</li>
</ol>
<p>如果某个变量不存在，则设置其为 javaboy，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!&quot;javaboy&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>如果某个变量不存在，则设置其为空字符串，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>即，<code>!</code> 后面的东西如果省略了，默认就是空字符串。</p>
<p>判断某个变量是否存在：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!&quot;javaboy&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
  &lt;#if aaa??&gt;
    aaa
    &lt;/#if&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h4 id="2-2-2-内建函数"><a href="#2-2-2-内建函数" class="headerlink" title="2.2.2 内建函数"></a>2.2.2 内建函数</h4><p>内建函数涉及到的东西比较多，可以参考官方文档:<a target="_blank" rel="noopener" href="http://freemarker.foofun.cn/ref_builtins.html%E3%80%82">http://freemarker.foofun.cn/ref_builtins.html。</a></p>
<p>这里仅说一些比较常用的内建函数。</p>
<p><strong>cap_first</strong></p>
<p>使字符串第一个字母大写：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;hello&quot;?cap_first&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><strong>lower_case</strong></p>
<p>将字符串转换成小写：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;HELLO&quot;?lower_case&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><strong>upper_case</strong></p>
<p>将字符串转换成大写：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot;hello&quot;?upper_case&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><strong>trim</strong></p>
<p>去掉字符串前后的空白字符：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;&quot; hello&quot;?trim&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><strong>size</strong></p>
<p>获取序列中元素的个数：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;users?size&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><strong>int</strong></p>
<p>取得数字的整数部分,结果带符号：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;3.14?int&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><strong>日期格式化</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;birthday?string(&quot;yyyy-MM-dd&quot;)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<h4 id="2-2-3-常用指令"><a href="#2-2-3-常用指令" class="headerlink" title="2.2.3 常用指令"></a>2.2.3 常用指令</h4><h5 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h5><p>分支控制指令，作用类似于 Java 语言中的 if：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    &lt;#assign age=23&gt;
    &lt;#if (age&gt;60)&gt;老年人
    &lt;#elseif (age&gt;40)&gt;中年人
    &lt;#elseif (age&gt;20)&gt;青年人
    &lt;#else&gt; 少年人
    &lt;/#if&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>比较符号中用了 <code>()</code>，因此不用转义。</p>
<h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><p>分支指令，类似于 Java 中的 switch：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    &lt;#assign age=99&gt;
    &lt;#switch age&gt;
        &lt;#case 23&gt;23&lt;#break&gt;
        &lt;#case 24&gt;24&lt;#break&gt;
        &lt;#default&gt;9999
    &lt;/#switch&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p><code>&lt;#break&gt;</code> 是提前退出，也可以用在 <code>&lt;#list&gt;</code> 中。</p>
<h5 id="include"><a href="#include" class="headerlink" title="include"></a>include</h5><p>include 可以包含一个外部页面进来。</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#include &quot;./javaboy.ftlh&quot;&gt;</code></pre></div>

<h5 id="macro"><a href="#macro" class="headerlink" title="macro"></a>macro</h5><p>macro 用来定义一个宏。</p>
<p>我们可以自定义一个名为 book 的宏，并引用它：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#macro book&gt;
    三国演义
&lt;/#macro&gt;
&lt;@book/&gt;</code></pre></div>

<p>最终页面中会输出宏中所定义的内容。</p>
<p>在定义宏的时候，也可以传入参数，那么引用时，也需要传入参数：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#macro book bs&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
        &lt;#list bs as b&gt;
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;b&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        &lt;/#list&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
&lt;/#macro&gt;
&lt;@book [&quot;三国演义&quot;,&quot;水浒传&quot;]/&gt;</code></pre></div>

<p>bs 就是需要传入的参数。可以通过传入多个参数，多个参数跟在 bs 后面即可，中间用空格隔开。</p>
<p>还可以使用 <code>&lt;#nested&gt;</code> 引入用户自定义指令的标签体，像下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#macro book bs&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
        &lt;#list bs as b&gt;
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;b&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        &lt;/#list&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
    &lt;#nested&gt;
&lt;/#macro&gt;
&lt;@book [&quot;三国演义&quot;,&quot;水浒传&quot;]&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello javaboy!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
&lt;/@book&gt;</code></pre></div>

<p>在宏定义的时候，<code>&lt;#nested&gt;</code> 相当于是一个占位符，在调用的时候，<code>&lt;@book&gt;</code> 标签中的内容会出现在 <code>&lt;#nested&gt;</code> 位置。</p>
<p>前面的案例中，宏都是定义在当前页面中，宏也可以定义在一个专门的页面中。新建<code>myjavaboy.ftlh</code>页面，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#macro book bs&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
        &lt;#list bs as b&gt;
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;b&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        &lt;/#list&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
    &lt;#nested&gt;
&lt;/#macro&gt;</code></pre></div>

<p>此时，需要先通过 <code>&lt;#import&gt;</code> 标签导入宏，然后才能调用，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#import &quot;./myjavaboy.ftlh&quot; as com&gt;
&lt;@com.book bs=[&quot;三国演义&quot;,&quot;水浒传&quot;]&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello javaboy!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
&lt;/@com.book&gt;</code></pre></div>

<h5 id="noparse"><a href="#noparse" class="headerlink" title="noparse"></a>noparse</h5><p>如果想在页面展示一些 Freemarker 语法而不被渲染，则可以使用 noparse 标签，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html">&lt;#noparse&gt;
&lt;#import &quot;./myjavaboy.ftlh&quot; as com&gt;
&lt;@com.book bs=[&quot;三国演义&quot;,&quot;水浒传&quot;]&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello javaboy!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
&lt;/@com.book&gt;
&lt;/#noparse&gt;</code></pre></div>

<p>显示效果如下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/20201217214402.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20201217214402.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>如果要同时使用Thymeleaf，要把Freemarker的pom依赖放在前面</strong></p>
<h1 id="第三章、SpringBoot整合Web"><a href="#第三章、SpringBoot整合Web" class="headerlink" title="第三章、SpringBoot整合Web"></a>第三章、SpringBoot整合Web</h1><h2 id="1-SpringBoot中的JSON"><a href="#1-SpringBoot中的JSON" class="headerlink" title="1. SpringBoot中的JSON"></a>1. SpringBoot中的JSON</h2><p>具体的JSON用法可以[参考SringMVC](#11. JSON)中的介绍，这里补充几点</p>
<h3 id="1-1-Jackson"><a href="#1-1-Jackson" class="headerlink" title="1.1 Jackson"></a>1.1 Jackson</h3><p>SpringBoot默认就有，不需要额外引入<code>pom.xml</code>的依赖</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//批量忽略字段</span>
<span class="hljs-meta">@JsonIgnoreProperties(&#123;&quot;birthday&quot;,&quot;address&quot;&#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-comment">//指定属性序列化/反序列化时的名称，默认名称就是属性名</span>
    <span class="hljs-meta">@JsonProperty(value = &quot;aaaage&quot;,index = 99)</span>
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-meta">@JsonProperty(index = 98)</span>
    <span class="hljs-keyword">private</span> String username;
		<span class="hljs-meta">@JsonProperty(index = 97)</span>
    <span class="hljs-comment">//日期格式化，注意时区问题</span>
		<span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;Asia/Shanghai&quot;)</span>
    <span class="hljs-comment">//类似于 @JsonProperty 中的 index</span>
    <span class="hljs-meta">@JsonPropertyOrder</span>
    <span class="hljs-keyword">private</span> Date birthday;

    <span class="hljs-comment">//序列化/反序列化时忽略某一个字段</span>
		<span class="hljs-meta">@JsonIgnore</span>
    <span class="hljs-keyword">private</span> String address;</code></pre></div>

<p>自己提供一个<code>ObjectMapper</code>实例，就不用每个实体类上添加</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">ObjectMapper <span class="hljs-title">objectMapper</span><span class="hljs-params">()</span> </span>&#123;
        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();
        om.setDateFormat(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));
        <span class="hljs-keyword">return</span> om;
    &#125;
&#125;</code></pre></div>

<h3 id="1-2-Gson"><a href="#1-2-Gson" class="headerlink" title="1.2 Gson"></a>1.2 Gson</h3><p>在<code>pom.xml</code>里排除默认的依赖再引入</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><code>application.properties</code>里的配置</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.gson.date-format</span>=<span class="hljs-string">yyyy-MM-dd HH:mm:ss</span>
<span class="hljs-comment">## 是否禁用 HTML 的转义字符</span>
<span class="hljs-meta">spring.gson.disable-html-escaping</span>=<span class="hljs-string">true</span>
<span class="hljs-comment">## 序列化时是否排除内部类</span>
<span class="hljs-meta">spring.gson.disable-inner-class-serialization</span>=<span class="hljs-string">false</span>
<span class="hljs-comment">## 序列化时是否弃用复杂映射键</span>
<span class="hljs-meta">spring.gson.enable-complex-map-key-serialization</span>=<span class="hljs-string"></span>
<span class="hljs-comment">## 是否排除没有 @Expose 注解的字段</span>
<span class="hljs-meta">spring.gson.exclude-fields-without-expose-annotation</span>=<span class="hljs-string"></span>
<span class="hljs-comment">## 序列化时字段名的命名策略</span>
<span class="hljs-meta">spring.gson.field-naming-policy</span>=<span class="hljs-string"></span>
<span class="hljs-comment">## 在输出之前添加一些特殊的文本来生成一个不可执行的 JSON</span>
<span class="hljs-meta">spring.gson.generate-non-executable-json</span>=<span class="hljs-string"></span>
<span class="hljs-comment">## 是否序列化空字段</span>
<span class="hljs-meta">spring.gson.serialize-nulls</span>=<span class="hljs-string"></span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/user&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setUsername(<span class="hljs-string">&quot;javaboy&quot;</span>);
        user.setBirthday(<span class="hljs-keyword">new</span> Date());
        <span class="hljs-keyword">return</span> user;
    &#125;
&#125;


<span class="hljs-comment">//同理于jackson的ObjectMapper</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">GsonBuilder <span class="hljs-title">gsonBuilder</span><span class="hljs-params">()</span> </span>&#123;
        GsonBuilder gsonBuilder = <span class="hljs-keyword">new</span> GsonBuilder();
        gsonBuilder.setDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);
        <span class="hljs-keyword">return</span> gsonBuilder;
    &#125;
  
<span class="hljs-comment">//或者</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">GsonHttpMessageConverter <span class="hljs-title">gsonHttpMessageConverter</span><span class="hljs-params">()</span> </span>&#123;
        GsonBuilder gsonBuilder = <span class="hljs-keyword">new</span> GsonBuilder();
        gsonBuilder.setDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);
        GsonHttpMessageConverter converter = <span class="hljs-keyword">new</span> GsonHttpMessageConverter();
        converter.setGson(gsonBuilder.create());
        <span class="hljs-keyword">return</span> converter;
    &#125;
&#125;</code></pre></div>

<h3 id="1-3-fastjson"><a href="#1-3-fastjson" class="headerlink" title="1.3 fastjson"></a>1.3 fastjson</h3><p>在<code>pom.xml</code>里排除默认的依赖再引入</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.75<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>Spring没有给它提供<code>FastJsonHttpMessageConverter</code>，必须要自己提供</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">FastJsonHttpMessageConverter <span class="hljs-title">fastJsonHttpMessageConverter</span><span class="hljs-params">()</span> </span>&#123;
        FastJsonHttpMessageConverter converter = <span class="hljs-keyword">new</span> FastJsonHttpMessageConverter();
        FastJsonConfig fastJsonConfig = <span class="hljs-keyword">new</span> FastJsonConfig();
        fastJsonConfig.setCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));
        fastJsonConfig.setDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);
        converter.setFastJsonConfig(fastJsonConfig);
        converter.setDefaultCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));
        <span class="hljs-keyword">return</span> converter;
    &#125;
&#125;

<span class="hljs-comment">//或者</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;
        FastJsonHttpMessageConverter converter = <span class="hljs-keyword">new</span> FastJsonHttpMessageConverter();
        FastJsonConfig fastJsonConfig = <span class="hljs-keyword">new</span> FastJsonConfig();
        fastJsonConfig.setCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));
        fastJsonConfig.setDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);
        converter.setFastJsonConfig(fastJsonConfig);
        converter.setDefaultCharset(Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));
        converters.add(converter);
    &#125;
&#125;</code></pre></div>

<h2 id="2-静态资源配置"><a href="#2-静态资源配置" class="headerlink" title="2. 静态资源配置"></a>2. 静态资源配置</h2><h3 id="2-1-SSM-中的配置"><a href="#2-1-SSM-中的配置" class="headerlink" title="2.1 SSM 中的配置"></a>2.1 SSM 中的配置</h3><p>要讲 Spring Boot 中的问题，我们得先回到 SSM 环境搭建中，一般来说，我们可以通过 <code>&lt;mvc:resources /&gt;</code> 节点来配置不拦截静态资源，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/js/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/js/&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/css/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/css/&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/html/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/html/&quot;</span>/&gt;</span></code></pre></div>

<p>由于这是一种Ant风格的路径匹配符，<code>/**</code> 表示可以匹配任意层级的路径，因此上面的代码也可以像下面这样简写：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/&quot;</span>/&gt;</span></code></pre></div>

<p>这种配置是在 XML 中的配置，大家知道，SpringMVC 的配置除了在XML中配置，也可以在 Java 代码中配置，如果在Java代码中配置的话，我们只需要自定义一个类，继承自WebMvcConfigurationSupport即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = &quot;org.sang.javassm&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;
        registry.addResourceHandler(<span class="hljs-string">&quot;/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;/&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>重写 WebMvcConfigurationSupport 类中的addResourceHandlers方法，在该方法中配置静态资源位置即可，这里的含义和上面 xml 配置的含义一致，因此无需多说。<br>这是我们传统的解决方案，在Spring Boot 中，其实配置方式和这个一脉相承，只是有一些自动化的配置了。</p>
<h3 id="2-2-Spring-Boot-中的配置"><a href="#2-2-Spring-Boot-中的配置" class="headerlink" title="2.2 Spring Boot 中的配置"></a>2.2 Spring Boot 中的配置</h3><p>在 Spring Boot 中，如果我们是从 <code>https://start.spring.io</code> 这个网站上创建的项目，或者使用 IntelliJ IDEA 中的 Spring Boot 初始化工具创建的项目，默认都会存在<code>resources/static</code>目录，很多小伙伴也知道静态资源只要放到这个目录下，就可以直接访问，除了这里还有没有其他可以放静态资源的位置呢？为什么放在这里就能直接访问了呢？这就是本文要讨论的问题了。</p>
<h4 id="2-2-1-整体规划"><a href="#2-2-1-整体规划" class="headerlink" title="2.2.1 整体规划"></a>2.2.1 整体规划</h4><p>首先，在 Spring Boot 中，默认情况下，一共有5个位置可以放静态资源，五个路径分别是如下5个：</p>
<ul>
<li>classpath:/META-INF/resources/</li>
<li>classpath:/resources/</li>
<li>classpath:/static/</li>
<li>classpath:/public/</li>
<li>/</li>
</ul>
<p>前四个目录好理解，分别对应了resources目录下不同的目录，第5个 <code>/</code> 是啥意思呢？我们知道，在 Spring Boot 项目中，默认是没有 webapp 这个目录的，当然我们也可以自己添加（例如在需要使用JSP的时候），这里第5个 <code>/</code>其实就是表示 webapp 目录中的静态资源也不被拦截。如果同一个文件分别出现在五个目录下，那么优先级也是按照上面列出的顺序。</p>
<p>不过，虽然有5个存储目录，除了第5个用的比较少之外，其他四个，系统默认创建了 <code>classpath:/static/</code> ， 正常情况下，我们只需要将我们的静态资源放到这个目录下即可，也不需要额外去创建其他静态资源目录，例如我在 <code>classpath:/static/</code> 目录下放了一张名为1.png 的图片，那么我的访问路径是：</p>
<div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8080</span>/<span class="hljs-number">1</span>.png</code></pre></div>

<p>这里大家注意，请求地址中并不需要 <code>static</code>，如果加上了<code>static</code>反而多此一举会报404错误。很多人会觉得奇怪，为什么不需要添加<code> static</code>呢？资源明明放在 <code>static </code>目录下。其实这个效果很好实现，例如在SSM配置中，我们的静态资源拦截配置如果是下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/&quot;</span>/&gt;</span></code></pre></div>

<p>如果我们是这样配置的话，请求地址如果是 <code>http://localhost:8080/1.png</code> 实际上系统会去 <code>/static/1.png</code> 目录下查找相关的文件。</p>
<p>所以我们理所当然的猜测，在 Spring Boot 中可能也是类似的配置。</p>
<h4 id="2-2-2-源码解读"><a href="#2-2-2-源码解读" class="headerlink" title="2.2.2 源码解读"></a>2.2.2 源码解读</h4><p>胡适之先生说：“大胆猜想，小心求证”，我们这里就通过源码解读来看看 Spring Boot 中的静态资源到底是怎么配置的。</p>
<p>首先我们在 <code>WebMvcAutoConfiguration </code>类中看到了 SpringMVC 自动化配置的相关的内容，找到了静态资源拦截的配置，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/21-1-20210525153453678.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>可以看到这里静态资源的定义和我们前面提到的Java配置SSM中的配置非常相似，其中，<code>this.mvcProperties.getStaticPathPattern() </code>方法对应的值是 <code>“/**”</code>，<code>this.resourceProperties.getStaticLocations()</code>方法返回了四个位置，分别是：”<code>classpath:/META-INF/resources/”, “classpath:/resources/”,”classpath:/static/”, “classpath:/public/”</code>，然后在<code>getResourceLocations</code>方法中，又添加了<code>“/”</code>，因此这里返回值一共有5个。其中，<code>/</code>表示<code>webapp</code>目录，即webapp中的静态文件也可以直接访问。静态资源的匹配路径按照定义路径优先级依次降低。因此这里的配置和我们前面提到的如出一辙。这样大伙就知道了为什么Spring Boot 中支持5个静态资源位置，同时也明白了为什么静态资源请求路径中不需要<code>/static</code>，因为在路径映射中已经自动的添加上了<code>/static</code>了。</p>
<h4 id="2-2-3-自定义配置"><a href="#2-2-3-自定义配置" class="headerlink" title="2.2.3 自定义配置"></a>2.2.3 自定义配置</h4><p>当然，这个是系统默认配置，如果我们并不想将资源放在系统默认的这五个位置上，也可以自定义静态资源位置和映射，自定义的方式也有两种，可以通过 application.properties 来定义，也可以在 Java 代码中来定义，下面分别来看。</p>
<ul>
<li>application.properties</li>
</ul>
<p>在配置文件中定义的方式比较简单，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.resources.static-locations</span>=<span class="hljs-string">classpath:/</span>
<span class="hljs-meta">spring.mvc.static-path-pattern</span>=<span class="hljs-string">/**</span></code></pre></div>

<p>第一行配置表示定义资源位置，第二行配置表示定义请求 URL 规则。以上文的配置为例，如果我们这样定义了，表示可以将静态资源放在 resources目录下的任意地方，我们访问的时候当然也需要写完整的路径，例如在resources/static目录下有一张名为1.png 的图片，那么访问路径就是 <code>http://localhost:8080/static/1.png</code> ,注意此时的static不能省略。</p>
<ul>
<li>Java 代码定义</li>
</ul>
<p>当然，在Spring Boot中我们也可以通过 Java代码来自定义，方式和 Java 配置的 SSM 比较类似，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMVCConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;
        registry.addResourceHandler(<span class="hljs-string">&quot;/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/aaa/&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>这里需要提醒大家的是，有很多人用了 Thymeleaf 之后，<strong>会将静态资源也放在 resources/templates 目录下，注意，templates 目录并不是静态资源目录，它是一个放页面模板的位置（</strong>你看到的 Thymeleaf 模板虽然后缀为 .html，其实并不是静态资源）</p>
<h3 id="2-3-路径映射"><a href="#2-3-路径映射" class="headerlink" title="2.3 路径映射"></a>2.3 路径映射</h3><p>利用Controller跳转</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/01&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello01</span><span class="hljs-params">(Model model)</span> </span>&#123;

        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;01&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>利用配置类直接进行</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;
        registry.addViewController(<span class="hljs-string">&quot;/02&quot;</span>).setViewName(<span class="hljs-string">&quot;02&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>这样就可以在不创建controller的情况下，在url中直接输入02跳转到02.html页面了，但是此方法不支持跳转到动态渲染的页面上，具有一定的局限性</p>
<h3 id="2-4-自定义首页"><a href="#2-4-自定义首页" class="headerlink" title="2.4 自定义首页"></a>2.4 自定义首页</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;
        registry.addViewController(<span class="hljs-string">&quot;/index&quot;</span>).setViewName(<span class="hljs-string">&quot;index&quot;</span>);

    &#125;
&#125;</code></pre></div>

<p>默认访问的是<code>static</code>下的<code>index.html</code>，如果下面没有，去访问<code>templates</code>下的<code>index.html</code></p>
<p>如果要定义网站<code>favicon</code>，放置<code>favicon.ico</code>放在<code>static</code>下即可</p>
<h2 id="3-文件上传"><a href="#3-文件上传" class="headerlink" title="3. 文件上传"></a>3. 文件上传</h2><p>Spring自带的是<code>StandardServletMultipartResolver</code>，创建Controller</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController</span> </span>&#123;
    <span class="hljs-comment">//分类处理</span>
    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;/yyyy/MM/dd/&quot;</span>);
    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span>
    <span class="hljs-comment">//file要和html的name值对应</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;
        <span class="hljs-comment">//临时目录</span>
        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">&quot;/&quot;</span>);
        String format = sdf.format(<span class="hljs-keyword">new</span> Date());
        String path = realPath + format;
        File folder = <span class="hljs-keyword">new</span> File(path);
        <span class="hljs-comment">//判空处理</span>
        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;
            folder.mkdirs();
        &#125;
        <span class="hljs-comment">//名字后缀</span>
        String oldName = file.getOriginalFilename();
        <span class="hljs-comment">//前缀</span>
        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//拼接</span>
            file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));
            <span class="hljs-comment">//动态获取</span>
            String s = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + format + newName;
            <span class="hljs-keyword">return</span> s;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;
    &#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>
<span class="hljs-comment">&lt;!--name属性必须写上,同时要和controller里的对应--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#设置上传文件大小</span>
<span class="hljs-meta">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">1KB</span></code></pre></div>

<p><strong>如果要上传多文件</strong>，配置如下</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController2</span> </span>&#123;
    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;/yyyy/MM/dd/&quot;</span>);

    <span class="hljs-meta">@PostMapping(&quot;/upload2&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile[] files, HttpServletRequest req)</span> </span>&#123;
        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">&quot;/&quot;</span>);
        String format = sdf.format(<span class="hljs-keyword">new</span> Date());
        String path = realPath + format;
        File folder = <span class="hljs-keyword">new</span> File(path);
        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;
            folder.mkdirs();
        &#125;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">for</span> (MultipartFile file : files) &#123;
                String oldName = file.getOriginalFilename();
                String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));
                file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));
                String s = req.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + req.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + req.getServerPort() + format + newName;
                System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload2&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;files&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p><strong>ajax的文件上传</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://code.jquery.com/jquery-3.5.1.js&quot;</span> <span class="hljs-attr">integrity</span>=<span class="hljs-string">&quot;sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc=&quot;</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;uploadFile()&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadFile</span>(<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">        <span class="hljs-comment">//拿到文件对象</span></span>
<span class="javascript">        <span class="hljs-keyword">var</span> file = $(<span class="hljs-string">&quot;#file&quot;</span>)[<span class="hljs-number">0</span>].files[<span class="hljs-number">0</span>];</span>
<span class="javascript">        <span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> FormData();</span>
<span class="javascript">        formData.append(<span class="hljs-string">&quot;file&quot;</span>, file);</span>
<span class="javascript">        formData.append(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);</span>
<span class="javascript">        $.ajax(&#123;</span>
<span class="javascript">            type:<span class="hljs-string">&#x27;post&#x27;</span>,</span>
<span class="javascript">            url:<span class="hljs-string">&#x27;/upload&#x27;</span>,</span>
<span class="javascript">            processData:<span class="hljs-literal">false</span>,</span>
<span class="javascript">            contentType:<span class="hljs-literal">false</span>,</span>
            data:formData,
<span class="javascript">            success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span>
<span class="javascript">                $(<span class="hljs-string">&quot;#result&quot;</span>).html(msg);</span>
            &#125;
        &#125;)
    &#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<h2 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h2><p>在 Spring Boot 项目中 ，异常统一处理，可以使用 Spring 中 @ControllerAdvice 来统一处理，也可以自己来定义异常处理方案。Spring Boot 中，对异常的处理有一些默认的策略，我们分别来看。</p>
<p>默认情况下，Spring Boot 中的异常页面 是这样的：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-1-20210525153453655.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我们从这个异常提示中，也能看出来，之所以用户看到这个页面，是因为开发者没有明确提供一个 /error 路径，如果开发者提供了 /error 路径 ，这个页面就不会展示出来，不过在 Spring Boot 中，提供 /error 路径实际上是下下策，Spring Boot 本身在处理异常时，也是当所有条件都不满足时，才会去找 /error 路径。那么我们就先来看看，在 Spring Boot 中，如何自定义 error 页面，整体上来说，可以分为两种，一种是静态页面，另一种是动态页面。</p>
<h3 id="4-1-静态异常页面"><a href="#4-1-静态异常页面" class="headerlink" title="4.1 静态异常页面"></a>4.1 静态异常页面</h3><p>自定义静态异常页面，又分为两种，第一种 是使用 HTTP 响应码来命名页面，例如<code> 404.html、405.html、500.html ….</code>，另一种就是直接定义一个 <code>4xx.html</code>，表示400-499 的状态都显示这个异常页面，5xx.html 表示 500-599 的状态显示这个异常页面。</p>
<p>默认是在 <code>classpath:/static/error/</code> 路径下定义相关页面：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-2-20210525153453642.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>此时，启动项目，如果项目抛出 500 请求错误，就会自动展示 500.html 这个页面，发生 404 就会展示 404.html 页面。如果异常展示页面既存在 5xx.html，也存在 500.html ，此时，发生500异常时，优先展示 500.html 页面</p>
<h3 id="4-2-动态异常页面"><a href="#4-2-动态异常页面" class="headerlink" title="4.2 动态异常页面"></a>4.2 动态异常页面</h3><p>动态的异常页面定义方式和静态的基本 一致，可以采用的页面模板有 jsp、freemarker、thymeleaf。动态异常页面，也支持 404.html 或者 4xx.html ，但是一般来说，由于动态异常页面可以直接展示异常详细信息，所以就没有必要挨个枚举错误了 ，直接定义 4xx.html（这里使用thymeleaf模板）或者 5xx.html 即可。</p>
<p><strong>注意，动态页面模板，不需要开发者自己去定义控制器，直接定义异常页面即可 ，Spring Boot 中自带的异常处理器会自动查找到异常页面。</strong></p>
<p>页面定义如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-3-20210525153453651.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>页面内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>5xx<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>path<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;path&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;error&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>message<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>timestamp<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;timestamp&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>status<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;status&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>默认情况下，完整的异常信息就是这5条，展示 效果如下 ：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-4-20210525153453654.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如果动态页面和静态页面同时定义了异常处理页面，例如 <code>classpath:/static/error/404.html</code> 和 <code>classpath:/templates/error/404.html</code> 同时存在时，默认使用动态页面。即完整的错误页面查找方式应该是这样：</p>
<p><strong>发生了500错误–&gt;查找动态 500.html 页面–&gt;查找静态 500.html –&gt; 查找动态 5xx.html–&gt;查找静态 5xx.html</strong></p>
<h3 id="4-3-自定义异常数据"><a href="#4-3-自定义异常数据" class="headerlink" title="4.3 自定义异常数据"></a>4.3 自定义异常数据</h3><p>默认情况下，在Spring Boot 中，所有的异常数据其实就是上文所展示出来的5条数据，这5条数据定义在 <code>org.springframework.boot.web.reactive.error.DefaultErrorAttributes</code> 类中，具体定义在 <code>getErrorAttributes</code> 方法中 ：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getErrorAttributes</span><span class="hljs-params">(ServerRequest request,</span></span>
<span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">boolean</span> includeStackTrace)</span> </span>&#123;
        Map&lt;String, Object&gt; errorAttributes = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();
        errorAttributes.put(<span class="hljs-string">&quot;timestamp&quot;</span>, <span class="hljs-keyword">new</span> Date());
        errorAttributes.put(<span class="hljs-string">&quot;path&quot;</span>, request.path());
        Throwable error = getError(request);
        HttpStatus errorStatus = determineHttpStatus(error);
        errorAttributes.put(<span class="hljs-string">&quot;status&quot;</span>, errorStatus.value());
        errorAttributes.put(<span class="hljs-string">&quot;error&quot;</span>, errorStatus.getReasonPhrase());
        errorAttributes.put(<span class="hljs-string">&quot;message&quot;</span>, determineMessage(error));
        handleException(errorAttributes, determineException(error), includeStackTrace);
        <span class="hljs-keyword">return</span> errorAttributes;
&#125;</code></pre></div>

<p><code>DefaultErrorAttributes </code>类本身则是在<code>org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration </code>异常自动配置类中定义的，如果开发者没有自己提供一个 <code>ErrorAttributes</code> 的实例的话，那么 Spring Boot 将自动提供一个<code>ErrorAttributes</code> 的实例，也就是 <code>DefaultErrorAttributes </code></p>
<p>基于此 ，开发者自定义 <code>ErrorAttributes </code>有两种方式 ：</p>
<ul>
<li>直接实现 <code>ErrorAttributes </code>接口</li>
<li>继承 <code>DefaultErrorAttributes</code>（推荐），因为<code>DefaultErrorAttributes</code>中对异常数据的处理已经完成，开发者可以直接使用。</li>
</ul>
<p>具体定义如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyErrorAttributes</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultErrorAttributes</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getErrorAttributes</span><span class="hljs-params">(WebRequest webRequest, <span class="hljs-keyword">boolean</span> includeStackTrace)</span> </span>&#123;
        Map&lt;String, Object&gt; map = <span class="hljs-keyword">super</span>.getErrorAttributes(webRequest, includeStackTrace);
        <span class="hljs-keyword">if</span> ((Integer)map.get(<span class="hljs-string">&quot;status&quot;</span>) == <span class="hljs-number">500</span>) &#123;
            map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;服务器内部错误!&quot;</span>);
        &#125;
        <span class="hljs-keyword">return</span> map;
    &#125;
&#125;</code></pre></div>

<p>定义好的<code>ErrorAttributes</code>一定要注册成一个 Bean ，这样，Spring Boot 就不会使用默认的 <code>DefaultErrorAttributes </code>了，运行效果如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-5-20210525153453655.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="4-4-自定义异常视图"><a href="#4-4-自定义异常视图" class="headerlink" title="4.4 自定义异常视图"></a>4.4 自定义异常视图</h3><p>异常视图默认就是前面所说的静态或者动态页面，这个也是可以自定义的，首先 ，默认的异常视图加载逻辑在 <code>org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController </code>类的 <code>errorHtml </code>方法中，这个方法用来返回异常页面+数据，还有另外一个 error 方法，这个方法用来返回异常数据（如果是 ajax 请求，则该方法会被触发）。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">errorHtml</span><span class="hljs-params">(HttpServletRequest request,</span></span>
<span class="hljs-function"><span class="hljs-params">                HttpServletResponse response)</span> </span>&#123;
        HttpStatus status = getStatus(request);
        Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(
                        request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));
        response.setStatus(status.value());
        ModelAndView modelAndView = resolveErrorView(request, response, status, model);
        <span class="hljs-keyword">return</span> (modelAndView != <span class="hljs-keyword">null</span>) ? modelAndView : <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>, model);
&#125;</code></pre></div>

<p>在该方法中 ，首先会通过 <code>getErrorAttributes</code> 方法去获取异常数据（实际上会调用到 <code>ErrorAttributes </code>的实例 的 <code>getErrorAttributes </code>方法），然后调用<code> resolveErrorView</code> 去创建一个<code> ModelAndView</code> ，如果这里创建失败，那么用户将会看到默认的错误提示页面。</p>
<p>正常情况下，<code>resolveErrorView</code>方法会来到 <code>DefaultErrorViewResolver </code>类的 <code>resolveErrorView</code> 方法中：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveErrorView</span><span class="hljs-params">(HttpServletRequest request, HttpStatus status,</span></span>
<span class="hljs-function"><span class="hljs-params">                Map&lt;String, Object&gt; model)</span> </span>&#123;
        ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);
        <span class="hljs-keyword">if</span> (modelAndView == <span class="hljs-keyword">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;
                modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);
        &#125;
        <span class="hljs-keyword">return</span> modelAndView;
&#125;</code></pre></div>

<p>在这里，首先以异常响应码作为视图名分别去查找动态页面和静态页面，如果没有查找到，则再以 4xx 或者 5xx 作为视图名再去分别查找动态或者静态页面。</p>
<p>要自定义异常视图解析，也很容易 ，由于<code>DefaultErrorViewResolver</code>是在<code> ErrorMvcAutoConfiguration</code> 类中提供的实例，即开发者没有提供相关实例时，会使用默认的 <code>DefaultErrorViewResolver </code>，开发者提供了自己的<code> ErrorViewResolver</code> 实例后，默认的配置就会失效，因此，自定义异常视图，只需要提供 一个 <code>ErrorViewResolver </code>的实例即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyErrorViewResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultErrorViewResolver</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyErrorViewResolver</span><span class="hljs-params">(ApplicationContext applicationContext, ResourceProperties resourceProperties)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(applicationContext, resourceProperties);
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveErrorView</span><span class="hljs-params">(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;/aaa/123&quot;</span>, model);
    &#125;
&#125;</code></pre></div>

<p>实际上，开发者也可以在这里定义异常数据（直接在<code> resolveErrorView</code> 方法重新定义一个 model ，将参数中的model 数据拷贝过去并修改，注意参数中的 model 类型为 <code>UnmodifiableMap</code>，即不可以直接修改），而不需要自定义<code>MyErrorAttributes</code>。定义完成后，提供一个名为123的视图，如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/4-6-20210525153453660.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如此之后，错误试图就算定义成功了。</p>
<h2 id="5-CORS解决跨域"><a href="#5-CORS解决跨域" class="headerlink" title="5. CORS解决跨域"></a>5. CORS解决跨域</h2><blockquote>
<p>域：协议+域名/IP/端口</p>
</blockquote>
<h3 id="5-1-同源策略"><a href="#5-1-同源策略" class="headerlink" title="5.1 同源策略"></a>5.1 同源策略</h3><p>很多人对跨域有一种误解，以为这是前端的事，和后端没关系，其实不是这样的，说到跨域，就不得不说说浏览器的同源策略。<br>同源策略是由Netscape提出的一个著名的安全策略，它是浏览器最核心也最基本的安全功能，现在所有支持JavaScript的浏览器都会使用这个策略。所谓同源是指协议、域名以及端口要相同。同源策略是基于安全方面的考虑提出来的，这个策略本身没问题，但是我们在实际开发中，由于各种原因又经常有跨域的需求，传统的跨域方案是JSONP，JSONP虽然能解决跨域但是有一个很大的局限性，那就是只支持GET请求，不支持其他类型的请求，而今天我们说的<strong>CORS（跨域源资源共享）（CORS，Cross-origin resource sharing）</strong>是一个W3C标准，它是一份浏览器技术的规范，提供了Web服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，这是JSONP模式的现代版。<br>在Spring框架中，对于CORS也提供了相应的解决方案，今天我们就来看看SpringBoot中如何实现CORS。</p>
<h3 id="5-2-实践"><a href="#5-2-实践" class="headerlink" title="5.2 实践"></a>5.2 实践</h3><p>首先创建两个普通的SpringBoot项目，第一个命名为<code>provider</code>提供服务，第二个命名为<code>consumer</code>消费服务，第一个配置端口为8080，第二个配置配置为8081，然后在provider上提供两个hello接口，一个get，一个post，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
    &#125;
    <span class="hljs-meta">@PostMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;post hello&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>在<code>consumer</code>的<code>resources/static</code>目录下创建一个html文件，发送一个简单的ajax请求，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;btnClick()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;get_button&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;btnClick2()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;post_button&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">btnClick</span>(<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">        $.get(<span class="hljs-string">&#x27;http://localhost:8080/hello&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span>
<span class="javascript">            $(<span class="hljs-string">&quot;#app&quot;</span>).html(msg);</span>
        &#125;);
    &#125;

<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">btnClick2</span>(<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">        $.post(<span class="hljs-string">&#x27;http://localhost:8080/hello&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span>
<span class="javascript">            $(<span class="hljs-string">&quot;#app&quot;</span>).html(msg);</span>
        &#125;);
    &#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p>然后分别启动两个项目，发送请求按钮，观察浏览器控制台如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">Access to XMLHttpRequest at <span class="hljs-string">&#x27;http://localhost:8080/hello&#x27;</span> from origin <span class="hljs-string">&#x27;http://localhost:8081&#x27;</span> has been blocked by CORS policy: No <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.</code></pre></div>

<p>可以看到，由于同源策略的限制，请求无法发送成功。</p>
<p>使用CORS可以在前端代码不做任何修改的情况下，实现跨域，那么接下来看看在provider中如何配置。首先可以通过<code>@CrossOrigin</code>注解配置某一个方法接受某一个域的请求，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span>
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
    &#125;

    <span class="hljs-meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span>
    <span class="hljs-meta">@PostMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;post hello&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>这个注解表示这两个接口接受来自<a href="http://localhost:8081地址的请求，配置完成后，重启provider，再次发送请求，浏览器控制台就不会报错了，consumer也能拿到数据了">http://localhost:8081地址的请求，配置完成后，重启provider，再次发送请求，浏览器控制台就不会报错了，consumer也能拿到数据了</a></p>
<p>此时观察浏览器请求网络控制台，可以看到响应头中多了如下信息：<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/w1-1-20210525153453702.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这个表示服务端愿意接收来自<a href="http://localhost:8081的请求，拿到这个信息后，浏览器就不会再去限制本次请求的跨域了。">http://localhost:8081的请求，拿到这个信息后，浏览器就不会再去限制本次请求的跨域了。</a></p>
<p>provider上，每一个方法上都去加注解未免太麻烦了，在Spring Boot中，还可以通过全局配置一次性解决这个问题，全局配置只需要在配置类中重写<code>addCorsMappings</code>方法即可，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;
        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)
        .allowedOrigins(<span class="hljs-string">&quot;http://localhost:8081&quot;</span>)
        .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)
        .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>);
    &#125;
  
<span class="hljs-comment">//或者</span>
      <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;
        UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();
        CorsConfiguration cfg = <span class="hljs-keyword">new</span> CorsConfiguration();
        cfg.addAllowedOrigin(<span class="hljs-string">&quot;http://localhost:8081&quot;</span>);
      	<span class="hljs-comment">//允许options探测请求</span>
        cfg.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);
        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>,cfg);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(source);
    &#125;


&#125;</code></pre></div>

<p><code>/**</code>表示本应用的所有方法都会去处理跨域请求，<code>allowedMethods</code>表示允许通过的请求数，<code>allowedHeaders</code>则表示允许的请求头。经过这样的配置之后，就不必在每个方法上单独配置跨域了。</p>
<h3 id="5-3-存在的问题"><a href="#5-3-存在的问题" class="headerlink" title="5.3 存在的问题"></a>5.3 存在的问题</h3><p>了解了整个CORS的工作过程之后，我们通过Ajax发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是CSRF（Cross-site request forgery）跨站请求伪造。跨站请求伪造也被称为one-click attack 或者 session riding，通常缩写为CSRF或者XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法，举个例子：</p>
<blockquote>
<p>假如一家银行用以运行转账操作的URL地址如下：<code>http://icbc.com/aa?bb=cc</code>，那么，一个恶意攻击者可以在另一个网站上放置如下代码：<code>&lt;img src=&quot;http://icbc.com/aa?bb=cc&quot;&gt;</code>，如果用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会遭受损失。</p>
</blockquote>
<p>基于此，浏览器在实际操作中，会对请求进行分类，分为简单请求，预先请求，带凭证的请求等，预先请求会首先发送一个options探测请求，和浏览器进行协商是否接受请求。默认情况下跨域请求是不需要凭证的，但是服务端可以配置要求客户端提供凭证，这样就可以有效避免csrf攻击。</p>
<h2 id="6-拦截器"><a href="#6-拦截器" class="headerlink" title="6. 拦截器"></a>6. 拦截器</h2><p>和SpringMVC的用法相同</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;

    <span class="hljs-comment">//该方法返回 false，请求将不再继续往下走</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;preHandle&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-comment">//Controller 执行之后被调用</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;postHandle&quot;</span>);
    &#125;

    <span class="hljs-comment">//preHandle 方法返回 true，afterCompletion 才会执行。</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;afterCompletion&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>不再用xml配置，使用基于注解的配置</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;
        registry.addInterceptor(<span class="hljs-keyword">new</span> MyInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).excludePathPatterns(<span class="hljs-string">&quot;/hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>就可以对Conroller进行拦截</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
    &#125;
    <span class="hljs-meta">@GetMapping(&quot;/hello2&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello2&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello2&quot;</span>;
    &#125;
&#125;</code></pre></div>

<h2 id="7-定义系统启动任务"><a href="#7-定义系统启动任务" class="headerlink" title="7. 定义系统启动任务"></a>7. 定义系统启动任务</h2><p>在 Servlet/Jsp 项目中，如果涉及到系统任务，例如在项目启动阶段要做一些数据初始化操作，这些操作有一个共同的特点，只在项目启动时进行，以后都不再执行，这里，容易想到web基础中的三大组件（ Servlet、Filter、Listener ）之一 Listener ，这种情况下，一般定义一个 ServletContextListener，然后就可以监听到项目启动和销毁，进而做出相应的数据初始化和销毁操作，例如下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;
        <span class="hljs-comment">//在这里做数据初始化操作</span>
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;
        <span class="hljs-comment">//在这里做数据备份操作</span>
    &#125;
&#125;</code></pre></div>

<p>当然，这是基础 web 项目的解决方案，如果使用了 Spring Boot，那么我们可以使用更为简便的方式。Spring Boot 中针对系统启动任务提供了两种解决方案，分别是 CommandLineRunner 和 ApplicationRunner，分别来看。</p>
<h3 id="7-1-CommandLineRunner"><a href="#7-1-CommandLineRunner" class="headerlink" title="7.1 CommandLineRunner"></a>7.1 CommandLineRunner</h3><p>使用 CommandLineRunner 时，首先自定义 MyCommandLineRunner1 并且实现 CommandLineRunner 接口：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Order(100)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCommandLineRunner1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    &#125;
&#125;</code></pre></div>

<p>关于这段代码，我做如下解释：</p>
<ul>
<li>首先通过 <code>@Compoent </code>注解将 <code>MyCommandLineRunner1 </code>注册为Spring容器中的一个 Bean。</li>
<li>添加 <code>@Order</code>注解，表示这个启动任务的执行优先级，因为在一个项目中，启动任务可能有多个，所以需要有一个排序。<code>@Order</code> 注解中，数字越小，优先级越大，默认情况下，优先级的值为<code> Integer.MAX_VALUE</code>，表示优先级最低。</li>
<li>在 run 方法中，写启动任务的核心逻辑，当项目启动时，run方法会被自动执行。</li>
<li>run 方法的参数，来自于项目的启动参数，即项目入口类中，main方法的参数会被传到这里。</li>
</ul>
<p>此时启动项目，run方法就会被执行，至于参数，可以通过两种方式来传递，如果是在 IDEA 中，可以通过如下方式来配置参数：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-1-20210523104130918-20210525153453711.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>另一种方式，则是将项目打包，在命令行中启动项目，然后启动时在命令行传入参数，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs shell">java -jar devtools-0.0.1-SNAPSHOT.jar 三国演义 西游记</code></pre></div>

<p>注意，这里参数传递时没有key，直接写value即可，执行结果如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-2-20210525153453688.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="7-2-ApplicationRunner"><a href="#7-2-ApplicationRunner" class="headerlink" title="7.2 ApplicationRunner"></a>7.2 ApplicationRunner</h3><p>ApplicationRunner 和 CommandLineRunner 功能一致，用法也基本一致，唯一的区别主要体现在对参数的处理上，ApplicationRunner 可以接收更多类型的参数（ApplicationRunner 除了可以接收 CommandLineRunner 的参数之外，还可以接收 key/value形式的参数）。</p>
<p>使用 ApplicationRunner ，自定义类实现 ApplicationRunner 接口即可，组件注册以及组件优先级的配置都和 CommandLineRunner 一致，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Order(98)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationRunner1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();
        System.out.println(<span class="hljs-string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+nonOptionArgs);
        Set&lt;String&gt; optionNames = args.getOptionNames();
        <span class="hljs-keyword">for</span> (String key : optionNames) &#123;
            System.out.println(<span class="hljs-string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+key + <span class="hljs-string">&quot;:&quot;</span> + args.getOptionValues(key));
        &#125;
        String[] sourceArgs = args.getSourceArgs();
        System.out.println(<span class="hljs-string">&quot;MyApplicationRunner1&gt;&gt;&gt;&quot;</span>+Arrays.toString(sourceArgs));
    &#125;
&#125;</code></pre></div>

<p>当项目启动时，这里的 run 方法就会被自动执行，关于 run 方法的参数 ApplicationArguments ，我说如下几点：</p>
<ul>
<li><code>args.getNonOptionArgs()</code>;可以用来获取命令行中的无key参数（和CommandLineRunner一样）。</li>
<li><code>args.getOptionNames()</code>;可以用来获取所有key/value形式的参数的key。</li>
<li><code>args.getOptionValues(key))</code>;可以根据key获取key/value 形式的参数的value。</li>
<li><code>args.getSourceArgs()</code>; 则表示获取命令行中的所有参数。</li>
</ul>
<p>ApplicationRunner 定义完成后，传启动参数也是两种方式，参数类型也有两种，第一种和 CommandLineRunner 一致，第二种则是 –key=value 的形式，在 IDEA 中定义方式如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-3-20210525153453687.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>或者使用 如下启动命令：</p>
<div class="hljs code-wrapper"><pre><code class="hljs shell">java -jar devtools-0.0.1-SNAPSHOT.jar 三国演义 西游记 --age=99</code></pre></div>

<p>运行结果如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-4-20210525153453678.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="8-定时任务"><a href="#8-定时任务" class="headerlink" title="8. 定时任务"></a>8. 定时任务</h2><p>在 Spring + SpringMVC 环境中，一般来说，要实现定时任务，我们有两中方案，一种是使用 Spring 自带的定时任务处理器 @Scheduled 注解，另一种就是使用第三方框架 Quartz ，Spring Boot 源自 Spring+SpringMVC ，因此天然具备这两个 Spring 中的定时任务实现策略，当然也支持 Quartz，本文我们就来看下 Spring Boot 中两种定时任务的实现方式。</p>
<h4 id="8-1-Scheduled"><a href="#8-1-Scheduled" class="headerlink" title="8.1 @Scheduled"></a>8.1 @Scheduled</h4><p>使用 @Scheduled 非常容易，直接创建一个 Spring Boot 项目，并且添加 web 依赖 <code>spring-boot-starter-web</code>，项目创建成功后，添加 <code>@EnableScheduling</code> 注解，开启定时任务：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableScheduling</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledApplication</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(ScheduledApplication.class, args);
    &#125;

&#125;</code></pre></div>

<p>接下来配置定时任务：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(fixedRate = 2000)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fixedRate</span><span class="hljs-params">()</span> </span>&#123;
  System.out.println(<span class="hljs-string">&quot;fixedRate&gt;&gt;&gt;&quot;</span>+<span class="hljs-keyword">new</span> Date());    
&#125;
<span class="hljs-meta">@Scheduled(fixedDelay = 2000)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fixedDelay</span><span class="hljs-params">()</span> </span>&#123;
  System.out.println(<span class="hljs-string">&quot;fixedDelay&gt;&gt;&gt;&quot;</span>+<span class="hljs-keyword">new</span> Date());
&#125;
<span class="hljs-meta">@Scheduled(initialDelay = 2000,fixedDelay = 2000)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialDelay</span><span class="hljs-params">()</span> </span>&#123;
  System.out.println(<span class="hljs-string">&quot;initialDelay&gt;&gt;&gt;&quot;</span>+<span class="hljs-keyword">new</span> Date());
&#125;</code></pre></div>

<ul>
<li>首先使用 @Scheduled 注解开启一个定时任务。</li>
<li>fixedRate 表示任务执行之间的时间间隔，具体是指两次任务的开始时间间隔，即第二次任务开始时，第一次任务可能还没结束。</li>
<li>fixedDelay 表示任务执行之间的时间间隔，具体是指本次任务结束到下次任务开始之间的时间间隔。</li>
<li>initialDelay 表示首次任务启动的延迟时间。</li>
<li>所有时间的单位都是毫秒。</li>
</ul>
<p>上面这是一个基本用法，除了这几个基本属性之外，@Scheduled 注解也支持 cron 表达式，使用 cron 表达式，可以非常丰富的描述定时任务的时间。cron 表达式格式如下：</p>
<blockquote>
<p>[秒] [分] [小时] [日] [月] [周] [年]</p>
</blockquote>
<p>具体取值如下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">说明</th>
<th align="left">是否必填</th>
<th align="left">允许填写的值</th>
<th align="left">允许的通配符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">秒</td>
<td align="left">是</td>
<td align="left">0-59</td>
<td align="left">- * /</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">分</td>
<td align="left">是</td>
<td align="left">0-59</td>
<td align="left">- * /</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">时</td>
<td align="left">是</td>
<td align="left">0-23</td>
<td align="left">- * /</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">日</td>
<td align="left">是</td>
<td align="left">1-31</td>
<td align="left">- * ? / L W</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">月</td>
<td align="left">是</td>
<td align="left">1-12 or JAN-DEC</td>
<td align="left">- * /</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">周</td>
<td align="left">是</td>
<td align="left">1-7 or SUN-SAT</td>
<td align="left">- * ? / L #</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">年</td>
<td align="left">否</td>
<td align="left">1970-2099</td>
<td align="left">- * /</td>
</tr>
</tbody></table>
<p><strong>这一块需要大家注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 <code>?</code></strong></p>
<p><strong>通配符含义：</strong></p>
<ul>
<li><code>?</code> 表示不指定值，即不关心某个字段的取值时使用。需要注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 <code>?</code></li>
<li><code>*</code> 表示所有值，例如:在秒的字段上设置 <code>*</code>,表示每一秒都会触发</li>
<li><code>,</code> 用来分开多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</li>
<li><code>-</code> 表示区间，例如在秒上设置 “10-12”,表示 10,11,12秒都会触发</li>
<li><code>/</code> 用于递增触发，如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)</li>
<li><code>#</code> 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六，(用 在母亲节和父亲节再合适不过了)</li>
<li>周字段的设置，若使用英文字母是不区分大小写的 ，即 MON 与mon相同</li>
<li><code>L</code> 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会自动判断是否是润年), 在周字段上表示星期六，相当于”7”或”SAT”（注意周日算是第一天）。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示”本月最后一个星期五”</li>
<li><code>W</code> 表示离指定日期的最近工作日(周一至周五)，例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)</li>
<li><code>L</code> 和 <code>W</code> 可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发(一般指发工资 )</li>
</ul>
<p>例如，在 @Scheduled 注解中来一个简单的 cron 表达式，每隔5秒触发一次，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(cron = &quot;0/5 * * * * *&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cron</span><span class="hljs-params">()</span> </span>&#123;
    System.out.println(<span class="hljs-keyword">new</span> Date());
&#125;</code></pre></div>

<p>上面介绍的是使用 @Scheduled 注解的方式来实现定时任务，接下来我们再来看看如何使用 Quartz 实现定时任务。</p>
<h4 id="8-2-Quartz"><a href="#8-2-Quartz" class="headerlink" title="8.2 Quartz"></a>8.2 Quartz</h4><p>一般在项目中，除非定时任务涉及到的业务实在是太简单，使用 @Scheduled 注解来解决定时任务，否则大部分情况可能都是使用 Quartz 来做定时任务。在 Spring Boot 中使用 Quartz ，只需要在创建项目时，添加 Quartz 依赖即可：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/6-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>项目创建完成后，也需要添加开启定时任务的注解：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableScheduling</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuartzApplication</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(QuartzApplication.class, args);
    &#125;
&#125;</code></pre></div>

<p>Quartz 在使用过程中，有两个关键概念，一个是JobDetail（要做的事情），另一个是触发器（什么时候做），要定义 JobDetail，需要先定义 Job，Job 的定义有两种方式：</p>
<p>第一种方式，直接定义一个Bean：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJob1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyJob1&gt;&gt;&gt;&quot;</span>+<span class="hljs-keyword">new</span> Date());
    &#125;
&#125;</code></pre></div>

<p>关于这种定义方式说两点：</p>
<ol>
<li>首先将这个 Job 注册到 Spring 容器中。</li>
<li>这种定义方式有一个缺陷，就是无法传参。</li>
</ol>
<p>第二种定义方式，则是继承 QuartzJobBean 并实现默认的方法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJob2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">QuartzJobBean</span> </span>&#123;
    HelloService helloService;
    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">getHelloService</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> helloService;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHelloService</span><span class="hljs-params">(HelloService helloService)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.helloService = helloService;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeInternal</span><span class="hljs-params">(JobExecutionContext jobExecutionContext)</span> <span class="hljs-keyword">throws</span> JobExecutionException </span>&#123;
        helloService.sayHello();
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello service &gt;&gt;&gt;&quot;</span>+<span class="hljs-keyword">new</span> Date());
    &#125;
&#125;</code></pre></div>

<p>和第1种方式相比，这种方式支持传参，任务启动时，executeInternal 方法将会被执行。</p>
<p>Job 有了之后，接下来创建类，配置 JobDetail 和 Trigger 触发器，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuartzConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">MethodInvokingJobDetailFactoryBean <span class="hljs-title">methodInvokingJobDetailFactoryBean</span><span class="hljs-params">()</span> </span>&#123;
        MethodInvokingJobDetailFactoryBean bean = <span class="hljs-keyword">new</span> MethodInvokingJobDetailFactoryBean();
        bean.setTargetBeanName(<span class="hljs-string">&quot;myJob1&quot;</span>);
        bean.setTargetMethod(<span class="hljs-string">&quot;sayHello&quot;</span>);
        <span class="hljs-keyword">return</span> bean;
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">JobDetailFactoryBean <span class="hljs-title">jobDetailFactoryBean</span><span class="hljs-params">()</span> </span>&#123;
        JobDetailFactoryBean bean = <span class="hljs-keyword">new</span> JobDetailFactoryBean();
        bean.setJobClass(MyJob2.class);
        JobDataMap map = <span class="hljs-keyword">new</span> JobDataMap();
        map.put(<span class="hljs-string">&quot;helloService&quot;</span>, helloService());
        bean.setJobDataMap(map);
        <span class="hljs-keyword">return</span> bean;
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">SimpleTriggerFactoryBean <span class="hljs-title">simpleTriggerFactoryBean</span><span class="hljs-params">()</span> </span>&#123;
        SimpleTriggerFactoryBean bean = <span class="hljs-keyword">new</span> SimpleTriggerFactoryBean();
        bean.setStartTime(<span class="hljs-keyword">new</span> Date());
        bean.setRepeatCount(<span class="hljs-number">5</span>);
        bean.setJobDetail(methodInvokingJobDetailFactoryBean().getObject());
        bean.setRepeatInterval(<span class="hljs-number">3000</span>);
        <span class="hljs-keyword">return</span> bean;
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">CronTriggerFactoryBean <span class="hljs-title">cronTrigger</span><span class="hljs-params">()</span> </span>&#123;
        CronTriggerFactoryBean bean = <span class="hljs-keyword">new</span> CronTriggerFactoryBean();
        bean.setCronExpression(<span class="hljs-string">&quot;0/10 * * * * ?&quot;</span>);
        bean.setJobDetail(jobDetailFactoryBean().getObject());
        <span class="hljs-keyword">return</span> bean;
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">SchedulerFactoryBean <span class="hljs-title">schedulerFactoryBean</span><span class="hljs-params">()</span> </span>&#123;
        SchedulerFactoryBean bean = <span class="hljs-keyword">new</span> SchedulerFactoryBean();
        bean.setTriggers(cronTrigger().getObject(), simpleTriggerFactoryBean().getObject());
        <span class="hljs-keyword">return</span> bean;
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">HelloService <span class="hljs-title">helloService</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloService();
    &#125;
&#125;</code></pre></div>

<p>关于这个配置说如下几点：</p>
<ul>
<li>JobDetail 的配置有两种方式：MethodInvokingJobDetailFactoryBean 和 JobDetailFactoryBean 。</li>
<li>使用 MethodInvokingJobDetailFactoryBean 可以配置目标 Bean 的名字和目标方法的名字，这种方式不支持传参。</li>
<li>使用 JobDetailFactoryBean 可以配置 JobDetail ，任务类继承自 QuartzJobBean ，这种方式支持传参，将参数封装在 JobDataMap 中进行传递。</li>
<li>Trigger 是指触发器，Quartz 中定义了多个触发器，这里向大家展示其中两种的用法，SimpleTrigger 和 CronTrigger 。</li>
<li>SimpleTrigger 有点类似于前面说的 @Scheduled 的基本用法。</li>
<li>CronTrigger 则有点类似于 @Scheduled 中 cron 表达式的用法。</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/6-2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="9-Web基础组件"><a href="#9-Web基础组件" class="headerlink" title="9. Web基础组件"></a>9. Web基础组件</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestContextListener</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestInitialized</span><span class="hljs-params">(ServletRequestEvent requestEvent)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;requestInitialized&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestDestroyed</span><span class="hljs-params">(ServletRequestEvent requestEvent)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;requestDestroyed&quot;</span>);
    &#125;
&#125;

<span class="hljs-meta">@WebServlet(urlPatterns = &quot;/hello&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        doPost(req,resp);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyServlet&quot;</span>);
    &#125;
&#125;

<span class="hljs-comment">//启动类</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@ServletComponentScan(&quot;org.javaboy.webcomponent&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebcomponentApplication</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(WebcomponentApplication.class, args);
    &#125;

&#125;</code></pre></div>

<p>关于过滤器，一般推荐使用拦截器，但这里还是对过滤器进行一定的说明</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//基础用法</span>
<span class="hljs-meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyFilter&quot;</span>);
        chain.doFilter(request,response);
    &#125;
&#125;

<span class="hljs-comment">//设置优先级需要用当基础组件处理</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-comment">//数字越小优先级越高</span>
<span class="hljs-meta">@Order(101)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyFilter02&quot;</span>);
        chain.doFilter(request, response);
    &#125;
&#125;

<span class="hljs-comment">//上述过滤器2无法指定拦截url，需要更换配置</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyFilter04&quot;</span>);
        chain.doFilter(request, response);
    &#125;
&#125;
<span class="hljs-comment">//针对03对应的配置类</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterConfiguration</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">FilterRegistrationBean&lt;MyFilter03&gt; <span class="hljs-title">filter03FilterRegistrationBean03</span><span class="hljs-params">()</span> </span>&#123;
        FilterRegistrationBean&lt;MyFilter03&gt; bean = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();
        bean.setOrder(<span class="hljs-number">90</span>);
        bean.setFilter(<span class="hljs-keyword">new</span> MyFilter03());
        bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">&quot;/*&quot;</span>));
        <span class="hljs-keyword">return</span> bean;
    &#125;
&#125;</code></pre></div>

<h2 id="10-AOP"><a href="#10-AOP" class="headerlink" title="10.  AOP"></a>10.  AOP</h2><p>Spring中已经对[AOP注解编程](#6. 基于注解的AOP编程)进行了讲解，这里做一定的补充</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//UserService</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserById</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;getUserById&quot;</span>);
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user&quot;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;delete id:&quot;</span> + id);
    &#125;
&#125;

<span class="hljs-comment">//LogAspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Aspect</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;
    <span class="hljs-meta">@Pointcut(&quot;execution(* org.javaboy.aop.service.*.*(..))&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc1</span><span class="hljs-params">()</span> </span>&#123;

    &#125;

    <span class="hljs-meta">@Before(&quot;pc1()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(JoinPoint jp)</span> </span>&#123;
        String name = jp.getSignature().getName();
        System.out.println(name + <span class="hljs-string">&quot; 方法开始执行了...&quot;</span>);
    &#125;

    <span class="hljs-meta">@After(&quot;pc1()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">(JoinPoint jp)</span> </span>&#123;
        String name = jp.getSignature().getName();
        System.out.println(name + <span class="hljs-string">&quot; 方法执行结束了...&quot;</span>);
    &#125;

    <span class="hljs-meta">@AfterReturning(value = &quot;pc1()&quot;, returning = &quot;s&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(JoinPoint jp, String s)</span> </span>&#123;
        String name = jp.getSignature().getName();
        System.out.println(name + <span class="hljs-string">&quot; 方法的返回值是 &quot;</span> + s);
    &#125;

    <span class="hljs-meta">@AfterThrowing(value = &quot;pc1()&quot;, throwing = &quot;e&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(JoinPoint jp, Exception e)</span> </span>&#123;
        String name = jp.getSignature().getName();
        System.out.println(name + <span class="hljs-string">&quot; 方法抛出了异常 &quot;</span> + e.getMessage());
    &#125;

    <span class="hljs-meta">@Around(&quot;pc1()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;

            <span class="hljs-comment">//类似于反射中的 invoke 方法</span>
            Object proceed = pjp.proceed();
            <span class="hljs-keyword">return</span> proceed;
        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;
            throwable.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;</code></pre></div>

<h2 id="11-整合Swagger"><a href="#11-整合Swagger" class="headerlink" title="11. 整合Swagger"></a>11. 整合Swagger</h2><h3 id="11-1-引言"><a href="#11-1-引言" class="headerlink" title="11.1 引言"></a>11.1 引言</h3><blockquote>
<p>相信无论是前端还是后端开发，都或多或少地被接口文档折磨过。前端经常抱怨后端给的接口文档和实际情况不一致。后端又觉得编写及维护接口文档会耗费不少精力，经常来不及更新。其实无论是前端调用后端，还是后端调用前端，都期望有一个好的接口文档。但是这个接口文档对于程序员来说，就跟注释一样，经常还会抱怨别人写的代码没有写注释，然而自己写起代码来，最讨厌的也是写注释。所以仅仅只听过强制了来规范大家是不够的，随着时间推移，版本迭代，接口文档往往很容易就跟不上代码了</p>
</blockquote>
<h3 id="11-2-什么是Swagger"><a href="#11-2-什么是Swagger" class="headerlink" title="11.2  什么是Swagger"></a>11.2  什么是Swagger</h3><blockquote>
<p>发现了痛点就要去找解决方案。解决方案用的人多了，就成了标准的规范，这就是 Swagger 的由来。通过这套规范，你只需要按照它的规范去定义接口及接口相关信息。再通过 Swagger 衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，生成多做语言的客户端和服务端的代码，以及在线接口调试页面等等。这样，如果按照新的开发木事，在开发新版本或者迭代版本的时候，只需要更新 Swagger 描述文件，就可以自动生成接口文档和客户端代码，做到调用端代码、服务端代码以及接口文档的一致性。 但即便如此，对于许多开发来说，编写这个 yml 或 json 格式的描述文件，本身也是有一定负担的工作，特别是在后面持续迭代开发的时候，往往会忽略更新这个描述文件，直接更改代码。久而久之，这个描述文件也和实际项目渐行渐远，基于该描述文件生成的接口文档也失去了参考意义。<code>所以作为 Java 界服务端的大一统框架 Spring，迅速将 Swagger 规范纳入自身的标准，建立了 Spring-swagger 项目，后面改成了现在的 Springfox。通过在项目中引入 Springfox，可以扫描相关的代码，生成该描述文件，进而生成与代码一致的接口文档和客户端代码。</code>这种通过代码生成接口文档的形式，在后面需求持续迭代的项目中，显得尤为重要和高效</p>
</blockquote>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519160517871.png" srcset="/img/loading.gif" lazyload alt="image-20210519160517871"></p>
<p><strong>总结：Swagger 就是一个用来定义接口标准，接口规范，同时能根据你的代码自动生成接口说明文档的一个工具</strong></p>
<h3 id="11-3-官方提供的工具"><a href="#11-3-官方提供的工具" class="headerlink" title="11.3 官方提供的工具"></a>11.3 官方提供的工具</h3><p><strong>Swagger Codegen</strong>：通过Codegen 可以将描述文件生成 html 格式和 cwiki 形式的接口文档，同时也能生成多种语言的服务端和客户端代码。支持通过 jar 包、docker、node 等方式在本地化执行生成。也可以在后面的 Swagger Editor 中在线生成。 </p>
<p><strong>Swagger UI</strong>：提供了一个可视化的 UI 页面展示描述文件。接口的调用方、测试、项目经理等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求。该项目支持在线导入描述文件和本地部署 UI 项目。 </p>
<p><strong>Swagger Editor</strong>：类似于 Markdown 编辑器的编辑 Swagger 描述文件的编辑器，该编辑器支持实时预览描述文件的更新效果，也提供了在线编辑器和本地部署器俩种方式。         </p>
<p><strong>Swagger Inspector</strong>：感觉和 Postman 差不多，是一个可以对接口进行测试的在线版的 postman。比如在 Swagger UI 里面做接口请求，会返回更多的信息，也会保存你请求的实际请求参数等数据。         </p>
<p><strong>Swagger Hub</strong>：集成了上面所有项目的各个功能，你可以以项目和版本为单位，将你的描述文件上传到 Swagger Hub 中。在 Swagger Hub 中可以完成上面项目的所有工作，需要注册账号，分免费版和收费版。         </p>
<p><strong>Springfox Swagger</strong>：Spring 基于 Swagger 规范，可以将基于 SpringMVC 和 Spring Boot 项目的项目代码，自动生成 JSON 格式的描述文件。本身不是属于 Swagger 官网提供的，在这里列出来做个说明，方便后面作一个使用的展开。</p>
<h3 id="11-4-构建-Swagger-与-Spring-Boot-环境"><a href="#11-4-构建-Swagger-与-Spring-Boot-环境" class="headerlink" title="11.4 构建 Swagger 与 Spring Boot 环境"></a>11.4 构建 Swagger 与 Spring Boot 环境</h3><h4 id="11-4-1-引入依赖"><a href="#11-4-1-引入依赖" class="headerlink" title="11.4.1 引入依赖"></a>11.4.1 引入依赖</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h4 id="11-4-2-编写-Swagger-配置类"><a href="#11-4-2-编写-Swagger-配置类" class="headerlink" title="11.4.2 编写 Swagger 配置类"></a>11.4.2 编写 Swagger 配置类</h4><blockquote>
<p>这个配置类基本都是不变的</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;
<span class="hljs-keyword">import</span> springfox.documentation.builders.PathSelectors;
<span class="hljs-keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;
<span class="hljs-keyword">import</span> springfox.documentation.service.Contact;
<span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;
<span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;
<span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableSwagger2</span>  
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)
                .pathMapping(<span class="hljs-string">&quot;/&quot;</span>)
                .select()
                <span class="hljs-comment">// 扫描哪个接口的包</span>
                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.example.controller&quot;</span>))
                .paths(PathSelectors.any())
                .build().apiInfo(<span class="hljs-keyword">new</span> ApiInfoBuilder()
                        .title(<span class="hljs-string">&quot;标题: SpringBoot 整合 Swagger 使用&quot;</span>)
                        .description(<span class="hljs-string">&quot;详细信息: SpringBoot 整合 Swagger,详细信息......&quot;</span>)
                        <span class="hljs-comment">// 版本信息</span>
                        .version(<span class="hljs-string">&quot;1.1&quot;</span>)
                        <span class="hljs-comment">// 开发文档的联系人</span>
                    .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;lucifer&quot;</span>, <span class="hljs-string">&quot;https://lucifer2u.github.io&quot;</span>,<span class="hljs-string">&quot;xiaoweliangx@gmail.com&quot;</span>))
                        .license(<span class="hljs-string">&quot;This Baidu License&quot;</span>)
                        .licenseUrl(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)
                        .build());
    &#125;
&#125;</code></pre></div>

<h4 id="11-4-3-启动-SpringBoot-项目"><a href="#11-4-3-启动-SpringBoot-项目" class="headerlink" title="11.4.3 启动 SpringBoot 项目"></a>11.4.3 启动 SpringBoot 项目</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519162040084.png" srcset="/img/loading.gif" lazyload alt="image-20210519162040084"></p>
<h4 id="11-4-4-访问-Swagger-的-UI-界面"><a href="#11-4-4-访问-Swagger-的-UI-界面" class="headerlink" title="11.4.4 访问 Swagger 的 UI 界面"></a>11.4.4 访问 Swagger 的 UI 界面</h4><p>访问 Swagger 提供的 UI 界面：<a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519162204984.png" srcset="/img/loading.gif" lazyload alt="image-20210519162204984"></p>
<h3 id="11-5-使用-Swagger-构建"><a href="#11-5-使用-Swagger-构建" class="headerlink" title="11.5 使用 Swagger 构建"></a>11.5 使用 Swagger 构建</h3><h4 id="11-5-1-开发-Controller-接口"><a href="#11-5-1-开发-Controller-接口" class="headerlink" title="11.5.1 开发 Controller 接口"></a>11.5.1 开发 Controller 接口</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;

    <span class="hljs-meta">@GetMapping(&quot;/findAll&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>&#123;
        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        map.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;查询所有数据成功&quot;</span>);
        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> map;
    &#125;
&#125;</code></pre></div>

<h4 id="11-5-2-重启项目访问接口界面"><a href="#11-5-2-重启项目访问接口界面" class="headerlink" title="11.5.2 重启项目访问接口界面"></a>11.5.2 重启项目访问接口界面</h4><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519162452762.png" srcset="/img/loading.gif" lazyload alt="image-20210519162452762"></p>
<h3 id="11-6-Swagger-注解"><a href="#11-6-Swagger-注解" class="headerlink" title="11.6 Swagger 注解"></a>11.6 Swagger 注解</h3><h4 id="11-6-1-Api"><a href="#11-6-1-Api" class="headerlink" title="11.6.1 @Api"></a>11.6.1 @Api</h4><blockquote>
<p>作用：用来指定接口的描述文字<br>修饰范围：用在类上</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span>
<span class="hljs-meta">@Api(tags = &quot;用户服务相关接口描叙&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;

		....
&#125;</code></pre></div>

<h4 id="11-6-2-ApiOperation"><a href="#11-6-2-ApiOperation" class="headerlink" title="11.6.2 @ApiOperation"></a>11.6.2 @ApiOperation</h4><blockquote>
<p>作用：用来对接口中具体方法做描叙<br>修饰范围：用在方法上</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/findAll&quot;)</span>
<span class="hljs-meta">@ApiOperation(value = &quot;查询所有用户接口&quot;,</span>
<span class="hljs-meta">        notes = &quot;&lt;span style=&#x27;color:red;&#x27;&gt;描叙:&lt;/span&gt;&amp;nbsp;&amp;nbsp;用来查询所有用户信息的接口&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>&#123;
    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    map.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;查询所有数据成功&quot;</span>);
    map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-keyword">true</span>);
    <span class="hljs-keyword">return</span> map;
&#125;</code></pre></div>

<h4 id="11-6-3-ApiImplicitParams"><a href="#11-6-3-ApiImplicitParams" class="headerlink" title="11.6.3 @ApiImplicitParams"></a>11.6.3 @ApiImplicitParams</h4><blockquote>
<p>作用：用来接口中参数进行说明<br>修饰范围：用在方法上</p>
</blockquote>
<h5 id="普通参数使用"><a href="#普通参数使用" class="headerlink" title="普通参数使用"></a>普通参数使用</h5><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;save&quot;)</span>
<span class="hljs-meta">@ApiOperation(value = &quot;保存用户信息接口&quot;,</span>
<span class="hljs-meta">        notes = &quot;&lt;span style=&#x27;color:red;&#x27;&gt;描叙:&lt;/span&gt;&amp;nbsp;&amp;nbsp;用来保存用户信息的接口&quot;)</span>
<span class="hljs-meta">@ApiImplicitParams(&#123;</span>
<span class="hljs-meta">        @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户 id&quot;, dataType = &quot;String&quot;, defaultValue = &quot;21&quot;),</span>
<span class="hljs-meta">        @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户姓名&quot;, dataType = &quot;String&quot;, defaultValue = &quot;lucifer&quot;)</span>
<span class="hljs-meta">&#125;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">save</span><span class="hljs-params">(String id, String name)</span> </span>&#123;
    System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);
    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);
    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    map.put(<span class="hljs-string">&quot;id&quot;</span>, id);
    map.put(<span class="hljs-string">&quot;name&quot;</span>, name);
    <span class="hljs-keyword">return</span> map;
&#125;</code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519163323183.png" srcset="/img/loading.gif" lazyload alt="image-20210519163323183"></p>
<h5 id="RestFul-风格使用"><a href="#RestFul-风格使用" class="headerlink" title="RestFul 风格使用"></a>RestFul 风格使用</h5><blockquote>
<p>如果使用的是 RestFul 风格进行传参，必须再添加一个 paramType=”path”</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;save/&#123;id&#125;/&#123;name&#125;&quot;)</span>
<span class="hljs-meta">@ApiOperation(value = &quot;保存用户信息接口&quot;,</span>
<span class="hljs-meta">        notes = &quot;&lt;span style=&#x27;color:red;&#x27;&gt;描叙:&lt;/span&gt;&amp;nbsp;&amp;nbsp;用来保存用户信息的接口&quot;)</span>
<span class="hljs-meta">@ApiImplicitParams(&#123;</span>
<span class="hljs-meta">        @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户 id&quot;, dataType = &quot;String&quot;, defaultValue = &quot;21&quot;, paramType = &quot;path&quot;),</span>
<span class="hljs-meta">        @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户姓名&quot;, dataType = &quot;String&quot;, defaultValue = &quot;lucifer&quot;, paramType = &quot;path&quot;)</span>
<span class="hljs-meta">&#125;)</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">save</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id,<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name)</span> </span>&#123;
    System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);
    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);
    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    map.put(<span class="hljs-string">&quot;id&quot;</span>, id);
    map.put(<span class="hljs-string">&quot;name&quot;</span>, name);
    <span class="hljs-keyword">return</span> map;
&#125;</code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519163641192.png" srcset="/img/loading.gif" lazyload alt="image-20210519163641192"></p>
<h5 id="JSON-格式使用"><a href="#JSON-格式使用" class="headerlink" title="JSON 格式使用"></a>JSON 格式使用</h5><p>如果是 <code>RequestBody</code> 的方式，需要定义一个对象进行接收</p>
<p><strong>定义一个 User 对象</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-keyword">private</span> String id;
    <span class="hljs-keyword">private</span> String name;
&#125;</code></pre></div>

<p><strong>编写 Controller</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;save2&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">save2</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>&#123;
    System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + user.getId());
    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + user.getName());
    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    map.put(<span class="hljs-string">&quot;id&quot;</span>, user.getId());
    map.put(<span class="hljs-string">&quot;name&quot;</span>, user.getName());
    <span class="hljs-keyword">return</span> map;
&#125;</code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519163919745.png" srcset="/img/loading.gif" lazyload alt="image-20210519163919745"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210519164215434.png" srcset="/img/loading.gif" lazyload alt="image-20210519164215434"></p>
<h4 id="11-6-4-ApiResponses"><a href="#11-6-4-ApiResponses" class="headerlink" title="11.6.4 @ApiResponses"></a>11.6.4 @ApiResponses</h4><blockquote>
<p>作用：用在请求的方法上，表示一组响应<br>修饰范围：用在方法上</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;save2&quot;)</span>
<span class="hljs-meta">@ApiResponses(&#123;</span>
<span class="hljs-meta">        @ApiResponse(code = 404, message = &quot;请求路径不对&quot;),</span>
<span class="hljs-meta">        @ApiResponse(code = 400, message = &quot;程序不对&quot;)</span>
<span class="hljs-meta">&#125;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">save2</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>&#123;
    System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + user.getId());
    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + user.getName());
    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    map.put(<span class="hljs-string">&quot;id&quot;</span>, user.getId());
    map.put(<span class="hljs-string">&quot;name&quot;</span>, user.getName());
    <span class="hljs-keyword">return</span> map;
&#125;</code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VuaXF1ZV9wZXJmZWN0,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="11-6-5-ApiModel"><a href="#11-6-5-ApiModel" class="headerlink" title="11.6.5 @ApiModel"></a>11.6.5 @ApiModel</h4><p>如果参数是一个对象（例如上文的更新接口），对于参数的描述也可以放在实体类中。例如下面一段代码： </p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ApiModel(value = &quot;用户实体类&quot;， description= &quot;定义了用户所有属性&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-meta">@ApiModelProperty(value = &quot;用户id&quot;)</span>
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-meta">@ApiModelProperty(value = &quot;用户名&quot;)</span>
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-meta">@ApiModelProperty(value = &quot;用户地址&quot;)</span>
    <span class="hljs-keyword">private</span> String address;
    <span class="hljs-comment">//getter/setter</span>
&#125;</code></pre></div>

<h3 id="11-7-在Security中的配置"><a href="#11-7-在Security中的配置" class="headerlink" title="11.7 在Security中的配置"></a>11.7 在Security中的配置</h3><p>如果我们的Spring Boot项目中集成了Spring Security，那么如果不做额外配置，Swagger2文档可能会被拦截，此时只需要在Spring Security的配置类中重写configure方法，添加如下过滤即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    web.ignoring()
            .antMatchers(<span class="hljs-string">&quot;/swagger-ui.html&quot;</span>)
            .antMatchers(<span class="hljs-string">&quot;/v2/**&quot;</span>)
            .antMatchers(<span class="hljs-string">&quot;/swagger-resources/**&quot;</span>);
&#125;</code></pre></div>

<h3 id="11-8-Swagger-3-0"><a href="#11-8-Swagger-3-0" class="headerlink" title="11.8 Swagger 3.0"></a>11.8 Swagger 3.0</h3><p>在 3.0 版本中，我们不需要这么麻烦了，一个 starter 就可以搞定：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>和 Spring Boot 中的其他 starter 一样，springfox-boot-starter 依赖可以实现零配置以及自动配置支持。也就是说，如果你没有其他特殊需求，加一个这个依赖就行了，接口文档就自动生成了。</p>
<p><strong>接口地址</strong></p>
<p>3.0 中的接口地址也和之前有所不同，以前在 2.9.2 中我们主要访问两个地址：</p>
<ul>
<li>文档接口地址：<a target="_blank" rel="noopener" href="http://localhost:8080/v2/api-docs">http://localhost:8080/v2/api-docs</a></li>
<li>文档页面地址：<a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></li>
</ul>
<p>现在在 3.0 中，这两个地址也发生了变化：</p>
<ul>
<li>文档接口地址：<a target="_blank" rel="noopener" href="http://localhost:8080/v3/api-docs">http://localhost:8080/v3/api-docs</a></li>
<li>文档页面地址：<a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a></li>
</ul>
<p>特别是文档页面地址，如果用了 3.0，而去访问之前的页面，会报 404</p>
<p><strong>注解</strong></p>
<p>旧的注解还可以继续使用，不过在 3.0 中还提供了一些其他注解。</p>
<p>例如我们可以使用 @EnableOpenApi 代替以前旧版本中的 @EnableSwagger2。</p>
<p>话是这么说，不过松哥在实际体验中，感觉 @EnableOpenApi 注解的功能不明显，加不加都行。翻了下源码，@EnableOpenApi 注解主要功能是为了导入 OpenApiDocumentationConfiguration 配置类，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(value = &#123;java.lang.annotation.ElementType.TYPE&#125;)</span>
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Import(OpenApiDocumentationConfiguration.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableOpenApi &#123;
&#125;</code></pre></div>

<p>然后我又看了下自动化配置类 OpenApiAutoConfiguration，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableConfigurationProperties(SpringfoxConfigurationProperties.class)</span>
<span class="hljs-meta">@ConditionalOnProperty(value = &quot;springfox.documentation.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span>
<span class="hljs-meta">@Import(&#123;</span>
<span class="hljs-meta">    OpenApiDocumentationConfiguration.class,</span>
<span class="hljs-meta">    SpringDataRestConfiguration.class,</span>
<span class="hljs-meta">    BeanValidatorPluginsConfiguration.class,</span>
<span class="hljs-meta">    Swagger2DocumentationConfiguration.class,</span>
<span class="hljs-meta">    SwaggerUiWebFluxConfiguration.class,</span>
<span class="hljs-meta">    SwaggerUiWebMvcConfiguration.class</span>
<span class="hljs-meta">&#125;)</span>
<span class="hljs-meta">@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, JacksonAutoConfiguration.class,</span>
<span class="hljs-meta">    HttpMessageConvertersAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class &#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenApiAutoConfiguration</span> </span>&#123;

&#125;</code></pre></div>

<p>可以看到，自动化配置类里边也导入了 OpenApiDocumentationConfiguration。</p>
<p>所以在正常情况下，实际上不需要添加 @EnableOpenApi 注解。</p>
<p>根据 OpenApiAutoConfiguration 上的 @ConditionalOnProperty 条件注解中的定义，我们发现，如果在 application.properties 中设置 <code>springfox.documentation.enabled=false</code>，即关闭了 swagger 功能，此时自动化配置类就不执行了，这个时候可以通过 @EnableOpenApi 注解导入 OpenApiDocumentationConfiguration 配置类。技术上来说逻辑是这样，不过应用中暂未发现这样的需求（即在 application.properties 中关闭 swagger，再通过 @EnableOpenApi 注解开启）。</p>
<p>另外，以前我们用的 @ApiResponses/@ApiResponse 注解，在 3.0 中名字没变，但是所在的包变了，小伙伴们使用时注意导包问题哦。</p>
<p>另外，我们之前用的 @ApiOperation 注解在 3.0 中可以使用 @Operation 代替。</p>
<p>另外还有一些新注解如 @Parameter、@Parameters、@Schema 等，感觉不太好用，不如旧的用的舒服，这些新注解小伙伴们可以自行尝试下。</p>
<h2 id="12-数据校验"><a href="#12-数据校验" class="headerlink" title="12. 数据校验"></a>12. 数据校验</h2><p><strong>依赖引入</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>配置文件 ValidationMessages.properties</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">user.name.size</span>=<span class="hljs-string">name xxx</span>
<span class="hljs-meta">user.address.notnull</span>=<span class="hljs-string">address xxx</span>
<span class="hljs-meta">user.age.min</span>=<span class="hljs-string">age xxx</span>
<span class="hljs-meta">user.age.max</span>=<span class="hljs-string">age xxx</span>
<span class="hljs-meta">user.email.notnull</span>=<span class="hljs-string">email xxx</span>
<span class="hljs-meta">user.email.pattern</span>=<span class="hljs-string">email xxx</span></code></pre></div>

<p>分组校验，首先需要定义校验组，所谓的校验组，其实就是<strong>空接口</strong>：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidationGroup1</span> </span>&#123;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidationGroup2</span> </span>&#123;
&#125;</code></pre></div>

<p><strong>实体类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-meta">@Size(min = 5,max = 8,message = &quot;&#123;user.name.size&#125;&quot;,groups = ValidationGroup1.class)</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@NotNull(message = &quot;&#123;user.address.notnull&#125;&quot;,groups = ValidationGroup2.class)</span>
    <span class="hljs-keyword">private</span> String address;
    <span class="hljs-meta">@DecimalMin(value = &quot;1&quot;,message = &quot;&#123;user.age.min&#125;&quot;,groups = &#123;ValidationGroup1.class,ValidationGroup2.class&#125;)</span>
    <span class="hljs-meta">@DecimalMax(value = &quot;200&quot;,message = &quot;&#123;user.age.max&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-meta">@NotNull(message = &quot;&#123;user.email.notnull&#125;&quot;)</span>
    <span class="hljs-meta">@Email(message = &quot;&#123;user.email.pattern&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String email;
&#125;</code></pre></div>

<p>校验注解，主要有如下几种：</p>
<ul>
<li>@Null 被注解的元素必须为 null</li>
<li>@NotNull 被注解的元素必须不为 null</li>
<li>@AssertTrue 被注解的元素必须为 true</li>
<li>@AssertFalse 被注解的元素必须为 false</li>
<li>@Min(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li>@Max(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li>@DecimalMin(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li>@DecimalMax(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li>@Size(max=, min=) 被注解的元素的大小必须在指定的范围内</li>
<li>@Digits (integer, fraction) 被注解的元素必须是一个数字，其值必须在可接受的范围内</li>
<li>@Past 被注解的元素必须是一个过去的日期</li>
<li>@Future 被注解的元素必须是一个将来的日期</li>
<li>@Pattern(regex=,flag=) 被注解的元素必须符合指定的正则表达式</li>
<li>@NotBlank(message =) 验证字符串非 null，且长度必须大于0</li>
<li>@Email 被注解的元素必须是电子邮箱地址</li>
<li>@Length(min=,max=) 被注解的字符串的大小必须在指定的范围内</li>
<li>@NotEmpty 被注解的字符串的必须非空</li>
<li>@Range(min=,max=,message=) 被注解的元素必须在合适的范围内</li>
</ul>
<p><strong>Controller</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;
    <span class="hljs-meta">@PostMapping(&quot;/user&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">(<span class="hljs-meta">@Validated(ValidationGroup1.class)</span> User user, BindingResult result)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span> &amp;&amp; result.hasErrors()) &#123;
            List&lt;ObjectError&gt; allErrors = result.getAllErrors();
            <span class="hljs-keyword">for</span> (ObjectError error : allErrors) &#123;
                System.out.println(error.getObjectName() + error.getDefaultMessage());
            &#125;
        &#125;

    &#125;
&#125;</code></pre></div>

<h1 id="第四章、SpringBoot整合持久层"><a href="#第四章、SpringBoot整合持久层" class="headerlink" title="第四章、SpringBoot整合持久层"></a>第四章、SpringBoot整合持久层</h1><h2 id="1-整合JDBCTemplate"><a href="#1-整合JDBCTemplate" class="headerlink" title="1. 整合JDBCTemplate"></a>1. 整合JDBCTemplate</h2><p>在Java领域，数据持久化有几个常见的方案，有Spring自带的JdbcTemplate、有MyBatis，还有JPA，在这些方案中，最简单的就是Spring自带的JdbcTemplate了，这个东西虽然没有MyBatis那么方便，但是比起最开始的Jdbc已经强了很多了，它没有MyBatis功能那么强大，当然也意味着它的使用比较简单，事实上，JdbcTemplate算是最简单的数据持久化方案</p>
<h3 id="1-1-基本配置"><a href="#1-1-基本配置" class="headerlink" title="1.1 基本配置"></a>1.1 基本配置</h3><p>JdbcTemplate基本用法实际上很简单，开发者在创建一个SpringBoot项目时，除了选择基本的Web依赖，再记得选上Jdbc依赖，以及数据库驱动依赖即可，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/1-1-20210525153228731.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>项目创建成功之后，记得添加Druid数据库连接池依赖（注意这里可以添加专门为Spring Boot打造的druid-spring-boot-starter，而不是我们一般在SSM中添加的Druid），所有添加的依赖如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>项目创建完后，接下来只需要在application.properties中提供数据的基本配置即可，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>
<span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8</span></code></pre></div>

<p>如此之后，所有的配置就算完成了，<strong>接下来就可以直接使用JdbcTemplate，其实这就是SpringBoot的自动化配置带来的好处</strong></p>
<h3 id="1-2-基本用法"><a href="#1-2-基本用法" class="headerlink" title="1.2 基本用法"></a>1.2 基本用法</h3><p>首先我们来创建一个User Bean，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> String address;
    <span class="hljs-comment">//省略getter/setter</span>
&#125;</code></pre></div>

<p>然后来创建一个UserService类，在UserService类中注入JdbcTemplate，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    JdbcTemplate jdbcTemplate;
&#125;</code></pre></div>

<p>好了，如此之后，准备工作就算完成了。</p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>JdbcTemplate中，除了查询有几个API之外，增删改统一都使用update来操作，自己来传入SQL即可。例如添加数据，方法如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span> </span>&#123;
    <span class="hljs-keyword">return</span> jdbcTemplate.update(<span class="hljs-string">&quot;insert into user (username,address) values (?,?);&quot;</span>, user.getUsername(), user.getAddress());
&#125;</code></pre></div>

<p>update方法的返回值就是SQL执行受影响的行数。</p>
<p>这里只需要传入SQL即可，如果你的需求比较复杂，例如在数据插入的过程中希望实现主键回填，那么可以使用PreparedStatementCreator，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addUser2</span><span class="hljs-params">(User user)</span> </span>&#123;
  
    KeyHolder keyHolder = <span class="hljs-keyword">new</span> GeneratedKeyHolder();
    <span class="hljs-keyword">int</span> update = jdbcTemplate.update(<span class="hljs-keyword">new</span> PreparedStatementCreator() &#123;
      
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title">createPreparedStatement</span><span class="hljs-params">(Connection connection)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
            PreparedStatement ps = connection.prepareStatement(<span class="hljs-string">&quot;insert into user (username,address) values (?,?);&quot;</span>, Statement.RETURN_GENERATED_KEYS);
            ps.setString(<span class="hljs-number">1</span>, user.getUsername());
            ps.setString(<span class="hljs-number">2</span>, user.getAddress());
            <span class="hljs-keyword">return</span> ps;
        &#125;
    &#125;, keyHolder);
    user.setId(keyHolder.getKey().longValue());
    System.out.println(user);
    <span class="hljs-keyword">return</span> update;
&#125;</code></pre></div>

<p>实际上这里就相当于完全使用了JDBC中的解决方案了，首先在构建PreparedStatement时传入Statement.RETURN_GENERATED_KEYS，然后传入KeyHolder，最终从KeyHolder中获取刚刚插入数据的id保存到user对象的id属性中去。</p>
<p>你能想到的JDBC的用法，在这里都能实现，Spring提供的JdbcTemplate虽然不如MyBatis，但是比起Jdbc还是要方便很多的。</p>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>删除也是使用update API，传入你的SQL即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;
    <span class="hljs-keyword">return</span> jdbcTemplate.update(<span class="hljs-string">&quot;delete from user where id=?&quot;</span>, id);
&#125;</code></pre></div>

<p>当然你也可以使用PreparedStatementCreator</p>
<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateUserById</span><span class="hljs-params">(User user)</span> </span>&#123;
    <span class="hljs-keyword">return</span> jdbcTemplate.update(<span class="hljs-string">&quot;update user set username=?,address=? where id=?&quot;</span>, user.getUsername(), user.getAddress(),user.getId());
&#125;</code></pre></div>

<p>当然你也可以使用PreparedStatementCreator</p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>查询的话，稍微有点变化，这里主要向大伙介绍query方法，例如查询所有用户：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getAllUsers</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> jdbcTemplate.query(<span class="hljs-string">&quot;select * from user&quot;</span>, <span class="hljs-keyword">new</span> RowMapper&lt;User&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
            String username = resultSet.getString(<span class="hljs-string">&quot;username&quot;</span>);
            String address = resultSet.getString(<span class="hljs-string">&quot;address&quot;</span>);
            <span class="hljs-keyword">long</span> id = resultSet.getLong(<span class="hljs-string">&quot;id&quot;</span>);
            User user = <span class="hljs-keyword">new</span> User();
            user.setAddress(address);
            user.setUsername(username);
            user.setId(id);
            <span class="hljs-keyword">return</span> user;
        &#125;
    &#125;);
&#125;</code></pre></div>

<p>查询的时候需要提供一个RowMapper，就是需要自己手动映射，将数据库中的字段和对象的属性一一对应起来，这样看起来有点麻烦，实际上，如果数据库中的字段和对象属性的名字一模一样的话，有另外一个简单的方案，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getAllUsers2</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> jdbcTemplate.query(<span class="hljs-string">&quot;select * from user&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class));
&#125;</code></pre></div>

<p>至于查询时候传参也是使用占位符，这个和前文的一致，这里不再赘述。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>除了这些基本用法之外，JdbcTemplate也支持其他用法，例如调用存储过程等，这些都比较容易，而且和Jdbc本身都比较相似，这里也就不做介绍了，有兴趣可以留言讨论。</p>
<h3 id="1-3-原理分析"><a href="#1-3-原理分析" class="headerlink" title="1.3 原理分析"></a>1.3 原理分析</h3><p>那么在SpringBoot中，配置完数据库基本信息之后，就有了一个JdbcTemplate了，这个东西是从哪里来的呢？源码在<code>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration</code>类中，该类源码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ConditionalOnClass(&#123; DataSource.class, JdbcTemplate.class &#125;)</span>
<span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span>
<span class="hljs-meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span>
<span class="hljs-meta">@EnableConfigurationProperties(JdbcProperties.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateAutoConfiguration</span> </span>&#123;

	<span class="hljs-meta">@Configuration</span>
	<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateConfiguration</span> </span>&#123;

		<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DataSource dataSource;

		<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JdbcProperties properties;

		JdbcTemplateConfiguration(DataSource dataSource, JdbcProperties properties) &#123;
			<span class="hljs-keyword">this</span>.dataSource = dataSource;
			<span class="hljs-keyword">this</span>.properties = properties;
		&#125;

		<span class="hljs-meta">@Bean</span>
		<span class="hljs-meta">@Primary</span>
		<span class="hljs-meta">@ConditionalOnMissingBean(JdbcOperations.class)</span>
		<span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">()</span> </span>&#123;
			JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(<span class="hljs-keyword">this</span>.dataSource);
			JdbcProperties.Template template = <span class="hljs-keyword">this</span>.properties.getTemplate();
			jdbcTemplate.setFetchSize(template.getFetchSize());
			jdbcTemplate.setMaxRows(template.getMaxRows());
			<span class="hljs-keyword">if</span> (template.getQueryTimeout() != <span class="hljs-keyword">null</span>) &#123;
				jdbcTemplate
						.setQueryTimeout((<span class="hljs-keyword">int</span>) template.getQueryTimeout().getSeconds());
			&#125;
			<span class="hljs-keyword">return</span> jdbcTemplate;
		&#125;

	&#125;

	<span class="hljs-meta">@Configuration</span>
	<span class="hljs-meta">@Import(JdbcTemplateConfiguration.class)</span>
	<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NamedParameterJdbcTemplateConfiguration</span> </span>&#123;

		<span class="hljs-meta">@Bean</span>
		<span class="hljs-meta">@Primary</span>
		<span class="hljs-meta">@ConditionalOnSingleCandidate(JdbcTemplate.class)</span>
		<span class="hljs-meta">@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)</span>
		<span class="hljs-function"><span class="hljs-keyword">public</span> NamedParameterJdbcTemplate <span class="hljs-title">namedParameterJdbcTemplate</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">				JdbcTemplate jdbcTemplate)</span> </span>&#123;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NamedParameterJdbcTemplate(jdbcTemplate);
		&#125;

	&#125;

&#125;</code></pre></div>

<p>从这个类中，大致可以看出，当当前类路径下存在DataSource和JdbcTemplate时，该类就会被自动配置，jdbcTemplate方法则表示，如果开发者没有自己提供一个JdbcOperations的实例的话，系统就自动配置一个JdbcTemplate Bean（JdbcTemplate是JdbcOperations接口的一个实现）</p>
<h3 id="1-4-多数据源配置"><a href="#1-4-多数据源配置" class="headerlink" title="1.4 多数据源配置"></a>1.4 多数据源配置</h3><p>多数据源配置也算是一个常见的开发需求，Spring和SpringBoot中，对此都有相应的解决方案，不过一般来说，如果有多数据源的需求，我还是建议首选分布式数据库中间件<code>MyCat</code>去解决相关问题，之前有小伙伴在我的知识星球上提问，他的数据根据条件的不同，可能保存在四十多个不同的数据库中，怎么办？这种场景下使用多数据源其实就有些费事了，我给的建议是使用MyCat，然后分表策略使用sharding-by-intfile。当然如果一些简单的需求，还是可以使用多数据源的，Spring Boot中，JdbcTemplate、MyBatis以及Jpa都可以配置多数据源，本文就先和大伙聊一聊JdbcTemplate中多数据源的配置</p>
<h4 id="1-4-1-创建工程"><a href="#1-4-1-创建工程" class="headerlink" title="1.4.1 创建工程"></a>1.4.1 创建工程</h4><p>首先是创建工程，和前文一样，创建工程时，也是选择Web、Jdbc以及MySQL驱动，如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/1-1-20210523152539479-20210525153228676.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>创建成功之后，一定接下来手动添加Druid依赖，由于这里一会需要开发者自己配置DataSoruce，所以这里必须要使用<code>druid-spring-boot-starter</code>依赖，而不是传统的那个druid依赖，因为<code>druid-spring-boot-starter</code>依赖提供了DruidDataSourceBuilder类，这个可以用来构建一个DataSource实例，而传统的Druid则没有该类。完整的依赖如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h4 id="1-4-2-配置数据源"><a href="#1-4-2-配置数据源" class="headerlink" title="1.4.2 配置数据源"></a>1.4.2 配置数据源</h4><p>接下来，在application.properties中配置数据源，不同于上文，这里的数据源需要配置两个，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.one.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=utf-8</span>
<span class="hljs-meta">spring.datasource.one.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.one.password</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.one.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>

<span class="hljs-meta">spring.datasource.two.url</span>=<span class="hljs-string">jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=utf-8</span>
<span class="hljs-meta">spring.datasource.two.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.two.password</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.two.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span></code></pre></div>

<p>这里通过one和two对数据源进行了区分，但是加了one和two之后，这里的配置就没法被SpringBoot自动加载了（因为前面的key变了），需要我们自己去加载DataSource了，此时，需要自己配置一个DataSourceConfig，用来提供两个DataSource Bean，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</span>
    <span class="hljs-function">DataSource <span class="hljs-title">dsOne</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)</span>
    <span class="hljs-function">DataSource <span class="hljs-title">dsTwo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();
    &#125;
&#125;</code></pre></div>

<p>这里提供了两个Bean，其中@ConfigurationProperties是Spring Boot提供的类型安全的属性绑定，以第一个Bean为例，<code>@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</code>表示使用<code>spring.datasource.one</code>前缀的数据库配置去创建一个DataSource，这样配置之后，我们就有了两个不同的DataSource，接下来再用这两个不同的DataSource去创建两个不同的JdbcTemplate</p>
<h4 id="1-4-3-配置JdbcTemplate实例"><a href="#1-4-3-配置JdbcTemplate实例" class="headerlink" title="1.4.3 配置JdbcTemplate实例"></a>1.4.3 配置JdbcTemplate实例</h4><p>创建JdbcTemplateConfig类，用来提供两个不同的JdbcTemplate实例，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">JdbcTemplate <span class="hljs-title">jdbcTemplateOne</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;dsOne&quot;)</span> DataSource dsOne)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dsOne);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">JdbcTemplate <span class="hljs-title">jdbcTemplateTwo</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;dsTwo&quot;)</span> DataSource dsTwo)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dsTwo);
    &#125;
&#125;</code></pre></div>

<p>每一个JdbcTemplate的创建都需要一个DataSource，由于Spring容器中现在存在两个DataSource，默认使用类型查找，会报错，因此加上@Qualifier注解，表示按照名称查找。这里创建了两个JdbcTemplate实例，分别对应了两个DataSource，接下来直接去使用这个JdbcTemplate就可以了</p>
<h4 id="1-4-4-测试使用"><a href="#1-4-4-测试使用" class="headerlink" title="1.4.4 测试使用"></a>1.4.4 测试使用</h4><p>关于JdbcTemplate的详细用法大伙可以参考我的上篇文章，这里我主要演示数据源的差异，在Controller中注入两个不同的JdbcTemplate，这两个JdbcTemplate分别对应了不同的数据源，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-meta">@Qualifier(&quot;jdbcTemplateOne&quot;)</span>
    JdbcTemplate jdbcTemplateOne;
    <span class="hljs-meta">@Resource(name = &quot;jdbcTemplateTwo&quot;)</span>
    JdbcTemplate jdbcTemplateTwo;

    <span class="hljs-meta">@GetMapping(&quot;/user&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;User&gt; list = jdbcTemplateOne.query(<span class="hljs-string">&quot;select * from t_user&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class));
        <span class="hljs-keyword">return</span> list;
    &#125;
    <span class="hljs-meta">@GetMapping(&quot;/user2&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getAllUser2</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;User&gt; list = jdbcTemplateTwo.query(<span class="hljs-string">&quot;select * from t_user&quot;</span>, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class));
        <span class="hljs-keyword">return</span> list;
    &#125;
&#125;</code></pre></div>

<p>和DataSource一样，Spring容器中的JdbcTemplate也是有两个，因此不能通过byType的方式注入进来，这里给大伙提供了两种注入思路，一种是使用@Resource注解，直接通过byName的方式注入进来，另外一种就是<code>@Autowired</code>注解加上<code>@Qualifier</code>注解，两者联合起来，实际上也是byName。将JdbcTemplate注入进来之后，jdbcTemplateOne和jdbcTemplateTwo此时就代表操作不同的数据源，使用不同的JdbcTemplate操作不同的数据源，实现了多数据源配置。</p>
<h2 id="2-整合MyBatis"><a href="#2-整合MyBatis" class="headerlink" title="2. 整合MyBatis"></a>2. 整合MyBatis</h2><p>JdbcTemplate虽然简单，但是用的并不多，因为它没有MyBatis方便，在Spring+SpringMVC中整合MyBatis步骤还是有点复杂的，要配置多个Bean，Spring Boot中对此做了进一步的简化，使MyBatis基本上可以做到开箱即用，本文就来看看在Spring Boot中MyBatis要如何使用</p>
<h3 id="2-1-工程创建"><a href="#2-1-工程创建" class="headerlink" title="2.1 工程创建"></a>2.1 工程创建</h3><p>首先创建一个基本的Spring Boot工程，添加Web依赖，MyBatis依赖以及MySQL驱动依赖，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-1-20210523153350314-20210525153228568.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>创建成功后，添加Druid依赖，并且锁定MySQL驱动版本，完整的依赖如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>如此，工程就算是创建成功了。读者注意，MyBatis和Druid依赖的命名和其他库的命名不太一样，是属于xxx-spring-boot-stater模式的，这表示该starter是由第三方提供的。</p>
<h3 id="2-2-基本用法"><a href="#2-2-基本用法" class="headerlink" title="2.2 基本用法"></a>2.2 基本用法</h3><p>MyBatis的使用和JdbcTemplate基本一致，首先也是在application.properties中配置数据库的基本信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=utf-8</span>
<span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span></code></pre></div>

<p>配置完成后，MyBatis就可以创建Mapper来使用了，例如我这里直接创建一个UserMapper2，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper2</span> </span>&#123;
    <span class="hljs-meta">@Select(&quot;select * from user&quot;)</span>
    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUsers</span><span class="hljs-params">()</span></span>;

    <span class="hljs-meta">@Results(&#123;</span>
<span class="hljs-meta">            @Result(property = &quot;id&quot;, column = &quot;id&quot;),</span>
<span class="hljs-meta">            @Result(property = &quot;username&quot;, column = &quot;u&quot;),</span>
<span class="hljs-meta">            @Result(property = &quot;address&quot;, column = &quot;a&quot;)</span>
<span class="hljs-meta">    &#125;)</span>
    <span class="hljs-meta">@Select(&quot;select username as u,address as a,id as id from user where id=#&#123;id&#125;&quot;)</span>
    <span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span></span>;

    <span class="hljs-meta">@Select(&quot;select * from user where username like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)&quot;)</span>
    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUsersByName</span><span class="hljs-params">(String name)</span></span>;

    <span class="hljs-meta">@Insert(&#123;&quot;insert into user(username,address) values(#&#123;username&#125;,#&#123;address&#125;)&quot;&#125;)</span>
    <span class="hljs-meta">@SelectKey(statement = &quot;select last_insert_id()&quot;, keyProperty = &quot;id&quot;, before = false, resultType = Integer.class)</span>
    <span class="hljs-function">Integer <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;

    <span class="hljs-meta">@Update(&quot;update user set username=#&#123;username&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&quot;)</span>
    <span class="hljs-function">Integer <span class="hljs-title">updateUserById</span><span class="hljs-params">(User user)</span></span>;

    <span class="hljs-meta">@Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)</span>
    <span class="hljs-function">Integer <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span></span>;
&#125;</code></pre></div>

<p>这里是通过全注解的方式来写SQL，不写XML文件，@Select、@Insert、@Update以及@Delete四个注解分别对应XML中的select、insert、update以及delete标签，@Results注解类似于XML中的ResultMap映射文件（getUserById方法给查询结果的字段取别名主要是向小伙伴们演示下<code>@Results</code>注解的用法），另外使用@SelectKey注解可以实现主键回填的功能，即当数据插入成功后，插入成功的数据id会赋值到user对象的id属性上。</p>
<p>UserMapper2创建好之后，还要配置mapper扫描，有两种方式，一种是直接在UserMapper2上面添加<code>@Mapper</code>注解，这种方式有一个弊端就是所有的Mapper都要手动添加，要是落下一个就会报错，还有一个一劳永逸的办法就是直接在启动类上添加Mapper扫描，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@MapperScan(basePackages = &quot;org.sang.mybatis.mapper&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisApplication</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(MybatisApplication.class, args);
    &#125;
&#125;</code></pre></div>

<p>好了，做完这些工作就可以去测试Mapper的使用了。</p>
<h3 id="2-3-mapper映射"><a href="#2-3-mapper映射" class="headerlink" title="2.3 mapper映射"></a>2.3 mapper映射</h3><p>当然，开发者也可以在XML中写SQL，例如创建一个UserMapper，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;
    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function">Integer <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;

    <span class="hljs-function">Integer <span class="hljs-title">updateUserById</span><span class="hljs-params">(User user)</span></span>;

    <span class="hljs-function">Integer <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span></span>;
&#125;</code></pre></div>

<p>然后创建UserMapper.xml文件，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span>
<span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span>
<span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.sang.mybatis.mapper.UserMapper&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span>
        select * from t_user;
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span>
        insert into user (username,address) values (#&#123;username&#125;,#&#123;address&#125;);
    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span>
        update user set username=#&#123;username&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUserById&quot;</span>&gt;</span>
        delete from user where id=#&#123;id&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span>

    <span class="hljs-comment">&lt;!--或者定义resultMap去映射--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.javaboy.mybatis.model.User&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;address1&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span>
  select * from user where id=#&#123;id&#125;;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUsers&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span>
  select * from user ;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div>

<p>将接口中方法对应的SQL直接写在XML文件中</p>
<p>那么这个UserMapper.xml到底放在哪里呢？有两个位置可以放，第一个是直接放在UserMapper所在的包下面：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-2-20210523153350459-20210525153228563.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>放在这里的UserMapper.xml会被自动扫描到，但是有另外一个Maven带来的问题，就是java目录下的xml资源在项目打包时会被忽略掉，所以，如果UserMapper.xml放在包下，需要在pom.xml文件中再添加如下配置，避免打包时java目录下的XML文件被自动忽略掉：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div>

<p>当然，UserMapper.xml也可以直接放在resources目录下，这样就不用担心打包时被忽略了，但是放在resources目录下，又不能自动被扫描到，需要添加额外配置。例如我在resources目录下创建mapper目录用来放mapper文件，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-3-20210523153349662-20210525153228563.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>此时在application.properties中告诉mybatis去哪里扫描mapper：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*.xml</span></code></pre></div>

<p>如此配置之后，mapper就可以正常使用了。注意第二种方式不需要在pom.xml文件中配置文件过滤。</p>
<h3 id="2-4-原理分析"><a href="#2-4-原理分析" class="headerlink" title="2.4 原理分析"></a>2.4 原理分析</h3><p>在SSM整合中，开发者需要自己提供两个Bean，一个SqlSessionFactoryBean，还有一个是MapperScannerConfigurer，在Spring Boot中，这两个东西虽然不用开发者自己提供了，但是并不意味着这两个Bean不需要了，在<code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code>类中，我们可以看到Spring Boot提供了这两个Bean，部分源码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration
<span class="hljs-meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span>
<span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span>
<span class="hljs-meta">@EnableConfigurationProperties(MybatisProperties.class)</span>
<span class="hljs-meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisAutoConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;

  <span class="hljs-meta">@Bean</span>
  <span class="hljs-meta">@ConditionalOnMissingBean</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    SqlSessionFactoryBean factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    <span class="hljs-keyword">return</span> factory.getObject();
  &#125;
  <span class="hljs-meta">@Bean</span>
  <span class="hljs-meta">@ConditionalOnMissingBean</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionTemplate <span class="hljs-title">sqlSessionTemplate</span><span class="hljs-params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;
    ExecutorType executorType = <span class="hljs-keyword">this</span>.properties.getExecutorType();
    <span class="hljs-keyword">if</span> (executorType != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory);
    &#125;
  &#125;
  <span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration
  <span class="hljs-meta">@Import(&#123; AutoConfiguredMapperScannerRegistrar.class &#125;)</span>
  <span class="hljs-meta">@ConditionalOnMissingBean(MapperFactoryBean.class)</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperScannerRegistrarNotFoundConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;
      logger.debug(<span class="hljs-string">&quot;No &#123;&#125; found.&quot;</span>, MapperFactoryBean.class.getName());
    &#125;
  &#125;
&#125;</code></pre></div>

<p>从类上的注解可以看出，当前类路径下存在SqlSessionFactory、 SqlSessionFactoryBean以及DataSource时，这里的配置才会生效，SqlSessionFactory和SqlTemplate都被提供了。</p>
<h3 id="2-5-多数据源"><a href="#2-5-多数据源" class="headerlink" title="2.5 多数据源"></a>2.5 多数据源</h3><p>其实关于多数据源，我的态度还是和之前一样，复杂的就直接上分布式数据库中间件，简单的再考虑多数据源。这是项目中的建议，技术上的话，当然还是各种技术都要掌握的。</p>
<h4 id="2-5-1-工程创建"><a href="#2-5-1-工程创建" class="headerlink" title="2.5.1 工程创建"></a>2.5.1 工程创建</h4><p>首先需要创建MyBatis项目，项目创建和前文的一样，添加MyBatis、MySQL以及Web依赖：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3-1-20210523173628435-20210525153228619.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>项目创建完成后，添加Druid依赖，和JdbcTemplate一样，这里添加Druid依赖也必须是专为Spring boot打造的Druid，不能使用传统的Druid。完整的依赖如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h4 id="2-5-2-多数据源配置"><a href="#2-5-2-多数据源配置" class="headerlink" title="2.5.2 多数据源配置"></a>2.5.2 多数据源配置</h4><p>接下来配置多数据源，这里基本上还是和JdbcTemplate多数据源的配置方式一致，首先在application.properties中配置数据库基本信息，然后提供两个DataSource即可，这里我再把代码贴出来，里边的道理条条框框的，大伙可以参考前面的文章，这里不再赘述。</p>
<p>application.properties中的配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.one.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=utf-8</span>
<span class="hljs-meta">spring.datasource.one.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.one.password</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.one.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>

<span class="hljs-meta">spring.datasource.two.url</span>=<span class="hljs-string">jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=utf-8</span>
<span class="hljs-meta">spring.datasource.two.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.two.password</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.two.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span></code></pre></div>

<p>然后再提供两个DataSource，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</span>
    <span class="hljs-function">DataSource <span class="hljs-title">dsOne</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)</span>
    <span class="hljs-function">DataSource <span class="hljs-title">dsTwo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();
    &#125;
&#125;</code></pre></div>

<h4 id="2-5-3-MyBatis配置"><a href="#2-5-3-MyBatis配置" class="headerlink" title="2.5.3 MyBatis配置"></a>2.5.3 MyBatis配置</h4><p>接下来则是MyBatis的配置，不同于JdbcTemplate，MyBatis的配置要稍微麻烦一些，因为要提供两个Bean，因此这里两个数据源我将在两个类中分开来配置，首先来看第一个数据源的配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@MapperScan(basePackages = &quot;org.sang.mybatis.mapper1&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactory1&quot;,sqlSessionTemplateRef = &quot;sqlSessionTemplate1&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfigOne</span> </span>&#123;
    <span class="hljs-meta">@Resource(name = &quot;dsOne&quot;)</span>
    DataSource dsOne;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">SqlSessionFactory <span class="hljs-title">sqlSessionFactory1</span><span class="hljs-params">()</span> </span>&#123;
        SqlSessionFactory sessionFactory = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            SqlSessionFactoryBean bean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();
            bean.setDataSource(dsOne);
            sessionFactory = bean.getObject();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> sessionFactory;
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">SqlSessionTemplate <span class="hljs-title">sqlSessionTemplate1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory1());
    &#125;
&#125;</code></pre></div>

<p>创建MyBatisConfigOne类，首先指明该类是一个配置类，配置类中要扫描的包是org.sang.mybatis.mapper1，即该包下的Mapper接口将操作dsOne中的数据，对应的SqlSessionFactory和SqlSessionTemplate分别是sqlSessionFactory1和sqlSessionTemplate1，在MyBatisConfigOne内部，分别提供SqlSessionFactory和SqlSessionTemplate即可，SqlSessionFactory根据dsOne创建，然后再根据创建好的SqlSessionFactory创建一个SqlSessionTemplate。</p>
<p>这里配置完成后，依据这个配置，再来配置第二个数据源即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@MapperScan(basePackages = &quot;org.sang.mybatis.mapper2&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactory2&quot;,sqlSessionTemplateRef = &quot;sqlSessionTemplate2&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfigTwo</span> </span>&#123;
    <span class="hljs-meta">@Resource(name = &quot;dsTwo&quot;)</span>
    DataSource dsTwo;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">SqlSessionFactory <span class="hljs-title">sqlSessionFactory2</span><span class="hljs-params">()</span> </span>&#123;
        SqlSessionFactory sessionFactory = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            SqlSessionFactoryBean bean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();
            bean.setDataSource(dsTwo);
            sessionFactory = bean.getObject();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> sessionFactory;
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">SqlSessionTemplate <span class="hljs-title">sqlSessionTemplate2</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory2());
    &#125;
&#125;</code></pre></div>

<p>好了，这样MyBatis多数据源基本上就配置好了，接下来只需要在org.sang.mybatis.mapper1和org.sang.mybatis.mapper2包中提供不同的Mapper，Service中注入不同的Mapper就可以操作不同的数据源。</p>
<h4 id="2-5-4-mapper创建"><a href="#2-5-4-mapper创建" class="headerlink" title="2.5.4 mapper创建"></a>2.5.4 mapper创建</h4><p>org.sang.mybatis.mapper1中的mapper：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapperOne</span> </span>&#123;
    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p>对应的XML文件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span>
<span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span>
<span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.sang.mybatis.mapper1.UserMapperOne&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span>
        select * from t_user;
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>

<p>org.sang.mybatis.mapper2中的mapper：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;
    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p>对应的XML文件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span>
<span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span>
<span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.sang.mybatis.mapper2.UserMapper&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.sang.mybatis.model.User&quot;</span>&gt;</span>
        select * from t_user;
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>

<p>接下来，在Service中注入两个不同的Mapper，不同的Mapper将操作不同的数据源。</p>
<h2 id="3-整合Jpa"><a href="#3-整合Jpa" class="headerlink" title="3. 整合Jpa"></a>3. 整合Jpa</h2><h3 id="3-1-JPA是什么"><a href="#3-1-JPA是什么" class="headerlink" title="3.1 JPA是什么"></a>3.1 JPA是什么</h3><ul>
<li><p>Java Persistence API：用于对象持久化的 API</p>
</li>
<li><p>Java EE 5.0 平台标准的 ORM 规范，使得应用程序以统一的方式访问持久层 </p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/19-1-20210525153228703.png" srcset="/img/loading.gif" lazyload alt="img"></p>
</li>
</ul>
<h3 id="3-2-JPA和Hibernate的关系"><a href="#3-2-JPA和Hibernate的关系" class="headerlink" title="3.2 JPA和Hibernate的关系"></a>3.2 JPA和Hibernate的关系</h3><ul>
<li>JPA 是 Hibernate 的一个抽象（就像JDBC和JDBC驱动的关系）</li>
<li>JPA 是规范：JPA 本质上就是一种 ORM 规范，不是ORM 框架，这是因为 JPA 并未提供 ORM 实现，它只是制订了一些规范，提供了一些编程的 API 接口，但具体实现则由 ORM 厂商提供实现；</li>
<li>Hibernate 是实现：Hibernate 除了作为 ORM 框架之外，它也是一种 JPA 实现</li>
<li>从功能上来说， JPA 是 Hibernate 功能的一个子集</li>
</ul>
<h3 id="3-3-JPA的供应商"><a href="#3-3-JPA的供应商" class="headerlink" title="3.3 JPA的供应商"></a>3.3 JPA的供应商</h3><p>JPA 的目标之一是制定一个可以由很多供应商实现的 API，Hibernate 3.2+、TopLink 10.1+ 以及 OpenJPA 都提供了 JPA 的实现，Jpa 供应商有很多，常见的有如下四种：</p>
<ul>
<li>Hibernate<br>JPA 的始作俑者就是 Hibernate 的作者，Hibernate 从 3.2 开始兼容 JPA。</li>
<li>OpenJPA<br>OpenJPA 是 Apache 组织提供的开源项目。</li>
<li>TopLink<br>TopLink 以前需要收费，如今开源了。</li>
<li>EclipseLink</li>
</ul>
<h3 id="3-4-JPA的优势"><a href="#3-4-JPA的优势" class="headerlink" title="3.4 JPA的优势"></a>3.4 JPA的优势</h3><ul>
<li>标准化: 提供相同的 API，这保证了基于JPA 开发的企业应用能够经过少量的修改就能够在不同的 JPA 框架下运行。</li>
<li>简单易用，集成方便: JPA 的主要目标之一就是提供更加简单的编程模型，在 JPA 框架下创建实体和创建 Java 类一样简单，只需要使用 javax.persistence.Entity 进行注解；JPA 的框架和接口也都非常简单。</li>
<li>可媲美JDBC的查询能力: JPA的查询语言是面向对象的，JPA定义了独特的JPQL，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。</li>
<li>支持面向对象的高级特性: JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，最大限度的使用面向对象的模型</li>
</ul>
<h3 id="3-5-JPA包含的技术"><a href="#3-5-JPA包含的技术" class="headerlink" title="3.5 JPA包含的技术"></a>3.5 JPA包含的技术</h3><ul>
<li>ORM 映射元数据：JPA 支持 XML 和 JDK 5.0 注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。</li>
<li>JPA 的 API：用来操作实体对象，执行CRUD操作，框架在后台完成所有的事情，开发者从繁琐的 JDBC 和 SQL 代码中解脱出来。</li>
<li>查询语言（JPQL）：这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序和具体的 SQL 紧密耦合。</li>
</ul>
<h3 id="3-6-Spring-Data"><a href="#3-6-Spring-Data" class="headerlink" title="3.6 Spring Data"></a>3.6 Spring Data</h3><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p>
<ul>
<li>SpringData 项目支持 NoSQL 存储：<br>MongoDB （文档数据库）<br>Neo4j（图形数据库）<br>Redis（键/值存储）<br>Hbase（列族数据库）</li>
<li>SpringData 项目所支持的关系数据存储技术：<br>JDBC<br>JPA</li>
<li>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！</li>
<li>框架怎么可能代替开发者实现业务逻辑呢？比如：当有一个 UserDao.findUserById() 这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象。Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</li>
</ul>
<h3 id="3-7-Jpa-的故事"><a href="#3-7-Jpa-的故事" class="headerlink" title="3.7 Jpa 的故事"></a>3.7 Jpa 的故事</h3><p>为了让大伙彻底把这两个东西学会，这里我就先来介绍单纯的Jpa使用，然后我们再结合 Spring Data 来看 Jpa如何使用。</p>
<p>整体步骤如下：</p>
<p>1.使用 IntelliJ IDEA 创建项目，创建时选择 JavaEE Persistence ，如下：<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/19-2-20210525153228734.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>2.创建成功后，添加依赖jar，由于 Jpa 只是一个规范，因此我们说用Jpa实际上必然是用Jpa的某一种实现，那么是哪一种实现呢？当然就是Hibernate了，所以添加的jar，实际上来自 Hibernate，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/19-3-20210525153228618.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>3.添加实体类</p>
<p>接下来在项目中添加实体类，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Entity(name = &quot;t_book&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String author;

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;
    <span class="hljs-comment">// 省略其他getter/setter</span>
&#125;</code></pre></div>

<p>首先@Entity注解表示这是一个实体类，那么在项目启动时会自动针对该类生成一张表，默认的表名为类名，@Entity注解的name属性表示自定义生成的表名。@Id注解表示这个字段是一个id，@GeneratedValue注解表示主键的自增长策略，对于类中的其他属性，默认都会根据属性名在表中生成相应的字段，字段名和属性名相同，如果开发者想要对字段进行定制，可以使用@Column注解，去配置字段的名称，长度，是否为空等等。</p>
<p>4.创建 persistence.xml 文件</p>
<p>JPA 规范要求在类路径的 META-INF 目录下放置persistence.xml，文件的名称是固定的</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">persistence</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/persistence&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">persistence-unit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;NewPersistenceUnit&quot;</span> <span class="hljs-attr">transaction-type</span>=<span class="hljs-string">&quot;RESOURCE_LOCAL&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">provider</span>&gt;</span>org.hibernate.jpa.HibernatePersistenceProvider<span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">class</span>&gt;</span>org.sang.Book<span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.connection.url&quot;</span></span>
<span class="hljs-tag">                      <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///jpa01?useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.connection.driver_class&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.connection.username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.connection.password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.archive.autodetection&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;class&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.show_sql&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.format_sql&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.hbm2ddl.auto&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;update&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">persistence-unit</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">persistence</span>&gt;</span></code></pre></div>

<p>注意：</p>
<ul>
<li>persistence-unit 的name 属性用于定义持久化单元的名字, 必填。</li>
<li>transaction-type：指定 JPA 的事务处理策略。RESOURCE_LOCAL：默认值，数据库级别的事务，只能针对一种数据库，不支持分布式事务。如果需要支持分布式事务，使用JTA：transaction-type=”JTA”</li>
<li>class节点表示显式的列出实体类</li>
<li>properties中的配置分为两部分：数据库连接信息以及Hibernate信息</li>
</ul>
<ol>
<li>执行持久化操作</li>
</ol>
<div class="hljs code-wrapper"><pre><code class="hljs java">EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(<span class="hljs-string">&quot;NewPersistenceUnit&quot;</span>);
EntityManager manager = entityManagerFactory.createEntityManager();
EntityTransaction transaction = manager.getTransaction();
transaction.begin();
Book book = <span class="hljs-keyword">new</span> Book();
book.setAuthor(<span class="hljs-string">&quot;罗贯中&quot;</span>);
book.setName(<span class="hljs-string">&quot;三国演义&quot;</span>);
manager.persist(book);
transaction.commit();
manager.close();
entityManagerFactory.close();</code></pre></div>

<p>这里首先根据配置文件创建出来一个 EntityManagerFactory ，然后再根据 EntityManagerFactory 的实例创建出来一个 EntityManager ，然后再开启事务，调用 EntityManager 中的 persist 方法执行一次持久化操作，最后提交事务，执行完这些操作后，数据库中旧多出来一个 t_book 表，并且表中有一条数据。</p>
<h4 id="关于-JPQL"><a href="#关于-JPQL" class="headerlink" title="关于 JPQL"></a>关于 JPQL</h4><ul>
<li><p>JPQL语言，即 Java Persistence Query Language 的简称。JPQL 是一种和 SQL 非常类似的中间性和对象化查询语言，它最终会被编译成针对不同底层数据库的 SQL 查询，从而屏蔽不同数据库的差异。JPQL语言的语句可以是 select 语句、update 语句或delete语句，它们都通过 Query 接口封装执行。</p>
</li>
<li><p>Query接口封装了执行数据库查询的相关方法。调用 EntityManager 的 createQuery、create NamedQuery 及 createNativeQuery 方法可以获得查询对象，进而可调用 Query 接口的相关方法来执行查询操作。</p>
</li>
<li><p>Query接口的主要方法如下：</p>
<ul>
<li><table>
<thead>
<tr>
<th><strong>int executeUpdate();</strong></th>
<th>用于执行update或delete语句。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>List getResultList();</strong></th>
<th>用于执行select语句并返回结果集实体列表。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>Object getSingleResult();</strong></th>
<th>用于执行只返回单个结果实体的select语句。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>Query setFirstResult(int startPosition);</strong></th>
<th>用于设置从哪个实体记录开始返回查询结果。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>Query setMaxResults(int maxResult);</strong></th>
<th>用于设置返回结果实体的最大数。与setFirstResult结合使用可实现分页查询。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>Query setFlushMode(FlushModeType flushMode);</strong></th>
<th>设置查询对象的Flush模式。参数可以取2个枚举值：FlushModeType.AUTO 为自动更新数据库记录，FlushMode Type.COMMIT 为直到提交事务时才更新数据库记录。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>setHint(String hintName, Object value);</strong></th>
<th>设置与查询对象相关的特定供应商参数或提示信息。参数名及其取值需要参考特定 JPA 实现库提供商的文档。如果第二个参数无效将抛出IllegalArgumentException异常。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>setParameter(int position, Object value);</strong></th>
<th>为查询语句的指定位置参数赋值。Position 指定参数序号，value 为赋给参数的值。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>setParameter(int position, Date d, TemporalType type);</strong></th>
<th>为查询语句的指定位置参数赋 Date 值。Position 指定参数序号，value 为赋给参数的值，temporalType 取 TemporalType 的枚举常量，包括 DATE、TIME 及 TIMESTAMP 三个，，用于将 Java 的 Date 型值临时转换为数据库支持的日期时间类型（java.sql.Date、java.sql.Time及java.sql.Timestamp）。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>setParameter(int position, Calendar c, TemporalType type);</strong></th>
<th>为查询语句的指定位置参数赋 Calenda r值。position 指定参数序号，value 为赋给参数的值，temporalType 的含义及取舍同前。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>setParameter(String name, Object value);</strong></th>
<th>为查询语句的指定名称参数赋值。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th><strong>setParameter(String name, Date d, TemporalType type);</strong></th>
<th>为查询语句的指定名称参数赋 Date 值,用法同前。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>setParameter(String name, Calendar c, TemporalType type);</strong></th>
<th>为查询语句的指定名称参数设置Calendar值。name为参数名，其它同前。该方法调用时如果参数位置或参数名不正确，或者所赋的参数值类型不匹配，将抛出 IllegalArgumentException 异常。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="JPQL-举例"><a href="#JPQL-举例" class="headerlink" title="JPQL 举例"></a>JPQL 举例</h4><p>和在 SQL 中一样，JPQL 中的 select 语句用于执行查询。其语法可表示为：<br><code>select_clause form_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause]</code></p>
<p>其中：</p>
<ol>
<li>from 子句是查询语句的必选子句。</li>
<li>select 用来指定查询返回的结果实体或实体的某些属性。</li>
<li>from 子句声明查询源实体类，并指定标识符变量（相当于SQL表的别名）。</li>
<li>如果不希望返回重复实体，可使用关键字 distinct 修饰。select、from 都是 JPQL 的关键字，通常全大写或全小写，建议不要大小写混用。</li>
</ol>
<p>在 JPQL 中，查询所有实体的 JPQL 查询语句很简单，如下：<br><code>select o from Order o 或 select o from Order as o</code><br>这里关键字 as 可以省去，标识符变量的命名规范与 Java 标识符相同，且区分大小写,调用 EntityManager 的 createQuery() 方法可创建查询对象，接着调用 Query 接口的 getResultList() 方法就可获得查询结果集，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">Query query = entityManager.createQuery( <span class="hljs-string">&quot;select o from Order o&quot;</span>); 
List orders = query.getResultList();
Iterator iterator = orders.iterator();
<span class="hljs-keyword">while</span>(iterator.hasNext() ) &#123;
  <span class="hljs-comment">// 处理Order</span>
&#125;</code></pre></div>

<p>其他方法的与此类似，这里不再赘述。</p>
<h3 id="3-8-Spring-Data-的故事"><a href="#3-8-Spring-Data-的故事" class="headerlink" title="3.8 Spring Data 的故事"></a>3.8 Spring Data 的故事</h3><p>在 Spring Boot 中，Spring Data Jpa 官方封装了太多东西了，导致很多人用的时候不知道底层到底是怎么配置的，本文就和大伙来看看在手工的Spring环境下，Spring Data Jpa要怎么配置，配置完成后，用法和 Spring Boot 中的用法是一致的。</p>
<h4 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h4><p>首先创建一个普通的Maven工程，并添加如下依赖：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-oxm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.12.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-jpamodelgen<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.12.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.11.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<p>这里除了 Jpa 的依赖之外，就是Spring Data Jpa 的依赖了。</p>
<p>接下来创建一个 User 实体类，创建方式参考 Jpa中实体类的创建方式，这里不再赘述。</p>
<p>接下来在resources目录下创建一个applicationContext.xml文件，并配置Spring和Jpa，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.sang&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.driver&#125;&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.url&#125;&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.username&#125;&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.password&#125;&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jpaVendorAdapter&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;packagesToScan&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.sang.model&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jpaProperties&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL57Dialect<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span>
<span class="hljs-comment">&lt;!-- 配置jpa --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">jpa:repositories</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.sang.dao&quot;</span></span>
<span class="hljs-tag">                  <span class="hljs-attr">entity-manager-factory-ref</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span>/&gt;</span></code></pre></div>

<p>这里和 Jpa 相关的配置主要是三个，一个是entityManagerFactory，一个是Jpa的事务，还有一个是配置dao的位置，配置完成后，就可以在 org.sang.dao 包下创建相应的 Repository 了，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">User</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;
    <span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span></span>;
&#125;</code></pre></div>

<p>getUserById表示根据id去查询User对象，只要我们的方法名称符合类似的规范，就不需要写SQL，具体的规范一会来说。好了，接下来，创建 Service 和 Controller 来调用这个方法，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;
    <span class="hljs-meta">@Resource</span>
    UserDao userDao;

    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;
        <span class="hljs-keyword">return</span> userDao.getUserById(id);
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;
    ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);
    UserService userService = ctx.getBean(UserService.class);
    User user = userService.getUserById(<span class="hljs-number">1L</span>);
    System.out.println(user);
&#125;</code></pre></div>

<p>这样，就可以查询到id为1的用户了。</p>
<h4 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h4><p>上文我们自定义的 UserDao 实现了 Repository 接口，这个 Repository 接口是什么来头呢？</p>
<p>首先来看 Repository 的一个继承关系图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/19-4-20210525152813140.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>可以看到，实现类不少。那么到底如何理解 Repository 呢？</p>
<ol>
<li>Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法 <code>public interface Repository&lt;T, ID extends Serializable&gt; &#123; &#125;</code></li>
<li>若我们定义的接口继承了 Repository, 则该接口会被 IOC 容器识别为一个 Repository Bean，进而纳入到 IOC 容器中，进而可以在该接口中定义满足一定规范的方法。</li>
<li>Spring Data可以让我们只定义接口，只要遵循 Spring Data 的规范，就无需写实现类。</li>
<li>与继承 Repository 等价的一种方式，就是在持久层接口上使用 @RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性。像下面这样：</li>
</ol>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RepositoryDefinition(domainClass = User.class, idClass = Long.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(Long id)</span></span>;
    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p>基础的 Repository 提供了最基本的数据访问功能，其几个子接口则扩展了一些功能，它的几个常用的实现类如下：</p>
<ul>
<li>CrudRepository： 继承 Repository，实现了一组 CRUD 相关的方法</li>
<li>PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法</li>
<li>JpaRepository： 继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法</li>
<li>自定义的 XxxxRepository 需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力。</li>
<li>JpaSpecificationExecutor： 不属于Repository体系，实现一组 JPA Criteria 查询相关的方法</li>
</ul>
<h4 id="方法定义规范"><a href="#方法定义规范" class="headerlink" title="方法定义规范"></a>方法定义规范</h4><h5 id="简单条件查询"><a href="#简单条件查询" class="headerlink" title="简单条件查询"></a>简单条件查询</h5><ul>
<li>按照 Spring Data 的规范，查询方法以 find  read  get 开头</li>
<li>涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写</li>
</ul>
<p>例如：定义一个 Entity 实体类：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>｛ </span>
<span class="hljs-class">   <span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">firstName</span></span>; 
   <span class="hljs-keyword">private</span> String lastName; 
｝</code></pre></div>

<p>使用And条件连接时，条件的属性名称与个数要与参数的位置与个数一一对应，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">findByLastNameAndFirstName(String lastName,String firstName);</code></pre></div>

<ul>
<li>支持属性的级联查询. 若当前类有符合条件的属性, 则优先使用, 而不使用级联属性. 若需要使用级联属性, 则属性之间使用 _ 进行连接.</li>
</ul>
<p>查询举例：<br>1.按照id查询</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span></span>;
<span class="hljs-function">User <span class="hljs-title">getById</span><span class="hljs-params">(Long id)</span></span>;</code></pre></div>

<p>2.查询所有年龄小于90岁的人</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByAgeLessThan</span><span class="hljs-params">(Long age)</span></span>;</code></pre></div>

<p>3.查询所有姓赵的人</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByUsernameStartingWith</span><span class="hljs-params">(String u)</span></span>;</code></pre></div>

<p>4.查询所有姓赵的、并且id大于50的人</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByUsernameStartingWithAndIdGreaterThan</span><span class="hljs-params">(String name, Long id)</span></span>;</code></pre></div>

<p>5.查询所有姓名中包含”上”字的人</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByUsernameContaining</span><span class="hljs-params">(String name)</span></span>;</code></pre></div>

<p>6.查询所有姓赵的或者年龄大于90岁的</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByUsernameStartingWithOrAgeGreaterThan</span><span class="hljs-params">(String name, Long age)</span></span>;</code></pre></div>

<p>7.查询所有角色为1的用户</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByRole_Id</span><span class="hljs-params">(Long id)</span></span>;</code></pre></div>

<h5 id="支持的关键字"><a href="#支持的关键字" class="headerlink" title="支持的关键字"></a>支持的关键字</h5><p>支持的查询关键字如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/19-5-20210525152813173.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="查询方法流程解析"><a href="#查询方法流程解析" class="headerlink" title="查询方法流程解析"></a>查询方法流程解析</h5><p>为什么写上方法名，JPA就知道你想干嘛了呢？假如创建如下的查询：<code>findByUserDepUuid()</code>，框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析，假设查询实体为Doc：</p>
<ol>
<li>先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步；</li>
<li>从右往左截取第一个大写字母开头的字符串(此处为Uuid)，然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设 user 为查询实体的一个属性；</li>
<li>接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 “ Doc.user.depUuid” 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 “Doc.user.dep.uuid” 的值进行查询。</li>
<li>可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 “_” 以显式表达意图，比如 “findByUser_DepUuid()” 或者 “findByUserDep_uuid()”</li>
<li>还有一些特殊的参数：例如分页或排序的参数：</li>
</ol>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Page&lt;UserModel&gt; <span class="hljs-title">findByName</span><span class="hljs-params">(String name, Pageable pageable)</span></span>;  
<span class="hljs-function">List&lt;UserModel&gt; <span class="hljs-title">findByName</span><span class="hljs-params">(String name, Sort sort)</span></span>;</code></pre></div>

<h4 id="Query注解"><a href="#Query注解" class="headerlink" title="@Query注解"></a>@Query注解</h4><p>有的时候，这里提供的查询关键字并不能满足我们的查询需求，这个时候就可以使用 @Query 关键字，来自定义查询 SQL，例如查询Id最大的User：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Query(&quot;select u from t_user u where id=(select max(id) from t_user)&quot;)</span>
<span class="hljs-function">User <span class="hljs-title">getMaxIdUser</span><span class="hljs-params">()</span></span>;</code></pre></div>

<p>如果查询有参数的话，参数有两种不同的传递方式:</p>
<p>1.利用下标索引传参，索引参数如下所示，索引值从1开始，查询中 ”?X” 个数需要与方法定义的参数个数相一致，并且顺序也要一致：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Query(&quot;select u from t_user u where id&gt;?1 and username like ?2&quot;)</span>
<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">selectUserByParam</span><span class="hljs-params">(Long id, String name)</span></span>;</code></pre></div>

<p>2.命名参数（推荐）：这种方式可以定义好参数名，赋值时采用@Param(“参数名”)，而不用管顺序：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Query(&quot;select u from t_user u where id&gt;:id and username like :name&quot;)</span>
<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">selectUserByParam2</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name, <span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</code></pre></div>

<p>查询时候，也可以是使用原生的SQL查询，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Query(value = &quot;select * from t_user&quot;,nativeQuery = true)</span>
<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">selectAll</span><span class="hljs-params">()</span></span>;</code></pre></div>

<h4 id="Modifying注解"><a href="#Modifying注解" class="headerlink" title="@Modifying注解"></a>@Modifying注解</h4><p>涉及到数据修改操作，可以使用 @Modifying 注解，@Query 与 @Modifying 这两个 annotation一起声明，可定义个性化更新操作，例如涉及某些字段更新时最为常用，示例如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Modifying</span>
<span class="hljs-meta">@Query(&quot;update t_user set age=:age where id&gt;:id&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;age&quot;)</span> Long age, <span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</code></pre></div>

<p>注意：</p>
<ol>
<li>可以通过自定义的 JPQL 完成 UPDATE 和 DELETE 操作. 注意: JPQL 不支持使用 INSERT</li>
<li>方法的返回值应该是 int，表示更新语句所影响的行数</li>
<li>在调用的地方必须加事务，没有事务不能正常执行</li>
<li>默认情况下, Spring Data 的每个方法上有事务, 但都是一个只读事务. 他们不能完成修改操作</li>
</ol>
<p>说到这里，再来顺便说说Spring Data 中的事务问题：</p>
<ol>
<li>Spring Data 提供了默认的事务处理方式，即所有的查询均声明为只读事务。</li>
<li>对于自定义的方法，如需改变 Spring Data 提供的事务默认方式，可以在方法上添加 @Transactional 注解。</li>
<li>进行多个 Repository 操作时，也应该使它们在同一个事务中处理，按照分层架构的思想，这部分属于业务逻辑层，因此，需要在Service 层实现对多个 Repository 的调用，并在相应的方法上声明事务。</li>
</ol>
<p>Spring Boot中的数据持久化方案前面给大伙介绍了两种了，一个是JdbcTemplate，还有一个MyBatis，JdbcTemplate配置简单，使用也简单，但是功能也非常有限，MyBatis则比较灵活，功能也很强大，据我所知，公司采用MyBatis做数据持久化的相当多，但是MyBatis并不是唯一的解决方案，除了MyBatis之外，还有另外一个东西，那就是Jpa，松哥也有一些朋友在公司里使用Jpa来做数据持久化，本文就和大伙来说说Jpa如何实现数据持久化。</p>
<h3 id="3-9-整合Jpa"><a href="#3-9-整合Jpa" class="headerlink" title="3.9 整合Jpa"></a>3.9 整合Jpa</h3><p>首先需要向大伙介绍一下Jpa，Jpa（Java Persistence API）Java持久化API，它是一套ORM规范，而不是具体的实现，Jpa的江湖地位类似于JDBC，只提供规范，所有的数据库厂商提供实现（即具体的数据库驱动），Java领域，小伙伴们熟知的ORM框架可能主要是Hibernate，实际上，除了Hibernate之外，还有很多其他的ORM框架，例如：</p>
<ul>
<li>Batoo JPA</li>
<li>DataNucleus (formerly JPOX)</li>
<li>EclipseLink (formerly Oracle TopLink)</li>
<li>IBM, for WebSphere Application Server</li>
<li>JBoss with Hibernate</li>
<li>Kundera</li>
<li>ObjectDB</li>
<li>OpenJPA</li>
<li>OrientDB from Orient Technologies</li>
<li>Versant Corporation JPA (not relational, object database)</li>
</ul>
<p>Hibernate只是ORM框架的一种，上面列出来的ORM框架都是支持JPA2.0规范的ORM框架。既然它是一个规范，不是具体的实现，那么必然就不能直接使用（类似于JDBC不能直接使用，必须要加了驱动才能用），我们使用的是具体的实现，在这里我们采用的实现实际上还是Hibernate。</p>
<p>Spring Boot中使用的Jpa实际上是Spring Data Jpa，Spring Data是Spring家族的一个子项目，用于简化SQL和NoSQL的访问，在Spring Data中，只要你的方法名称符合规范，它就知道你想干嘛，不需要自己再去写SQL。</p>
<h4 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h4><p>创建Spring Boot工程，添加Web、Jpa以及MySQL驱动依赖，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5-1-20210523202517154-20210525152813172.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>工程创建好之后，添加Druid依赖，完整的依赖如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>如此，工程就算创建成功了。</p>
<h4 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h4><p>工程创建完成后，只需要在application.properties中进行数据库基本信息配置以及Jpa基本配置，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 数据库的基本配置</span>
<span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8</span>
<span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>
<span class="hljs-comment"># JPA配置</span>
<span class="hljs-meta">spring.jpa.database</span>=<span class="hljs-string">mysql</span>
<span class="hljs-comment"># 在控制台打印SQL</span>
<span class="hljs-meta">spring.jpa.show-sql</span>=<span class="hljs-string">true</span>
<span class="hljs-comment"># 数据库平台</span>
<span class="hljs-meta">spring.jpa.database-platform</span>=<span class="hljs-string">mysql</span>
<span class="hljs-comment"># 每次启动项目时，数据库初始化策略</span>
<span class="hljs-meta">spring.jpa.hibernate.ddl-auto</span>=<span class="hljs-string">update</span>
<span class="hljs-comment"># 指定默认的存储引擎为InnoDB</span>
<span class="hljs-meta">spring.jpa.properties.hibernate.dialect</span>=<span class="hljs-string">org.hibernate.dialect.MySQL57Dialect</span></code></pre></div>

<p>注意这里和JdbcTemplate以及MyBatis比起来，多了Jpa配置，Jpa配置含义我都注释在代码中了，这里不再赘述，需要强调的是，最后一行配置，默认情况下，自动创建表的时候会使用MyISAM做表的引擎，如果配置了数据库方言为MySQL57Dialect，则使用InnoDB做表的引擎</p>
<p>好了，配置完成后，我们的Jpa差不多就可以开始用了</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ORM(Object Relational Mapping)框架表示对象关系映射，使用ORM框架我们不必再去创建表，框架会自动根据当前项目中的实体类创建相应的数据表。因此，我这里首先创建一个User对象，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Entity(name = &quot;t_user&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span>
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> String address;
    <span class="hljs-comment">//省略getter/setter</span>
&#125;</code></pre></div>

<p>首先@Entity注解表示这是一个实体类，那么在项目启动时会自动针对该类生成一张表，默认的表名为类名，@Entity注解的name属性表示自定义生成的表名。@Id注解表示这个字段是一个id，@GeneratedValue注解表示主键的自增长策略，对于类中的其他属性，默认都会根据属性名在表中生成相应的字段，字段名和属性名相同，如果开发者想要对字段进行定制，可以使用@Column注解，去配置字段的名称，长度，是否为空等等。</p>
<p>做完这一切之后，启动Spring Boot项目，就会发现数据库中多了一个名为t_user的表了。</p>
<p>针对该表的操作，则需要我们提供一个Repository，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;
    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByAddressEqualsAndIdLessThanEqual</span><span class="hljs-params">(String address, Integer id)</span></span>;

    <span class="hljs-meta">@Query(value = &quot;select * from t_user where id=(select max(id) from t_user)&quot;,nativeQuery = true)</span>
    <span class="hljs-function">User <span class="hljs-title">maxIdUser</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p>这里，自定义UserDao接口继承自JpaRepository，JpaRepository提供了一些基本的数据操作方法，例如保存，更新，删除，分页查询等，开发者也可以在接口中自己声明相关的方法，只需要方法名称符合规范即可，在Spring Data中，只要按照既定的规范命名方法，Spring Data Jpa就知道你想干嘛，这样就不用写SQL了，那么规范是什么呢？参考下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5-2-20210525152813241.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>当然，这种方法命名主要是针对查询，但是一些特殊需求，可能并不能通过这种方式解决，例如想要查询id最大的用户，这时就需要开发者自定义查询SQL了，如上代码所示，自定义查询SQL，使用@Query注解，在注解中写自己的SQL，默认使用的查询语言不是SQL，而是JPQL，这是一种数据库平台无关的面向对象的查询语言，有点定位类似于Hibernate中的HQL，在@Query注解中设置nativeQuery属性为true则表示使用原生查询，即大伙所熟悉的SQL。上面代码中的只是一个很简单的例子，还有其他一些点，例如如果这个方法中的SQL涉及到数据操作，则需要使用@Modifying注解。</p>
<p>好了，定义完Dao之后，接下来就可以将UserDao注入到Controller中进行测试了(这里为了省事，就没有提供Service了，直接将UserDao注入到Controller中)。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    UserDao userDao;
    <span class="hljs-meta">@PostMapping(&quot;/&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">()</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setId(<span class="hljs-number">1</span>);
        user.setUsername(<span class="hljs-string">&quot;张三&quot;</span>);
        user.setAddress(<span class="hljs-string">&quot;深圳&quot;</span>);
        userDao.save(user);
    &#125;

    <span class="hljs-meta">@DeleteMapping(&quot;/&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">()</span> </span>&#123;
        userDao.deleteById(<span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-meta">@PutMapping(&quot;/&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">()</span> </span>&#123;
        User user = userDao.getOne(<span class="hljs-number">1</span>);
        user.setUsername(<span class="hljs-string">&quot;李四&quot;</span>);
        userDao.flush();
    &#125;

    <span class="hljs-meta">@GetMapping(&quot;/test1&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;User&gt; all = userDao.findAll();
        System.out.println(all);
    &#125;

    <span class="hljs-meta">@GetMapping(&quot;/test2&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;User&gt; list = userDao.getUserByAddressEqualsAndIdLessThanEqual(<span class="hljs-string">&quot;广州&quot;</span>, <span class="hljs-number">2</span>);
        System.out.println(list);
    &#125;
    <span class="hljs-meta">@GetMapping(&quot;/test3&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;
        User user = userDao.maxIdUser();
        System.out.println(user);
    &#125;
&#125;</code></pre></div>

<p>如此之后，即可查询到需要的数据。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在和Spring框架整合时，如果用到ORM框架，大部分人可能都是首选Hibernate，实际上，在和Spring+SpringMVC整合时，也可以选择Spring Data Jpa做数据持久化方案，用法和本文所述基本是一样的，Spring Boot只是将Spring Data Jpa的配置简化了，因此，很多初学者对Spring Data Jpa觉得很神奇，但是又觉得无从下手，其实，此时可以回到Spring框架，先去学习Jpa，再去学习Spring Data Jpa，这是给初学者的一点建议。</p>
<h3 id="3-10-整合多数据源"><a href="#3-10-整合多数据源" class="headerlink" title="3.10 整合多数据源"></a>3.10 整合多数据源</h3><p>本文是Spring Boot整合数据持久化方案的最后一篇，主要和大伙来聊聊Spring Boot整合Jpa多数据源问题。在Spring Boot整合JbdcTemplate多数据源、Spring Boot整合MyBatis多数据源以及Spring Boot整合Jpa多数据源这三个知识点中，整合Jpa多数据源算是最复杂的一种，也是很多人在配置时最容易出错的一种。</p>
<h4 id="3-10-1-工程创建"><a href="#3-10-1-工程创建" class="headerlink" title="3.10.1 工程创建"></a>3.10.1 工程创建</h4><p>首先是创建一个Spring Boot工程，创建时添加基本的Web、Jpa以及MySQL依赖，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/5-1-20210523212051594-20210525152813172.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>创建完成后，添加Druid依赖，这里和前文的要求一样，要使用专为Spring Boot打造的Druid，大伙可能发现了，如果整合多数据源一定要使用这个依赖，因为这个依赖中才有DruidDataSourceBuilder，最后还要记得锁定数据库依赖的版本，因为可能大部分人用的还是5.x的MySQL而不是8.x。完整依赖如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>如此之后，工程就创建成功了。</p>
<h4 id="3-10-2-基本配置"><a href="#3-10-2-基本配置" class="headerlink" title="3.10.2 基本配置"></a>3.10.2 基本配置</h4><p>在基本配置中，我们首先来配置多数据源基本信息以及DataSource，首先在application.properties中添加如下配置信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#  数据源一</span>
<span class="hljs-meta">spring.datasource.one.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.one.password</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.one.url</span>=<span class="hljs-string">jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8</span>
<span class="hljs-meta">spring.datasource.one.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>

<span class="hljs-comment">#  数据源二</span>
<span class="hljs-meta">spring.datasource.two.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.two.password</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.two.url</span>=<span class="hljs-string">jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=UTF-8</span>
<span class="hljs-meta">spring.datasource.two.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>

<span class="hljs-comment"># Jpa配置</span>
<span class="hljs-meta">spring.jpa.properties.database</span>=<span class="hljs-string">mysql</span>
<span class="hljs-meta">spring.jpa.properties.show-sql</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">spring.jpa.properties.database-platform</span>=<span class="hljs-string">mysql</span>
<span class="hljs-meta">spring.jpa.properties.hibernate.ddl-auto</span>=<span class="hljs-string">update</span>
<span class="hljs-meta">spring.jpa.properties.hibernate.dialect</span>=<span class="hljs-string">org.hibernate.dialect.MySQL57Dialect</span></code></pre></div>

<p>这里Jpa的配置和上文相比key中多了properties，多数据源的配置和前文一致，然后接下来配置两个DataSource，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)</span>
    <span class="hljs-meta">@Primary</span>
    <span class="hljs-function">DataSource <span class="hljs-title">dsOne</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)</span>
    <span class="hljs-function">DataSource <span class="hljs-title">dsTwo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> DruidDataSourceBuilder.create().build();
    &#125;
&#125;</code></pre></div>

<p>这里的配置和前文的多数据源配置基本一致，但是注意多了一个在Spring中使用较少的注解@Primary，这个注解一定不能少，否则在项目启动时会出错，@Primary表示当某一个类存在多个实例时，优先使用哪个实例。</p>
<h4 id="3-10-3-多数据源配置"><a href="#3-10-3-多数据源配置" class="headerlink" title="3.10.3 多数据源配置"></a>3.10.3 多数据源配置</h4><p>接下来配置Jpa的基本信息，这里两个数据源，我分别在两个类中来配置，先来看第一个配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableJpaRepositories(basePackages = &quot;org.sang.jpa.dao&quot;,entityManagerFactoryRef = &quot;localContainerEntityManagerFactoryBeanOne&quot;,transactionManagerRef = &quot;platformTransactionManagerOne&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaConfigOne</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-meta">@Qualifier(value = &quot;dsOne&quot;)</span>
    DataSource dsOne;

    <span class="hljs-meta">@Autowired</span>
    JpaProperties jpaProperties;


    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Primary</span>
    <span class="hljs-function">LocalContainerEntityManagerFactoryBean <span class="hljs-title">localContainerEntityManagerFactoryBeanOne</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;
        <span class="hljs-keyword">return</span> builder.dataSource(dsOne)
                .packages(<span class="hljs-string">&quot;org.sang.jpa.model&quot;</span>)
                .properties(jpaProperties.getProperties())
                .persistenceUnit(<span class="hljs-string">&quot;pu1&quot;</span>)
                .build();
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PlatformTransactionManager <span class="hljs-title">platformTransactionManagerOne</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;
        LocalContainerEntityManagerFactoryBean factoryBeanOne = localContainerEntityManagerFactoryBeanOne(builder);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JpaTransactionManager(factoryBeanOne.getObject());
    &#125;
&#125;</code></pre></div>

<p>首先这里注入dsOne，再注入JpaProperties，JpaProperties是系统提供的一个实例，里边的数据就是我们在application.properties中配置的jpa相关的配置。然后我们提供两个Bean，分别是LocalContainerEntityManagerFactoryBean和PlatformTransactionManager事务管理器，不同于MyBatis和JdbcTemplate，在Jpa中，事务一定要配置。在提供LocalContainerEntityManagerFactoryBean的时候，需要指定packages，这里的packages指定的包就是这个数据源对应的实体类所在的位置，另外在这里配置类上通过@EnableJpaRepositories注解指定dao所在的位置，以及LocalContainerEntityManagerFactoryBean和PlatformTransactionManager分别对应的引用的名字。</p>
<p>好了，这样第一个就配置好了，第二个基本和这个类似，主要有几个不同点：</p>
<ul>
<li>dao的位置不同</li>
<li>persistenceUnit不同</li>
<li>相关bean的名称不同</li>
</ul>
<p>注意实体类可以共用。</p>
<p>代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableJpaRepositories(basePackages = &quot;org.sang.jpa.dao2&quot;,entityManagerFactoryRef = &quot;localContainerEntityManagerFactoryBeanTwo&quot;,transactionManagerRef = &quot;platformTransactionManagerTwo&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaConfigTwo</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-meta">@Qualifier(value = &quot;dsTwo&quot;)</span>
    DataSource dsTwo;

    <span class="hljs-meta">@Autowired</span>
    JpaProperties jpaProperties;


    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">LocalContainerEntityManagerFactoryBean <span class="hljs-title">localContainerEntityManagerFactoryBeanTwo</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;
        <span class="hljs-keyword">return</span> builder.dataSource(dsTwo)
                .packages(<span class="hljs-string">&quot;org.sang.jpa.model&quot;</span>)
                .properties(jpaProperties.getProperties())
                .persistenceUnit(<span class="hljs-string">&quot;pu2&quot;</span>)
                .build();
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PlatformTransactionManager <span class="hljs-title">platformTransactionManagerTwo</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;
        LocalContainerEntityManagerFactoryBean factoryBeanTwo = localContainerEntityManagerFactoryBeanTwo(builder);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JpaTransactionManager(factoryBeanTwo.getObject());
    &#125;
&#125;</code></pre></div>

<p>接下来，在对应位置分别提供相关的实体类和dao即可，数据源一的dao如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.sang.jpa.dao;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;
    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByAddressEqualsAndIdLessThanEqual</span><span class="hljs-params">(String address, Integer id)</span></span>;

    <span class="hljs-meta">@Query(value = &quot;select * from t_user where id=(select max(id) from t_user)&quot;,nativeQuery = true)</span>
    <span class="hljs-function">User <span class="hljs-title">maxIdUser</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p>数据源二的dao如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.sang.jpa.dao2;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;
    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByAddressEqualsAndIdLessThanEqual</span><span class="hljs-params">(String address, Integer id)</span></span>;

    <span class="hljs-meta">@Query(value = &quot;select * from t_user where id=(select max(id) from t_user)&quot;,nativeQuery = true)</span>
    <span class="hljs-function">User <span class="hljs-title">maxIdUser</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p>共同的实体类如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.sang.jpa.model;

<span class="hljs-meta">@Entity(name = &quot;t_user&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> String address;
    <span class="hljs-comment">//省略getter/setter</span>
&#125;</code></pre></div>

<p>到此，所有的配置就算完成了，接下来就可以在Service中注入不同的UserDao，不同的UserDao操作不同的数据源。</p>
<h1 id="第五章、SpringBoot整合NoSQL"><a href="#第五章、SpringBoot整合NoSQL" class="headerlink" title="第五章、SpringBoot整合NoSQL"></a>第五章、SpringBoot整合NoSQL</h1><h2 id="1-整合Redis"><a href="#1-整合Redis" class="headerlink" title="1. 整合Redis"></a>1. 整合Redis</h2><h3 id="1-1-创建工程"><a href="#1-1-创建工程" class="headerlink" title="1.1 创建工程"></a>1.1 创建工程</h3><p>创建工程，引入 Redis 依赖：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13-2-20210525152434590.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>创建成功后，还需要手动引入 commos-pool2 的依赖，因此最终完整的 pom.xml 依赖如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>这里主要就是引入了 Spring Data Redis + 连接池。</p>
<h3 id="1-2-配置-Redis-信息"><a href="#1-2-配置-Redis-信息" class="headerlink" title="1.2 配置 Redis 信息"></a>1.2 配置 Redis 信息</h3><p>接下来配置 Redis 的信息，信息包含两方面，一方面是 Redis 的基本信息，另一方面则是连接池信息:</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span>
<span class="hljs-comment">#没有就空着</span>
<span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string">123</span>
<span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span>
<span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.66.128</span>
<span class="hljs-meta">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">5</span>
<span class="hljs-meta">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">10</span>
<span class="hljs-meta">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">8</span>
<span class="hljs-meta">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">1ms</span>
<span class="hljs-meta">spring.redis.lettuce.shutdown-timeout</span>=<span class="hljs-string">100ms</span></code></pre></div>

<h3 id="1-3-自动配置"><a href="#1-3-自动配置" class="headerlink" title="1.3 自动配置"></a>1.3 自动配置</h3><p>当开发者在项目中引入了 Spring Data Redis ，并且配置了 Redis 的基本信息，此时，自动化配置就会生效。</p>
<p>我们从 Spring Boot 中 Redis 的自动化配置类中就可以看出端倪：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ConditionalOnClass(RedisOperations.class)</span>
<span class="hljs-meta">@EnableConfigurationProperties(RedisProperties.class)</span>
<span class="hljs-meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;
        <span class="hljs-meta">@Bean</span>
        <span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">                        RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;
                RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();
                template.setConnectionFactory(redisConnectionFactory);
                <span class="hljs-keyword">return</span> template;
        &#125;
  
        <span class="hljs-meta">@Bean</span>
        <span class="hljs-meta">@ConditionalOnMissingBean</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">                        RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;
                StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();
                template.setConnectionFactory(redisConnectionFactory);
                <span class="hljs-keyword">return</span> template;
        &#125;
&#125;</code></pre></div>

<p>这个自动化配置类很好理解：</p>
<ul>
<li>首先标记这个是一个配置类，同时该配置在 RedisOperations 存在的情况下才会生效(即项目中引入了 Spring Data Redis)</li>
<li>然后导入在 application.properties 中配置的属性</li>
<li>然后再导入连接池信息（如果存在的话）</li>
<li>最后，提供了两个 Bean ，RedisTemplate 和 StringRedisTemplate ，其中 StringRedisTemplate 是 RedisTemplate 的子类，两个的方法基本一致，不同之处主要体现在操作的数据类型不同，RedisTemplate 中的两个泛型都是 Object ，意味者存储的 key 和 value 都可以是一个对象，而 StringRedisTemplate 的 两个泛型都是 String ，意味者 StringRedisTemplate 的 key 和 value 都只能是字符串。如果开发者没有提供相关的 Bean ，这两个配置就会生效，否则不会生效。</li>
</ul>
<h3 id="1-4-使用"><a href="#1-4-使用" class="headerlink" title="1.4 使用"></a>1.4 使用</h3><p>接下来，可以直接在 Service 中注入 StringRedisTemplate 或者 RedisTemplate 来使用：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    RedisTemplate redisTemplate;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        ValueOperations ops = redisTemplate.opsForValue();
        ops.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);
        Object k1 = ops.get(<span class="hljs-string">&quot;k1&quot;</span>);
        System.out.println(k1);
    &#125;
&#125;</code></pre></div>

<p>Redis 中的数据操作，大体上来说，可以分为两种：</p>
<ul>
<li>针对 key 的操作，相关的方法就在 RedisTemplate 中</li>
<li>针对具体数据类型的操作，相关的方法需要首先获取对应的数据类型，获取相应数据类型的操作方法是 opsForXXX</li>
</ul>
<p>调用该方法就可以将数据存储到 Redis 中去了，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13-3-20210525152434572.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>k1 前面的字符是由于使用了 RedisTemplate 导致的，RedisTemplate 对 key 进行序列化之后的结果。</p>
<p>RedisTemplate 中，key 默认的序列化方案是 JdkSerializationRedisSerializer 。</p>
<p>而在 StringRedisTemplate 中，key 默认的序列化方案是 StringRedisSerializer ，因此，如果使用 StringRedisTemplate ，默认情况下 key 前面不会有前缀。</p>
<p>不过开发者也可以自行修改 RedisTemplate 中的序列化方案，如下:</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    RedisTemplate redisTemplate;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());
        ValueOperations ops = redisTemplate.opsForValue();
        ops.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);
        Object k1 = ops.get(<span class="hljs-string">&quot;k1&quot;</span>);
        System.out.println(k1);
    &#125;
&#125;</code></pre></div>

<p>当然也可以直接使用 StringRedisTemplate：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    StringRedisTemplate stringRedisTemplate;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;
        ValueOperations ops = stringRedisTemplate.opsForValue();
        ops.set(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);
        Object k1 = ops.get(<span class="hljs-string">&quot;k2&quot;</span>);
        System.out.println(k1);
    &#125;
&#125;</code></pre></div>

<p>另外需要注意 ，Spring Boot 的自动化配置，只能配置单机的 Redis ，如果是 Redis 集群，则所有的东西都需要自己手动配置</p>
<h3 id="1-5-解决接口幂等性"><a href="#1-5-解决接口幂等性" class="headerlink" title="1.5 解决接口幂等性"></a>1.5 解决接口幂等性</h3><p>利用Service操作Redis</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    StringRedisTemplate stringRedisTemplate;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setEx</span><span class="hljs-params">(String key, String value, Long expireTime)</span> </span>&#123;
        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">try</span> &#123;
            ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();
            ops.set(key,value);
            stringRedisTemplate.expire(key, expireTime, TimeUnit.SECONDS);
            result = <span class="hljs-keyword">true</span>;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exists</span><span class="hljs-params">(String key)</span> </span>&#123;
        <span class="hljs-keyword">return</span> stringRedisTemplate.hasKey(key);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(String key)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (exists(key)) &#123;
            <span class="hljs-keyword">return</span> stringRedisTemplate.delete(key);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
&#125;


<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    RedisService redisService;
    <span class="hljs-comment">//创建</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createToken</span><span class="hljs-params">()</span> </span>&#123;
        String uuid = UUID.randomUUID().toString();
        redisService.setEx(uuid, uuid, <span class="hljs-number">10000L</span>);
        <span class="hljs-keyword">return</span> uuid;
    &#125;
    <span class="hljs-comment">//检查</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkToken</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> IdempotentException </span>&#123;
        String token = request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);
        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(token)) &#123;
            token = request.getParameter(<span class="hljs-string">&quot;token&quot;</span>);
            <span class="hljs-keyword">if</span> (StringUtils.isEmpty(token)) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IdempotentException(<span class="hljs-string">&quot;token 不存在&quot;</span>);
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (!redisService.exists(token)) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IdempotentException(<span class="hljs-string">&quot;重复操作！&quot;</span>);
        &#125;
        <span class="hljs-keyword">boolean</span> remove = redisService.remove(token);
        <span class="hljs-keyword">if</span> (!remove) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IdempotentException(<span class="hljs-string">&quot;重复操作！&quot;</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre></div>

<p><strong>自定义注解</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//有此方法代表需要处理幂等性问题</span>
<span class="hljs-meta">@Target(ElementType.METHOD)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoIdempotent &#123;
&#125;</code></pre></div>

<p><strong>自定义异常</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdempotentException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IdempotentException</span><span class="hljs-params">(String message)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(message);
    &#125;
&#125;

<span class="hljs-comment">//全局异常处理器</span>
<span class="hljs-meta">@RestControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalException</span> </span>&#123;
    <span class="hljs-meta">@ExceptionHandler(IdempotentException.class)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">idempotentException</span><span class="hljs-params">(IdempotentException e)</span> </span>&#123;
        <span class="hljs-keyword">return</span> e.getMessage();
    &#125;
&#125;</code></pre></div>

<h4 id="利用拦截器的解决方案"><a href="#利用拦截器的解决方案" class="headerlink" title="利用拦截器的解决方案"></a><strong>利用拦截器的解决方案</strong></h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdempotentInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    TokenService tokenService;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//不是直接放行</span>
        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        &#125;

        Method method = ((HandlerMethod) handler).getMethod();
        AutoIdempotent idempotent = method.getAnnotation(AutoIdempotent.class);
        <span class="hljs-comment">//自定义的注解不为空，说明加了注解，要进行幂等性处理</span>
        <span class="hljs-keyword">if</span> (idempotent != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">return</span> tokenService.checkToken(request);
            &#125; <span class="hljs-keyword">catch</span> (IdempotentException e) &#123;
                <span class="hljs-keyword">throw</span> e;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre></div>

<p>配置类</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    IdempotentInterceptor idempotentInterceptor;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;
        registry.addInterceptor(idempotentInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    TokenService tokenService;

    <span class="hljs-meta">@GetMapping(&quot;/gettoken&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getToken</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> tokenService.createToken();
    &#125;

    <span class="hljs-meta">@PostMapping(&quot;/hello&quot;)</span>
    <span class="hljs-meta">@AutoIdempotent</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
    &#125;

    <span class="hljs-meta">@PostMapping(&quot;/hello2&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello2&quot;</span>;
    &#125;
&#125;</code></pre></div>

<h4 id="利用AOP的解决方案"><a href="#利用AOP的解决方案" class="headerlink" title="利用AOP的解决方案"></a>利用AOP的解决方案</h4><p>因为要使用AOP，把IdempotentInterceptor上的@Component注解掉，让其失效，同时让WebMvcConfig也失效，然后创建即可</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Aspect</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdempotentAspect</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    TokenService tokenService;

    <span class="hljs-comment">//加了自定义注解的</span>
    <span class="hljs-meta">@Pointcut(&quot;@annotation(org.javaboy.idempontent.anno.AutoIdempotent)&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc1</span><span class="hljs-params">()</span> </span>&#123;

    &#125;
    <span class="hljs-comment">//前置通知</span>
    <span class="hljs-meta">@Before(&quot;pc1()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IdempotentException </span>&#123;
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        <span class="hljs-keyword">try</span> &#123;
            tokenService.checkToken(request);
        &#125; <span class="hljs-keyword">catch</span> (IdempotentException e) &#123;
            <span class="hljs-keyword">throw</span> e;
        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="2-session共享"><a href="#2-session共享" class="headerlink" title="2. session共享"></a>2. session共享</h2><p>在传统的单服务架构中，一般来说，只有一个服务器，那么不存在 Session 共享问题，但是在分布式/集群项目中，Session 共享则是一个必须面对的问题，先看一个简单的架构图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-1-20210525152434632.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在这样的架构中，会出现一些单服务中不存在的问题，例如客户端发起一个请求，这个请求到达 Nginx 上之后，被 Nginx 转发到 Tomcat A 上，然后在 Tomcat A 上往 session 中保存了一份数据，下次又来一个请求，这个请求被转发到 Tomcat B 上，此时再去 Session 中获取数据，发现没有之前的数据。对于这一类问题的解决，思路很简单，就是将各个服务之间需要共享的数据，保存到一个公共的地方（主流方案就是 Redis）：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-2-20210525152434653.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>当所有 Tomcat 需要往 Session 中写数据时，都往 Redis 中写，当所有 Tomcat 需要读数据时，都从 Redis 中读。这样，不同的服务就可以使用相同的 Session 数据了。</p>
<p>这样的方案，可以由开发者手动实现，即手动往 Redis 中存储数据，手动从 Redis 中读取数据，相当于使用一些 Redis 客户端工具来实现这样的功能，毫无疑问，手动实现工作量还是蛮大的。</p>
<p>一个简化的方案就是使用 Spring Session 来实现这一功能，Spring Session 就是使用 Spring 中的代理过滤器，将所有的 Session 操作拦截下来，自动的将数据 同步到 Redis 中，或者自动的从 Redis 中读取数据。</p>
<p>对于开发者来说，所有关于 Session 同步的操作都是透明的，开发者使用 Spring Session，一旦配置完成后，具体的用法就像使用一个普通的 Session 一样。</p>
<h3 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1 创建工程"></a>2.1 创建工程</h3><p>首先 创建一个 Spring Boot 工程，引入 Web、Spring Session 以及 Redis:</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-3-20210525152434702.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>创建成功之后，pom.xml 文件如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<p><strong>注意：</strong></p>
<p>这里我使用的 Spring Boot 版本是 2.1.4 ，如果使用当前最新版 Spring Boot2.1.5 的话，除了上面这些依赖之外，需要额外添加 Spring Security 依赖（其他操作不受影响，仅仅只是多了一个依赖，当然也多了 Spring Security 的一些默认认证流程）。</p>
<h3 id="2-2-配置-Redis"><a href="#2-2-配置-Redis" class="headerlink" title="2.2 配置 Redis"></a>2.2 配置 Redis</h3><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.66.128</span>
<span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span>
<span class="hljs-comment">#spring.redis.password=123</span>
<span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span></code></pre></div>

<p>这里的 Redis ，我虽然配置了四行，但是考虑到端口默认就是 6379 ，database 默认就是 0，所以真正要配置的，其实就是两行。</p>
<h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><p>配置完成后 ，就可以使用 Spring Session 了，其实就是使用普通的 HttpSession ，其他的 Session 同步到 Redis 等操作，框架已经自动帮你完成了：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
    Integer port;
    <span class="hljs-meta">@GetMapping(&quot;/set&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;
        session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);
        <span class="hljs-keyword">return</span> String.valueOf(port);
    &#125;
    <span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;
        <span class="hljs-keyword">return</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>) + <span class="hljs-string">&quot;:&quot;</span> + port;
    &#125;
&#125;</code></pre></div>

<p>考虑到一会 Spring Boot 将以集群的方式启动 ，为了获取每一个请求到底是哪一个 Spring Boot 提供的服务，需要在每次请求时返回当前服务的端口号，因此这里我注入了 server.port </p>
<p>接下来 ，项目打包：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-4-20210525152434653.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>打包之后，启动项目的两个实例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs shell">java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8080
java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8081</code></pre></div>

<p>然后先访问 <code>localhost:8080/set</code> 向 <code>8080</code> 这个服务的 <code>Session</code> 中保存一个变量，访问完成后，数据就已经自动同步到 <code>Redis</code> 中 了 ：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-5-20210525152434610.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>然后，再调用 <code>localhost:8081/get</code> 接口，就可以获取到 <code>8080</code> 服务的 <code>session</code> 中的数据：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-6-20210525152434632.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>此时关于 session 共享的配置就已经全部完成了，session 共享的效果我们已经看到了，但是每次访问都是我自己手动切换服务实例，因此，接下来我们来引入 Nginx ，实现服务实例自动切换。</p>
<h3 id="2-4-引入-Nginx"><a href="#2-4-引入-Nginx" class="headerlink" title="2.4 引入 Nginx"></a>2.4 引入 Nginx</h3><p>很简单，进入 Nginx 的安装目录的 conf 目录下（默认是在 <code>/usr/local/nginx/conf</code>），编辑 nginx.conf 文件:</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-7-20210525152434641.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在这段配置中：</p>
<ul>
<li>upstream 表示配置上游服务器</li>
<li>javaboy.org 表示服务器集群的名字，这个可以随意取名字</li>
<li>upstream 里边配置的是一个个的单独服务</li>
<li>weight 表示服务的权重，意味者将有多少比例的请求从 Nginx 上转发到该服务上</li>
<li>location 中的 proxy_pass 表示请求转发的地址，<code>/</code> 表示拦截到所有的请求，转发转发到刚刚配置好的服务集群中</li>
<li>proxy_redirect 表示设置当发生重定向请求时，nginx 自动修正响应头数据（默认是 Tomcat 返回重定向，此时重定向的地址是 Tomcat 的地址，我们需要将之修改使之成为 Nginx 的地址）</li>
</ul>
<p>配置完成后，将本地的 Spring Boot 打包好的 jar 上传到 Linux ，然后在 Linux 上分别启动两个 Spring Boot 实例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs shell">nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8080 &amp;
nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8081 &amp;</code></pre></div>

<p>其中</p>
<ul>
<li>nohup 表示当终端关闭时，Spring Boot 不要停止运行</li>
<li>&amp; 表示让 Spring Boot 在后台启动</li>
</ul>
<p>配置完成后，重启 Nginx：</p>
<div class="hljs code-wrapper"><pre><code class="hljs shell">/usr/local/nginx/sbin/nginx -s reload</code></pre></div>

<p>Nginx 启动成功后，我们首先手动清除 Redis 上的数据，然后访问 <code>192.168.66.128/set</code> 表示向 <code>session</code> 中保存数据，这个请求首先会到达 <code>Nginx</code> 上，再由 <code>Nginx</code> 转发给某一个 <code>Spring Boot</code> 实例：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-8-20210525152434681.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如上，表示端口为 <code>8081</code> 的 <code>Spring Boot</code> 处理了这个 <code>/set</code> 请求，再访问 <code>/get</code> 请求：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/14-9-20210525152434677.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>可以看到，<code>/get</code> 请求是被端口为 8080 的服务所处理的。</p>
<h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p>本文主要向大家介绍了 Spring Session 的使用，另外也涉及到一些 Nginx 的使用 ，虽然本文较长，但是实际上 Spring Session 的配置没啥。</p>
<p>我们写了一些代码，也做了一些配置，但是全都和 Spring Session 无关，配置是配置 Redis，代码就是普通的 HttpSession，和 Spring Session 没有任何关系！</p>
<p>唯一和 Spring Session 相关的，可能就是我在一开始引入了 Spring Session 的依赖吧！</p>
<p>如果大家没有在 SSM 架构中用过 Spring Session ，可能不太好理解我们在 Spring Boot 中使用 Spring Session 有多么方便，因为在 SSM 架构中，Spring Session 的使用要配置三个地方 ，一个是 web.xml 配置代理过滤器，然后在 Spring 容器中配置 Redis，最后再配置 Spring Session，步骤还是有些繁琐的，而 Spring Boot 中直接帮我们省去了这些繁琐的步骤！不用再去配置 Spring Session。</p>
<h1 id="第六章、SpringBoot构建RESTful"><a href="#第六章、SpringBoot构建RESTful" class="headerlink" title="第六章、SpringBoot构建RESTful"></a>第六章、SpringBoot构建RESTful</h1><p>RESTful ，到现在相信已经没人不知道这个东西了吧！关于 RESTful 的概念，我这里就不做过多介绍了，传统的 Struts 对 RESTful 支持不够友好 ，但是 SpringMVC 对于 RESTful 提供了很好的支持，常见的相关注解有：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@GetMapping</span>
<span class="hljs-meta">@PutMapping</span>
<span class="hljs-meta">@PostMapping</span>
<span class="hljs-meta">@DeleteMapping</span>
<span class="hljs-meta">@ResponseBody</span>
...</code></pre></div>

<p>这些注解都是和 RESTful 相关的，在移动互联网中，RESTful 得到了非常广泛的使用。RESTful 这个概念提出来很早，但是以前没有移动互联网时，我们做的大部分应用都是前后端不分的，在这种架构的应用中，数据基本上都是在后端渲染好返回给前端展示的，此时 RESTful 在 Web 应用中基本就没用武之地，移动互联网的兴起，让我们一套后台对应多个前端项目，因此前后端分离，RESTful 顺利走上前台。</p>
<p>Spring Boot 继承自 Spring + SpringMVC， SpringMVC 中对于 RESTful 支持的特性在 Spring Boot 中全盘接收，同时，结合 Jpa 和 自动化配置，对于 RESTful 还提供了更多的支持，使得开发者几乎不需要写代码（很少几行），就能快速实现一个 RESTful 风格的增删改查</p>
<h2 id="1-Spring-Data-JPA构建"><a href="#1-Spring-Data-JPA构建" class="headerlink" title="1. Spring Data JPA构建"></a>1. Spring Data JPA构建</h2><h3 id="1-1-创建工程-1"><a href="#1-1-创建工程-1" class="headerlink" title="1.1 创建工程"></a>1.1 创建工程</h3><p>首先创建一个 Spring Boot 工程，引入 <code>Web</code> 、 <code>Jpa</code> 、 <code>MySQL</code> 、<code>Rest Repositories</code> 依赖：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-1-20210525152434677.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>创建完成后，还需要锁定 MySQL 驱动的版本以及加入 Druid 数据库连接池，完整依赖如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-rest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<h3 id="1-2-配置数据库"><a href="#1-2-配置数据库" class="headerlink" title="1.2 配置数据库"></a>1.2 配置数据库</h3><p>主要配置两个，一个是数据库，另一个是 Jpa：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>
<span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///test01</span>
<span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span>
<span class="hljs-meta">spring.jpa.properties.hibernate.dialect</span>=<span class="hljs-string">org.hibernate.dialect.MySQL57Dialect</span>
<span class="hljs-meta">spring.jpa.show-sql</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">spring.jpa.hibernate.ddl-auto</span>=<span class="hljs-string">update</span>
<span class="hljs-meta">spring.jpa.database-platform</span>=<span class="hljs-string">mysql</span>
<span class="hljs-meta">spring.jpa.database</span>=<span class="hljs-string">mysql</span></code></pre></div>

<p>这里的配置，和 Jpa 中的基本一致。</p>
<p>前面五行配置了数据库的基本信息，包括数据库连接池、数据库用户名、数据库密码、数据库连接地址以及数据库驱动名称。</p>
<p>接下来的五行配置了 JPA 的基本信息，分别表示生成 SQL 的方言、打印出生成的 SQL 、每次启动项目时根据实际情况选择是否更新表、数据库平台是 MySQL。</p>
<h3 id="1-3-构建实体类"><a href="#1-3-构建实体类" class="headerlink" title="1.3 构建实体类"></a>1.3 构建实体类</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Entity(name = &quot;t_book&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-meta">@Column(name = &quot;book_name&quot;)</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String author;
    <span class="hljs-comment">//省略 getter/setter</span>
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;
&#125;</code></pre></div>

<p>这里一个是配置了一个实体类 Book，另一个则是配置了一个 BookRepository ，项目启动成功后，框架会根据 Book 类的定义，在数据库中自动创建相应的表，BookRepository 接口则是继承自 JpaRepository ，JpaRepository 中自带了一些基本的增删改查方法。</p>
<p>一个 RESTful 风格的增删改查应用就有了，这就是 Spring Boot 的魅力</p>
<h3 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h3><p>此时，我们就可以启动项目进行测试了，使用 <code>POSTMAN </code>来测试（大家也可以自行选择趁手的 HTTP 请求工具）</p>
<p>此时我们的项目已经默认具备了一些接口，我们分别来看：</p>
<h4 id="根据-id-查询接口"><a href="#根据-id-查询接口" class="headerlink" title="根据 id 查询接口"></a>根据 id 查询接口</h4><ul>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/books/%7Bid%7D">http://127.0.0.1:8080/books/{id}</a></li>
</ul>
<p>这个接口表示根据 id 查询某一本书：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-2-20210525152434684.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/books">http://127.0.0.1:8080/books</a></li>
</ul>
<p>这是一个批量查询接口，默认请求路径是类名首字母小写，并且再加一个 s 后缀。这个接口实际上是一个分页查询接口，没有传参数，表示查询第一页，每页 20 条数据。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-3-20210525152434693.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>查询结果中，除了该有的数据之外，也包含了分页数据：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-4-20210525152434757.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>分页数据中：</p>
<ol>
<li>size 表示每页查询记录数</li>
<li>totalElements 表示总记录数</li>
<li>totalPages 表示总页数</li>
<li>number 表示当前页数，从0开始计</li>
</ol>
<p>如果要分页或者排序查询，可以使用 _links 中的链接。<code>http://127.0.0.1:8080/books?page=1&amp;size=3&amp;sort=id,desc</code> </p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-5-20210525152434720.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>也可以添加数据，添加是 POST 请求，数据通过 JSON 的形式传递，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-6-20210525152434720.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>添加成功之后，默认会返回添加成功的数据。</p>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>修改接口默认也是存在的，数据修改请求是一个 PUT 请求，修改的参数也是通过 JSON 的形式传递：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-7-20210525152434752.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>默认情况下，修改成功后，会返回修改成功的数据。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>当然也可以通过 DELETE 请求根据 id 删除数据：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-8-20210525152434730.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>删除成功后，是没有返回值的。</p>
<p>不需要几行代码，一个基本的增删改查就有了。</p>
<p>这些都是默认的配置，这些默认的配置实际上都是在 JpaRepository 的基础上实现的，实际项目中，我们还可以对这些功能进行定制。</p>
<h3 id="1-5-查询定制"><a href="#1-5-查询定制" class="headerlink" title="1.5 查询定制"></a>1.5 查询定制</h3><p>最广泛的定制，就是查询，因为增删改操作的变化不像查询这么丰富。对于查询的定制，非常容易，只需要提供相关的方法即可。例如根据作者查询书籍：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;
    <span class="hljs-function">List&lt;Book&gt; <span class="hljs-title">findBookByAuthorContaining</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;author&quot;)</span> String author)</span></span>;
&#125;</code></pre></div>

<p>注意，方法的定义，参数要有 @Param 注解。</p>
<p>定制完成后，重启项目，此时就多了一个查询接口，开发者可以通过 <a target="_blank" rel="noopener" href="http://localhost:8080/books/search">http://localhost:8080/books/search</a> 来查看和 book 相关的自定义接口都有哪些：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-9-20210525152434766.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>查询结果表示，只有一个自定义接口，接口名就是方法名，而且查询结果还给出了接口调用的示例。我们来尝试调用一下自己定义的查询接口：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-10-20210525152434772.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>开发者可以根据实际情况，在 BookRepository 中定义任意多个查询方法，查询方法的定义规则和 Jpa 中一模一样，但是，这样有一个缺陷，就是 Jpa 中方法名太长，因此，如果不想使用方法名作为接口名，则可以自定义接口名</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;
    <span class="hljs-meta">@RestResource(rel = &quot;byauthor&quot;,path = &quot;byauthor&quot;)</span>
    <span class="hljs-function">List&lt;Book&gt; <span class="hljs-title">findBookByAuthorContaining</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;author&quot;)</span> String author)</span></span>;
&#125;</code></pre></div>

<p>@RestResource 注解中，两个参数的含义：</p>
<ul>
<li>rel 表示接口查询中，这个方法的 key</li>
<li>path 表示请求路径</li>
</ul>
<p>这样定义完成后，表示接口名为 byauthor ，重启项目，继续查询接口：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-11-20210525152434803.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>除了 <code>rel</code> 和 <code>path</code> 两个属性之外，<code>@RestResource</code> 中还有一个属性，<code>exported</code> 表示是否暴露接口，默认为 <code>true</code>，表示暴露接口，即方法可以在前端调用，如果仅仅只是想定义一个方法，不需要在前端调用这个方法，可以设置 <code>exported</code> 属性为 <code>false</code> 。</p>
<p>如果不想暴露官方定义好的方法，例如根据 <code>id</code> 删除数据，只需要在自定义接口中重写该方法，然后在该方法上加 <code>@RestResource</code> 注解并且配置相关属性即可。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;
    <span class="hljs-meta">@RestResource(rel = &quot;byauthor&quot;,path = &quot;byauthor&quot;)</span>
    <span class="hljs-function">List&lt;Book&gt; <span class="hljs-title">findBookByAuthorContaining</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;author&quot;)</span> String author)</span></span>;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@RestResource(exported = false)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Long aLong)</span></span>;
&#125;</code></pre></div>

<p>另外生成的 JSON 字符串中的集合名和单个 <code>item</code> 的名字都是可以自定义的：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RepositoryRestResource(collectionResourceRel = &quot;bs&quot;,itemResourceRel = &quot;b&quot;,path = &quot;bs&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Book</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;
    <span class="hljs-meta">@RestResource(rel = &quot;byauthor&quot;,path = &quot;byauthor&quot;)</span>
    <span class="hljs-function">List&lt;Book&gt; <span class="hljs-title">findBookByAuthorContaining</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;author&quot;)</span> String author)</span></span>;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@RestResource(exported = false)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Long aLong)</span></span>;
&#125;</code></pre></div>

<p><code>path</code> 属性表示请求路径，请求路径默认是类名首字母小写+s，可以在这里自己重新定义。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16-12-20210525152434760.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="1-6-其他配置"><a href="#1-6-其他配置" class="headerlink" title="1.6 其他配置"></a>1.6 其他配置</h3><p>最后，也可以在 application.properties 中配置 REST 基本参数：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.data.rest.base-path</span>=<span class="hljs-string">/api</span>
<span class="hljs-meta">spring.data.rest.sort-param-name</span>=<span class="hljs-string">sort</span>
<span class="hljs-meta">spring.data.rest.page-param-name</span>=<span class="hljs-string">page</span>
<span class="hljs-meta">spring.data.rest.limit-param-name</span>=<span class="hljs-string">size</span>
<span class="hljs-meta">spring.data.rest.max-page-size</span>=<span class="hljs-string">20</span>
<span class="hljs-meta">spring.data.rest.default-page-size</span>=<span class="hljs-string">0</span>
<span class="hljs-meta">spring.data.rest.return-body-on-update</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">spring.data.rest.return-body-on-create</span>=<span class="hljs-string">true</span></code></pre></div>

<p>配置含义，从上往下，依次是：</p>
<ul>
<li>给所有的接口添加统一的前缀</li>
<li>配置排序参数的 key ，默认是 sort</li>
<li>配置分页查询时页码的 key，默认是 page</li>
<li>配置分页查询时每页查询页数的 key，默认是size</li>
<li>配置每页最大查询记录数，默认是 20 条</li>
<li>分页查询时默认的页码</li>
<li>更新成功时是否返回更新记录</li>
<li>添加成功时是否返回添加记录</li>
</ul>
<h1 id="第七章、SpringBoot开发者工具"><a href="#第七章、SpringBoot开发者工具" class="headerlink" title="第七章、SpringBoot开发者工具"></a>第七章、SpringBoot开发者工具</h1><h2 id="1-Devtools"><a href="#1-Devtools" class="headerlink" title="1. Devtools"></a>1. Devtools</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524151205975.png" srcset="/img/loading.gif" lazyload alt="image-20210524151205975"></p>
<p>Spring Boot 中的热部署相信大家都用过吧，只需要添加 <code>spring-boot-devtools</code> 依赖就可以轻松实现热部署。Spring Boot 中热部署最最关键的原理就是两个不同的 classloader：</p>
<ul>
<li>base classloader</li>
<li>restart classloader</li>
</ul>
<p>其中 base classloader 用来加载那些不会变化的类，例如各种第三方依赖，而 restart classloader 则用来加载那些会发生变化的类，例如你自己写的代码。Spring Boot 中热部署的原理就是当代码发生变化时，base classloader 不变，而 restart classloader 则会被废弃，被另一个新的 restart classloader 代替。在整个过程中，因为只重新加载了变化的类，所以启动速度要被重启快</p>
<p><strong>引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>在IDEA中开启</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524154546455.png" srcset="/img/loading.gif" lazyload alt="image-20210524154546455"></p>
<p>找到</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524154656023.png" srcset="/img/loading.gif" lazyload alt="image-20210524154656023"></p>
<p>在<code>Registry</code>中</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524154820641.png" srcset="/img/loading.gif" lazyload alt="image-20210524154820641"></p>
<p>即可开启自动重启</p>
<p><strong>配置文件</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#关闭自动重启</span>
<span class="hljs-meta">spring.devtools.restart.enabled</span>=<span class="hljs-string">false</span>
<span class="hljs-comment">#触发重启的文件，放置在resources目录下</span>
<span class="hljs-meta">spring.devtools.restart.trigger-file</span>=<span class="hljs-string">.reloadtrigger</span></code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524153804327.png" srcset="/img/loading.gif" lazyload alt="image-20210524153804327"></p>
<p>添加后这个文件下，每次去修改<code>.reloadtrigger</code>文件然后去刷新才会重启，这里的重启还是不全部重启的刷新</p>
<p>如果有个多模块的项目，在当前目录下创建<code>spring-boot-devtools.properties</code>文件</p>
<p>这里面的配置都让所有使用Devtools模块的项目都生效</p>
<p>但是有另外一个问题，就是静态资源文件！使用 devtools ，默认情况下当静态资源发生变化时，并不会触发项目重启。虽然我们可以通过配置解决这一问题，但是没有必要！因为静态资源文件发生变化后不需要编译，按理说保存后刷新下就可以访问到了，所以静态资源不会被Devtools监视到，静态资源不需要重启也能直接同步到target目录下</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210524151746545.png" srcset="/img/loading.gif" lazyload alt="image-20210524151746545"></p>
<h3 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h3><p>devtools 中默认嵌入了 LiveReload 服务器，利用 LiveReload 可以实现静态文件的热部署，LiveReload 可以在资源发生变化时自动触发浏览器更新，LiveReload 支持 Chrome、Firefox 以及 Safari 。以 Chrome 为例，在 Chrome 应用商店搜索 LiveReload ，结果如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/27-1-20210525152240919.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>将第一个搜索结果添加到 Chrome 中，添加成功后，在 Chrome 右上角有一个 LiveReload 图标</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/27-2-20210525152240870.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在浏览器中打开项目的页面，然后点击浏览器右上角的 LiveReload 按钮，打开 LiveReload 连接。</p>
<p><strong>注意：</strong></p>
<p>LiveReload 是和浏览器选项卡绑定在一起的，在哪个选项卡中打开了 LiveReload，就在哪个选项卡中访问页面，这样才有效果</p>
<p>此时随便在 resources/static 目录下添加一个静态 html 页面，然后启动 Spring Boot 项目，在<strong>打开了 LiveReload 的选项卡中访问 html 页面</strong>。</p>
<p>访问成功后，我们再去手动修改 html 页面代码，修改成功后，回到浏览器，不用做任何操作，就会发现浏览器自动刷新了，页面已经更新了。</p>
<p>整个过程中，我的 Spring Boot 项目并没有重启。</p>
<p>如果开发者安装并且启动了 LiveReload 插件，同时也添加了 devtools 依赖，但是却并不想当静态页面发生变化时浏览器自动刷新，那么可以在 application.properties 中添加如下代码进行配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.devtools.livereload.enabled</span>=<span class="hljs-string">false</span></code></pre></div>

<p>建议开发者使用 LiveReload 策略而不是项目重启策略来实现静态资源的动态加载，因为项目重启所耗费时间一般来说要超过使用LiveReload 所耗费的时间</p>
<h2 id="2-Mock单元测试"><a href="#2-Mock单元测试" class="headerlink" title="2. Mock单元测试"></a>2. Mock单元测试</h2><p>针对Controller的接口简单测试，这里不使用Postman，使用Java代码来完成</p>
<p><strong>实体类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String username;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> username;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.username = username;
    &#125;
&#125;</code></pre></div>

<p><strong>Controller</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setId(id);
        user.setUsername(<span class="hljs-string">&quot;javaboy&quot;</span>);
        <span class="hljs-keyword">return</span> user;
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * webEnvironment：指定 web 应用环境：</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * - MOCK</span>
<span class="hljs-comment"> * - RANDOM_PORT (对事务不回滚)</span>
<span class="hljs-comment"> * - DEFINED_PORT (对事务不回滚)</span>
<span class="hljs-comment"> * - NONE</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * classes：指定应用启动类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@SpringBootTest()</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestApplicationTests</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    WebApplicationContext webApplicationContext;
    MockMvc mockMvc;
    <span class="hljs-meta">@BeforeEach</span> <span class="hljs-comment">//相当于Before</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>&#123;
        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
   <span class="hljs-comment">//或者，但不推荐  mockMvc = MockMvcBuilders.standaloneSetup(new UserController()).build();</span>
    &#125;
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//GET请求</span>
  			mockMvc
  .perform(MockMvcRequestBuilders.get(<span class="hljs-string">&quot;/user/99&quot;</span>).accept(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content().string(<span class="hljs-string">&quot;&#123;\&quot;id\&quot;:99,\&quot;username\&quot;:\&quot;javaboy\&quot;&#125;&quot;</span>))
                .andDo(MockMvcResultHandlers.print());
    &#125;
    
&#125;</code></pre></div>

<p><strong>对Service的测试</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    UserDao userDao;

    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;
        <span class="hljs-keyword">return</span> userDao.getUserById(id);
    &#125;
&#125;</code></pre></div>

<p><strong>DAO</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setId(id);
        user.setUsername(<span class="hljs-string">&quot;111&quot;</span>);
        <span class="hljs-keyword">return</span> user;
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest()</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestApplicationTests</span> </span>&#123;    
<span class="hljs-comment">//不涉及数据库的注入，如果用AutoWired会改变数据库</span>
    <span class="hljs-meta">@MockBean</span>
    UserDao userDao;
    <span class="hljs-meta">@Autowired</span>
    UserService userService;
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;
      	<span class="hljs-comment">//仅供测试的数据</span>
        User user = <span class="hljs-keyword">new</span> User();
        user.setId(<span class="hljs-number">99L</span>);
        user.setUsername(<span class="hljs-string">&quot;javaboy&quot;</span>);
        Mockito.when(userDao.getUserById(<span class="hljs-number">99L</span>)).thenReturn(user);

        User u = userService.getUserById(<span class="hljs-number">99L</span>);
        Assertions.assertEquals(<span class="hljs-number">99L</span>,u.getId());
        Assertions.assertEquals(<span class="hljs-string">&quot;javaboy&quot;</span>, u.getUsername());
    &#125;
&#125;</code></pre></div>

<h1 id="第八章、SpringBoot整合缓存"><a href="#第八章、SpringBoot整合缓存" class="headerlink" title="第八章、SpringBoot整合缓存"></a>第八章、SpringBoot整合缓存</h1><h2 id="1-Spring-Cache-Redis"><a href="#1-Spring-Cache-Redis" class="headerlink" title="1. Spring Cache + Redis"></a>1. Spring Cache + Redis</h2><p>经过Spring Boot的整合封装与自动化配置，在Spring Boot中整合Redis已经变得非常容易了，开发者只需要引入Spring Data Redis依赖，然后简单配下redis的基本信息，系统就会提供一个RedisTemplate供开发者使用。Spring3.1中开始引入了令人激动的Cache，在Spring Boot中，可以非常方便的使用Redis来作为Cache的实现，进而实现数据的缓存。</p>
<h3 id="1-1-工程创建"><a href="#1-1-工程创建" class="headerlink" title="1.1 工程创建"></a>1.1 工程创建</h3><p>首先创建一个Spring Boot工程，注意创建的时候需要引入三个依赖，web、cache以及redis，如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13-1-20210525152240902.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>对应的依赖内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h3 id="1-2-基本配置"><a href="#1-2-基本配置" class="headerlink" title="1.2 基本配置"></a>1.2 基本配置</h3><p>工程创建好之后，首先需要简单配置一下Redis，Redis的基本信息，另外，这里要用到Cache，因此还需要稍微配置一下Cache，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6380</span>
<span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.66.128</span>

<span class="hljs-meta">spring.cache.cache-names</span>=<span class="hljs-string">c1</span></code></pre></div>

<p>简单起见，这里我只是配置了Redis的端口和地址，然后给缓存取了一个名字，这个名字在后文会用到。</p>
<p>另外，还需要在配置类上添加如下代码，表示开启缓存：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableCaching</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RediscacheApplication</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(RediscacheApplication.class, args);
    &#125;

&#125;</code></pre></div>

<p>完成了这些配置之后，Spring Boot就会自动帮我们在后台配置一个RedisCacheManager，相关的配置是在org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration类中完成的。部分源码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ConditionalOnClass(RedisConnectionFactory.class)</span>
<span class="hljs-meta">@AutoConfigureAfter(RedisAutoConfiguration.class)</span>
<span class="hljs-meta">@ConditionalOnBean(RedisConnectionFactory.class)</span>
<span class="hljs-meta">@ConditionalOnMissingBean(CacheManager.class)</span>
<span class="hljs-meta">@Conditional(CacheCondition.class)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCacheConfiguration</span> </span>&#123;

	<span class="hljs-meta">@Bean</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> RedisCacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory,</span></span>
<span class="hljs-function"><span class="hljs-params">			ResourceLoader resourceLoader)</span> </span>&#123;
		RedisCacheManagerBuilder builder = RedisCacheManager
				.builder(redisConnectionFactory)
				.cacheDefaults(determineConfiguration(resourceLoader.getClassLoader()));
		List&lt;String&gt; cacheNames = <span class="hljs-keyword">this</span>.cacheProperties.getCacheNames();
		<span class="hljs-keyword">if</span> (!cacheNames.isEmpty()) &#123;
			builder.initialCacheNames(<span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(cacheNames));
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.customizerInvoker.customize(builder.build());
	&#125;
&#125;</code></pre></div>

<p>看类上的注解，发现在万事俱备的情况下，系统会自动提供一个RedisCacheManager的Bean，这个RedisCacheManager间接实现了Spring中的Cache接口，有了这个Bean，我们就可以直接使用Spring中的缓存注解和接口了，而缓存数据则会被自动存储到Redis上。在单机的Redis中，这个Bean系统会自动提供，如果是Redis集群，这个Bean需要开发者来提供。</p>
<h3 id="1-3-缓存使用"><a href="#1-3-缓存使用" class="headerlink" title="1.3 缓存使用"></a>1.3 缓存使用</h3><p>这里主要向小伙伴们介绍缓存中几个核心的注解使用。</p>
<h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><p>这个注解在类上使用，用来描述该类中所有方法使用的缓存名称，当然也可以不使用该注解，直接在具体的缓存注解上配置名称，示例代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@CacheConfig(cacheNames = &quot;c1&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;
&#125;</code></pre></div>

<h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>这个注解一般加在查询方法上，表示将一个方法的返回值缓存起来，默认情况下，缓存的key就是方法的参数，缓存的value就是方法的返回值。示例代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(key = &quot;#id&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Integer id,String username)</span> </span>&#123;
    System.out.println(<span class="hljs-string">&quot;getUserById&quot;</span>);
    <span class="hljs-keyword">return</span> getUserFromDBById(id);
&#125;</code></pre></div>

<p>当有多个参数时，默认就使用多个参数来做key，如果只需要其中某一个参数做key，则可以在@Cacheable注解中，通过key属性来指定key，如上代码就表示只使用id作为缓存的key，如果对key有复杂的要求，可以自定义keyGenerator。当然，Spring Cache中提供了root对象，即<code>#root.</code>可以在不定义keyGenerator的情况下实现一些复杂的效果：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13-2-20210524162051323-20210525152240881.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>也可以自定义缓存的格式</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyKeyGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">KeyGenerator</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">generate</span><span class="hljs-params">(Object target, Method method, Object... params)</span> </span>&#123;
        String s = target.toString() + <span class="hljs-string">&quot;:&quot;</span> + method.getName() + <span class="hljs-string">&quot;:&quot;</span> + Arrays.toString(params);
        <span class="hljs-keyword">return</span> s;
    &#125;
&#125;

<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@CacheConfig(cacheNames = &quot;c1&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123; 
<span class="hljs-meta">@Cacheable(keyGenerator = &quot;myKeyGenerator&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById2</span><span class="hljs-params">(Long id,String username)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;getUserById2:&quot;</span> + id);
        User user = <span class="hljs-keyword">new</span> User();
        user.setId(id);
        user.setUsername(username);
        <span class="hljs-keyword">return</span> user;
    &#125;
  
&#125;</code></pre></div>

<h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>这个注解一般加在更新方法上，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的key上，示例代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//如果缓存不存在，则进行缓存，否则进行更新</span>
<span class="hljs-meta">@CachePut(key = &quot;#user.id&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">updateUserById</span><span class="hljs-params">(User user)</span> </span>&#123;
    <span class="hljs-keyword">return</span> user;
&#125;</code></pre></div>

<h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>这个注解一般加在删除方法上，当数据库中的数据删除后，相关的缓存数据也要自动清除，该注解在使用的时候也可以配置按照某种条件删除（condition属性）或者或者配置清除所有缓存（allEntries属性），示例代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict()</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span> </span>&#123;
    <span class="hljs-comment">//在这里执行删除操作， 删除是去数据库中删除</span>
&#125;</code></pre></div>

<h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>在Spring Boot中，使用Redis缓存，既可以使用RedisTemplate自己来实现，也可以使用使用这种方式，这种方式是Spring Cache提供的统一接口，实现既可以是Redis，也可以是Ehcache或者其他支持这种规范的缓存框架。从这个角度来说，Spring Cache和Redis、Ehcache的关系就像JDBC与各种数据库驱动的关系。</p>
<h2 id="2-Spring-Cache-Ehcache"><a href="#2-Spring-Cache-Ehcache" class="headerlink" title="2. Spring Cache + Ehcache"></a>2. Spring Cache + Ehcache</h2><p>用惯了 Redis ，很多人已经忘记了还有另一个缓存方案 Ehcache ，是的，在 Redis 一统江湖的时代，Ehcache 渐渐有点没落了，不过，我们还是有必要了解下 Ehcache ，在有的场景下，我们还是会用到 Ehcache。</p>
<p>Ehcache 也是 Java 领域比较优秀的缓存方案之一，Ehcache 这个缓存的名字很有意思，正着念反着念，都是 Ehcache，Spring Boot 中对此也提供了很好的支持，这个支持主要是通过 Spring Cache 来实现的。</p>
<p>Spring Cache 可以整合 Redis，当然也可以整合 Ehcache，两种缓存方案的整合还是比较相似，主要是配置的差异，具体的用法是一模一样的，就类似于 JDBC 和 数据库驱动的关系一样。前面配置完成后，后面具体使用的 API 都是一样的。</p>
<p>和 Spring Cache + Redis 相比，Spring Cache + Ehcache 主要是配置有所差异，具体的用法是一模一样的。我们来看下使用步骤。</p>
<h3 id="2-1-项目创建"><a href="#2-1-项目创建" class="headerlink" title="2.1 项目创建"></a>2.1 项目创建</h3><p>首先，来创建一个 Spring Boot 项目，引入 Cache 依赖：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/17-1-20210525152240867.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>工程创建完成后，引入 Ehcache 的依赖，Ehcache 目前有两个版本：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/17-2-20210525152240892.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这里采用第二个，在 pom.xml 文件中，引入 Ehcache 依赖：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<h3 id="2-2-添加-Ehcache-配置"><a href="#2-2-添加-Ehcache-配置" class="headerlink" title="2.2 添加 Ehcache 配置"></a>2.2 添加 Ehcache 配置</h3><p>在 resources 目录下，添加 ehcache 的配置文件 ehcache.xml ，文件内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;java.io.tmpdir/shiro-spring-sample&quot;</span>/&gt;</span>
    &lt;defaultCache
            maxElementsInMemory=&quot;10000&quot;
            eternal=&quot;false&quot;
            timeToIdleSeconds=&quot;120&quot;
            timeToLiveSeconds=&quot;120&quot;
            overflowToDisk=&quot;false&quot;
            diskPersistent=&quot;false&quot;
            diskExpiryThreadIntervalSeconds=&quot;120&quot;
    /&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span></span>
<span class="hljs-tag">            <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;10000&quot;</span></span>
<span class="hljs-tag">            <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;true&quot;</span></span>
<span class="hljs-tag">            <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;true&quot;</span></span>
<span class="hljs-tag">            <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">&quot;true&quot;</span></span>
<span class="hljs-tag">            <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">&quot;600&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span></code></pre></div>

<p>配置含义：</p>
<ul>
<li>name:缓存名称。</li>
<li>maxElementsInMemory：缓存最大个数。</li>
<li>eternal:对象是否永久有效，一但设置了，timeout将不起作用。</li>
<li>timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</li>
<li>timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</li>
<li>overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。</li>
<li>diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</li>
<li>maxElementsOnDisk：硬盘最大缓存个数。</li>
<li>diskPersistent：是否缓存虚拟机重启期数据。</li>
<li>diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</li>
<li>memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</li>
<li>clearOnFlush：内存数量最大时是否清除。</li>
<li>diskStore 则表示临时缓存的硬盘目录。</li>
</ul>
<p><strong>注意</strong></p>
<p>默认情况下，这个文件名是固定的，必须叫 ehcache.xml ，如果一定要换一个名字，那么需要在 application.properties 中明确指定配置文件名，配置方式如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.cache.ehcache.config</span>=<span class="hljs-string">classpath:aaa.xml</span></code></pre></div>

<h3 id="2-3-开启缓存"><a href="#2-3-开启缓存" class="headerlink" title="2.3 开启缓存"></a>2.3 开启缓存</h3><p>开启缓存的方式，也和 Redis 中一样，如下添加 <code>@EnableCaching</code> 依赖即可：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableCaching</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EhcacheApplication</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(EhcacheApplication.class, args);
    &#125;
&#125;</code></pre></div>

<p>其实到这一步，Ehcache 就算配置完成了，接下来的用法，和Redis的就一样了</p>
<h3 id="2-4-使用缓存"><a href="#2-4-使用缓存" class="headerlink" title="2.4 使用缓存"></a>2.4 使用缓存</h3><p>这里主要向小伙伴们介绍缓存中几个核心的注解使用。</p>
<h4 id="CacheConfig-1"><a href="#CacheConfig-1" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><p>这个注解在类上使用，用来描述该类中所有方法使用的缓存名称，当然也可以不使用该注解，直接在具体的缓存注解上配置名称，示例代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@CacheConfig(cacheNames = &quot;user&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;
&#125;</code></pre></div>

<h4 id="Cacheable-1"><a href="#Cacheable-1" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>这个注解一般加在查询方法上，表示将一个方法的返回值缓存起来，默认情况下，缓存的 key 就是方法的参数，缓存的 value 就是方法的返回值。示例代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(key = &quot;#id&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Integer id,String username)</span> </span>&#123;
    System.out.println(<span class="hljs-string">&quot;getUserById&quot;</span>);
    <span class="hljs-keyword">return</span> getUserFromDBById(id);
&#125;</code></pre></div>

<p>当有多个参数时，默认就使用多个参数来做 key ，如果只需要其中某一个参数做 key ，则可以在 @Cacheable 注解中，通过 key 属性来指定 key ，如上代码就表示只使用 id 作为缓存的 key ，如果对 key 有复杂的要求，可以自定义 keyGenerator 。当然，Spring Cache 中提供了root对象，可以在不定义 keyGenerator 的情况下实现一些复杂的效果，root 对象有如下属性：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/13-2-20210524162503768-20210525152240961.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>也可以通过 keyGenerator 自定义 key ，方式如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyKeyGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">KeyGenerator</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">generate</span><span class="hljs-params">(Object target, Method method, Object... params)</span> </span>&#123;
        <span class="hljs-keyword">return</span> method.getName()+Arrays.toString(params);
    &#125;
&#125;</code></pre></div>

<p>然后在方法上使用该 keyGenerator ：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(keyGenerator = &quot;myKeyGenerator&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;
    User user = <span class="hljs-keyword">new</span> User();
    user.setId(id);
    user.setUsername(<span class="hljs-string">&quot;lisi&quot;</span>);
    System.out.println(user);
    <span class="hljs-keyword">return</span> user;
&#125;</code></pre></div>

<h4 id="CachePut-1"><a href="#CachePut-1" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>这个注解一般加在更新方法上，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的 key 上，示例代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CachePut(key = &quot;#user.id&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">updateUserById</span><span class="hljs-params">(User user)</span> </span>&#123;
    <span class="hljs-keyword">return</span> user;
&#125;</code></pre></div>

<h4 id="CacheEvict-1"><a href="#CacheEvict-1" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>这个注解一般加在删除方法上，当数据库中的数据删除后，相关的缓存数据也要自动清除，该注解在使用的时候也可以配置按照某种条件删除（ condition 属性）或者或者配置清除所有缓存（ allEntries 属性），示例代码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict()</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUserById</span><span class="hljs-params">(Integer id)</span> </span>&#123;
    <span class="hljs-comment">//在这里执行删除操作， 删除是去数据库中删除</span>
&#125;</code></pre></div>

<h1 id="第九章、SpringBoot安全管理"><a href="#第九章、SpringBoot安全管理" class="headerlink" title="第九章、SpringBoot安全管理"></a>第九章、SpringBoot安全管理</h1><h2 id="1-Spring-Security"><a href="#1-Spring-Security" class="headerlink" title="1. Spring Security"></a>1. Spring Security</h2><p>Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。</p>
<p>相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。</p>
<p>自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。</p>
<p>因此，一般来说，常见的安全管理技术栈的组合是这样的：</p>
<ul>
<li>SSM + Shiro</li>
<li>Spring Boot/Spring Cloud + Spring Security</li>
</ul>
<blockquote>
<p>注意，这只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的。</p>
</blockquote>
<h3 id="1-1-项目创建"><a href="#1-1-项目创建" class="headerlink" title="1.1 项目创建"></a>1.1 项目创建</h3><p>在 Spring Boot 中使用 Spring Security 非常容易，引入依赖即可：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/25-1-20210525152241244.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>pom.xml 中的 Spring Security 依赖：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>只要加入依赖，项目的所有接口都会被自动保护起来。</p>
<h3 id="1-2-初次体验"><a href="#1-2-初次体验" class="headerlink" title="1.2 初次体验"></a>1.2 初次体验</h3><p>我们创建一个 HelloController:</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>访问 <code>/hello</code> ，需要登录之后才能访问。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/25-2-20210525152240990.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>当用户从浏览器发送请求访问 <code>/hello</code> 接口时，服务端会返回 <code>302</code> 响应码，让客户端重定向到 <code>/login</code> 页面，用户在 <code>/login</code> 页面登录，登陆成功之后，就会自动跳转到 <code>/hello</code> 接口</p>
<p>另外，也可以使用 <code>POSTMAN</code> 来发送请求，使用 <code>POSTMAN</code> 发送请求时，可以将用户信息放在请求头中（这样可以避免重定向到登录页面）：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/25-3-20210525152241103.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>通过以上两种不同的登录方式，可以看出，Spring Security 支持两种不同的认证方式：</p>
<ul>
<li>可以通过 form 表单来认证</li>
<li>可以通过 HttpBasic 来认证</li>
</ul>
<h3 id="1-3-用户名配置"><a href="#1-3-用户名配置" class="headerlink" title="1.3 用户名配置"></a>1.3 用户名配置</h3><p>默认情况下，登录的用户名是 <code>user</code> ，密码则是项目启动时随机生成的字符串，可以从启动的控制台日志中看到默认密码：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/25-4-20210525152241074.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这个随机生成的密码，每次启动时都会变。对登录的用户名/密码进行配置，有三种不同的方式：</p>
<ul>
<li>在 application.properties 中进行配置</li>
<li>通过 Java 代码配置在内存中</li>
<li>通过 Java 从数据库中加载</li>
</ul>
<p>前两种比较简单，第三种代码量略大，本文就先来看看前两种，第三种后面再单独写文章介绍，也可以参考<a target="_blank" rel="noopener" href="http://springboot.javaboy.org/2019/0725/springboot-springsecurity">微人事项目</a></p>
<h4 id="配置文件配置用户名-密码"><a href="#配置文件配置用户名-密码" class="headerlink" title="配置文件配置用户名/密码"></a>配置文件配置用户名/密码</h4><p>可以直接在 application.properties 文件中配置用户的基本信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.security.user.name</span>=<span class="hljs-string">javaboy</span>
<span class="hljs-meta">spring.security.user.password</span>=<span class="hljs-string">123</span></code></pre></div>

<p>配置完成后，重启项目，就可以使用这里配置的用户名/密码登录了</p>
<h4 id="Java-配置用户名-密码"><a href="#Java-配置用户名-密码" class="headerlink" title="Java 配置用户名/密码"></a>Java 配置用户名/密码</h4><p>也可以在 Java 代码中配置用户名密码，首先需要我们创建一个 Spring Security 的配置类，集成自 WebSecurityConfigurerAdapter 类，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//下面这两行配置表示在内存中配置了两个用户</span>
        auth.inMemoryAuthentication()
                .withUser(<span class="hljs-string">&quot;javaboy&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$OR3VSksVAmCzc.7WeaRPR.t0wyCsIj24k0Bne8iKWV1o.V9wsP8Xe&quot;</span>)
                .and()
          .withUser(<span class="hljs-string">&quot;lisi&quot;</span>).roles(<span class="hljs-string">&quot;user&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$p1H8iWa8I4.CA.7Z8bwLjes91ZpY.rYREGHQEInNtAp4NzL6PLKxi&quot;</span>);
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
    &#125;
&#125;</code></pre></div>

<p>这里我们在 configure 方法中配置了两个用户，用户的密码都是加密之后的字符串(明文是 123)，<strong>从 Spring5 开始，强制要求密码要加密</strong>，如果非不想加密，可以使用一个过期的 PasswordEncoder 的实例 NoOpPasswordEncoder，但是不建议这么做，毕竟不安全。</p>
<h3 id="1-4-加密方案"><a href="#1-4-加密方案" class="headerlink" title="1.4 加密方案"></a>1.4 加密方案</h3><p>密码加密我们一般会用到散列函数，又称散列算法、哈希函数，这是一种从任何数据中创建数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来，然后将数据打乱混合，重新创建一个散列值。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。我们常用的散列函数有 MD5 消息摘要算法、安全散列算法（Secure Hash Algorithm）。</p>
<p>但是仅仅使用散列函数还不够，为了增加密码的安全性，一般在密码加密过程中还需要加盐，所谓的盐可以是一个随机数也可以是用户名，加盐之后，即使密码明文相同的用户生成的密码密文也不相同，这可以极大的提高密码的安全性。但是传统的加盐方式需要在数据库中有专门的字段来记录盐值，这个字段可能是用户名字段（因为用户名唯一），也可能是一个专门记录盐值的字段，这样的配置比较繁琐。 </p>
<p>Spring Security 提供了多种密码加密方案，官方推荐使用 BCryptPasswordEncoder，BCryptPasswordEncoder 使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。</p>
<p>Spring Security 中提供了 BCryptPasswordEncoder 密码编码工具，可以非常方便的实现密码的加密加盐，相同明文加密出来的结果总是不同，这样就不需要用户去额外保存<strong>盐</strong>的字段了，这一点比 Shiro 要方便很多，而 BCryptPasswordEncoder 就是 PasswordEncoder 接口的实现类，只需要提供 BCryptPasswordEncoder 这个 Bean 的实例即可，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder(<span class="hljs-number">10</span>);
&#125;</code></pre></div>

<p>创建 BCryptPasswordEncoder 时传入的参数 10 就是 strength，即密钥的迭代次数（也可以不配置，默认为 10）。同时，配置的内存用户的密码也不再是 123 了，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">auth.inMemoryAuthentication()
.withUser(<span class="hljs-string">&quot;admin&quot;</span>)
.password(<span class="hljs-string">&quot;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&quot;</span>)
.roles(<span class="hljs-string">&quot;ADMIN&quot;</span>, <span class="hljs-string">&quot;USER&quot;</span>)
.and()
.withUser(<span class="hljs-string">&quot;sang&quot;</span>)
.password(<span class="hljs-string">&quot;$2a$10$eUHbAOMq4bpxTvOVz33LIehLe3fu6NwqC9tdOcxJXEhyZ4simqXTC&quot;</span>)
.roles(<span class="hljs-string">&quot;USER&quot;</span>);</code></pre></div>

<p>这里的密码就是使用 BCryptPasswordEncoder 加密后的密码，虽然 admin 和 sang 加密后的密码不一样，但是明文都是 123。配置完成后，使用 admin/123 或者 sang/123 就可以实现登录。</p>
<p>本案例使用了配置在内存中的用户，一般情况下，用户信息是存储在数据库中的，因此需要在用户注册时对密码进行加密处理，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegService</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reg</span><span class="hljs-params">(String username, String password)</span> </span>&#123;
        BCryptPasswordEncoder encoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder(<span class="hljs-number">10</span>);
        String encodePasswod = encoder.encode(password);
        <span class="hljs-keyword">return</span> saveToDb(username, encodePasswod);
    &#125;
&#125;</code></pre></div>

<p>用户将密码从前端传来之后，通过调用 BCryptPasswordEncoder 实例中的 encode 方法对密码进行加密处理，加密完成后将密文存入数据库。</p>
<h3 id="1-5-登录配置"><a href="#1-5-登录配置" class="headerlink" title="1.5 登录配置"></a>1.5 登录配置</h3><p>对于登录接口，登录成功后的响应，登录失败后的响应，我们都可以在 WebSecurityConfigurerAdapter 的实现类中进行配置。例如下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
  
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
    &#125;
    <span class="hljs-meta">@Autowired</span>
    VerifyCodeFilter verifyCodeFilter;
    <span class="hljs-comment">//http配置</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);
        http
        .authorizeRequests()<span class="hljs-comment">//开启登录配置</span>
        .antMatchers(<span class="hljs-string">&quot;/hello&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)<span class="hljs-comment">//表示访问 /hello 这个接口，需要具备 admin 这个角色</span>
        .anyRequest().authenticated()<span class="hljs-comment">//表示剩余的其他接口，登录之后就能访问</span>
        .and()
        .formLogin()
        <span class="hljs-comment">//定义登录页面，未登录时，访问一个需要登录之后才能访问的接口，会自动跳转到该页面</span>
        .loginPage(<span class="hljs-string">&quot;/login_p&quot;</span>)
        <span class="hljs-comment">//登录处理接口</span>
        .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)
        <span class="hljs-comment">//定义登录时，用户名的 key，默认为 username</span>
        .usernameParameter(<span class="hljs-string">&quot;uname&quot;</span>)
        <span class="hljs-comment">//定义登录时，用户密码的 key，默认为 password</span>
        .passwordParameter(<span class="hljs-string">&quot;passwd&quot;</span>)
          
        <span class="hljs-comment">//登录成功的处理器</span>
                .successHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                        PrintWriter out = resp.getWriter();
                        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
                        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">200</span>);
                        map.put(<span class="hljs-string">&quot;msg&quot;</span>, authentication.getPrincipal());
                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map));
                        out.flush();
                        out.close();
                    &#125;
                &#125;)
          
          <span class="hljs-comment">//登录失败的处理器</span>
               .failureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                        PrintWriter out = resp.getWriter();
                        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
                        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">401</span>);
                        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException) &#123;
                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;账户被锁定，登录失败!&quot;</span>);
                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;
                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;用户名或密码输入错误，登录失败!&quot;</span>);
                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> DisabledException) &#123;
                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;账户被禁用，登录失败!&quot;</span>);
                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;
                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;账户过期，登录失败!&quot;</span>);
                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;
                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;密码过期，登录失败!&quot;</span>);
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;登录失败!&quot;</span>);
                        &#125;
                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map));
                        out.flush();
                        out.close();
                    &#125;
                &#125;)
            .permitAll()<span class="hljs-comment">//和表单登录相关的接口统统都直接通过</span>
            .and()
            .logout()
            .logoutUrl(<span class="hljs-string">&quot;/logout&quot;</span>)
          <span class="hljs-comment">//注销成功的处理器</span>
                .logoutSuccessHandler(<span class="hljs-keyword">new</span> LogoutSuccessHandler() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                        PrintWriter out = resp.getWriter();
                        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
                        map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">200</span>);
                        map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;注销登录成功!&quot;</span>);
                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(map));
                        out.flush();
                        out.close();
                    &#125;
                &#125;)
            .permitAll()
            .and()
            .httpBasic()
            .and()
            .csrf().disable();
    &#125;
&#125;</code></pre></div>

<p>我们可以在 successHandler 方法中，配置登录成功的回调，如果是前后端分离开发的话，登录成功后返回 JSON 即可，同理，failureHandler 方法中配置登录失败的回调，logoutSuccessHandler 中则配置注销成功的回调。</p>
<h4 id="多个Http的配置"><a href="#多个Http的配置" class="headerlink" title="多个Http的配置"></a><strong>多个Http的配置</strong></h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-comment">//不需要继承</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiHttpSecurityConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
    &#125;
  
		<span class="hljs-comment">//公用</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        auth.inMemoryAuthentication()
                .withUser(<span class="hljs-string">&quot;javaboy&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$G3kVAJHvmRrr6sOj.j4xpO2Dsxl5EG8rHycPHFWyi9UMIhtdSH15u&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>)
                .and()
                .withUser(<span class="hljs-string">&quot;江南一点雨&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$kWjG2GxWhm/2tN2ZBpi7bexXjUneIKFxIAaMYJzY7WcziZLCD4PZS&quot;</span>).roles(<span class="hljs-string">&quot;user&quot;</span>);
    &#125;

    <span class="hljs-meta">@Configuration</span>
    <span class="hljs-meta">@Order(1)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
            http.antMatcher(<span class="hljs-string">&quot;/admin/**&quot;</span>).authorizeRequests().anyRequest().hasAnyRole(<span class="hljs-string">&quot;admin&quot;</span>);
        &#125;
    &#125;

    <span class="hljs-meta">@Configuration</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span></span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
            http.authorizeRequests().anyRequest().authenticated()
                    .and()
                    .formLogin()
                    .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)
                    .permitAll()
                    .and()
                    .csrf().disable();
        &#125;
    &#125;
&#125;</code></pre></div>

<h4 id="表达式控制方法权限"><a href="#表达式控制方法权限" class="headerlink" title="表达式控制方法权限"></a>表达式控制方法权限</h4><p>方法的安全默认是没有开启的，如果在Config类上加上注解<code>@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)</code>就可以开启方法的安全</p>
<p>这个配置开启了三个注解，分别是：</p>
<ul>
<li>@PreAuthorize：方法执行前进行权限检查</li>
<li>@PostAuthorize：方法执行后进行权限检查</li>
<li>@Secured：类似于 @PreAuthorize</li>
</ul>
<p>这三个结合 SpEL 之后，用法非常灵活，这里和大家稍微分享几个 Demo。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;
    <span class="hljs-meta">@PreAuthorize(&quot;principal.username.equals(&#x27;javaboy&#x27;)&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
    &#125;

    <span class="hljs-meta">@PreAuthorize(&quot;hasRole(&#x27;admin&#x27;)&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;admin&quot;</span>;
    &#125;

    <span class="hljs-meta">@Secured(&#123;&quot;ROLE_user&quot;&#125;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user&quot;</span>;
    &#125;

    <span class="hljs-meta">@PreAuthorize(&quot;#age&gt;98&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;
        <span class="hljs-keyword">return</span> String.valueOf(age);
    &#125;
&#125;</code></pre></div>

<ul>
<li>第一个 hello 方法，注解的约束是，只有当前登录用户名为 javaboy 的用户才可以访问该方法。</li>
<li>第二个 admin 方法，表示访问该方法的用户必须具备 admin 角色。</li>
<li>第三个 user 方法，表示方法该方法的用户必须具备 user 角色，但是注意 user 角色需要加上 <code>ROLE_</code> 前缀。</li>
<li>第四个 getAge 方法，表示访问该方法的 age 参数必须大于 98，否则请求不予通过。</li>
</ul>
<p>可以看到，这里的表达式还是非常丰富，如果想引用方法的参数，前面加上一个 <code>#</code> 即可，既可以引用基本类型的参数，也可以引用对象参数。</p>
<h4 id="过滤注解"><a href="#过滤注解" class="headerlink" title="过滤注解"></a>过滤注解</h4><p>Spring Security 中还有两个过滤函数 @PreFilter 和 @PostFilter，可以根据给出的条件，自动移除集合中的元素。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostFilter(&quot;filterObject.lastIndexOf(&#x27;2&#x27;)!=-1&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span> </span>&#123;
    List&lt;String&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
        users.add(<span class="hljs-string">&quot;javaboy:&quot;</span> + i);
    &#125;
    <span class="hljs-keyword">return</span> users;
&#125;
<span class="hljs-meta">@PreFilter(filterTarget = &quot;ages&quot;,value = &quot;filterObject%2==0&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAllAge</span><span class="hljs-params">(List&lt;Integer&gt; ages,List&lt;String&gt; users)</span> </span>&#123;
    System.out.println(<span class="hljs-string">&quot;ages = &quot;</span> + ages);
    System.out.println(<span class="hljs-string">&quot;users = &quot;</span> + users);
&#125;</code></pre></div>

<ul>
<li>在 getAllUser 方法中，对集合进行过滤，只返回后缀为 2 的元素，filterObject 表示要过滤的元素对象。</li>
<li>在 getAllAge 方法中，由于有两个集合，因此使用 filterTarget 指定过滤对象。</li>
</ul>
<h4 id="忽略拦截"><a href="#忽略拦截" class="headerlink" title="忽略拦截"></a>忽略拦截</h4><p>如果某一个请求地址不需要拦截的话，有两种方式实现：</p>
<ul>
<li>设置该地址匿名访问</li>
<li>直接过滤掉该地址，即该地址不走 Spring Security 过滤器链</li>
</ul>
<p>推荐使用第二种方案，配置如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        web.ignoring().antMatchers(<span class="hljs-string">&quot;/vercode&quot;</span>);
    &#125;
&#125;</code></pre></div>

<h3 id="1-7-自定义表单登录"><a href="#1-7-自定义表单登录" class="headerlink" title="1.7 自定义表单登录"></a>1.7 自定义表单登录</h3><p>继续完善前面的 SecurityConfig 类，继续重写它的 <code>configure(WebSecurity web)</code> 和 <code>configure(HttpSecurity http)</code> 方法，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    web.ignoring().antMatchers(<span class="hljs-string">&quot;/js/**&quot;</span>, <span class="hljs-string">&quot;/css/**&quot;</span>,<span class="hljs-string">&quot;/images/**&quot;</span>);
&#125;
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    http.authorizeRequests()
            .anyRequest().authenticated()
            .and()
            .formLogin()
            .loginPage(<span class="hljs-string">&quot;/login.html&quot;</span>)
            .permitAll()
            .and()
            .csrf().disable();
&#125;</code></pre></div>

<ul>
<li>web.ignoring() 用来配置忽略掉的 URL 地址，一般对于静态文件，我们可以采用此操作。</li>
<li>如果我们使用 XML 来配置 Spring Security ，里边会有一个重要的标签 <code>&lt;http&gt;</code>，HttpSecurity 提供的配置方法 都对应了该标签。</li>
<li>authorizeRequests 对应了 <code>&lt;intercept-url&gt;</code>。</li>
<li>formLogin 对应了 <code>&lt;formlogin&gt;</code>。</li>
<li>and 方法表示结束当前标签，上下文回到HttpSecurity，开启新一轮的配置。</li>
<li>permitAll 表示登录相关的页面/接口不要被拦截。</li>
<li>最后记得关闭 csrf ，关于 csrf 问题我到后面专门和大家说</li>
</ul>
<p>当我们定义了登录页面为 /login.html 的时候，Spring Security 也会帮我们自动注册一个 /login.html 的接口，这个接口是 POST 请求，用来处理登录逻辑。</p>
<p>我们将登录页面的相关静态文件拷贝到 Spring Boot 项目的 resources/static 目录下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com//2020/03/spring-security-2-7.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/spring-security-2-7.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>前端页面比较长，这里我把核心部分列出来（完整代码我会上传到 GitHub：<a target="_blank" rel="noopener" href="https://github.com/lenve/spring-security-samples%EF%BC%89%EF%BC%9A">https://github.com/lenve/spring-security-samples）：</a></p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/login.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spin&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;pass&quot;</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pass&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spin&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button login&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-check&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div>

<p>form 表单中，注意 action 为 <code>/login.html</code> </p>
<p>实际上它还有一个隐藏的操作，就是登录接口地址也设置成 <code>/login.html</code> 了。换句话说，新的登录页面和登录接口地址都是 <code>/login.html</code>，现在存在如下两个请求：</p>
<ul>
<li>GET <a target="_blank" rel="noopener" href="http://localhost:8080/login.html">http://localhost:8080/login.html</a></li>
<li>POST <a target="_blank" rel="noopener" href="http://localhost:8080/login.html">http://localhost:8080/login.html</a></li>
</ul>
<p>前面的 GET 请求用来获取登录页面，后面的 POST 请求用来提交登录数据。</p>
<p>有的小伙伴会感到奇怪？为什么登录页面和登录接口不能分开配置呢？</p>
<p>其实是可以分开配置的！</p>
<p>在 SecurityConfig 中，我们可以通过 loginProcessingUrl 方法来指定登录接口地址，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">.and()
.formLogin()
.loginPage(<span class="hljs-string">&quot;/login.html&quot;</span>)
.loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)
.permitAll()
.and()</code></pre></div>

<p>这样配置之后，登录页面地址和登录接口地址就分开了，各是各的。</p>
<p>此时我们还需要修改登录页面里边的 action 属性，改为 <code>/doLogin</code>，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/doLogin&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>
<span class="hljs-comment">&lt;!--省略--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div>

<p>此时，启动项目重新进行登录，我们发现依然可以登录成功。</p>
<p>那么为什么默认情况下两个配置地址是一样的呢？</p>
<p>我们知道，form 表单的相关配置在 FormLoginConfigurer 中，该类继承自 AbstractAuthenticationFilterConfigurer ，所以当 FormLoginConfigurer 初始化的时候，AbstractAuthenticationFilterConfigurer 也会初始化，在 AbstractAuthenticationFilterConfigurer 的构造方法中，我们可以看到：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractAuthenticationFilterConfigurer</span><span class="hljs-params">()</span> </span>&#123;
	setLoginPage(<span class="hljs-string">&quot;/login&quot;</span>);
&#125;</code></pre></div>

<p>这就是配置默认的 loginPage 为 <code>/login</code>。</p>
<p>另一方面，FormLoginConfigurer 的初始化方法 init 方法中也调用了父类的 init 方法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(H http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
	<span class="hljs-keyword">super</span>.init(http);
	initDefaultLoginFilter(http);
&#125;</code></pre></div>

<p>而在父类的 init 方法中，又调用了 updateAuthenticationDefaults，我们来看下这个方法：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAuthenticationDefaults</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-keyword">if</span> (loginProcessingUrl == <span class="hljs-keyword">null</span>) &#123;
		loginProcessingUrl(loginPage);
	&#125;
	<span class="hljs-comment">//省略</span>
&#125;</code></pre></div>

<p>从这个方法的逻辑中我们就可以看到，如果用户没有给 loginProcessingUrl 设置值的话，默认就使用 loginPage 作为 loginProcessingUrl。</p>
<p>而如果用户配置了 loginPage，在配置完 loginPage 之后，updateAuthenticationDefaults 方法还是会被调用，此时如果没有配置 loginProcessingUrl，则使用新配置的 loginPage 作为 loginProcessingUrl。</p>
<h3 id="1-8-基于数据库的认证"><a href="#1-8-基于数据库的认证" class="headerlink" title="1.8 基于数据库的认证"></a>1.8 基于数据库的认证</h3><p><strong>创建库</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;*!40101 SET NAMES utf8 *&#x2F;;

&#x2F;*!40101 SET SQL_MODE&#x3D;&#39;&#39;*&#x2F;;

&#x2F;*!40014 SET @OLD_UNIQUE_CHECKS&#x3D;@@UNIQUE_CHECKS, UNIQUE_CHECKS&#x3D;0 *&#x2F;;
&#x2F;*!40014 SET @OLD_FOREIGN_KEY_CHECKS&#x3D;@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS&#x3D;0 *&#x2F;;
&#x2F;*!40101 SET @OLD_SQL_MODE&#x3D;@@SQL_MODE, SQL_MODE&#x3D;&#39;NO_AUTO_VALUE_ON_ZERO&#39; *&#x2F;;
&#x2F;*!40111 SET @OLD_SQL_NOTES&#x3D;@@SQL_NOTES, SQL_NOTES&#x3D;0 *&#x2F;;
CREATE DATABASE &#x2F;*!32312 IF NOT EXISTS*&#x2F;&#96;security&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F;;

USE &#96;security&#96;;

&#x2F;*Table structure for table &#96;role&#96; *&#x2F;

DROP TABLE IF EXISTS &#96;role&#96;;

CREATE TABLE &#96;role&#96; (
  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;name&#96; varchar(32) DEFAULT NULL,
  &#96;nameZh&#96; varchar(32) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)
) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;

&#x2F;*Data for the table &#96;role&#96; *&#x2F;

insert  into &#96;role&#96;(&#96;id&#96;,&#96;name&#96;,&#96;nameZh&#96;) values 
(1,&#39;ROLE_dba&#39;,&#39;数据库管理员&#39;),
(2,&#39;ROLE_admin&#39;,&#39;系统管理员&#39;),
(3,&#39;ROLE_user&#39;,&#39;用户&#39;);

&#x2F;*Table structure for table &#96;user&#96; *&#x2F;

DROP TABLE IF EXISTS &#96;user&#96;;

CREATE TABLE &#96;user&#96; (
  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;username&#96; varchar(32) DEFAULT NULL,
  &#96;password&#96; varchar(255) DEFAULT NULL,
  &#96;enabled&#96; tinyint(1) DEFAULT NULL,
  &#96;locked&#96; tinyint(1) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)
) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;

&#x2F;*Data for the table &#96;user&#96; *&#x2F;

insert  into &#96;user&#96;(&#96;id&#96;,&#96;username&#96;,&#96;password&#96;,&#96;enabled&#96;,&#96;locked&#96;) values 
(1,&#39;root&#39;,&#39;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&#39;,1,0),
(2,&#39;admin&#39;,&#39;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&#39;,1,0),
(3,&#39;sang&#39;,&#39;$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq&#39;,1,0);

&#x2F;*Table structure for table &#96;user_role&#96; *&#x2F;

DROP TABLE IF EXISTS &#96;user_role&#96;;

CREATE TABLE &#96;user_role&#96; (
  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;uid&#96; int(11) DEFAULT NULL,
  &#96;rid&#96; int(11) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)
) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;5 DEFAULT CHARSET&#x3D;utf8;

&#x2F;*Data for the table &#96;user_role&#96; *&#x2F;

insert  into &#96;user_role&#96;(&#96;id&#96;,&#96;uid&#96;,&#96;rid&#96;) values 
(1,1,1),
(2,1,2),
(3,2,2),
(4,3,3);

&#x2F;*!40101 SET SQL_MODE&#x3D;@OLD_SQL_MODE *&#x2F;;
&#x2F;*!40014 SET FOREIGN_KEY_CHECKS&#x3D;@OLD_FOREIGN_KEY_CHECKS *&#x2F;;
&#x2F;*!40014 SET UNIQUE_CHECKS&#x3D;@OLD_UNIQUE_CHECKS *&#x2F;;
&#x2F;*!40111 SET SQL_NOTES&#x3D;@OLD_SQL_NOTES *&#x2F;;</code></pre></div>

<p>得到user表、user_role表、role表</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525102214396.png" srcset="/img/loading.gif" lazyload alt="image-20210525102214396"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525102226106.png" srcset="/img/loading.gif" lazyload alt="image-20210525102226106"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525102243104.png" srcset="/img/loading.gif" lazyload alt="image-20210525102243104"></p>
<p><strong>引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div>

<p><strong>配置文件</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://192.168.66.128:3306/security</span>
<span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>
<span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span></code></pre></div>

<p><strong>定义实体类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实现认证的接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> String password;
    <span class="hljs-keyword">private</span> Boolean enabled;
    <span class="hljs-keyword">private</span> Boolean locked;
    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;
  
 <span class="hljs-comment">//重写接口中的方法</span>
   <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> username;
    &#125;
		<span class="hljs-comment">//账户是否未过期，对应user中的locked</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
		<span class="hljs-comment">//是否没有被锁定</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> !locked;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> enabled;
    &#125;
		<span class="hljs-comment">//返回用户的所有角色</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;
        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (Role role : roles) &#123;
          	<span class="hljs-comment">//数据库的role表中用户必须以&quot;ROLE_&quot;开头</span>
            authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));
        &#125;
        <span class="hljs-keyword">return</span> authorities;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> password;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String nameZh;
  
  ...
&#125;</code></pre></div>

<p><strong>创建Service</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    UserMapper userMapper;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;
      <span class="hljs-comment">//方法一  </span>
      User user = userMapper.loadUserByUsername(username);
        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;用户不存在!&quot;</span>);
        &#125;
       <span class="hljs-comment">//方法二</span>
        user.setRoles(userMapper.getUserRolesById(user.getId()));
        <span class="hljs-keyword">return</span> user;
    &#125;
&#125;</code></pre></div>

<p><strong>Mapper的接口以及实现类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;
    <span class="hljs-function">User <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span></span>;

    <span class="hljs-function">List&lt;Role&gt; <span class="hljs-title">getUserRolesById</span><span class="hljs-params">(Integer id)</span></span>;
&#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span>
<span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span>
<span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.javaboy.securitydb.mapper.UserMapper&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loadUserByUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.javaboy.securitydb.bean.User&quot;</span>&gt;</span>
        select * from user where username=#&#123;username&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserRolesById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.javaboy.securitydb.bean.Role&quot;</span>&gt;</span>
        select * from role where id in (select rid from user_role where uid=#&#123;id&#125;)
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>

<p><strong>Security配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    UserService userService;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        auth.userDetailsService(userService);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
    &#125;
  
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        http.authorizeRequests()
                .antMatchers(<span class="hljs-string">&quot;/dba/**&quot;</span>).hasRole(<span class="hljs-string">&quot;dba&quot;</span>)
                .antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)
                .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasRole(<span class="hljs-string">&quot;user&quot;</span>)
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .permitAll()
                .and()
                .csrf().disable();
    &#125;
&#125;</code></pre></div>

<p><strong>测试接口Controller</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello security!&quot;</span>;
    &#125;

    <span class="hljs-meta">@GetMapping(&quot;/dba/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dba</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello dba!&quot;</span>;
    &#125;

    <span class="hljs-meta">@GetMapping(&quot;/admin/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello admin&quot;</span>;
    &#125;

    <span class="hljs-meta">@GetMapping(&quot;/user/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello user&quot;</span>;
    &#125;
&#125;</code></pre></div>

<h4 id="角色继承"><a href="#角色继承" class="headerlink" title="角色继承"></a>角色继承</h4><p>角色继承实际上是一个很常见的需求，因为大部分公司治理可能都是金字塔形的，上司可能具备下属的部分甚至所有权限，这一现实场景，反映到我们的代码中，就是角色继承了。 Spring Security 中为开发者提供了相关的角色继承解决方案，但是这一解决方案在最近的 Spring Security 版本变迁中，使用方法有所变化</p>
<p>SpringSecurity 在角色继承上有两种不同的写法，在 Spring Boot2.0.8（对应 Spring Security 也是 5.0.11）上面是一种写法，从 Spring Boot2.1.0（对应 Spring Security5.1.1）又是另外一种写法</p>
<p><strong>以前的写法</strong></p>
<p>这里说的以前写法，就是指 SpringBoot2.0.8（含）之前的写法，在之前的写法中，角色继承只需要开发者提供一个 RoleHierarchy 接口的实例即可，例如下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function">RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;
    RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();
    String hierarchy = <span class="hljs-string">&quot;ROLE_dba &gt; ROLE_admin ROLE_admin &gt; ROLE_user&quot;</span>;
    roleHierarchy.setHierarchy(hierarchy);
    <span class="hljs-keyword">return</span> roleHierarchy;
&#125;</code></pre></div>

<p>在这里我们提供了一个 RoleHierarchy 接口的实例，使用字符串来描述了角色之间的继承关系， <code>ROLE_dba</code> 具备 <code>ROLE_admin</code> 的所有权限，而 <code>ROLE_admin</code> 则具备 <code>ROLE_user</code> 的所有权限，继承与继承之间用一个空格隔开。提供了这个 Bean 之后，以后所有具备 <code>ROLE_user</code> 角色才能访问的资源， <code>ROLE_dba</code> 和 <code>ROLE_admin</code> 也都能访问，具备 <code>ROLE_amdin</code> 角色才能访问的资源， <code>ROLE_dba</code> 也能访问。</p>
<p><strong>现在的写法</strong></p>
<p>但是上面这种写法仅限于 Spring Boot2.0.8（含）之前的版本，在之后的版本中，这种写法则不被支持，新版的写法是下面这样：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function">RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;
    RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();
    String hierarchy = <span class="hljs-string">&quot;ROLE_dba &gt; ROLE_admin \n ROLE_admin &gt; ROLE_user&quot;</span>;
    roleHierarchy.setHierarchy(hierarchy);
    <span class="hljs-keyword">return</span> roleHierarchy;
&#125;</code></pre></div>

<p>变化主要就是分隔符，将原来用空格隔开的地方，现在用换行符了。这里表达式的含义依然和上面一样，不再赘述。</p>
<p>上面两种不同写法都是配置角色的继承关系，配置完成后，接下来指定角色和资源的对应关系即可，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    http.authorizeRequests().antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>)
            .hasRole(<span class="hljs-string">&quot;admin&quot;</span>)
            .antMatchers(<span class="hljs-string">&quot;/db/**&quot;</span>)
            .hasRole(<span class="hljs-string">&quot;dba&quot;</span>)
            .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>)
            .hasRole(<span class="hljs-string">&quot;user&quot;</span>)
            .and()
            .formLogin()
            .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)
            .permitAll()
            .and()
            .csrf().disable();
&#125;</code></pre></div>

<p>这个表示 <code>/db/**</code> 格式的路径需要具备 dba 角色才能访问， <code>/admin/**</code> 格式的路径则需要具备 admin 角色才能访问， <code>/user/**</code> 格式的路径，则需要具备 user 角色才能访问，此时提供相关接口，会发现，dba 除了访问 <code>/db/**</code>，也能访问 <code>/admin/**</code> 和 <code>/user/**</code> ，admin 角色除了访问 <code>/admin/**</code> ，也能访问 <code>/user/**</code> ，user 角色则只能访问 <code>/user/**</code> 。</p>
<h4 id="动态权限配置"><a href="#动态权限配置" class="headerlink" title="动态权限配置"></a><strong>动态权限配置</strong></h4><p>继续创建表</p>
<div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;*Table structure for table &#96;menu&#96; *&#x2F;

DROP TABLE IF EXISTS &#96;menu&#96;;

CREATE TABLE &#96;menu&#96; (
  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;pattern&#96; varchar(128) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)
) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;

&#x2F;*Data for the table &#96;menu&#96; *&#x2F;

insert  into &#96;menu&#96;(&#96;id&#96;,&#96;pattern&#96;) values 
(1,&#39;&#x2F;db&#x2F;**&#39;),
(2,&#39;&#x2F;admin&#x2F;**&#39;),
(3,&#39;&#x2F;user&#x2F;**&#39;);

&#x2F;*Table structure for table &#96;menu_role&#96; *&#x2F;

DROP TABLE IF EXISTS &#96;menu_role&#96;;

CREATE TABLE &#96;menu_role&#96; (
  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;mid&#96; int(11) DEFAULT NULL,
  &#96;rid&#96; int(11) DEFAULT NULL,
  PRIMARY KEY (&#96;id&#96;)
) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;

&#x2F;*Data for the table &#96;menu_role&#96; *&#x2F;

insert  into &#96;menu_role&#96;(&#96;id&#96;,&#96;mid&#96;,&#96;rid&#96;) values 
(1,1,1),
(2,2,2),
(3,3,3);</code></pre></div>

<p>menu表、menu_role表</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525105223533.png" srcset="/img/loading.gif" lazyload alt="image-20210525105223533"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525105242464.png" srcset="/img/loading.gif" lazyload alt="image-20210525105242464"></p>
<p><strong>最终的五张表</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525105211929.png" srcset="/img/loading.gif" lazyload alt="image-20210525105211929"></p>
<p>上面的角色之间的权限是在Config类中写死的</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    http.authorizeRequests()
            .antMatchers(<span class="hljs-string">&quot;/dba/**&quot;</span>).hasRole(<span class="hljs-string">&quot;dba&quot;</span>)
            .antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)
            .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasRole(<span class="hljs-string">&quot;user&quot;</span>)
            .anyRequest().authenticated()
            .and()
            .formLogin()
            .permitAll()
            .and()
            .csrf().disable();
&#125;</code></pre></div>

<p>如今转换到数据库中动态加载，<strong>新增实体类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String pattern;
    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Menu&#123;&quot;</span> +
                <span class="hljs-string">&quot;id=&quot;</span> + id +
                <span class="hljs-string">&quot;, pattern=&#x27;&quot;</span> + pattern + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, roles=&quot;</span> + roles +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">getRoles</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> roles;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoles</span><span class="hljs-params">(List&lt;Role&gt; roles)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.roles = roles;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPattern</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> pattern;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPattern</span><span class="hljs-params">(String pattern)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.pattern = pattern;
    &#125;
&#125;</code></pre></div>

<p><strong>Service及Mapper</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    MenuMapper menuMapper;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getAllMenus</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> menuMapper.getAllMenus();
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MenuMapper</span> </span>&#123;
    <span class="hljs-function">List&lt;Menu&gt; <span class="hljs-title">getAllMenus</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p><strong>查询一对多的关系</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs mysql">select m.*,r.&#96;id&#96; as rid,r.&#96;name&#96; as rname,r.&#96;nameZh&#96; as rnameZh from menu m left join menu_role mr on m.&#96;id&#96;&#x3D;mr.&#96;mid&#96; left join role r on mr.&#96;rid&#96;&#x3D;r.&#96;id&#96;</code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210525111027555.png" srcset="/img/loading.gif" lazyload alt="image-20210525111027555"></p>
<p><strong>对应的Menumapper.xml</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span>
<span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span>
<span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.javaboy.securitydy.mapper.MenuMapper&quot;</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.javaboy.securitydy.bean.Menu&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pattern&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;roles&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;org.javaboy.securitydy.bean.Role&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;rnameZh&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;nameZh&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- 一对多，需要resultMap--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllMenus&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span>
        select m.*,r.`id` as rid,r.`name` as rname,r.`nameZh` as rnameZh from menu m left join menu_role mr on m.`id`=mr.`mid` left join role r on mr.`rid`=r.`id`
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>

<p>在更新配置类之前，先创建过滤器根据url匹配用户角色</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterInvocationSecurityMetadataSource</span> </span>&#123;
    <span class="hljs-comment">//路径匹配</span>
    AntPathMatcher pathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();
    <span class="hljs-meta">@Autowired</span>
    MenuService menuService;

    <span class="hljs-comment">//根据请求的地址分析需要那个角色</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAttributes</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;
        String requestUrl = ((FilterInvocation) o).getRequestUrl();
        List&lt;Menu&gt; allMenus = menuService.getAllMenus();
        <span class="hljs-comment">//遍历从数据库取出的结果，开始匹配</span>
        <span class="hljs-keyword">for</span> (Menu menu : allMenus) &#123;
            <span class="hljs-keyword">if</span> (pathMatcher.match(menu.getPattern(), requestUrl)) &#123;
                <span class="hljs-comment">//url对应得上库中的结果</span>
                List&lt;Role&gt; roles = menu.getRoles();
                String[] rolesStr = <span class="hljs-keyword">new</span> String[roles.size()];
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; roles.size(); i++) &#123;
                    rolesStr[i] = roles.get(i).getName();
                &#125;
                <span class="hljs-keyword">return</span> SecurityConfig.createList(rolesStr);
            &#125;
        &#125;
        <span class="hljs-comment">//url无法匹配，特殊标记</span>
        <span class="hljs-keyword">return</span> SecurityConfig.createList(<span class="hljs-string">&quot;ROLE_login&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAllConfigAttributes</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; aClass)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre></div>

<p>根据过滤器Collection得到的返回值，再进行处理Collection</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAccessDecisionManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDecisionManager</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decide</span><span class="hljs-params">(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection)</span> <span class="hljs-keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;
        <span class="hljs-keyword">for</span> (ConfigAttribute attribute : collection) &#123;
            <span class="hljs-comment">//说明url没匹配上</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ROLE_login&quot;</span>.equals(attribute.getAttribute())) &#123;
                <span class="hljs-comment">//如果是匿名用户，抛异常</span>
                <span class="hljs-keyword">if</span> (authentication <span class="hljs-keyword">instanceof</span> AnonymousAuthenticationToken) &#123;
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;非法请求!&quot;</span>);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
            &#125;
            <span class="hljs-comment">//匹配得上</span>
            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();
            <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;
                <span class="hljs-keyword">if</span> (authority.getAuthority().equals(attribute.getAttribute())) &#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccessDeniedException(<span class="hljs-string">&quot;非法请求!&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute configAttribute)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; aClass)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
&#125;</code></pre></div>

<p><strong>更新配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    UserService userService;
    <span class="hljs-comment">//注入过滤器</span>
    <span class="hljs-meta">@Autowired</span>
    MyFilter myFilter;
    <span class="hljs-comment">//注入处理</span>
    <span class="hljs-meta">@Autowired</span>
    MyAccessDecisionManager myAccessDecisionManager;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        auth.userDetailsService(userService);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        http.authorizeRequests()
                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O o)</span> </span>&#123;
                        <span class="hljs-comment">//使用过滤器和处理</span>
                        o.setAccessDecisionManager(myAccessDecisionManager);
                        o.setSecurityMetadataSource(myFilter);
                        <span class="hljs-keyword">return</span> o;
                    &#125;
                &#125;)
                .and()
                .formLogin()
                .permitAll()
                .and()
                .csrf().disable();
    &#125;
&#125;</code></pre></div>

<h3 id="1-9-使用JSON登录"><a href="#1-9-使用JSON登录" class="headerlink" title="1.9 使用JSON登录"></a>1.9 使用JSON登录</h3><h4 id="使用Key-Value登录"><a href="#使用Key-Value登录" class="headerlink" title="使用Key/Value登录"></a>使用Key/Value登录</h4><ul>
<li>创建 Spring Boot 工程</li>
</ul>
<p>首先创建 SpringBoot 工程，添加 SpringSecurity 依赖，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<ul>
<li>添加 Security 配置</li>
</ul>
<p>创建 SecurityConfig，完成 SpringSecurity 的配置，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        auth.inMemoryAuthentication().withUser(<span class="hljs-string">&quot;zhangsan&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$2O4EwLrrFPEboTfDOtC0F.RpUMk.3q3KvBHRx7XXKUMLBGjOOBs8q&quot;</span>).roles(<span class="hljs-string">&quot;user&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>)
                .successHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
                        RespBean ok = RespBean.ok(<span class="hljs-string">&quot;登录成功！&quot;</span>,authentication.getPrincipal());
                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                        PrintWriter out = resp.getWriter();
                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok));
                        out.flush();
                        out.close();
                    &#125;
                &#125;)
                .failureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
                        RespBean error = RespBean.error(<span class="hljs-string">&quot;登录失败&quot;</span>);
                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                        PrintWriter out = resp.getWriter();
                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(error));
                        out.flush();
                        out.close();
                    &#125;
                &#125;)
                .loginPage(<span class="hljs-string">&quot;/login&quot;</span>)
                .permitAll()
                .and()
                .logout()
                .logoutUrl(<span class="hljs-string">&quot;/logout&quot;</span>)
                .logoutSuccessHandler(<span class="hljs-keyword">new</span> LogoutSuccessHandler() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
                        RespBean ok = RespBean.ok(<span class="hljs-string">&quot;注销成功！&quot;</span>);
                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                        PrintWriter out = resp.getWriter();
                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok));
                        out.flush();
                        out.close();
                    &#125;
                &#125;)
                .permitAll()
                .and()
                .csrf()
                .disable()
                .exceptionHandling()
                .accessDeniedHandler(<span class="hljs-keyword">new</span> AccessDeniedHandler() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AccessDeniedException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
                        RespBean error = RespBean.error(<span class="hljs-string">&quot;权限不足，访问失败&quot;</span>);
                        resp.setStatus(<span class="hljs-number">403</span>);
                        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
                        PrintWriter out = resp.getWriter();
                        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(error));
                        out.flush();
                        out.close();
                    &#125;
                &#125;);

    &#125;
&#125;</code></pre></div>

<p>这里的配置虽然有点长，但是很基础，配置含义也比较清晰，首先提供 BCryptPasswordEncoder 作为 PasswordEncoder ，可以实现对密码的自动加密加盐，非常方便，然后提供了一个名为 <code>zhangsan</code> 的用户，密码是 <code>123</code> ，角色是 <code>user</code> ，最后配置登录逻辑，所有的请求都需要登录后才能访问，登录接口是 <code>/doLogin</code> ，用户名的 key 是 username ，密码的 key 是 password ，同时配置登录成功、登录失败以及注销成功、权限不足时都给用户返回JSON提示，另外，这里虽然配置了登录页面为 <code>/login</code> ，实际上这不是一个页面，而是一段 JSON ，在 LoginController 中提供该接口，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">&quot;尚未登录，请登录&quot;</span>);
    &#125;
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>这里 <code>/login</code> 只是一个 JSON 提示，而不是页面， <code>/hello</code> 则是一个测试接口。</p>
<p>OK，做完上述步骤就可以开始测试了，运行SpringBoot项目，访问 <code>/hello</code> 接口，结果如下：</p>
<p><img src="http://www.javaboy.org/images/boot/p1-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>此时先调用登录接口进行登录，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/p1-2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>登录成功后，再去访问 <code>/hello</code> 接口就可以成功访问了。</p>
<h4 id="使用JSON登录"><a href="#使用JSON登录" class="headerlink" title="使用JSON登录"></a>使用JSON登录</h4><p>上面演示的是一种原始的登录方案，如果想将用户名密码通过 JSON 的方式进行传递，则需要自定义相关过滤器，通过分析源码我们发现，默认的用户名密码提取在 UsernamePasswordAuthenticationFilter 过滤器中，部分源码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> <span class="hljs-keyword">extends</span></span>
<span class="hljs-class">		<span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPRING_SECURITY_FORM_USERNAME_KEY = <span class="hljs-string">&quot;username&quot;</span>;
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPRING_SECURITY_FORM_PASSWORD_KEY = <span class="hljs-string">&quot;password&quot;</span>;

	<span class="hljs-keyword">private</span> String usernameParameter = SPRING_SECURITY_FORM_USERNAME_KEY;
	<span class="hljs-keyword">private</span> String passwordParameter = SPRING_SECURITY_FORM_PASSWORD_KEY;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> postOnly = <span class="hljs-keyword">true</span>;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>));
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span>
<span class="hljs-function"><span class="hljs-params">			HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;
    
		<span class="hljs-keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(
					<span class="hljs-string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());
		&#125;

		String username = obtainUsername(request);
		String password = obtainPassword(request);

		<span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;
			username = <span class="hljs-string">&quot;&quot;</span>;
		&#125;

		<span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;
			password = <span class="hljs-string">&quot;&quot;</span>;
		&#125;

		username = username.trim();

		UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(
				username, password);

		<span class="hljs-comment">// Allow subclasses to set the &quot;details&quot; property</span>
		setDetails(request, authRequest);

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainPassword</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;
		<span class="hljs-keyword">return</span> request.getParameter(passwordParameter);
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainUsername</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;
		<span class="hljs-keyword">return</span> request.getParameter(usernameParameter);
	&#125;
    <span class="hljs-comment">//...</span>
    <span class="hljs-comment">//...</span>
&#125;</code></pre></div>

<p>从这里可以看到，默认的用户名/密码提取就是通过 request 中的 getParameter 来提取的，如果想使用 JSON 传递用户名密码，只需要将这个过滤器替换掉即可，自定义过滤器如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;
      
        <span class="hljs-keyword">if</span> (request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)
                || request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) &#123;
            ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();
            UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">try</span> (InputStream is = request.getInputStream()) &#123;
                Map&lt;String,String&gt; authenticationBean = mapper.readValue(is, Map.class);
                authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(
                        authenticationBean.get(<span class="hljs-string">&quot;username&quot;</span>), authenticationBean.get(<span class="hljs-string">&quot;password&quot;</span>));
            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                e.printStackTrace();
                authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(
                        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
            &#125; <span class="hljs-keyword">finally</span> &#123;
                setDetails(request, authRequest);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);
            &#125;
        &#125;
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.attemptAuthentication(request, response);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>这里只是将用户名/密码的获取方案重新修正下，改为了从 JSON 中获取用户名密码，然后在 SecurityConfig 中作出如下修改：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    http.authorizeRequests().anyRequest().authenticated()
            .and()
            .formLogin()
            .and().csrf().disable();
    http.addFilterAt(customAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
&#125;
<span class="hljs-meta">@Bean</span>
<span class="hljs-function">CustomAuthenticationFilter <span class="hljs-title">customAuthenticationFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    CustomAuthenticationFilter filter = <span class="hljs-keyword">new</span> CustomAuthenticationFilter();
    filter.setAuthenticationSuccessHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
            PrintWriter out = resp.getWriter();
            RespBean respBean = RespBean.ok(<span class="hljs-string">&quot;登录成功!&quot;</span>);
            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));
            out.flush();
            out.close();
        &#125;
    &#125;);
    filter.setAuthenticationFailureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
            resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
            PrintWriter out = resp.getWriter();
            RespBean respBean = RespBean.error(<span class="hljs-string">&quot;登录失败!&quot;</span>);
            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));
            out.flush();
            out.close();
        &#125;
    &#125;);
    filter.setAuthenticationManager(authenticationManagerBean());
    <span class="hljs-keyword">return</span> filter;
&#125;</code></pre></div>

<p>将自定义的 CustomAuthenticationFilter 类加入进来即可，接下来就可以使用 JSON 进行登录了，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/p1-3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="2-Shiro"><a href="#2-Shiro" class="headerlink" title="2. Shiro"></a>2. Shiro</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>Apache Shiro是一个开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架具有直观、易用等特性，同时也能提供健壮的安全性，虽然它的功能不如SpringSecurity那么强大，但是在普通的项目中也够用了。</p>
<h4 id="2-1-1-由来"><a href="#2-1-1-由来" class="headerlink" title="2.1.1 由来"></a>2.1.1 由来</h4><p>Shiro的前身是JSecurity，2004年，Les Hazlewood和Jeremy Haile创办了Jsecurity。当时他们找不到适用于应用程序级别的合适Java安全框架，同时又对JAAS非常失望。2004年到2008年期间，JSecurity托管在SourceForge上，贡献者包括Peter Ledbrook、Alan Ditzel和Tim Veil。2008年，JSecurity项目贡献给了Apache软件基金会（ASF），并被接纳成为Apache Incubator项目，由导师管理，目标是成为一个顶级Apache项目。期间，Jsecurity曾短暂更名为Ki，随后因商标问题被社区更名为“Shiro”。随后项目持续在Apache Incubator中孵化，并增加了贡献者Kalle Korhonen。2010年7月，Shiro社区发布了1.0版，随后社区创建了其项目管理委员会，并选举Les Hazlewood为主席。2010年9月22日，Shrio成为Apache软件基金会的顶级项目（TLP）。</p>
<h4 id="3-1-2-有哪些功能"><a href="#3-1-2-有哪些功能" class="headerlink" title="3.1.2 有哪些功能"></a>3.1.2 有哪些功能</h4><p>Apache Shiro是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。Apache Shiro的首要目标是易于使用和理解。安全有时候是很复杂的，甚至是痛苦的，但它没有必要这样。框架应该尽可能掩盖复杂的地方，露出一个干净而直观的API，来简化开发人员在应用程序安全上所花费的时间。</p>
<p>以下是你可以用Apache Shiro 所做的事情：</p>
<ul>
<li>验证用户来核实他们的身份</li>
<li>对用户执行访问控制，如：判断用户是否被分配了一个确定的安全角色；判断用户是否被允许做某事</li>
<li>在任何环境下使用Session API，即使没有Web容器</li>
<li>在身份验证，访问控制期间或在会话的生命周期，对事件作出反应</li>
<li>聚集一个或多个用户安全数据的数据源，并作为一个单一的复合用户“视图”</li>
<li>单点登录（SSO）功能</li>
<li>为没有关联到登录的用户启用”Remember Me”服务</li>
</ul>
<p>Apache Shiro是一个拥有许多功能的综合性的程序安全框架。下面的图表展示了Shiro的重点：</p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/img_convert/a6a1cb5eb8a807afe4f4b2bd094a97ba.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/a6a1cb5eb8a807afe4f4b2bd094a97ba.png" srcset="/img/loading.gif" lazyload alt="p306"></a></p>
<p>Shiro中有四大基石——身份验证，授权，会话管理和加密</p>
<ol>
<li>Authentication：有时也简称为“登录”，这是一个证明用户是谁的行为。</li>
<li>Authorization：访问控制的过程，也就是决定“谁”去访问“什么”。</li>
<li>Session Management：管理用户特定的会话，即使在非Web 或EJB 应用程序。</li>
<li>Cryptography：通过使用加密算法保持数据安全同时易于使用。</li>
</ol>
<p>除此之外，Shiro也提供了额外的功能来解决在不同环境下所面临的安全问题，尤其是以下这些：</p>
<ol>
<li>Web Support：Shiro的web支持的API能够轻松地帮助保护Web应用程序。</li>
<li>Caching：缓存是Apache Shiro中的第一层公民，来确保安全操作快速而又高效。</li>
<li>Concurrency：Apache Shiro利用它的并发特性来支持多线程应用程序。</li>
<li>Testing：测试支持的存在来帮助你编写单元测试和集成测试。</li>
<li>“Run As”：一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。</li>
<li>“Remember Me”：在会话中记住用户的身份，这样用户只需要在强制登录时候登录。</li>
</ol>
<h3 id="2-2-Realm"><a href="#2-2-Realm" class="headerlink" title="2.2 Realm"></a>2.2 Realm</h3><h4 id="2-2-1-登录流程是什么样的"><a href="#2-2-1-登录流程是什么样的" class="headerlink" title="2.2.1 登录流程是什么样的"></a>2.2.1 登录流程是什么样的</h4><p>首先我们来看shiro官方文档中这样一张登录流程图：</p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/img_convert/f8b6568be71a8cb15f49f862101dd661.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/f8b6568be71a8cb15f49f862101dd661.png" srcset="/img/loading.gif" lazyload alt="p308"></a></p>
<p>参照此图，我们的登录一共要经过如下几个步骤：</p>
<ol>
<li>应用程序代码调用Subject.login方法，传递创建好的包含终端用户的Principals(身份)和Credentials(凭证)的AuthenticationToken实例(即上文例子中的UsernamePasswordToken)。</li>
<li>Subject实例，通常是DelegatingSubject（或子类）委托应用程序的SecurityManager通过调用securityManager.login(token)开始真正的验证工作(在DelegatingSubject类的login方法中打断点即可看到)。</li>
<li>SubjectManager作为一个基本的“保护伞”的组成部分，接收token以及简单地委托给内部的Authenticator实例通过调用authenticator.authenticate(token)。这通常是一个ModularRealmAuthenticator实例，支持在身份验证中协调一个或多个Realm实例。ModularRealmAuthenticator本质上为Apache Shiro 提供了PAM-style 范式（其中在PAM 术语中每个Realm 都是一个’module’）。</li>
<li>如果应用程序中配置了一个以上的Realm，ModularRealmAuthenticator实例将利用配置好的AuthenticationStrategy来启动Multi-Realm认证尝试。在Realms 被身份验证调用之前，期间和以后，AuthenticationStrategy被调用使其能够对每个Realm的结果作出反应。如果只有一个单一的Realm 被配置，它将被直接调用，因为没有必要为一个单一Realm的应用使用AuthenticationStrategy。</li>
<li>每个配置的Realm用来帮助看它是否支持提交的AuthenticationToken。如果支持，那么支持Realm的getAuthenticationInfo方法将会伴随着提交的token被调用。</li>
</ol>
<h4 id="2-2-2-什么是Realm"><a href="#2-2-2-什么是Realm" class="headerlink" title="2.2.2 什么是Realm"></a>2.2.2 什么是Realm</h4><p>根据Realm文档上的解释，Realms担当Shiro和你的应用程序的安全数据之间的“桥梁”或“连接器”。当它实际上与安全相关的数据如用来执行身份验证（登录）及授权（访问控制）的用户帐户交互时，Shiro从一个或多个为应用程序配置的Realm 中寻找许多这样的东西。在这个意义上说，<strong>Realm 本质上是一个特定安全的DAO</strong>：它封装了数据源的连接详细信息，使Shiro 所需的相关的数据可用。当配置Shiro 时，你必须指定至少一个Realm 用来进行身份验证和/或授权。SecurityManager可能配置多个Realms，但至少有一个是必须的。Shiro 提供了立即可用的Realms 来连接一些安全数据源（即目录），如LDAP，关系数据库（JDBC），文本配置源，像INI 及属性文件，以及更多。</p>
<h3 id="2-2-整合SpringBoot"><a href="#2-2-整合SpringBoot" class="headerlink" title="2.2 整合SpringBoot"></a>2.2 整合SpringBoot</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p><strong>引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>自定义Realm</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;
        String username = (String) token.getPrincipal();
        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;javaboy&quot;</span>.equals(username)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username, <span class="hljs-string">&quot;123&quot;</span>, getName());
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;</code></pre></div>

<p>在 Realm 中实现简单的认证操作即可，不做授权，授权的具体写法和 SSM 中的 Shiro 一样，不赘述。这里的认证表示用户名必须是 javaboy ，用户密码必须是 123 ，满足这样的条件，就能登录成功！</p>
<p><strong>配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">MyRealm <span class="hljs-title">myRealm</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyRealm();
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">SecurityManager <span class="hljs-title">securityManager</span><span class="hljs-params">()</span> </span>&#123;
        DefaultWebSecurityManager manager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();
        manager.setRealm(myRealm());
        <span class="hljs-keyword">return</span> manager;
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">ShiroFilterFactoryBean <span class="hljs-title">shiroFilterFactoryBean</span><span class="hljs-params">()</span> </span>&#123;
        ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();
        bean.setSecurityManager(securityManager());
        bean.setLoginUrl(<span class="hljs-string">&quot;/login&quot;</span>);
        bean.setSuccessUrl(<span class="hljs-string">&quot;/index&quot;</span>);
        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();
        map.put(<span class="hljs-string">&quot;/doLogin&quot;</span>, <span class="hljs-string">&quot;anon&quot;</span>);
        map.put(<span class="hljs-string">&quot;/**&quot;</span>, <span class="hljs-string">&quot;authc&quot;</span>);
        bean.setFilterChainDefinitionMap(map);
        <span class="hljs-keyword">return</span> bean;
    &#125;
&#125;</code></pre></div>

<p>在这里进行 Shiro 的配置主要配置 3 个 Bean ：</p>
<ul>
<li>首先需要提供一个 Realm 的实例</li>
<li>需要配置一个 SecurityManager，在 SecurityManager 中配置 Realm</li>
<li>配置一个 ShiroFilterFactoryBean ，在 ShiroFilterFactoryBean 中指定路径拦截规则等</li>
<li>配置登录和测试接口</li>
<li>其中，ShiroFilterFactoryBean 的配置稍微多一些，配置含义如下：<ul>
<li>setSecurityManager 表示指定 SecurityManager</li>
<li>setLoginUrl 表示指定登录页面</li>
<li>setSuccessUrl 表示指定登录成功页面</li>
<li>接下来的 Map 中配置了路径拦截规则，注意，要有序</li>
</ul>
</li>
</ul>
<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">loging</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;please login&quot;</span>;
    &#125;

    <span class="hljs-meta">@PostMapping(&quot;/doLogin&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doLogin</span><span class="hljs-params">(String username, String password)</span> </span>&#123;
        Subject subject = SecurityUtils.getSubject();
        <span class="hljs-keyword">try</span> &#123;
            subject.login(<span class="hljs-keyword">new</span> UsernamePasswordToken(username, password));
            System.out.println(<span class="hljs-string">&quot;success&quot;</span>);
        &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;
            e.printStackTrace();
            System.out.println(<span class="hljs-string">&quot;fail&gt;&gt;&quot;</span> + e.getMessage());
        &#125;
    &#125;

    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello shiro!&quot;</span>;
    &#125;
&#125;</code></pre></div>

<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>上面这种配置方式实际上相当于把 SSM 中的 XML 配置拿到 Spring Boot 中用 Java 代码重新写了一遍，除了这种方式之外，我们也可以直接使用 Shiro 官方提供的 Starter </p>
<p><strong>依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">shiro.sessionManager.sessionIdCookieEnabled</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">shiro.sessionManager.sessionIdUrlRewritingEnabled</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">shiro.unauthorizedUrl</span>=<span class="hljs-string">/unauthorizedurl</span>
<span class="hljs-meta">shiro.web.enabled</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">shiro.successUrl</span>=<span class="hljs-string">/success</span>
<span class="hljs-meta">shiro.loginUrl</span>=<span class="hljs-string">/login</span></code></pre></div>

<ul>
<li>第一行表示是否允许将sessionId 放到 cookie 中</li>
<li>第二行表示是否允许将 sessionId 放到 Url 地址拦中</li>
<li>第三行表示访问未获授权的页面时，默认的跳转路径 </li>
<li>第四行表示开启 shiro</li>
<li>第五行表示登录成功的跳转页面 </li>
<li>第六行表示登录页面</li>
</ul>
<p><strong>配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Realm <span class="hljs-title">realm</span><span class="hljs-params">()</span> </span>&#123;
        TextConfigurationRealm realm = <span class="hljs-keyword">new</span> TextConfigurationRealm();
        realm.setUserDefinitions(<span class="hljs-string">&quot;javaboy=123,user \n admin=123,admin&quot;</span>);
        realm.setRoleDefinitions(<span class="hljs-string">&quot;admin=read,write \n user=read&quot;</span>);
        <span class="hljs-keyword">return</span> realm;
    &#125;
  	<span class="hljs-comment">//配置拦截规则</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">ShiroFilterChainDefinition <span class="hljs-title">shiroFilterChainDefinition</span><span class="hljs-params">()</span> </span>&#123;
        DefaultShiroFilterChainDefinition definition = <span class="hljs-keyword">new</span> DefaultShiroFilterChainDefinition();
        definition.addPathDefinition(<span class="hljs-string">&quot;/doLogin&quot;</span>, <span class="hljs-string">&quot;anon&quot;</span>);
        definition.addPathDefinition(<span class="hljs-string">&quot;/**&quot;</span>, <span class="hljs-string">&quot;authc&quot;</span>);
        <span class="hljs-keyword">return</span> definition;
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello shiro!&quot;</span>;
    &#125;

    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;please login&quot;</span>;
    &#125;

    <span class="hljs-meta">@PostMapping(&quot;/doLogin&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doLogin</span><span class="hljs-params">(String username, String password)</span> </span>&#123;
        Subject subject = SecurityUtils.getSubject();
        <span class="hljs-keyword">try</span> &#123;
            subject.login(<span class="hljs-keyword">new</span> UsernamePasswordToken(username, password));
            System.out.println(<span class="hljs-string">&quot;success&quot;</span>);
        &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;
            e.printStackTrace();
            System.out.println(<span class="hljs-string">&quot;fail&gt;&quot;</span> + e.getMessage());
        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="3-OAuth2"><a href="#3-OAuth2" class="headerlink" title="3. OAuth2"></a>3. OAuth2</h2><h3 id="3-1-引入"><a href="#3-1-引入" class="headerlink" title="3.1 引入"></a>3.1 引入</h3><p>住在一个大型的居民小区，小区有门禁系统，进入的时候需要输入密码，我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区，如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限。</p>
<h4 id="授权机制的设计"><a href="#授权机制的设计" class="headerlink" title="授权机制的设计"></a>授权机制的设计</h4><p>于是，我设计了一套授权机制。</p>
<p>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。</p>
<p>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p>
<p>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</p>
<p>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</p>
<p>第四步，快递员向门禁系统输入令牌，进入小区。</p>
<p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p>
<h4 id="互联网场景"><a href="#互联网场景" class="headerlink" title="互联网场景"></a>互联网场景</h4><p>我们把上面的例子搬到互联网，就是 OAuth 的设计了。</p>
<p>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。</p>
<p>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。</p>
<p>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</p>
<p>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p>
<h4 id="令牌与密码"><a href="#令牌与密码" class="headerlink" title="令牌与密码"></a>令牌与密码</h4><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p>
<p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p>
<p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p>
<p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p>
<p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth2.0 的优点。</p>
<p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。</p>
<p>OAuth2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。</p>
<h3 id="3-2-简介"><a href="#3-2-简介" class="headerlink" title="3.2 简介"></a>3.2 简介</h3><p>OAuth 是一个开放标准，该标准允许用户让第三方应用访问该用户在某一网站上存储的私密资源（如头像、照片、视频等），而在这个过程中无需将用户名和密码提供给第三方应用。实现这一功能是通过提供一个令牌（token），而不是用户名和密码来访问他们存放在特定服务提供者的数据。采用令牌（token）的方式可以让用户灵活的对第三方应用授权或者收回权限。</p>
<p>OAuth2 是 OAuth 协议的下一版本，但不向下兼容 OAuth 1.0。传统的 Web 开发登录认证一般都是基于 session 的，但是在前后端分离的架构中继续使用 session 就会有许多不便，因为移动端（Android、iOS、微信小程序等）要么不支持 cookie（微信小程序），要么使用非常不便，对于这些问题，使用 OAuth2 认证都能解决。</p>
<p>对于大家而言，我们在互联网应用中最常见的 OAuth2 应该就是各种第三方登录了，例如 QQ 授权登录、微信授权登录、微博授权登录、GitHub 授权登录等等。</p>
<h3 id="3-3-四种模式"><a href="#3-3-四种模式" class="headerlink" title="3.3 四种模式"></a>3.3 四种模式</h3><p>OAuth2 协议一共支持 4 种不同的授权模式：</p>
<ol>
<li>授权码模式：常见的第三方平台登录功能基本都是使用这种模式。</li>
<li>简化模式：简化模式是不需要客户端服务器参与，直接在浏览器中向授权服务器申请令牌（token），一般如果网站是纯静态页面则可以采用这种方式。</li>
<li>密码模式：密码模式是用户把用户名密码直接告诉客户端，客户端使用这些信息向授权服务器申请令牌（token）。这需要用户对客户端高度信任，例如客户端应用和服务提供商就是同一家公司，我们自己做前后端分离登录就可以采用这种模式。</li>
<li>客户端模式：客户端模式是指客户端使用自己的名义而不是用户的名义向服务提供者申请授权，严格来说，客户端模式并不能算作 OAuth 协议要解决的问题的一种解决方案，但是，对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是非常方便的。</li>
</ol>
<h4 id="3-2-1-授权码模式"><a href="#3-2-1-授权码模式" class="headerlink" title="3.2.1 授权码模式"></a>3.2.1 授权码模式</h4><p>授权码模式是最安全并且使用最广泛的一种模式。假如我要引入微信登录功能，那么我的流程可能是这样：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/04/oauth-1-7.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/oauth-1-7.png" srcset="/img/loading.gif" lazyload alt="图片源自网络"></a></p>
<p>在授权码模式中，我们分授权服务器和资源服务器，授权服务器用来派发 Token，拿着 Token 则可以去资源服务器获取资源，这两个服务器可以分开，也可以合并。</p>
<p>上面这张流程图的含义，具体是这样：</p>
<ul>
<li>首先，在网页上放一个超链接（我的网站相当于是第三方应用），用户 A （服务方的用户，例如微信用户）点击这个超链接就会去请求授权服务器（微信的授权服务器），用户点击的过程其实也就是我跟用户要授权的过程，这就是上图中的 1、2 步。</li>
<li>接下来的第三步，就是用户点击了超链接之后，像授权服务器发送请求，一般来说，我放在 <a target="_blank" rel="noopener" href="http://www.javaboy.org/">www.javaboy.org</a> 网页上的超链接可能有如下参数：</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//wx.qq.com/oauth/authorize?response_type=code&amp;client_id=javaboy&amp;redirect_uri=www.javaboy.org&amp;scope=all</span></code></pre></div>

<ol>
<li>response_type 表示授权类型，使用授权码模式的时候这里固定为 code，表示要求返回授权码（将来拿着这个授权码去获取 access_token）</li>
<li>client_id 表示客户端 id，也就是我应用的 id。有的小伙伴对这个不好理解，我说一下，如果我想让我的 <a target="_blank" rel="noopener" href="http://www.javaboy.org/">www.javaboy.org</a> 接入微信登录功能，我肯定得去微信开放平台注册，去填入我自己应用的基本信息等等，弄完之后，微信会给我一个 APPID，也就是我这里的 client_id，所以，从这里可以看出，授权服务器在校验的时候，会做两件事：1.校验客户端的身份；2.校验用户身份。</li>
<li>redirect_uri 表示用户登录在成功/失败后，跳转的地址（成功登录微信后，跳转到 <a target="_blank" rel="noopener" href="http://www.javaboy.org/">www.javaboy.org</a> 中的哪个页面），跳转的时候，还会携带上一个授权码参数。</li>
<li>scope 表示授权范围，即 <a target="_blank" rel="noopener" href="http://www.javaboy.org/">www.javaboy.org</a> 这个网站拿着用户的 token 都能干啥（一般来说就是获取用户非敏感的基本信息）</li>
</ol>
<ul>
<li><p>接下来第四步，<a target="_blank" rel="noopener" href="http://www.javaboy.org/">www.javaboy.org</a> 这个网站，拿着第三步获取到的 code 以及自己的 client_id 和 client_secret 以及其他一些信息去授权服务器请求令牌，微信的授权服务器在校验过这些数据之后，就会发送一个令牌回来。这个过程一般是在后端完成的，而不是利用 js 去完成。</p>
</li>
<li><p>接下来拿着这个 token，我们就可以去请求用户信息了。</p>
</li>
</ul>
<p>一般情况下我们认为授权码模式是四种模式中最安全的一种模式，因为这种模式我们的 access_token 不用经过浏览器或者移动端 App，是直接从我们的后台发送到授权服务器上，这样就很大程度减少了 access_token 泄漏的风险。</p>
<h4 id="3-3-2-简化模式"><a href="#3-3-2-简化模式" class="headerlink" title="3.3.2 简化模式"></a>3.3.2 简化模式</h4><p>技术栈搭建的博客/电子书都是典型的纯前端应用，就是只有页面，没有后端，对于这种情况，如果我想接入微信登录该怎么办呢？这就用到了我们说的简化模式。</p>
<p>我们来看下简化模式的流程图：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/04/oauth-1-8.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/oauth-1-8.png" srcset="/img/loading.gif" lazyload alt="图片源自网络"></a></p>
<p>这个流程是这样：</p>
<ol>
<li>在我 <a target="_blank" rel="noopener" href="http://www.javaboy.org/">www.javaboy.org</a> 网站上有一个微信登录的超链接，这个超链接类似下面这样：</li>
</ol>
<div class="hljs code-wrapper"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>wx.qq.com<span class="hljs-regexp">/oauth/</span>authorize?response_type=token&amp;client_id=javaboy&amp;redirect_uri=www.javaboy.org&amp;scope=all</code></pre></div>

<p>这里的参数和前面授权码模式的基本相同，只有 response_type 的值不一样，这里是 token，表示要求授权服务器直接返回 access_token。</p>
<ol>
<li>用户点击我这个超链接之后，就会跳转到微信登录页面，然后用户进行登录。</li>
<li>用户登录成功后，微信会自动重定向到 redirect_uri 参数指定的跳转网址，同时携带上 access_token，这样用户在前端就获取到 access_token 了。</li>
</ol>
<p>简化模式的弊端很明显，因为没有后端，所以非常不安全，除非你对安全性要求不高，否则不建议使用。</p>
<h4 id="3-3-3-密码模式"><a href="#3-3-3-密码模式" class="headerlink" title="3.3.3 密码模式"></a>3.3.3 密码模式</h4><p>密码模式在 Spring Cloud 项目中有着非常广泛的应用</p>
<p>密码模式有一个前提就是你高度信任第三方应用，举个不恰当的例子：如果我要在 <a target="_blank" rel="noopener" href="http://www.javaboy.org/">www.javaboy.org</a> 这个网站上接入微信登录，我使用了密码模式，那你就要在 <a target="_blank" rel="noopener" href="http://www.javaboy.org/">www.javaboy.org</a> 这个网站去输入微信的用户名密码，这肯定是不靠谱的，所以密码模式需要你非常信任第三方应用。</p>
<p>微服务中有一个特殊的场景，就是服务之间的调用，用密码模式做鉴权是非常恰当不过的了。这个以后再细说。</p>
<p>我们来看下密码模式的流程：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/04/oauth-1-9.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/oauth-1-9.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>密码式的流程比较简单：</p>
<ul>
<li>首先 <a target="_blank" rel="noopener" href="http://www.javaboy.org/">www.javaboy.org</a> 会发送一个 post 请求，类似下面这样的：</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>wx.qq.com<span class="hljs-regexp">/oauth/</span>authorize?response_type=password&amp;client_id=javaboy&amp;username=江南一点雨&amp;password=<span class="hljs-number">123</span></code></pre></div>

<p>这里的参数和前面授权码模式的略有差异，response_type 的值不一样，这里是 password，表示密码式，另外多了用户名/密码参数，没有重定向的 redirect_uri ，因为这里不需要重定向。</p>
<ul>
<li>微信校验过用户名/密码之后，直接在 HTTP 响应中把 access_token 返回给客户端。</li>
</ul>
<h4 id="3-3-4-客户端模式"><a href="#3-3-4-客户端模式" class="headerlink" title="3.3.4 客户端模式"></a>3.3.4 客户端模式</h4><p>有的应用可能没有前端页面，就是一个后台，比如</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw">Spring Boot 开发微信公众号后台，看看松哥公众号后台是怎么实现的！</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/1jTl9kBeFeibjbe5EbsCzg">Spring Boot 如何给微信公众号返回消息</a></li>
</ul>
<p>这种应用开发好了就没有后台。</p>
<p>我们来看一个客户端模式的流程图：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/04/oauth-1-10.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/oauth-1-10.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这个步骤也很简单，就两步：</p>
<ul>
<li>客户端发送一个请求到授权服务器，请求格式如下：</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">GET</span> <span class="hljs-string">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;client_id=APPID&amp;client_secret=APPSECRET</span></code></pre></div>

<p>这里有三个参数，含义如下：</p>
<p>grant_type，获取access_token填写client_credential</p>
<p>client_id 和 client_secret 用来确认客户端的身份</p>
<ul>
<li>授权服务器通过验证后，会直接返回 access_token 给客户端。</li>
</ul>
<p>大家发现，在这个过程中好像没有用户什么事了！是的，客户端模式给出的令牌，就是针对第三方应用的，而不是针对用户的。</p>
<p>在接入微信公众号后台的时候，有一个获取 Access_token 的步骤，其实就是这种模式，我截了一张微信开发平台文档的图，大家看下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2020/04/oauth-1-11.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/oauth-1-11.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="3-4-整合到SpringBoot"><a href="#3-4-整合到SpringBoot" class="headerlink" title="3.4 整合到SpringBoot"></a>3.4 整合到SpringBoot</h3><p><strong>引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security.oauth<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>配置文件</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.66.128</span>
<span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span>
<span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string">123</span>
<span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span></code></pre></div>

<p><strong>授权服务器配置（密码模式）</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableAuthorizationServer</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    AuthenticationManager authenticationManager;
    <span class="hljs-meta">@Autowired</span>
    RedisConnectionFactory redisConnectionFactory;
    <span class="hljs-meta">@Autowired</span>
    UserDetailsService userDetailsService;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();
    &#125;
    <span class="hljs-comment">//token的配置</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        clients.inMemory()
                .withClient(<span class="hljs-string">&quot;password&quot;</span>)
                .authorizedGrantTypes(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;refresh_token&quot;</span>)
                .accessTokenValiditySeconds(<span class="hljs-number">1800</span>)
                .resourceIds(<span class="hljs-string">&quot;rid&quot;</span>)
                .scopes(<span class="hljs-string">&quot;all&quot;</span>)
                .secret(<span class="hljs-string">&quot;$2a$10$kwLIAqAupvY87OM.O25.Yu1QKEXV1imAv7jWbDaQRFUFWSnSiDEwG&quot;</span>);
    &#125;
    <span class="hljs-comment">//token的存储</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        endpoints.tokenStore(<span class="hljs-keyword">new</span> RedisTokenStore(redisConnectionFactory))
                .authenticationManager(authenticationManager)
                .userDetailsService(userDetailsService);
    &#125;
    <span class="hljs-comment">//登录认证</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        security.allowFormAuthenticationForClients();
    &#125;
&#125;</code></pre></div>

<p><strong>配置资源服务器</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableResourceServer</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        resources.resourceId(<span class="hljs-string">&quot;rid&quot;</span>).stateless(<span class="hljs-keyword">true</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        http.authorizeRequests().antMatchers(<span class="hljs-string">&quot;/admin/**&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)
                .antMatchers(<span class="hljs-string">&quot;/user/**&quot;</span>).hasRole(<span class="hljs-string">&quot;user&quot;</span>)
                .anyRequest().authenticated();
    &#125;
&#125;</code></pre></div>

<p><strong>Security配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationManager();
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.userDetailsService();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        auth.inMemoryAuthentication()
                .withUser(<span class="hljs-string">&quot;javaboy&quot;</span>).password(<span class="hljs-string">&quot;$2a$10$kwLIAqAupvY87OM.O25.Yu1QKEXV1imAv7jWbDaQRFUFWSnSiDEwG&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>)
                .and()
                .withUser(<span class="hljs-string">&quot;江南一点雨&quot;</span>)
                .password(<span class="hljs-string">&quot;$2a$10$kwLIAqAupvY87OM.O25.Yu1QKEXV1imAv7jWbDaQRFUFWSnSiDEwG&quot;</span>)
                .roles(<span class="hljs-string">&quot;user&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        http.antMatcher(<span class="hljs-string">&quot;/oauth/**&quot;</span>)
                .authorizeRequests()
                .antMatchers(<span class="hljs-string">&quot;/oauth/**&quot;</span>).permitAll()
                .and().csrf().disable();
    &#125;
&#125;</code></pre></div>



<h2 id="4-JWT"><a href="#4-JWT" class="headerlink" title="4. JWT"></a>4. JWT</h2><p>在前后端分离的项目中，上面介绍了Oauth2的方式，不过 JWT 算是目前比较流行的一种解决方案了，本文就和大家来分享一下如何将 Spring Security 和 JWT 结合在一起使用，进而实现前后端分离时的登录解决方案。</p>
<h3 id="1-无状态登录"><a href="#1-无状态登录" class="headerlink" title="1 无状态登录"></a>1 无状态登录</h3><h4 id="1-1-什么是有状态？"><a href="#1-1-什么是有状态？" class="headerlink" title="1.1 什么是有状态？"></a>1.1 什么是有状态？</h4><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如Tomcat中的Session。例如登录：用户登录后，我们把用户的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session，然后下次请求，用户携带cookie值来（这一步有浏览器自动完成），我们就能识别到对应session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p>
<ul>
<li>服务端保存大量数据，增加服务端压力</li>
<li>服务端保存用户状态，不支持集群化部署</li>
</ul>
<h4 id="1-2-什么是无状态"><a href="#1-2-什么是无状态" class="headerlink" title="1.2 什么是无状态"></a>1.2 什么是无状态</h4><p>微服务集群中的每个服务，对外提供的都使用RESTful风格的接口。而RESTful风格的一个最重要的规范就是：服务的无状态性，即：</p>
<ul>
<li>服务端不保存任何客户端请求者信息</li>
<li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li>
</ul>
<p><strong>那么这种无状态性有哪些好处呢？</strong></p>
<ul>
<li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li>
<li>服务端的集群和状态对客户端透明</li>
<li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li>
<li>减小服务端存储压力</li>
</ul>
<h4 id="1-3-如何实现无状态"><a href="#1-3-如何实现无状态" class="headerlink" title="1.3.如何实现无状态"></a>1.3.如何实现无状态</h4><p>无状态登录的流程：</p>
<ul>
<li>首先客户端发送账户名/密码到服务端进行认证</li>
<li>认证通过后，服务端将用户信息加密并且编码成一个token，返回给客户端</li>
<li>以后客户端每次发送请求，都需要携带认证的token</li>
<li>服务端对客户端发送来的token进行解密，判断是否有效，并且获取用户登录信息</li>
</ul>
<h4 id="1-4-JWT"><a href="#1-4-JWT" class="headerlink" title="1.4 JWT"></a>1.4 JWT</h4><h5 id="1-4-1-简介"><a href="#1-4-1-简介" class="headerlink" title="1.4.1 简介"></a>1.4.1 简介</h5><p>JWT，全称是Json Web Token， 是一种JSON风格的轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权，JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的Java 实现是GitHub 上的开源项目 jjwt，地址如下：<code>https://github.com/jwtk/jjwt</code></p>
<h5 id="1-4-2-JWT数据格式"><a href="#1-4-2-JWT数据格式" class="headerlink" title="1.4.2 JWT数据格式"></a>1.4.2 JWT数据格式</h5><p>JWT包含三部分数据：</p>
<ul>
<li><p>Header：头部，通常头部有两部分信息：</p>
<ul>
<li>声明类型，这里是JWT</li>
<li>加密算法，自定义</li>
</ul>
<p>我们会对头部进行Base64Url编码（可解码），得到第一部分数据。</p>
</li>
<li><p>Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息：</p>
<ul>
<li>iss (issuer)：表示签发人</li>
<li>exp (expiration time)：表示token过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<p>这部分也会采用Base64Url编码，得到第二部分数据。</p>
</li>
<li><p>Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过Header中配置的加密算法生成。用于验证整个数据完整和可靠性。</p>
</li>
</ul>
<p>生成的数据格式如下图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p>
<h5 id="1-4-3-JWT交互流程"><a href="#1-4-3-JWT交互流程" class="headerlink" title="1.4.3 JWT交互流程"></a>1.4.3 JWT交互流程</h5><p>流程图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>步骤翻译：</p>
<ol>
<li>应用程序或客户端向授权服务器请求授权</li>
<li>获取到授权后，授权服务器会向应用程序返回访问令牌</li>
<li>应用程序使用访问令牌来访问受保护资源（如API）</li>
</ol>
<p>因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了RESTful的无状态规范。</p>
<h4 id="1-5-JWT-存在的问题"><a href="#1-5-JWT-存在的问题" class="headerlink" title="1.5 JWT 存在的问题"></a>1.5 JWT 存在的问题</h4><p>说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：</p>
<ol>
<li>续签问题，这是被很多人诟病的问题之一，传统的cookie+session的方案天然的支持续签，但是jwt由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入redis，虽然可以解决问题，但是jwt也变得不伦不类了。</li>
<li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改secret来实现注销，服务端secret修改后，已经颁发的未过期的token就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li>
<li>密码重置，密码重置后，原本的token依然可以访问系统，这时候也需要强制修改secret。</li>
<li>基于第2点和第3点，一般建议不同用户取不同secret。</li>
</ol>
<h3 id="2-整合到SpringBoot"><a href="#2-整合到SpringBoot" class="headerlink" title="2 整合到SpringBoot"></a>2 整合到SpringBoot</h3><h4 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h4><p>首先我们来创建一个Spring Boot项目，创建时需要添加Spring Security依赖，创建完成后，添加 <code>jjwt</code> 依赖，完整的pom.xml文件如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>然后在项目中创建一个简单的 User 对象实现 UserDetails 接口，如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> String password;
    <span class="hljs-keyword">private</span> List&lt;GrantedAuthority&gt; authorities;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> username;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-comment">//省略getter/setter</span>
&#125;</code></pre></div>

<p>这个就是我们的用户对象，先放着备用，再创建一个HelloController，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello jwt !&quot;</span>;
    &#125;
    <span class="hljs-meta">@GetMapping(&quot;/admin&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello admin !&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>HelloController 很简单，这里有两个接口，设计是 <code>/hello</code> 接口可以被具有 user 角色的用户访问，而 <code>/admin</code> 接口则可以被具有 admin 角色的用户访问。</p>
<h4 id="2-2-JWT-过滤器配置"><a href="#2-2-JWT-过滤器配置" class="headerlink" title="2.2 JWT 过滤器配置"></a>2.2 JWT 过滤器配置</h4><p>接下来提供两个和 JWT 相关的过滤器配置：</p>
<ol>
<li>一个是用户登录的过滤器，在用户的登录的过滤器中校验用户是否登录成功，如果登录成功，则生成一个token返回给客户端，登录失败则给前端一个登录失败的提示。</li>
<li>第二个过滤器则是当其他请求发送来，校验token的过滤器，如果校验成功，就让请求继续执行。</li>
</ol>
<p>这两个过滤器，我们分别来看，先看第一个：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtLoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;
    
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">JwtLoginFilter</span><span class="hljs-params">(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager)</span> </span>&#123;
    
        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(defaultFilterProcessesUrl));
        setAuthenticationManager(authenticationManager);
    &#125;
  
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;
        User user = <span class="hljs-keyword">new</span> ObjectMapper().readValue(req.getInputStream(), User.class);
        <span class="hljs-keyword">return</span> getAuthenticationManager().authenticate(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword()));
    &#125;
  
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, FilterChain chain, Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
        Collection&lt;? extends GrantedAuthority&gt; authorities = authResult.getAuthorities();
        StringBuffer as = <span class="hljs-keyword">new</span> StringBuffer();
        <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;
            as.append(authority.getAuthority())
                    .append(<span class="hljs-string">&quot;,&quot;</span>);
        &#125;
        String jwt = Jwts.builder()
                .claim(<span class="hljs-string">&quot;authorities&quot;</span>, as)<span class="hljs-comment">//配置用户角色</span>
                .setSubject(authResult.getName())
                .setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">10</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>))
                .signWith(SignatureAlgorithm.HS512,<span class="hljs-string">&quot;sang@123&quot;</span>)
                .compact();
        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
        PrintWriter out = resp.getWriter();
        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(jwt));
        out.flush();
        out.close();
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException failed)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
        resp.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);
        PrintWriter out = resp.getWriter();
        out.write(<span class="hljs-string">&quot;登录失败!&quot;</span>);
        out.flush();
        out.close();
    &#125;
&#125;</code></pre></div>

<p>关于这个类，我说如下几点：</p>
<ol>
<li>自定义 JwtLoginFilter 继承自 AbstractAuthenticationProcessingFilter，并实现其中的三个默认方法。</li>
<li>attemptAuthentication方法中，我们从登录参数中提取出用户名密码，然后调用AuthenticationManager.authenticate()方法去进行自动校验。</li>
<li>第二步如果校验成功，就会来到successfulAuthentication回调中，在successfulAuthentication方法中，将用户角色遍历然后用一个 <code>,</code> 连接起来，然后再利用Jwts去生成token，按照代码的顺序，生成过程一共配置了四个参数，分别是用户角色、主题、过期时间以及加密算法和密钥，然后将生成的token写出到客户端。</li>
<li>第二步如果校验失败就会来到unsuccessfulAuthentication方法中，在这个方法中返回一个错误提示给客户端即可。</li>
</ol>
<p>再来看第二个token校验的过滤器：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
        HttpServletRequest req = (HttpServletRequest) servletRequest;
        String jwtToken = req.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);
        System.out.println(jwtToken);
        Claims claims = Jwts.parser().setSigningKey(<span class="hljs-string">&quot;sang@123&quot;</span>).parseClaimsJws(jwtToken.replace(<span class="hljs-string">&quot;Bearer&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))
                .getBody();
        String username = claims.getSubject();<span class="hljs-comment">//获取当前登录用户名</span>
        List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(<span class="hljs-string">&quot;authorities&quot;</span>));
        UsernamePasswordAuthenticationToken token = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, <span class="hljs-keyword">null</span>, authorities);
        SecurityContextHolder.getContext().setAuthentication(token);
        filterChain.doFilter(req,servletResponse);
    &#125;
&#125;</code></pre></div>

<p>关于这个过滤器，我说如下几点：</p>
<ol>
<li>首先从请求头中提取出 authorization 字段，这个字段对应的value就是用户的token。</li>
<li>将提取出来的token字符串转换为一个Claims对象，再从Claims对象中提取出当前用户名和用户角色，创建一个UsernamePasswordAuthenticationToken放到当前的Context中，然后执行过滤链使请求继续执行下去。</li>
</ol>
<p>如此之后，两个和JWT相关的过滤器就算配置好了。</p>
<h4 id="2-3-Spring-Security-配置"><a href="#2-3-Spring-Security-配置" class="headerlink" title="2.3 Spring Security 配置"></a>2.3 Spring Security 配置</h4><p>接下来我们来配置 Spring Security,如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        auth.inMemoryAuthentication().withUser(<span class="hljs-string">&quot;admin&quot;</span>)
                .password(<span class="hljs-string">&quot;123&quot;</span>).roles(<span class="hljs-string">&quot;admin&quot;</span>)
                .and()
                .withUser(<span class="hljs-string">&quot;sang&quot;</span>)
                .password(<span class="hljs-string">&quot;456&quot;</span>)
                .roles(<span class="hljs-string">&quot;user&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        http.authorizeRequests()
                .antMatchers(<span class="hljs-string">&quot;/hello&quot;</span>).hasRole(<span class="hljs-string">&quot;user&quot;</span>)
                .antMatchers(<span class="hljs-string">&quot;/admin&quot;</span>).hasRole(<span class="hljs-string">&quot;admin&quot;</span>)
                .antMatchers(HttpMethod.POST, <span class="hljs-string">&quot;/login&quot;</span>).permitAll()
                .anyRequest().authenticated()
                .and()
                .addFilterBefore(<span class="hljs-keyword">new</span> JwtLoginFilter(<span class="hljs-string">&quot;/login&quot;</span>,authenticationManager()),UsernamePasswordAuthenticationFilter.class)
                .addFilterBefore(<span class="hljs-keyword">new</span> JwtFilter(),UsernamePasswordAuthenticationFilter.class)
                .csrf().disable();
    &#125;
&#125;</code></pre></div>

<ol>
<li>简单起见，这里我并未对密码进行加密，因此配置了NoOpPasswordEncoder的实例。</li>
<li>简单起见，这里并未连接数据库，我直接在内存中配置了两个用户，两个用户具备不同的角色。</li>
<li>配置路径规则时， <code>/hello</code> 接口必须要具备 user 角色才能访问， <code>/admin</code> 接口必须要具备 admin 角色才能访问，POST 请求并且是 <code>/login</code> 接口则可以直接通过，其他接口必须认证后才能访问。</li>
<li>最后配置上两个自定义的过滤器并且关闭掉csrf保护。</li>
</ol>
<h4 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h4><p>做完这些之后，我们的环境就算完全搭建起来了，接下来启动项目然后在 POSTMAN 中进行测试，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-4.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>登录成功后返回的字符串就是经过 base64url 转码的token，一共有三部分，通过一个 <code>.</code> 隔开，我们可以对第一个 <code>.</code> 之前的字符串进行解码，即Header，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-5.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>再对两个 <code>.</code> 之间的字符解码，即 payload：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-6.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>可以看到，我们设置信息，由于base64并不是加密方案，只是一种编码方案，因此，不建议将敏感的用户信息放到token中。</p>
<p>接下来再去访问 <code>/hello</code> 接口，注意认证方式选择 Bearer Token，Token值为刚刚获取到的值，如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20-7.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="5-区别"><a href="#5-区别" class="headerlink" title="5. 区别"></a>5. 区别</h2><h3 id="JWT和OAuth2"><a href="#JWT和OAuth2" class="headerlink" title="JWT和OAuth2"></a>JWT和OAuth2</h3><ul>
<li> oauth2有client和scope的概念，jwt没有。如果只是拿来用于颁布token的话，二者没区别。常用的bearer算法oauth、jwt都可以用。应用场景不同而已  </li>
<li>Spring Cloud 的权限框架就是用的jwt实现的oauth2 。二者没有必然联系  </li>
<li>Token功能不一样，JWT的token是包含用户基本信息的，然后通过加密的方式生成的字符串，服务器端拿到这个token之后不需要再去查询用户基本信息，解析完token之后就能拿到。想想在微服务架构下，用户服务是一个单独的服务，但是其他服务大部分情况下也会需要用户信息，难道要每次用到都去取一次吗？ JWT非常适合微服务。  </li>
<li>OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)。OAuth2是一个相对复杂的协议, 有4种授权模式, 其中的access code模式在实现时可以使用jwt才生成code, 也可以不用. 它们之间没有必然的联系. </li>
<li>JWT是用在前后端分离, 需要简单的对后台API进行保护时使用.(前后端分离无session, 频繁传用户密码不安全)  </li>
<li>JWT是一种认证协议 。JWT提供了一种用于**发布接入令牌（Access Token),**并对发布的签名接入令牌进行验证的方法。 令牌（Token）本身包含了一系列声明，应用程序可以根据这些声明限制用户对资源的访问。  </li>
<li>OAuth2是一种授权框架。提供了一套详细的授权机制（指导）。用户或应用可以通过公开的或私有的设置，授权第三方应用访问特定资源。</li>
</ul>
<p>总而言之，Oauth2和jwt是完全不同的两种东西，一个是授权认证的框架，另一种则是认证验证的方式方法（轻量级概念）。OAuth2不像JWT一样是一个严格的标准协议，因此在实施过程中更容易出错。尽管有很多现有的库，但是每个库的成熟度也不尽相同，同样很容易引入各种错误。在常用的库中也很容易发现一些安全漏洞。</p>
<h3 id="OAuth2和Shiro"><a href="#OAuth2和Shiro" class="headerlink" title="OAuth2和Shiro"></a>OAuth2和Shiro</h3><p>一、性质不同</p>
<p>1、oauth2 ：是OAuth协议的延续版本，但不向前兼容OAuth 2.0(即完全废止了OAuth1.0)。</p>
<p>2、shiro：是一个强大且易用的Java安全框架。</p>
<p>二、语言不同</p>
<p>1、oauth2 ：PHP、JavaScript，Java</p>
<p>2、shiro：Java</p>
<p>三、用途不同</p>
<p>1、oauth2 ：允许第三方应用代表用户获得访问的权限。</p>
<p>2、shiro：执行身份验证、授权、密码和会话管理。</p>
<h1 id="第十章、SpringBoot与中间件"><a href="#第十章、SpringBoot与中间件" class="headerlink" title="第十章、SpringBoot与中间件"></a>第十章、SpringBoot与中间件</h1><h2 id="1-WebSocket"><a href="#1-WebSocket" class="headerlink" title="1. WebSocket"></a>1. WebSocket</h2><h3 id="1-1-引入"><a href="#1-1-引入" class="headerlink" title="1.1 引入"></a>1.1 引入</h3><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p>
<p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p>
<p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/bg2017051507.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<a target="_blank" rel="noopener" href="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">“轮询”</a>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p>
<p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p>
<p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/bg2017051502.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>其他特点包括：</p>
<p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p>
<p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p>
<p>（3）数据格式比较轻量，性能开销小，通信高效。</p>
<p>（4）可以发送文本，也可以发送二进制数据。</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信。</p>
<p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">ws</span>:<span class="hljs-string">//example.com:80/some/path</span></code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/bg2017051503.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="1-2-整合SpringBoot"><a href="#1-2-整合SpringBoot" class="headerlink" title="1.2 整合SpringBoot"></a>1.2 整合SpringBoot</h3><h4 id="实现群聊"><a href="#实现群聊" class="headerlink" title="实现群聊"></a>实现群聊</h4><p><strong>引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--前端库集成--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sockjs-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--兼容浏览器协议--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>stomp-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--js文件的定位器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>webjars-locator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>实体类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String content;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> content;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.content = content;
    &#125;
&#125;</code></pre></div>

<p><strong>配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebSocketMessageBroker</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebSocketMessageBrokerConfigurer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageBroker</span><span class="hljs-params">(MessageBrokerRegistry registry)</span> </span>&#123;
        <span class="hljs-comment">//广播前缀</span>
        registry.enableSimpleBroker(<span class="hljs-string">&quot;/topic&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerStompEndpoints</span><span class="hljs-params">(StompEndpointRegistry registry)</span> </span>&#123;
        <span class="hljs-comment">//注册端点，定义前缀为chat的endpoint并开启sockjs的支持</span>
        registry.addEndpoint(<span class="hljs-string">&quot;/chat&quot;</span>).withSockJS();
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingController</span> </span>&#123;
    <span class="hljs-meta">@MessageMapping(&quot;/hello&quot;)</span>
    <span class="hljs-meta">@SendTo(&quot;/topic/greetings&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">greeting1</span><span class="hljs-params">(Message message)</span> </span>&#123;
        <span class="hljs-keyword">return</span> message;
    &#125;
&#125;</code></pre></div>

<p><strong>前端页面</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>群聊<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/jquery/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/sockjs-client/sockjs.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/stomp-websocket/stomp.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>请输入用户名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;connect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;连接&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;disconnect&quot;</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&quot;disabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;断开连接&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chat&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>请输入聊天内容<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;send&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;发送&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversation&quot;</span>&gt;</span>群聊进行中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">        $(<span class="hljs-string">&quot;#connect&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>
            connect();
        &#125;)
<span class="javascript">        $(<span class="hljs-string">&quot;#disconnect&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">            <span class="hljs-keyword">if</span> (stompClient != <span class="hljs-literal">null</span>) &#123;</span>
                stompClient.disconnect();
            &#125;
<span class="javascript">            setConnected(<span class="hljs-literal">false</span>);</span>
        &#125;)

<span class="javascript">        $(<span class="hljs-string">&quot;#send&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">            stompClient.send(<span class="hljs-string">&#x27;/app/hello&#x27;</span>,&#123;&#125;,<span class="hljs-built_in">JSON</span>.stringify(&#123;<span class="hljs-string">&#x27;name&#x27;</span>:$(<span class="hljs-string">&quot;#name&quot;</span>).val(),<span class="hljs-string">&#x27;content&#x27;</span>:$(<span class="hljs-string">&quot;#content&quot;</span>).val()&#125;))</span>
        &#125;)
    &#125;)

<span class="javascript">    <span class="hljs-keyword">var</span> stompClient = <span class="hljs-literal">null</span>;</span>

<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">        <span class="hljs-keyword">if</span> (!$(<span class="hljs-string">&quot;#name&quot;</span>).val()) &#123;</span>
<span class="javascript">            <span class="hljs-keyword">return</span>;</span>
        &#125;
<span class="javascript">        <span class="hljs-keyword">var</span> socket = <span class="hljs-keyword">new</span> SockJS(<span class="hljs-string">&#x27;/chat&#x27;</span>);</span>
        stompClient = Stomp.over(socket);
<span class="javascript">        stompClient.connect(&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">success</span>) </span>&#123;</span>
<span class="javascript">            setConnected(<span class="hljs-literal">true</span>);</span>
<span class="javascript">            stompClient.subscribe(<span class="hljs-string">&#x27;/topic/greetings&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span>
<span class="javascript">                showGreeting(<span class="hljs-built_in">JSON</span>.parse(msg.body));</span>
            &#125;);
        &#125;)
    &#125;

<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showGreeting</span>(<span class="hljs-params">msg</span>) </span>&#123;</span>
<span class="javascript">        $(<span class="hljs-string">&quot;#conversation&quot;</span>).append(<span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span> + msg.name + <span class="hljs-string">&#x27;:&#x27;</span> + msg.content + <span class="hljs-string">&#x27;&lt;/div&gt;&#x27;</span>);</span>
    &#125;

<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setConnected</span>(<span class="hljs-params">flag</span>) </span>&#123;</span>
<span class="javascript">        $(<span class="hljs-string">&quot;#connect&quot;</span>).prop(<span class="hljs-string">&quot;disabled&quot;</span>, flag);</span>
<span class="javascript">        $(<span class="hljs-string">&quot;#disconnect&quot;</span>).prop(<span class="hljs-string">&quot;disabled&quot;</span>, !flag);</span>
        if (flag) &#123;
<span class="javascript">            $(<span class="hljs-string">&quot;#chat&quot;</span>).show();</span>
<span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span>
<span class="javascript">            $(<span class="hljs-string">&quot;#chat&quot;</span>).hide();</span>
        &#125;
    &#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<h4 id="实现单聊"><a href="#实现单聊" class="headerlink" title="实现单聊"></a>实现单聊</h4><p><strong>引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--前端库集成--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sockjs-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--兼容浏览器协议--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>stomp-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--js文件的定位器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>webjars-locator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>实体类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String content;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> content;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.content = content;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chat</span> </span>&#123;
    <span class="hljs-keyword">private</span> String from;
    <span class="hljs-keyword">private</span> String content;
    <span class="hljs-keyword">private</span> String to;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFrom</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> from;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFrom</span><span class="hljs-params">(String from)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.from = from;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> content;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.content = content;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> to;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTo</span><span class="hljs-params">(String to)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.to = to;
    &#125;
&#125;</code></pre></div>

<p><strong>Security配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        auth.inMemoryAuthentication()
                .withUser(<span class="hljs-string">&quot;javaboy&quot;</span>)
                .password(<span class="hljs-string">&quot;123&quot;</span>)
                .roles(<span class="hljs-string">&quot;admin&quot;</span>)
                .and()
                .withUser(<span class="hljs-string">&quot;sang&quot;</span>)
                .password(<span class="hljs-string">&quot;123&quot;</span>)
                .roles(<span class="hljs-string">&quot;user&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin().permitAll();
    &#125;
&#125;</code></pre></div>

<p><strong>socket配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableWebSocketMessageBroker</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebSocketMessageBrokerConfigurer</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageBroker</span><span class="hljs-params">(MessageBrokerRegistry registry)</span> </span>&#123;
        <span class="hljs-comment">//广播前缀</span>
        registry.enableSimpleBroker(<span class="hljs-string">&quot;/topic&quot;</span>,<span class="hljs-string">&quot;/queue&quot;</span>);
        registry.setApplicationDestinationPrefixes(<span class="hljs-string">&quot;/app&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerStompEndpoints</span><span class="hljs-params">(StompEndpointRegistry registry)</span> </span>&#123;
        <span class="hljs-comment">//新版SpringBoot要开启连接域</span>
        registry.addEndpoint(<span class="hljs-string">&quot;/chat&quot;</span>).setAllowedOrigins(<span class="hljs-string">&quot;http://localhost:8080&quot;</span>).withSockJS();
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingController</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    SimpMessagingTemplate simpMessagingTemplate;

    <span class="hljs-meta">@MessageMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">greeting</span><span class="hljs-params">(Message message)</span> </span>&#123;
        simpMessagingTemplate.convertAndSend(<span class="hljs-string">&quot;/topic/greetings&quot;</span>, message);
    &#125;

    <span class="hljs-meta">@MessageMapping(&quot;/chat&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">chat</span><span class="hljs-params">(Principal principal, Chat chat)</span> </span>&#123;
        chat.setFrom(principal.getName());
        simpMessagingTemplate.convertAndSendToUser(chat.getTo(), <span class="hljs-string">&quot;/queue/chat&quot;</span>, chat);
    &#125;
&#125;</code></pre></div>

<p><strong>前端页面</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>群聊<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/jquery/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/sockjs-client/sockjs.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/webjars/stomp-websocket/stomp.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;connect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;连接&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;disconnect&quot;</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&quot;disabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;断开连接&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
消息内容：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>目标用户：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;to&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;发送&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;send&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversation&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">        $(<span class="hljs-string">&quot;#connect&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>
            connect();
        &#125;)
<span class="javascript">        $(<span class="hljs-string">&quot;#disconnect&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">            <span class="hljs-keyword">if</span> (stompClient != <span class="hljs-literal">null</span>) &#123;</span>
                stompClient.disconnect();
            &#125;
<span class="javascript">            setConnected(<span class="hljs-literal">false</span>);</span>
        &#125;)

<span class="javascript">        $(<span class="hljs-string">&quot;#send&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">            stompClient.send(<span class="hljs-string">&#x27;/app/chat&#x27;</span>, &#123;&#125;, <span class="hljs-built_in">JSON</span>.stringify(&#123;</span>
<span class="javascript">                <span class="hljs-string">&#x27;to&#x27;</span>: $(<span class="hljs-string">&quot;#to&quot;</span>).val(),</span>
<span class="javascript">                <span class="hljs-string">&#x27;content&#x27;</span>: $(<span class="hljs-string">&quot;#content&quot;</span>).val()</span>
            &#125;))
        &#125;)
    &#125;)

<span class="javascript">    <span class="hljs-keyword">var</span> stompClient = <span class="hljs-literal">null</span>;</span>

<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params"></span>) </span>&#123;</span>
<span class="javascript">        <span class="hljs-keyword">var</span> socket = <span class="hljs-keyword">new</span> SockJS(<span class="hljs-string">&#x27;/chat&#x27;</span>);</span>
        stompClient = Stomp.over(socket);
<span class="javascript">        stompClient.connect(&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">success</span>) </span>&#123;</span>
<span class="javascript">            setConnected(<span class="hljs-literal">true</span>);</span>
<span class="javascript">            stompClient.subscribe(<span class="hljs-string">&#x27;/user/queue/chat&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span>
<span class="javascript">                showGreeting(<span class="hljs-built_in">JSON</span>.parse(msg.body));</span>
            &#125;);
        &#125;)
    &#125;

<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showGreeting</span>(<span class="hljs-params">msg</span>) </span>&#123;</span>
<span class="javascript">        $(<span class="hljs-string">&quot;#conversation&quot;</span>).append(<span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span> + msg.from + <span class="hljs-string">&#x27;:&#x27;</span> + msg.content + <span class="hljs-string">&#x27;&lt;/div&gt;&#x27;</span>);</span>
    &#125;

<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setConnected</span>(<span class="hljs-params">flag</span>) </span>&#123;</span>
<span class="javascript">        $(<span class="hljs-string">&quot;#connect&quot;</span>).prop(<span class="hljs-string">&quot;disabled&quot;</span>, flag);</span>
<span class="javascript">        $(<span class="hljs-string">&quot;#disconnect&quot;</span>).prop(<span class="hljs-string">&quot;disabled&quot;</span>, !flag);</span>
        if (flag) &#123;
<span class="javascript">            $(<span class="hljs-string">&quot;#chat&quot;</span>).show();</span>
<span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span>
<span class="javascript">            $(<span class="hljs-string">&quot;#chat&quot;</span>).hide();</span>
        &#125;
    &#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<h2 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h2><h3 id="2-1-为什么要用消息队列"><a href="#2-1-为什么要用消息队列" class="headerlink" title="2.1 为什么要用消息队列"></a>2.1 为什么要用消息队列</h3><p><strong>解耦、异步、削峰</strong></p>
<p>(1)解耦</p>
<p>传统模式:</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/3436b97edc32fbfdecda61aa1543e4c11603446712357.jpeg" srcset="/img/loading.gif" lazyload alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别1"></p>
<p>传统模式的缺点：</p>
<ul>
<li>系统间耦合性太强，如上图所示，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！</li>
</ul>
<p>中间件模式:</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/2c64f4b92100a42ad84a11bd5defbeb31603446712358.jpeg" srcset="/img/loading.gif" lazyload alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别2"></p>
<p>中间件模式的的优点：</p>
<ul>
<li>将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改。</li>
</ul>
<p>(2)异步</p>
<p>传统模式:</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/8c151f9dbfdf279ae55f37c683bc52b31603446712358.jpeg" srcset="/img/loading.gif" lazyload alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别3"></p>
<p>传统模式的缺点：</p>
<ul>
<li>一些非必要的业务逻辑以同步的方式运行，太耗费时间。</li>
</ul>
<p>中间件模式:</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/e13290419111dcb5c234f01693a376b81603446712358.jpeg" srcset="/img/loading.gif" lazyload alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别4"></p>
<p>中间件模式的的优点：</p>
<ul>
<li>将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</li>
</ul>
<p>(3)削峰</p>
<p>传统模式</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/ace4c2a7886db87fd0ae0e6ed11a99511603446712360.jpeg" srcset="/img/loading.gif" lazyload alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别5"></p>
<p>传统模式的缺点：</p>
<ul>
<li>并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</li>
</ul>
<p>中间件模式:</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/582691ee877b26dec97b30a3bf23ddf71603446712360.jpeg" srcset="/img/loading.gif" lazyload alt="消息中间件：ActiveMQ、RocketMQ、RabbitMQ、Kafka一些总结和区别6"></p>
<p>中间件模式的的优点：</p>
<ul>
<li>系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。</li>
</ul>
<h3 id="2-2-消息队列的弊端"><a href="#2-2-消息队列的弊端" class="headerlink" title="2.2 消息队列的弊端"></a>2.2 消息队列的弊端</h3><ul>
<li>系统可用性降低:本来其他系统只要运行好好的，那系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统也会挂。因此，系统可用性降低</li>
<li>系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大</li>
</ul>
<h3 id="2-3-如何选用"><a href="#2-3-如何选用" class="headerlink" title="2.3 如何选用"></a>2.3 如何选用</h3><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">ActiveMQ</th>
<th align="center">RabbitMQ</th>
<th align="center">RocketMQ</th>
<th align="center">kafka</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开发语言</td>
<td align="center">java</td>
<td align="center">erlang</td>
<td align="center">java</td>
<td align="center">scala</td>
</tr>
<tr>
<td align="center">单机吞吐量</td>
<td align="center">万级</td>
<td align="center">万级</td>
<td align="center">10万级</td>
<td align="center">10万级</td>
</tr>
<tr>
<td align="center">时效性</td>
<td align="center">ms级</td>
<td align="center">us级</td>
<td align="center">ms级</td>
<td align="center">ms级以内</td>
</tr>
<tr>
<td align="center">可用性</td>
<td align="center">高(主从架构)</td>
<td align="center">高(主从架构)</td>
<td align="center">非常高(分布式架构)</td>
<td align="center">非常高(分布式架构)</td>
</tr>
<tr>
<td align="center">功能特性</td>
<td align="center">成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好</td>
<td align="center">基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富</td>
<td align="center">MQ功能比较完备，扩展性佳</td>
<td align="center">只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。</td>
</tr>
</tbody></table>
<p>(1)中小型软件公司，建议选RabbitMQ.一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。正所谓，成也萧何，败也萧何！他的弊端也在这里，虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢？所幸，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。</p>
<p>(2)大型软件公司，根据具体使用在rocketMq和kafka之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针对rocketMQ,大型软件公司也可以抽出人手对rocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。至于kafka，根据业务场景选择，如果有日志采集功能，肯定是首选kafka了。具体该选哪个，看使用场景。</p>
<h3 id="2-4-保证是高可用"><a href="#2-4-保证是高可用" class="headerlink" title="2.4 保证是高可用"></a>2.4 保证是高可用</h3><p>以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。多master多slave模式部署架构图<br><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/o_rocketcluster.png" srcset="/img/loading.gif" lazyload alt="image"><br>类似于kafka，只是NameServer集群，在kafka中是用zookeeper代替，都是用来保存和发现master和slave用的。通信过程如下:<br>Producer 与 NameServer集群中的其中一个节点（随机选择)建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker 发送心跳。Producer 只能将消息发送到 Broker master，但是 Consumer 则不一样，它同时和提供 Topic 服务的 Master 和 Slave建立长连接，既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息。</p>
<h3 id="2-5-保证消息不被重复消费"><a href="#2-5-保证消息不被重复消费" class="headerlink" title="2.5 保证消息不被重复消费"></a>2.5 保证消息不被重复消费</h3><p>分析:这个问题其实换一种问法就是，如何保证消息队列的幂等性?这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。<br><strong>回答:先来说一下为什么会造成重复消费?</strong><br>其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下(如果还不懂，出门找一个kafka入门到精通教程),就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因?，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。<br> <strong>如何解决?这个问题针对业务场景来答分以下几点</strong><br>  (1)比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。<br>  (2)再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。<br>  (3)如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</p>
<h3 id="2-6-消费的可靠性传输"><a href="#2-6-消费的可靠性传输" class="headerlink" title="2.6 消费的可靠性传输"></a>2.6 消费的可靠性传输</h3><p>分析:我们在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。如果无法做到可靠性传输，可能给公司带来千万级别的财产损失。</p>
<p>回答:其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据</p>
<p><strong>以RabbitMQ为例</strong></p>
<p>(1)生产者丢数据<br>从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p>
<p>transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p>
<p>然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作</p>
<p>(2)消息队列丢数据</p>
<p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。<br>那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步</p>
<ul>
<li><p>将queue的持久化标识durable设置为true,则代表是一个持久的队列</p>
</li>
<li><p>发送消息的时候将deliveryMode=2</p>
<p>这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据</p>
</li>
</ul>
<p>(3)消费者丢数据</p>
<p>消费者丢数据一般是因为采用了自动确认消息模式。这种模式下，消费者会自动确认收到信息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。<br>至于解决方案，采用手动确认消息即可。</p>
<h3 id="2-7-保证消息顺序性"><a href="#2-7-保证消息顺序性" class="headerlink" title="2.7 保证消息顺序性"></a>2.7 保证消息顺序性</h3><p>回答:针对这个问题，通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。</p>
<p>有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？<br>这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。</p>
<p>总之，针对这个问题，我的观点是保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路。</p>
<h2 id="3-ActiveMQ"><a href="#3-ActiveMQ" class="headerlink" title="3. ActiveMQ"></a>3. ActiveMQ</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p>下载最新的压缩包</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210526113352279.png" srcset="/img/loading.gif" lazyload alt="image-20210526113352279"></p>
<p>下载完成后在bin目录下执行<code>./activemq start</code>即可</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210526113812627.png" srcset="/img/loading.gif" lazyload alt="image-20210526113812627"></p>
<p>账号密码都是admin</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210526113848366.png" srcset="/img/loading.gif" lazyload alt="image-20210526113848366"></p>
<h3 id="3-2-整合到SpringBoot"><a href="#3-2-整合到SpringBoot" class="headerlink" title="3.2 整合到SpringBoot"></a>3.2 整合到SpringBoot</h3><p><strong>引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>配置文件</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.activemq.broker-url</span>=<span class="hljs-string">tcp://127.0.0.1:61616</span>
<span class="hljs-meta">spring.activemq.packages.trust-all</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">spring.activemq.user</span>=<span class="hljs-string">adminx</span>
<span class="hljs-meta">spring.activemq.password</span>=<span class="hljs-string">admin</span></code></pre></div>

<p><strong>启动类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivemqApplication</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(ActivemqApplication.class, args);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveMQQueue(<span class="hljs-string">&quot;hello.javaboy&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>实体类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-keyword">private</span> String content;
    <span class="hljs-keyword">private</span> Date sendDate;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> content;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +
                <span class="hljs-string">&quot;content=&#x27;&quot;</span> + content + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, sendDate=&quot;</span> + sendDate +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.content = content;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getSendDate</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> sendDate;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSendDate</span><span class="hljs-params">(Date sendDate)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.sendDate = sendDate;
    &#125;
&#125;</code></pre></div>

<p><strong>配置组件</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JmsComponent</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    JmsMessagingTemplate jmsMessagingTemplate;
    <span class="hljs-meta">@Autowired</span>
    Queue queue;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Message message)</span> </span>&#123;
        jmsMessagingTemplate.convertAndSend(<span class="hljs-keyword">this</span>.queue, message);
    &#125;

    <span class="hljs-meta">@JmsListener(destination = &quot;hello.javaboy&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(Message msg)</span> </span>&#123;
        System.out.println(msg);
    &#125;
&#125;</code></pre></div>

<h2 id="4-RabbitMQ"><a href="#4-RabbitMQ" class="headerlink" title="4. RabbitMQ"></a>4. RabbitMQ</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>安装参考Linux中的教程</p>
<h3 id="2-整合到SpringBoot-1"><a href="#2-整合到SpringBoot-1" class="headerlink" title="2.整合到SpringBoot"></a>2.整合到SpringBoot</h3><p><strong>引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>配置文件</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">192.168.66.131</span>
<span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span>
<span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span>
<span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">32771</span></code></pre></div>

<p>RabbitMQ 有四种交换机模式：</p>
<ul>
<li>Direct Pattern （此模式不需要配置交换机）</li>
<li>Fanout Pattern ( 类似于广播一样，将消息发送给和他绑定的队列 )</li>
<li>Topic Pattern ( 绑定交换机时可以做匹配。 #：表示零个或多个单词。*：表示一个单词 )</li>
<li>Header Pattern ( 带有参数的匹配规则 )</li>
</ul>
<h4 id="2-1-Direct模式"><a href="#2-1-Direct模式" class="headerlink" title="2.1 Direct模式"></a>2.1 Direct模式</h4><p>直连交换机是一种带路由功能的交换机，一个队列会和一个交换机绑定，除此之外再绑定一个<code>routing_key</code>，当消息被发送的时候，需要指定一个<code>binding_key</code>，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个<code>binding_key</code>也是支持应用到多个队列中的。这样当一个交换机绑定多个队列，就会被送到对应的队列去处理。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1479657-3f2eff8920707c97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>适用场景：有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p>
<p><strong>配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitDirectConfig</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String DIRECTNAME = <span class="hljs-string">&quot;javaboy-direct&quot;</span>;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;hello.javaboy&quot;</span>);
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DIRECTNAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Binding <span class="hljs-title">binding</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue()).to(directExchange()).with(<span class="hljs-string">&quot;direct&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>接收机</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectReceiver</span> </span>&#123;
    <span class="hljs-meta">@RabbitListener(queues = &quot;hello.javaboy&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler1</span><span class="hljs-params">(String msg)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;handler1&gt;&gt;&gt;&quot;</span>+msg);
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span>
<span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqApplicationTests</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    RabbitTemplate rabbitTemplate;
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;
        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hello.javaboy&quot;</span>, <span class="hljs-string">&quot;hello javaboy!hahaha&quot;</span>);
    &#125;
&#125;</code></pre></div>

<h4 id="2-2-Fanout模式"><a href="#2-2-Fanout模式" class="headerlink" title="2.2 Fanout模式"></a>2.2 Fanout模式</h4><p>扇形交换机是最基本的交换机类型，它所能做的事情非常简单———广播消息。扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/1200.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitFanoutConfig</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FANOUTNAME = <span class="hljs-string">&quot;javaboy-fanout&quot;</span>;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Queue <span class="hljs-title">queueOne</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue-one&quot;</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Queue <span class="hljs-title">queueTwo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;queue-two&quot;</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">FanoutExchange <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(FANOUTNAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Binding <span class="hljs-title">bindingOne</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueOne()).to(fanoutExchange());
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Binding <span class="hljs-title">bindingTwo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueTwo()).to(fanoutExchange());
    &#125;
&#125;</code></pre></div>

<p><strong>接收机</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutReceiver</span> </span>&#123;
    <span class="hljs-meta">@RabbitListener(queues = &quot;queue-one&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler1</span><span class="hljs-params">(String msg)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;FanoutReceiver:handler1:&quot;</span> + msg);
    &#125;

    <span class="hljs-meta">@RabbitListener(queues = &quot;queue-two&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler2</span><span class="hljs-params">(String msg)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;FanoutReceiver:handler2:&quot;</span> + msg);
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;
    rabbitTemplate.convertAndSend(RabbitFanoutConfig.FANOUTNAME,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;hello fanout!&quot;</span>);
&#125;</code></pre></div>

<h4 id="2-3-Topic模式"><a href="#2-3-Topic模式" class="headerlink" title="2.3 Topic模式"></a>2.3 Topic模式</h4><p>直连交换机的<code>routing_key</code>方案非常简单，如果我们希望一条消息发送给多个队列，那么这个交换机需要绑定上非常多的<code>routing_key</code>，假设每个交换机上都绑定一堆的<code>routing_key</code>连接到各个队列上。那么消息的管理就会异常地困难。</p>
<p>所以<code>RabbitMQ</code>提供了一种主题交换机，发送到主题交换机上的消息需要携带指定规则的<code>routing_key</code>，主题交换机会根据这个规则将数据发送到对应的(多个)队列上。</p>
<p>主题交换机的<code>routing_key</code>需要有一定的规则，交换机和队列的<code>binding_key</code>需要采用<code>*.#.*.....</code>的格式，每个部分用<code>.</code>分开，其中：</p>
<ul>
<li><code>*</code>表示一个单词</li>
<li><code>#</code>表示任意数量（零个或多个）单词。</li>
</ul>
<p>假设有一条消息的<code>routing_key</code>为<code>fast.rabbit.white</code>,那么带有这样<code>binding_key</code>的几个队列都会接收这条消息：</p>
<ul>
<li>fast.<em>.</em></li>
<li><em>.</em>.white</li>
<li>fast.#</li>
<li>……</li>
</ul>
<p>这个图是网上找的，感觉对主题交换机的描述比较到位：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1479657-48e5409a26f0c75b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/571" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>主题交换机</p>
<p>当一个队列的绑定键为<code>#</code>的时候，这个队列将会无视消息的路由键，接收所有的消息</p>
<p><strong>配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitTopicConfig</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPICNAME = <span class="hljs-string">&quot;javaboy-topic&quot;</span>;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">TopicExchange <span class="hljs-title">topicExchange</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(TOPICNAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Queue <span class="hljs-title">xiaomi</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;xiaomi&quot;</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Queue <span class="hljs-title">huawei</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;huawei&quot;</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Queue <span class="hljs-title">phone</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;phone&quot;</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Binding <span class="hljs-title">xiaomiBinding</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(xiaomi()).to(topicExchange()).with(<span class="hljs-string">&quot;xiaomi.#&quot;</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Binding <span class="hljs-title">huaweiBinding</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(huawei()).to(topicExchange()).with(<span class="hljs-string">&quot;huawei.#&quot;</span>);
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Binding <span class="hljs-title">phoneBinding</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(phone()).to(topicExchange()).with(<span class="hljs-string">&quot;#.phone.#&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>接收机</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopicReceiver</span> </span>&#123;
    <span class="hljs-meta">@RabbitListener(queues = &quot;xiaomi&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler1</span><span class="hljs-params">(String msg)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;TopicReceiver:handler1:&quot;</span> + msg);
    &#125;

    <span class="hljs-meta">@RabbitListener(queues = &quot;huawei&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler2</span><span class="hljs-params">(String msg)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;TopicReceiver:handler2:&quot;</span> + msg);
    &#125;

    <span class="hljs-meta">@RabbitListener(queues = &quot;phone&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler3</span><span class="hljs-params">(String msg)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;TopicReceiver:handler3:&quot;</span> + msg);
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;
    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, <span class="hljs-string">&quot;xiaomi.news&quot;</span>, <span class="hljs-string">&quot;小米新闻&quot;</span>);
    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, <span class="hljs-string">&quot;vivo.phone&quot;</span>, <span class="hljs-string">&quot;vivo 手机&quot;</span>);
    rabbitTemplate.convertAndSend(RabbitTopicConfig.TOPICNAME, <span class="hljs-string">&quot;huawei.phone&quot;</span>, <span class="hljs-string">&quot;华为手机&quot;</span>);
&#125;</code></pre></div>

<h4 id="2-4-Header模式"><a href="#2-4-Header模式" class="headerlink" title="2.4 Header模式"></a>2.4 Header模式</h4><p>首部交换机是忽略<code>routing_key</code>的一种路由方式。路由器和交换机路由的规则是通过<code>Headers</code>信息来交换的，这个有点像<code>HTTP</code>的<code>Headers</code>。将一个交换机声明成首部交换机，绑定一个队列的时候，定义一个<code>Hash</code>的数据结构，消息发送的时候，会携带一组hash数据结构的信息，当<code>Hash</code>的内容匹配上的时候，消息就会被写入队列。</p>
<p>绑定<code>交换机</code>和队列的时候，Hash结构中要求携带一个键<code>“x-match”</code>，这个键的<code>Value</code>可以是<code>any</code>或者<code>all</code>，这代表消息携带的<code>Hash</code>是需要<code>全部匹配(all)</code>，还是<code>仅匹配一个键</code>(any)就可以了。相比直连交换机，首部交换机的优势是匹配的规则<code>不被</code>限定为字符串(string)</p>
<p><strong>配置类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitHeaderConfig</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HEADERNAME = <span class="hljs-string">&quot;javaboy-header&quot;</span>;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">HeadersExchange <span class="hljs-title">headersExchange</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeadersExchange(HEADERNAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Queue <span class="hljs-title">queueName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;name-queue&quot;</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Queue <span class="hljs-title">queueAge</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;age-queue&quot;</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Binding <span class="hljs-title">bindingName</span><span class="hljs-params">()</span> </span>&#123;
        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);
        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueName()).to(headersExchange()).whereAny(map).match();
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function">Binding <span class="hljs-title">bindingAge</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueAge()).to(headersExchange()).where(<span class="hljs-string">&quot;age&quot;</span>).exists();
    &#125;
&#125;</code></pre></div>

<p><strong>接收机</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeaderReceiver</span> </span>&#123;
    <span class="hljs-meta">@RabbitListener(queues = &quot;name-queue&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler1</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] msg)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;HeaderReceiver:handler1:&quot;</span> + <span class="hljs-keyword">new</span> String(msg, <span class="hljs-number">0</span>, msg.length));
    &#125;

    <span class="hljs-meta">@RabbitListener(queues = &quot;age-queue&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler2</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] msg)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;HeaderReceiver:handler2:&quot;</span> + <span class="hljs-keyword">new</span> String(msg, <span class="hljs-number">0</span>, msg.length));
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;
    Message nameMsg = MessageBuilder.withBody(<span class="hljs-string">&quot;hello javaboy !&quot;</span>.getBytes()).setHeader(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;江南一点雨&quot;</span>).build();
    Message ageMsg = MessageBuilder.withBody(<span class="hljs-string">&quot;hello 99 !&quot;</span>.getBytes()).setHeader(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;99&quot;</span>).build();
    rabbitTemplate.send(RabbitHeaderConfig.HEADERNAME, <span class="hljs-keyword">null</span>, ageMsg);
    rabbitTemplate.send(RabbitHeaderConfig.HEADERNAME, <span class="hljs-keyword">null</span>, nameMsg);
&#125;</code></pre></div>

<h1 id="第十一章、SpringBoot企业级开发"><a href="#第十一章、SpringBoot企业级开发" class="headerlink" title="第十一章、SpringBoot企业级开发"></a>第十一章、SpringBoot企业级开发</h1><h2 id="1-邮件"><a href="#1-邮件" class="headerlink" title="1. 邮件"></a>1. 邮件</h2><h3 id="1-1-邮件协议"><a href="#1-1-邮件协议" class="headerlink" title="1.1 邮件协议"></a>1.1 邮件协议</h3><p>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。 </p>
<p>SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。 </p>
<p>生活中我们投递一封邮件要经过如下几个步骤： </p>
<ol>
<li>深圳的小王先将邮件投递到深圳的邮局 </li>
<li>深圳的邮局将邮件运送到上海的邮局 </li>
<li>上海的小张来邮局取邮件 </li>
</ol>
<p>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:aaa@qq.com">aaa@qq.com</a> 发送邮件到 <a href="mailto:111@163.com">111@163.com</a> ： </p>
<ol>
<li><a href="mailto:aaa@qq.com">aaa@qq.com</a> 先将邮件投递到腾讯的邮件服务器 </li>
<li>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器 </li>
<li><a href="mailto:111@163.com">111@163.com</a> 登录网易的邮件服务器查看邮件 </li>
</ol>
<p>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。 </p>
<p>SMTP 协议全称为 <code>Simple Mail Transfer Protocol</code>，译作简单邮件传输协议，它定义了邮件客户端软件于 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p>
<p>也就是说 <a href="mailto:aaa@qq.com">aaa@qq.com</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p>
<p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:111@163.com">111@163.com</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p>
<h3 id="1-2-邮件发送"><a href="#1-2-邮件发送" class="headerlink" title="1.2 邮件发送"></a>1.2 邮件发送</h3><p><strong>项目创建</strong></p>
<p>接下来，我们就可以创建项目了，Spring Boot 中，对于邮件发送提供了自动配置类，开发者只需要加入相关依赖，然后配置一下邮箱的基本信息，就可以发送邮件了。</p>
<ul>
<li>首先创建一个 Spring Boot 项目，引入邮件发送依赖：</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.javaboy.org/images/boot2/43-4.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/43-4.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>创建完成后，项目依赖如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<ul>
<li>配置邮箱基本信息</li>
</ul>
<p>项目创建成功后，接下来在 application.properties 中配置邮箱的基本信息：</p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.mail.host</span>=<span class="hljs-string">smtp.qq.com</span>
<span class="hljs-meta">spring.mail.port</span>=<span class="hljs-string">587</span>
<span class="hljs-meta">spring.mail.username</span>=<span class="hljs-string">xxxx@xxx.com</span>
<span class="hljs-meta">spring.mail.password</span>=<span class="hljs-string">xxxx</span>
<span class="hljs-meta">spring.mail.default-encoding</span>=<span class="hljs-string">UTF-8</span>
<span class="hljs-meta">spring.mail.properties.mail.smtp.socketFactoryClass</span>=<span class="hljs-string">javax.net.ssl.SSLSocketFactory</span>
<span class="hljs-meta">spring.mail.properties.mail.debug</span>=<span class="hljs-string">true</span></code></pre></div>

<p>配置含义分别如下：</p>
<ul>
<li>配置 SMTP 服务器地址</li>
<li>SMTP 服务器的端口</li>
<li>配置邮箱用户名</li>
<li>配置密码，注意，不是真正的密码，而是刚刚申请到的授权码</li>
<li>默认的邮件编码</li>
<li>配饰 SSL 加密工厂</li>
<li>表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</li>
</ul>
<p>如果不知道 smtp 服务器的端口或者地址的的话，可以参考 腾讯的邮箱文档</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371</a></li>
</ul>
<p>做完这些之后，Spring Boot 就会自动帮我们配置好邮件发送类，相关的配置在 <code>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration</code> 类中，部分源码如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ConditionalOnClass(&#123; MimeMessage.class, MimeType.class, MailSender.class &#125;)</span>
<span class="hljs-meta">@ConditionalOnMissingBean(MailSender.class)</span>
<span class="hljs-meta">@Conditional(MailSenderCondition.class)</span>
<span class="hljs-meta">@EnableConfigurationProperties(MailProperties.class)</span>
<span class="hljs-meta">@Import(&#123; MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class &#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderAutoConfiguration</span> </span>&#123;
&#125;</code></pre></div>

<p>从这段代码中，可以看到，导入了另外一个配置 <code>MailSenderPropertiesConfiguration</code> 类，这个类中，提供了邮件发送相关的工具类：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;spring.mail&quot;, name = &quot;host&quot;)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderPropertiesConfiguration</span> </span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MailProperties properties;
        MailSenderPropertiesConfiguration(MailProperties properties) &#123;
                <span class="hljs-keyword">this</span>.properties = properties;
        &#125;
        <span class="hljs-meta">@Bean</span>
        <span class="hljs-meta">@ConditionalOnMissingBean</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> JavaMailSenderImpl <span class="hljs-title">mailSender</span><span class="hljs-params">()</span> </span>&#123;
                JavaMailSenderImpl sender = <span class="hljs-keyword">new</span> JavaMailSenderImpl();
                applyProperties(sender);
                <span class="hljs-keyword">return</span> sender;
        &#125;
&#125;</code></pre></div>

<p>可以看到，这里创建了一个 <code>JavaMailSenderImpl</code> 的实例， <code>JavaMailSenderImpl</code> 是 <code>JavaMailSender</code> 的一个实现，我们将使用 <code>JavaMailSenderImpl</code> 来完成邮件的发送工作。</p>
<h4 id="简单邮件"><a href="#简单邮件" class="headerlink" title="简单邮件"></a>简单邮件</h4><p>简单邮件就是指邮件内容是一个普通的文本文档：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
JavaMailSender javaMailSender;
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSimpleMail</span><span class="hljs-params">()</span> </span>&#123;
    SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();
    message.setSubject(<span class="hljs-string">&quot;这是一封测试邮件&quot;</span>);
    message.setFrom(<span class="hljs-string">&quot;1510161612@qq.com&quot;</span>);
    message.setTo(<span class="hljs-string">&quot;25xxxxx755@qq.com&quot;</span>);
    message.setCc(<span class="hljs-string">&quot;37xxxxx37@qq.com&quot;</span>);
    message.setBcc(<span class="hljs-string">&quot;14xxxxx098@qq.com&quot;</span>);
    message.setSentDate(<span class="hljs-keyword">new</span> Date());
    message.setText(<span class="hljs-string">&quot;这是测试邮件的正文&quot;</span>);
    javaMailSender.send(message);
&#125;</code></pre></div>

<p>从上往下，代码含义分别如下：</p>
<ul>
<li>构建一个邮件对象</li>
<li>设置邮件主题</li>
<li>设置邮件发送者</li>
<li>设置邮件接收者，可以有多个接收者</li>
<li>设置邮件抄送人，可以有多个抄送人</li>
<li>设置隐秘抄送人，可以有多个</li>
<li>设置邮件发送日期</li>
<li>设置邮件的正文</li>
<li>发送邮件</li>
</ul>
<h4 id="带附件的邮件"><a href="#带附件的邮件" class="headerlink" title="带附件的邮件"></a>带附件的邮件</h4><p>邮件的附件可以是图片，也可以是普通文件，都是支持的。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAttachFileMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;
    MimeMessage mimeMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage,<span class="hljs-keyword">true</span>);
    helper.setSubject(<span class="hljs-string">&quot;这是一封测试邮件&quot;</span>);
    helper.setFrom(<span class="hljs-string">&quot;1510161612@qq.com&quot;</span>);
    helper.setTo(<span class="hljs-string">&quot;25xxxxx755@qq.com&quot;</span>);
    helper.setCc(<span class="hljs-string">&quot;37xxxxx37@qq.com&quot;</span>);
    helper.setBcc(<span class="hljs-string">&quot;14xxxxx098@qq.com&quot;</span>);
    helper.setSentDate(<span class="hljs-keyword">new</span> Date());
    helper.setText(<span class="hljs-string">&quot;这是测试邮件的正文&quot;</span>);
    helper.addAttachment(<span class="hljs-string">&quot;javaboy.jpg&quot;</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\sang\\Downloads\\javaboy.png&quot;</span>));
    javaMailSender.send(mimeMessage);
&#125;</code></pre></div>

<p>注意这里在构建邮件对象上和前文有所差异，这里是通过 javaMailSender 来获取一个复杂邮件对象，然后再利用 MimeMessageHelper 对邮件进行配置，MimeMessageHelper 是一个邮件配置的辅助工具类，创建时候的 true 表示构建一个 multipart message 类型的邮件，有了 MimeMessageHelper 之后，我们针对邮件的配置都是由 MimeMessageHelper 来代劳。最后通过 addAttachment 方法来添加一个附件。</p>
<h4 id="图片资源的邮件"><a href="#图片资源的邮件" class="headerlink" title="图片资源的邮件"></a>图片资源的邮件</h4><p>图片资源和附件有什么区别呢？图片资源是放在邮件正文中的，即一打开邮件，就能看到图片。但是一般来说，不建议使用这种方式，一些公司会对邮件内容的大小有限制（因为这种方式是将图片一起发送的）。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendImgResMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;
    MimeMessage mimeMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);
    helper.setSubject(<span class="hljs-string">&quot;这是一封测试邮件&quot;</span>);
    helper.setFrom(<span class="hljs-string">&quot;1510161612@qq.com&quot;</span>);
    helper.setTo(<span class="hljs-string">&quot;25xxxxx755@qq.com&quot;</span>);
    helper.setCc(<span class="hljs-string">&quot;37xxxxx37@qq.com&quot;</span>);
    helper.setBcc(<span class="hljs-string">&quot;14xxxxx098@qq.com&quot;</span>);
    helper.setSentDate(<span class="hljs-keyword">new</span> Date());
    helper.setText(<span class="hljs-string">&quot;&lt;p&gt;hello 大家好，这是一封测试邮件，这封邮件包含两种图片，分别如下&lt;/p&gt;&lt;p&gt;第一张图片：&lt;/p&gt;&lt;img src=&#x27;cid:p01&#x27;/&gt;&lt;p&gt;第二张图片：&lt;/p&gt;&lt;img src=&#x27;cid:p02&#x27;/&gt;&quot;</span>,<span class="hljs-keyword">true</span>);
    helper.addInline(<span class="hljs-string">&quot;p01&quot;</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\sang\\Downloads\\javaboy.png&quot;</span>)));
    helper.addInline(<span class="hljs-string">&quot;p02&quot;</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\sang\\Downloads\\javaboy2.png&quot;</span>)));
    javaMailSender.send(mimeMessage);
&#125;</code></pre></div>

<p>这里的邮件 text 是一个 HTML 文本，里边涉及到的图片资源先用一个占位符占着，setText 方法的第二个参数 true 表示第一个参数是一个 HTML 文本。setText 之后，再通过 addInline 方法来添加图片资源。</p>
<h3 id="1-3-Freemarker邮件"><a href="#1-3-Freemarker邮件" class="headerlink" title="1.3 Freemarker邮件"></a>1.3 Freemarker邮件</h3><p>首先需要引入 Freemarker 依赖：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>然后在 <code>resources/templates</code> 目录下创建一个 <code>mail.ftl</code> 作为邮件发送模板：</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;salary&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: #ff1a0e&quot;</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>接下来，将邮件模板渲染成 HTML ，然后发送即可。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFreemarkerMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException, IOException, TemplateException </span>&#123;
    MimeMessage mimeMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);
    helper.setSubject(<span class="hljs-string">&quot;这是一封测试邮件&quot;</span>);
    helper.setFrom(<span class="hljs-string">&quot;1510161612@qq.com&quot;</span>);
    helper.setTo(<span class="hljs-string">&quot;25xxxxx755@qq.com&quot;</span>);
    helper.setCc(<span class="hljs-string">&quot;37xxxxx37@qq.com&quot;</span>);
    helper.setBcc(<span class="hljs-string">&quot;14xxxxx098@qq.com&quot;</span>);
    helper.setSentDate(<span class="hljs-keyword">new</span> Date());
    <span class="hljs-comment">//构建 Freemarker 的基本配置</span>
    Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_0);
    <span class="hljs-comment">// 配置模板位置</span>
    ClassLoader loader = MailApplication.class.getClassLoader();
    configuration.setClassLoaderForTemplateLoading(loader, <span class="hljs-string">&quot;templates&quot;</span>);
    <span class="hljs-comment">//加载模板</span>
    Template template = configuration.getTemplate(<span class="hljs-string">&quot;mail.ftl&quot;</span>);
    User user = <span class="hljs-keyword">new</span> User();
    user.setUsername(<span class="hljs-string">&quot;javaboy&quot;</span>);
    user.setNum(<span class="hljs-number">1</span>);
    user.setSalary((<span class="hljs-keyword">double</span>) <span class="hljs-number">99999</span>);
    StringWriter out = <span class="hljs-keyword">new</span> StringWriter();
    <span class="hljs-comment">//模板渲染，渲染的结果将被保存到 out 中 ，将out 中的 html 字符串发送即可</span>
    template.process(user, out);
    helper.setText(out.toString(),<span class="hljs-keyword">true</span>);
    javaMailSender.send(mimeMessage);
&#125;</code></pre></div>

<p>需要注意的是，虽然引入了 <code>Freemarker</code> 的自动化配置，但是我们在这里是直接 <code>new Configuration</code> 来重新配置 <code>Freemarker</code> 的，所以 Freemarker 默认的配置这里不生效，因此，在填写模板位置时，值为 <code>templates</code> </p>
<h3 id="1-4-Thymeleaf邮件"><a href="#1-4-Thymeleaf邮件" class="headerlink" title="1.4 Thymeleaf邮件"></a>1.4 Thymeleaf邮件</h3><p>推荐在 Spring Boot 中使用 Thymeleaf 来构建邮件模板。因为 Thymeleaf 的自动化配置提供了一个 TemplateEngine，通过 TemplateEngine 可以方便的将 Thymeleaf 模板渲染为 HTML ，同时，Thymeleaf 的自动化配置在这里是继续有效的 。</p>
<p>首先，引入 Thymeleaf 依赖：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>然后，创建 <code>Thymeleaf</code> 邮件模板：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">&lt;!DOCTYPE html&gt;
&lt;html lang=<span class="hljs-string">&quot;en&quot;</span> xmlns:th=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;
&lt;head&gt;
    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;hello 欢迎加入 xxx 大家庭，您的入职信息如下：&lt;/p&gt;
&lt;table border=<span class="hljs-string">&quot;1&quot;</span>&gt;
    &lt;tr&gt;
        &lt;td&gt;姓名&lt;/td&gt;
        &lt;td th:text=&quot;$&#123;username&#125;&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;工号&lt;/td&gt;
        &lt;td th:text=&quot;$&#123;num&#125;&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;薪水&lt;/td&gt;
        &lt;td th:text=&quot;$&#123;salary&#125;&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;div style=&quot;color: #ff1a0e&quot;&gt;一起努力创造辉煌&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>

<p>接下来发送邮件：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
TemplateEngine templateEngine;

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendThymeleafMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;
    MimeMessage mimeMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);
    helper.setSubject(<span class="hljs-string">&quot;这是一封测试邮件&quot;</span>);
    helper.setFrom(<span class="hljs-string">&quot;1510161612@qq.com&quot;</span>);
    helper.setTo(<span class="hljs-string">&quot;25xxxxx755@qq.com&quot;</span>);
    helper.setCc(<span class="hljs-string">&quot;37xxxxx37@qq.com&quot;</span>);
    helper.setBcc(<span class="hljs-string">&quot;14xxxxx098@qq.com&quot;</span>);
    helper.setSentDate(<span class="hljs-keyword">new</span> Date());
    Context context = <span class="hljs-keyword">new</span> Context();
    context.setVariable(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;javaboy&quot;</span>);
    context.setVariable(<span class="hljs-string">&quot;num&quot;</span>,<span class="hljs-string">&quot;000001&quot;</span>);
    context.setVariable(<span class="hljs-string">&quot;salary&quot;</span>, <span class="hljs-string">&quot;99999&quot;</span>);
    String process = templateEngine.process(<span class="hljs-string">&quot;mail.html&quot;</span>, context);
    helper.setText(process,<span class="hljs-keyword">true</span>);
    javaMailSender.send(mimeMessage);
&#125;</code></pre></div>

<h1 id="第十二章、SpringBoot应用监控"><a href="#第十二章、SpringBoot应用监控" class="headerlink" title="第十二章、SpringBoot应用监控"></a>第十二章、SpringBoot应用监控</h1><p>应用监控是我们在生产环境下一个非常重要的东西，运维人员不可能 24 小时盯着应用，应用挂了及时解决，这不现实。我们需要能够实时掌握应用的运行数据，以便提早发现问题，同时在应用挂掉的时候还能够自动报警，这样才能解放开发人员。</p>
<p>Spring Boot 中也提供了生产级的应用监控方案，对于单体应用、微服务应用都有相应的解决方案，今天松哥就想来和大家捋一捋 Spring Boot 中的应用监控方案都有哪些。</p>
<p>首先我们来捋一下应用监控都需要哪些东西？其实就两点：</p>
<ul>
<li>信息采集器</li>
<li>数据可视化 UI</li>
</ul>
<p>信息采集器会收集应用的健康、审计、指标、HTTP 请求等信息，并将之暴露出来，数据可视化 UI 则会通过仪表盘、图形等展示这些数据，并对数据进行分析、报警等处理。我们分别来看。</p>
<h2 id="1-Spring-Boot-Actuator"><a href="#1-Spring-Boot-Actuator" class="headerlink" title="1. Spring Boot Actuator"></a>1. Spring Boot Actuator</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>在 Spring Boot 项目中，我们使用的信息采集器主要就是 Spring Boot Actuator，这个模块由 Spring Boot 官方提供，它包含了许多生产级别的功能，例如健康检查、审计、指标收集、HTTP 请求追踪等，Spring Boot Actuator 将这些信息收集起来后，通过 HTTP 和 JMX 两种方式暴露给外部模块。例如 Spring Boot Actuator 通过 <code>/health</code> 端点（endpoints）提供了应用的健康信息，开发者只需要访问该端点就可以看到应用的健康信息，但是这些端点返回的数据是 JSON 格式的，不方便查看，也不方便分析，所以一般情况下，Spring Boot Actuator 都是和一些外部模块一起使用。</p>
<p>Spring Boot Actuator 支持的端点主要有如下一些：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2021/02/20210201202406.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20210201202406.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>如果是 Web 应用，则再次基础上还支持如下端点：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2021/02/20210201202855.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20210201202855.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>提到 Spring Boot Actuator，就还有一个东西需要和大家介绍，那就是 Micrometer，从 Spring Boot2.0 开始，Actuator 底层改为了 Micrometer。</p>
<p>当我们在一个 Spring Boot 项目中引入 Actuator 依赖之后，我们会发现它里边包含了 Micrometer：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2021/01/spring-cloud/20210201162644.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20210201162644.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标即可，而 Micrometer 则会负责完成与不同监控系统的适配工作，类似于一个 Adapter，有了这个 Adapter，切换监控系统就变得非常容易。同时 Micrometer 还支持推送数据到多个不同的监控系统。</p>
<p>而 Spring Boot Actuator 使用 Micrometer 与外部应用监视系统进行集成，这样一来，开发者只需要稍微配置一下就可以使其和外部应用监视系统进行整合了。Micrometer 支持的监控系统有：</p>
<ul>
<li>AppOptics</li>
<li>Atlas</li>
<li>Datadog</li>
<li>Dynatrace</li>
<li>Elastic</li>
<li>Ganglia</li>
<li>Graphite</li>
<li>Humio</li>
<li>Influx</li>
<li>JMX</li>
<li>KairosDB</li>
<li>New Relic</li>
<li>Prometheus</li>
<li>SignalFx</li>
<li>Simple (in-memory)</li>
<li>StatsD</li>
<li>Wavefront</li>
</ul>
<h3 id="1-2-整合到SpringBoot"><a href="#1-2-整合到SpringBoot" class="headerlink" title="1.2 整合到SpringBoot"></a>1.2 整合到SpringBoot</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p><strong>引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>启动后可以看到</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210527112349779.png" srcset="/img/loading.gif" lazyload alt="image-20210527112349779"></p>
<p><strong>配置文件</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span>
<span class="hljs-comment"># 开启优雅的关闭</span>
<span class="hljs-meta">management.endpoints.shutdown.enabled</span>=<span class="hljs-string">true</span>

<span class="hljs-comment">#SecurityConfig</span>
<span class="hljs-meta">spring.security.user.name</span>=<span class="hljs-string">javaboy</span>
<span class="hljs-meta">spring.security.user.password</span>=<span class="hljs-string">123</span>
<span class="hljs-meta">spring.security.user.roles</span>=<span class="hljs-string">ADMIN</span></code></pre></div>

<p><strong>Security配置</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        http.requestMatcher(EndpointRequest.toAnyEndpoint())
                .authorizeRequests()
                .anyRequest().hasRole(<span class="hljs-string">&quot;ADMIN&quot;</span>)
                .and()
                .httpBasic().and().csrf().disable();
    &#125;
&#125;</code></pre></div>

<h4 id="配置路径映射"><a href="#配置路径映射" class="headerlink" title="配置路径映射"></a>配置路径映射</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 以/开头</span>
<span class="hljs-meta">management.endpoints.web.base-path</span>=<span class="hljs-string">/</span>
<span class="hljs-comment"># bs代替beans</span>
<span class="hljs-meta">management.endpoints.web.path-mapping.beans</span>=<span class="hljs-string">bs</span></code></pre></div>

<h4 id="支持跨域"><a href="#支持跨域" class="headerlink" title="支持跨域"></a>支持跨域</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">management.endpoints.web.cors.allowed-origins</span>=<span class="hljs-string">http://localhost:8888</span>
<span class="hljs-meta">management.endpoints.web.cors.allowed-methods</span>=<span class="hljs-string">GET,POST</span></code></pre></div>

<h4 id="健康信息"><a href="#健康信息" class="headerlink" title="健康信息"></a>健康信息</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">management.endpoint.health.show-details</span>=<span class="hljs-string">when_authorized</span>
<span class="hljs-meta">management.endpoint.health.roles</span>=<span class="hljs-string">ADMIN</span>
<span class="hljs-meta">management.endpoint.health.status.order</span>=<span class="hljs-string">FATAL,DOWN,OUT_OF_SERVICE,UP,UNKNOWN</span>
<span class="hljs-meta">management.endpoint.health.status.http-mapping.FATAL</span>=<span class="hljs-string">503</span></code></pre></div>

<p>自定义健康</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaboyHealth</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HealthIndicator</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Health <span class="hljs-title">health</span><span class="hljs-params">()</span> </span>&#123;
 <span class="hljs-comment">//       return Health.status(&quot;FATAL&quot;).withDetail(&quot;msg&quot;,&quot;发现严重问题&quot;).build();</span>
       <span class="hljs-keyword">return</span> Health.up().withDetail(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;一切正常...&quot;</span>).build();
    &#125;
&#125;</code></pre></div>

<h4 id="应用信息"><a href="#应用信息" class="headerlink" title="应用信息"></a>应用信息</h4><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">info.app.encoding</span>=<span class="hljs-string">@project.build.sourceEncoding@</span>
<span class="hljs-meta">info.app.java.source</span>=<span class="hljs-string">@java.version@</span>
<span class="hljs-meta">info.app.java.target</span>=<span class="hljs-string">@java.version@</span>
<span class="hljs-meta">info.author.name</span>=<span class="hljs-string">lucifer</span>
<span class="hljs-meta">info.author.email</span>=<span class="hljs-string">xx@qq.com</span></code></pre></div>

<p>或者在配置类中定义</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InfoContributor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contribute</span><span class="hljs-params">(Info.Builder builder)</span> </span>&#123;
        Map&lt;String, String&gt; link = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        link.put(<span class="hljs-string">&quot;site&quot;</span>, <span class="hljs-string">&quot;www.javaboy.org&quot;</span>);
        link.put(<span class="hljs-string">&quot;site-2&quot;</span>, <span class="hljs-string">&quot;www.itboyhub.com&quot;</span>);
        builder.withDetail(<span class="hljs-string">&quot;link&quot;</span>, link);
    &#125;
&#125;</code></pre></div>

<h4 id="git相关"><a href="#git相关" class="headerlink" title="git相关"></a>git相关</h4><p>引入依赖</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>pl.project13.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>git-commit-id-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210527115729859.png" srcset="/img/loading.gif" lazyload alt="image-20210527115729859"></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">management.info.git.mode</span>=<span class="hljs-string">full</span></code></pre></div>

<h4 id="构建信息"><a href="#构建信息" class="headerlink" title="构建信息"></a>构建信息</h4><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build-info<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210527115712060.png" srcset="/img/loading.gif" lazyload alt="image-20210527115712060"></p>
<h3 id="1-3-Admin"><a href="#1-3-Admin" class="headerlink" title="1.3 Admin"></a>1.3 Admin</h3><p>这个算是 Spring Boot 中最最正宗的应用监控可视化工具了，看名字就知道有多正宗，当我们创建一个 Spring Boot 项目时，选择依赖时候就有这个选项：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2021/02/20210201173448.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20210201173448.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>如果是<strong>单体应用</strong>很多人可能会选择 Spring Boot Admin 作为监控数据可视化工具，不过它也支持微服务应用的(可以通过 Eureka、Consul 等注册中心获取应用信息)，只不过在微服务中，我们可能会更多的选择 Grafana+Prometheus 组合。</p>
<p>Spring Boot Admin 主要包含如下功能：</p>
<ul>
<li>显示应用健康信息。</li>
<li>显示应用运行的详细信息，例如 JVM 和内存指标、数据源指标、缓存指标等等。</li>
<li>显示应用的构建信息。</li>
<li>查看 JVM 系统和环境属性</li>
<li>查看 Spring Boot 配置属性</li>
<li>支持 Spring Cloud 中的端点刷新功能 /refresh-endpoint</li>
<li>方便的日志级别管理功能</li>
<li>可以与 JMX-beans 进行交互</li>
<li>查看 Thread dump</li>
<li>查看 http 请求</li>
<li>查看计划任务</li>
<li>查看和删除活动会话</li>
<li>查看 Flyway/Liquibase 数据库迁移</li>
<li>下载 heapdump</li>
<li>状态更改通知</li>
<li>…</li>
</ul>
<p>可以看到，Spring Boot Admin 不仅仅是将 Actuator 接口中的数据进行可视化，还在此基础上提供了分析、报警等功能。</p>
<p>Spring Boot Admin 的显示界面如下：</p>
<p><a target="_blank" rel="noopener" href="http://img.itboyhub.com/2021/02/20210201181913.png"><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/20210201181913.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>原本客户端上引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>这里服务端引入依赖</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>启动类</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableAdminServer</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminApplication</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(AdminApplication.class, args);
    &#125;

&#125;</code></pre></div>

<p><strong>服务器文件配置</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span>
<span class="hljs-meta">spring.boot.admin.instance-auth.default-user-name</span>=<span class="hljs-string">javaboy</span>
<span class="hljs-meta">spring.boot.admin.instance-auth.default-password</span>=<span class="hljs-string">123</span></code></pre></div>

<p><strong>客户端文件配置</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.boot.admin.client.url</span>=<span class="hljs-string">http://localhost:8081</span></code></pre></div>

<h3 id="1-4-邮件报警"><a href="#1-4-邮件报警" class="headerlink" title="1.4 邮件报警"></a>1.4 邮件报警</h3><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.mail.host</span>=<span class="hljs-string">smtp.qq.com</span>
<span class="hljs-meta">spring.mail.port</span>=<span class="hljs-string">465</span>
<span class="hljs-meta">spring.mail.username</span>=<span class="hljs-string">1510161612@qq.com</span>
<span class="hljs-meta">spring.mail.password</span>=<span class="hljs-string">laikremaxeyqfgbj</span>
<span class="hljs-meta">spring.mail.default-encoding</span>=<span class="hljs-string">utf-8</span>
<span class="hljs-meta">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="hljs-string">javax.net.ssl.SSLSocketFactory</span>
<span class="hljs-meta">spring.mail.properties.mail.debug</span>=<span class="hljs-string">true</span>

<span class="hljs-meta">spring.boot.admin.notify.mail.from</span>=<span class="hljs-string">1510161612@qq.com</span>
<span class="hljs-meta">spring.boot.admin.notify.mail.to</span>=<span class="hljs-string">1470249098@qq.com</span>
<span class="hljs-comment">#状态发生变化就发</span>
<span class="hljs-meta">spring.boot.admin.notify.mail.ignore-changes</span>=<span class="hljs-string"></span></code></pre></div>

<h1 id="第十三章、SpringBoot打包发布"><a href="#第十三章、SpringBoot打包发布" class="headerlink" title="第十三章、SpringBoot打包发布"></a>第十三章、SpringBoot打包发布</h1><h2 id="1-可执行Jar"><a href="#1-可执行Jar" class="headerlink" title="1. 可执行Jar"></a>1. 可执行Jar</h2><p>Spring Boot 中默认打包成的 jar 叫做 可执行 jar，这种 jar 不同于普通的 jar，普通的 jar 不可以通过 <code>java -jar xxx.jar</code> 命令执行，普通的 <code>jar</code> 主要是被其他应用依赖，<code>Spring Boot</code> 打成的 <code>jar</code> 可以执行，但是不可以被其他的应用所依赖，即使强制依赖，也无法获取里边的类。但是可执行 jar 并不是 Spring Boot 独有的，Java 工程本身就可以打包成可执行 jar 。</p>
<p>有的小伙伴可能就有疑问了，既然同样是执行 <code>mvn package</code> 命令进行项目打包，为什么 Spring Boot 项目就打成了可执行 jar ，而普通项目则打包成了不可执行 jar 呢？</p>
<p>这我们就不得不提 Spring Boot 项目中一个默认的插件配置 <code>spring-boot-maven-plugin</code> ，这个打包插件存在 5 个方面的功能，从插件命令就可以看出：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>五个功能分别是：</p>
<ul>
<li>build-info：生成项目的构建信息文件 build-info.properties</li>
<li>repackage：这个是默认 goal，在 <code>mvn package</code> 执行之后，这个命令再次打包生成可执行的 jar，同时将 <code>mvn package</code> 生成的 jar 重命名为 <code>*.origin</code></li>
<li>run：这个可以用来运行 Spring Boot 应用</li>
<li>start：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li>
<li>stop：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li>
</ul>
<p>这里功能，默认情况下使用就是 repackage 功能，其他功能要使用，则需要开发者显式配置</p>
<h2 id="2-打包"><a href="#2-打包" class="headerlink" title="2. 打包"></a>2. 打包</h2><p>打包的依赖</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div>

<p>repackage 功能的 作用，就是在打包的时候，多做一点额外的事情：</p>
<ol>
<li>首先 <code>mvn package</code> 命令 对项目进行打包，打成一个 <code>jar</code>，这个 <code>jar</code> 就是一个普通的 <code>jar</code>，可以被其他项目依赖，但是不可以被执行</li>
<li><code>repackage</code> 命令，对第一步 打包成的 <code>jar</code> 进行再次打包，将之打成一个 可执行 <code>jar</code> ，通过将第一步打成的 <code>jar</code> 重命名为 <code>*.original</code> 文件</li>
</ol>
<p>举个例子：</p>
<p>对任意一个 Spring Boot 项目进行打包，可以执行 <code>mvn package</code> 命令，也可以直接在 <code>IDEA</code> 中点击 <code>package</code> ，如下 ：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>打包成功之后， <code>target</code> 中的文件如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这里有两个文件，第一个 <code>restful-0.0.1-SNAPSHOT.jar</code> 表示打包成的可执行 <code>jar</code> ，第二个 <code>restful-0.0.1-SNAPSHOT.jar.original</code> 则是在打包过程中 ，被重命名的 <code>jar</code>，这是一个不可执行 <code>jar</code>，但是可以被其他项目依赖的 <code>jar</code>。通过对这两个文件的解压，我们可以看出这两者之间的差异。</p>
<p>可执行 <code>jar</code> 解压之后，目录如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-4.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>可以看到，可执行 jar 中，我们自己的代码是存在 于 <code>BOOT-INF/classes/</code> 目录下，另外，还有一个 <code>META-INF</code> 的目录，该目录下有一个 <code>MANIFEST.MF</code> 文件，打开该文件，内容如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">Manifest-Version: 1.0</span>
<span class="hljs-section">Implementation-Title: restful</span>
<span class="hljs-section">Implementation-Version: 0.0.1-SNAPSHOT</span>
<span class="hljs-section">Start-Class: org.javaboy.restful.RestfulApplication</span>
<span class="hljs-section">Spring-Boot-Classes: BOOT-INF/classes/</span>
<span class="hljs-section">Spring-Boot-Lib: BOOT-INF/lib/</span>
<span class="hljs-section">Build-Jdk-Spec: 1.8</span>
<span class="hljs-section">Spring-Boot-Version: 2.1.6.RELEASE</span>
<span class="hljs-section">Created-By: Maven Archiver 3.4.0</span>
<span class="hljs-section">Main-Class: org.springframework.boot.loader.JarLauncher</span></code></pre></div>

<p>可以看到，这里定义了一个 <code>Start-Class</code>，这就是可执行 <code>jar</code> 的入口类，<code>Spring-Boot-Classes</code> 表示我们自己代码编译后的位置，<code>Spring-Boot-Lib</code> 则表示项目依赖的 <code>jar</code> 的位置。</p>
<p>换句话说，如果自己要打一个可执行 <code>jar</code> 包的话，除了添加相关依赖之外，还需要配置 <code>META-INF/MANIFEST.MF</code> 文件。</p>
<p>这是可执行 jar 的结构，那么不可执行 jar 的结构呢？</p>
<p>我们首先将默认的后缀 <code>.original</code> 除去，然后给文件重命名，重命名完成，进行解压：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-5.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>解压后可以看到，不可执行 <code>jar</code> 根目录就相当于我们的 <code>classpath</code>，解压之后，直接就能看到我们的代码，它也有 <code>META-INF/MANIFEST.MF</code> 文件，但是文件中没有定义启动类等。</p>
<div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">Manifest-Version: 1.0</span>
<span class="hljs-section">Implementation-Title: restful</span>
<span class="hljs-section">Implementation-Version: 0.0.1-SNAPSHOT</span>
<span class="hljs-section">Build-Jdk-Spec: 1.8</span>
<span class="hljs-section">Created-By: Maven Archiver 3.4.0</span></code></pre></div>

<p><strong>注意</strong></p>
<p>这个不可以执行 <code>jar</code> 也没有将项目的依赖打包进来。</p>
<p>从这里我们就可以看出，两个 <code>jar</code> ，虽然都是 <code>jar</code> 包，但是内部结构是完全不同的，因此一个可以直接执行，另一个则可以被其他项目依赖。</p>
<p><strong>自定义jar包后缀</strong></p>
<p>一般来说，Spring Boot 直接打包成可执行 <code>jar</code> 就可以了，不建议将 Spring Boot 作为普通的 <code>jar</code> 被其他的项目所依赖。如果有这种需求，建议将被依赖的部分，单独抽出来做一个普通的 <code>Maven</code> 项目，然后在 Spring Boot 中引用这个 <code>Maven</code> 项目。</p>
<p>如果非要将 Spring Boot 打包成一个普通 <code>jar</code> 被其他项目依赖，技术上来说，也是可以的，给 <code>spring-boot-maven-plugin</code> 插件添加如下配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div>

<p>配置的 <code>classifier</code> 表示可执行 <code>jar</code> 的名字，配置了这个之后，在插件执行 <code>repackage</code> 命令时，就不会给 <code>mvn package</code> 所打成的 <code>jar</code> 重命名了，所以，打包后的 jar 如下：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/23-6.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>第一个 jar 表示可以被其他项目依赖的 jar ，第二个 jar 则表示一个可执行 jar。</p>
<p><strong>补充</strong></p>
<p>可执行 jar 的文件大小都很大，因为包含了打包项目所依赖的jar包，如果不需要打包的时候把这些包也加进来，可进行如下配置</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>org.javaboy.client.ClientApplication<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>ZIP<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div>

<p>这样打包后的jar体积就很小了，如果要执行需要加上原先lib所在的目录</p>
<div class="hljs code-wrapper"><pre><code class="hljs shell">java -Dloader.path=./xx/BOOT-INF/lib/ -jar xxx-exec.jar</code></pre></div>

<p><strong>war包</strong></p>
<p>在创建工程的时候选择war，在依赖中会多一个tomcat的依赖</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>并多了一个初始化的类</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Spring/">Spring</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/01/Spring/">
                        <span class="hidden-mobile">Spring</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#valine",
          app_id: "Q8utolFFXQsi71pQY6bCltkI-gzGzoHsz",
          app_key: "x4RAlPOpmFX9HdGyI6MLoCGn",
          placeholder: "说点什么....",
          path: window.location.pathname,
          avatar: "monsterid",
          meta: ["nick","mail","link"],
          pageSize: "12",
          lang: "zh-CN",
          highlight: true,
          recordIP: true,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>





  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
