

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bat.png">
  <link rel="icon" href="/img/bat.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Lucifer">
  <meta name="keywords" content="">
  
  <title>Java开发网络相关知识 - Lucifer&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/monokai.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lucifer2u.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":false,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Q8utolFFXQsi71pQY6bCltkI-gzGzoHsz","app_key":"x4RAlPOpmFX9HdGyI6MLoCGn","server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Lucifer</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Flower.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java开发网络相关知识">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-25 21:38" pubdate>
        2021年7月25日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      28.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      361
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java开发网络相关知识</h1>
            
            <div class="markdown-body">
              <h1 id="Web相关"><a href="#Web相关" class="headerlink" title="Web相关"></a>Web相关</h1><blockquote>
<p>本文整合了Java工程师所需要用到的Web开发相关的基础知识，供参考</p>
</blockquote>
<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、mac地址、ip地址"><a href="#1、mac地址、ip地址" class="headerlink" title="1、mac地址、ip地址"></a>1、mac地址、ip地址</h2><p>终端输入<code>ifconfig en0</code>可以查看</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqbxj10qtj30yq07kwh0.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420171424350"></p>
<p>其中ether指的就是mac地址、inet 地址就是ip。</p>
<p>mac地址也叫物理地址和局域网地址，主要用于确认网上设备的地址，类似于身份证号，具有唯一标识，每一个网卡制作完成之后就带有一个mac地址，永远都不会改变。 </p>
<p>ip地址，类似于你的现住址，是标记你在网络中的具体位置，一个网卡的ip地址是可以改变的。</p>
<h2 id="2、计算机之间是怎么连接的"><a href="#2、计算机之间是怎么连接的" class="headerlink" title="2、计算机之间是怎么连接的"></a>2、计算机之间是怎么连接的</h2><h4 id="2-1-双绞线"><a href="#2-1-双绞线" class="headerlink" title="2.1 双绞线"></a>2.1 双绞线</h4><p>如果只是两台计算机，我能就可以使用双绞线（网线）连载一起，就能互相发送消息，组成一个小网络。</p>
<h4 id="2-2-集线器"><a href="#2-2-集线器" class="headerlink" title="2.2 集线器"></a>2.2 集线器</h4><p>如果有多台计算机，可以使用hub，叫做集线器，一个电脑发送信息到集线器，集线器负责广播到其他的计算机。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqbz4v0z8j30ii09m756.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420171958113"></p>
<h4 id="2-3-交换机"><a href="#2-3-交换机" class="headerlink" title="2.3 交换机"></a>2.3 交换机</h4><p>由于集线器的问题，我们经常需要发送信息到特定的计算机而不是广播，所以一个新的设备就出现了叫做交换机（switch）。</p>
<p>交换机可以记录每一个设备的弟子和接口的对应关系。</p>
<p>思考问题，交换机要将内容发送给指定的计算机，那么内部一定维护了一张表，记录了哪个电脑链接了我的哪个口。<strong>交换机只能识别MAC地址。MAC地址是物理地址，ip地址交换机并不感兴趣</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqbzu54a6j30w80a2n09.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420172038615"></p>
<p>思考一个问题：</p>
<p>交换机啊是怎么知道这个表的：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqc0drv32j310o0hs0z9.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420172110207"></p>
<p>找不到就全员广播，交换机效率比较高，而且可以进行桥接。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqc102pvlj30zy0fkdj6.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420172144325"></p>
<h4 id="2-4-路由器"><a href="#2-4-路由器" class="headerlink" title="2.4 路由器"></a>2.4 路由器</h4><p>思考：使用交换机可以建立一个超大型的网络吗？</p>
<p>一般的交换机的地址表也就能存个几千个地址，当网络内的设备多起来以后，只要交换机找不到对应设备就会广播，地址表如果满了，新地址还会覆盖就地址就会导致重新寻找效率比较低。所以有引入了一个设备叫路由器，谁也听过的一个设备，一般家里都有。</p>
<p>注意：路由器不是猫，猫是调制解调器，调制解调器的作用是将进来的光信号转化为电信号</p>
<p><strong>于是提出了以下的设计</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc1wbgstj30zs0eoq7l.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420172236973"></p>
<p>这里就有了网络的概念了。以上的几种，哪怕是交换机的桥接也没有设计ip地址这个概念，都是基于mac地址进行数据传输。这里有了网络这个抽象概念之后ip地址就应用而生了，IP地址只要是用来表示计算机的网络位置，他处于哪一个网络。IP地址和子网掩码共同帮助我们定位一个计算机在网络中的位置。</p>
<p>ip地址和子网掩码其实是个32位的二进制数字</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc2h9o9kj310m0b6tcy.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420172310601"></p>
<p>此时发送信息就会再包一个消息的头部</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc2usjtbj311604emym.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420172332366"></p>
<p>家用的路由器，有个wan口，有好几个lan口，wan口用来来接互联网端，lan用来连接家庭设备，这连个口都有一个网卡，一个网卡属于互联网网络，ip可能是10.25.23.65，另一个属于内部网络比如192.168.0.1。内部网络和外部互联网的数据转发由路由器内部实现。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc3hbvt0j310e0ds40v.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420172408830"></p>
<p>路由器内有路由表。 </p>
<p>网络内传输，有了网关的概念了。 ip不能直接进行传输，应为网络内的交换机不支持ip地址，所以通信要转化为mac地址，根据ip查找mac 地址。 </p>
<p>非常重要的arp协议，要进行广播，问一问哪个mac地址的ip是192.168.0.5，他收到就会回应</p>
<p>来一个栗子，192.168.100.100 发送信息到 192.168.200.101</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc44vadvj310e0f0adl.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420172446386"></p>
<p>第一步： 192.168.100.100 -&gt; 192.168.200.101</p>
<p><strong>利用地址解析协议（ARP）协议对应IP地址到MAC地址，因为交换机只认识MAC地址，同时在传输过程中MAC地址会一直变化，如下图所示，头部会变</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421153534811.png" srcset="/img/loading.gif" lazyload alt="image-20210421153534811"></p>
<p>添加一条路由</p>
<div class="hljs code-wrapper"><pre><code class="hljs shell">route add -host 192.168.110.202 gw 192.168.120.202 
route del -host 192.168.110.202 gw 192.168.120.202</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs shell">tcpdump -i eth1 host 192.168.1.123 -w /tmp/xxx.cap</code></pre></div>

<p>ICMP（InternetControlMessageProtocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421104754669.png" srcset="/img/loading.gif" lazyload alt="image-20210421104754669"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421105345780.png" srcset="/img/loading.gif" lazyload alt="image-20210421105345780"></p>
<h4 id="2-5-NAT协议"><a href="#2-5-NAT协议" class="headerlink" title="2.5 NAT协议"></a>2.5 NAT协议</h4><p>每台设备都分配一个ip当然能够实现网络的建立，但是事实上我们只有数量有限的IP地址，能给我们用的大概只有40亿左右，于是一般的做法是家里只有一个ip地址，所有的设备通过路由器连接。连接在内网。那么问题来了，你的手机的地址是192.168.0.10，别人家的也可能是一样的百度怎么区分呀？</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc6j041yj30ym0i8q6i.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420172704178"></p>
<p>这个叫NAT协议 NAT（Network Address Translation，网络地址转换）。</p>
<p>现在家里的路由器都是带有交换功能的，能使用的IP地址 25.68亿 共有40多亿</p>
<h2 id="3、ip地址的分类"><a href="#3、ip地址的分类" class="headerlink" title="3、ip地址的分类"></a>3、ip地址的分类</h2><p>1、A类IP地址 </p>
<p>一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从 1.0.0.0 到126.0.0.0。可用的A类网络有126个，每个网络能容纳1亿多个主机。</p>
<p>2、B类IP地址 </p>
<p>一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范 围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。</p>
<p>3、C类IP地址 </p>
<p>一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从 192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。</p>
<p>4、D类地址 </p>
<p>用于多点广播（Multicast）。 D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算 机，它标识共享同一协议的一组计算机。224.0.0.0到239.255.255.255用于多点广播 。</p>
<p>5、E类IP地址 </p>
<p>以“11110”开始，为将来使用保留。240.0.0.0到255.255.255.254，255.255.255.255用于广播地址，全零 （“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播 地址。</p>
<p><strong>IP私有地址：</strong></p>
<p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：</p>
<p>A类地址：10.0.0.0～10.255.255.255 </p>
<p>B类地址：172.16.0.0～172.31.255.255 </p>
<p><strong>C类地址</strong>：192.168.0.0～192.168.255.255 </p>
<p>A类地址的第一组数字为1～126。注意，数字0和127不作为A类地址，数字127保留给内部回送函数，而数字0则表示该地址是本地宿主机，不能传送。</p>
<p>B类地址的第一组数字为128～191。</p>
<p>C类地址的第一组数字为192～223。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc8i8b99j30s60rsgt7.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420172857859"></p>
<h2 id="4、域名DNS"><a href="#4、域名DNS" class="headerlink" title="4、域名DNS"></a>4、域名DNS</h2><p>你真的能记住每个网站的ip地址吗？ 那我们输入的<a target="_blank" rel="noopener" href="http://www.github.com是什么是域名,我们可以去阿里云等云服务提供商购买域名./">www.github.com是什么是域名，我们可以去阿里云等云服务提供商购买域名。</a></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqc9n9n09j30wg0cqafi.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420173003852"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqca0gsvij30x40magna.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420173025265"></p>
<p>域名是需要解析的，指向一个ip地址</p>
<p>为了让你容易记忆引入了域名的概念，你不需要记忆，有人帮您记录</p>
<p><strong>DNS解析</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqcb18w1ij30yy0fg78b.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420173112302"></p>
<h4 id="4-1、国内的dns"><a href="#4-1、国内的dns" class="headerlink" title="4.1、国内的dns"></a>4.1、国内的dns</h4><p><strong>第一名 114DNS：</strong>★★★★★ </p>
<p>114DNS开启DNS高可靠服务时代的大幕。114DNS开始同时为公众提供高速、稳定、可信的DNS递归解析服务；为网站提供强大抗攻击能力的权威智能DNS解析服务；为ISP提供可靠的DNS灾备及外包服务，作为国内用户量最大的老牌DNS，访问速度快，各地区设有节点，负载各运营商用户，DNS防劫持能力，自然也是名列前茅。 </p>
<p>DNS 服务器 IP 地址：</p>
<p>首选：114.114.114.114</p>
<p>备选：114.114.114.115 </p>
<p>2017公共DNS服务器地址评估—DNS推荐 </p>
<p><strong>第二名 DNSPod DNS：</strong>★★★★★</p>
<p>DNSPod创始于2006年3月，是中国最大的第三方域名服务商，全球排名第四位。DNSPod是国内最早提 供免费智能DNS产品的网站,致力于为各类网站提供高质量的电信、网通、教育网双线或者三线智能DNS 免费解析，作为114DNS竞争对手之一，无论是访问速度，还是各地区节点覆盖率以及防劫持能力都是 顶级的。 </p>
<p>DNS 服务器 IP 地址： </p>
<p>首选：119.29.29.29 </p>
<p>备选：182.254.116.116 </p>
<p>2017公共DNS服务器地址评估—DNS推荐 </p>
<p><strong>第三名 阿里 DNS：</strong>★★★★★ </p>
<p>阿里公共DNS是阿里巴巴集团推出的DNS递归解析系统，作为国内最大的互联网基础服务提供商，阿里 巴巴在继承多年优秀技术的基础上，通过提供性能优异的公共DNS服务，为广大互联网用户提供最可靠 的面向互联网用户提供“快速”、“稳定”、“智能”的免费DNS递归解析服务。 </p>
<p>DNS 服务器 IP 地址：</p>
<p>首选：223.5.5.5 </p>
<p>备选：223.6.6.6 </p>
<p>2017公共DNS服务器地址评估—DNS推荐</p>
<h4 id="4-2、域名的分类"><a href="#4-2、域名的分类" class="headerlink" title="4.2、域名的分类"></a>4.2、域名的分类</h4><p><strong>语种分类</strong></p>
<p>英文域名、中文域名、日文域名、韩文域名等等。</p>
<p>现在我们常见的就是英文域名。</p>
<p>英文域名：baidu.com</p>
<p>中文域名：百度.com 、百度.中国、baidu.中国</p>
<p>其它语言域名同上。</p>
<p><strong>地区分类</strong></p>
<p>中国、美国、英国、日本等等。</p>
<p>在国内我们常用的就是.cn域名，.cn是中国大陆的国家一级域名。另外还 有.com.cn、.net.cn、.org.cn等等。</p>
<p>国内不同省市也有自己的顶级域名，例如内蒙古的顶级域名就是：.nm.cn。</p>
<p>美国国家顶级域名是.us 、日本的是.jp、香港的是.hk。</p>
<p><strong>机构分类</strong></p>
<p>.com 商业性的机构或公司 </p>
<p>.org 非盈利的组织、团体 apache.org </p>
<p>.gov 政府部门 <a target="_blank" rel="noopener" href="http://www.shanxi.gov.cn/">http://www.shanxi.gov.cn/</a> </p>
<p>.net 从事Internet相关的的机构或公司 </p>
<p>域名虽然有很多分类，但是我们平时在使用的时候，并没有过多的遵循这个原则。比如.com的也有 很多作为个人网站、.net很多也用来做了公司网站。</p>
<h4 id="4-3、层级分类"><a href="#4-3、层级分类" class="headerlink" title="4.3、层级分类"></a>4.3、层级分类</h4><p><strong>顶级域名（一级域名）</strong></p>
<p> baidu.com baidu.cn</p>
<p><strong>二级域名</strong></p>
<p><a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>  jingyan.baidu.com</p>
<p><strong>三级域名</strong></p>
<p>wangshangyingxiao.club.1688.com    hhz.bbs.53hui.com</p>
<h1 id="二、网络七层协议"><a href="#二、网络七层协议" class="headerlink" title="二、网络七层协议"></a>二、网络七层协议</h1><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqcgu0vbmj310i0jmwif.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420173658725"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqch8ru04j311e0fsgqx.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420173722089"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqchtkslkj31100haamx.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420173742375"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210609162902357.png" srcset="/img/loading.gif" lazyload alt="image-20210609162902357"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210609163017056.png" srcset="/img/loading.gif" lazyload alt="image-20210609163017056"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210609163330263.png" srcset="/img/loading.gif" lazyload alt="image-20210609163330263"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611114939511.png" srcset="/img/loading.gif" lazyload alt="image-20210611114939511"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611115531956.png" srcset="/img/loading.gif" lazyload alt="image-20210611115531956"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611115715297.png" srcset="/img/loading.gif" lazyload alt="image-20210611115715297"></p>
<h2 id="1、Socket"><a href="#1、Socket" class="headerlink" title="1、Socket"></a>1、Socket</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210610185953431.png" srcset="/img/loading.gif" lazyload alt="image-20210610185953431"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210610191338814.png" srcset="/img/loading.gif" lazyload alt="image-20210610191338814"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210610191651004.png" srcset="/img/loading.gif" lazyload alt="image-20210610191651004"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611102845612.png" srcset="/img/loading.gif" lazyload alt="image-20210611102845612"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611111622941.png" srcset="/img/loading.gif" lazyload alt="image-20210611111622941"></p>
<h2 id="2、C-S-amp-B-S"><a href="#2、C-S-amp-B-S" class="headerlink" title="2、C/S &amp; B/S"></a>2、C/S &amp; B/S</h2><ul>
<li>CS和BS含义： <strong>CS即Client/Server(客户机/服务器)结构</strong>。C/S结构在技术上很成熟，它的主要特点是<code>交互性强、具有安全的存取模式、网络通信量低、响应速度快、利于处理大量数据</code>。但是该结构的程序是<code>针对性开发，变更不够灵活，维护和管理的难度较大</code>。通常只局限于小型局域网，不利于扩展。并且，由于该结构的每台客户机都需要安装相应的客户端程序，分布功能弱且兼容性差，不能实现快速部署安装和配置，因此缺少通用性，具有较大的局限性。要求具有一定专业水准的技术人员去完成。  <strong>BS即Browser/Server(浏览器/服务器)结构</strong>，就是只安装维护一个服务器(Server)，而客户端采用浏览器(Browse)运行软件。B/S结构应用程序相对于传统的C/S结构应用程序是一个非常大的进步。B/S结构的主要特点是<code>分布性强、维护方便、开发简单且共享性强、总体拥有成本低</code>。但<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/data_protection?from=10680">数据安全</a>性问题、对服务器要求过高、数据传输速度慢、软件的个性化特点明显降低，这些缺点是有目共睹的，难以实现传统模式下的特殊功能要求。例如：通过浏览器进行大量的数据输入或进行报表的应答、专用性打印输出都比较困难和不便。此外，实现复杂的应用构造有较大的困难。</li>
<li>区别： <ul>
<li>1、开发维护成本 <strong>cs开发维护成本高于bs</strong>。因为采用cs结构时，对于不同的客户端要开发不同的程序，而且软件安装调试和升级都需要在所有客户机上进行。 bs只需要将服务器上的软件版本升级，然后从新登录就可以了。</li>
<li>2、客户端负载 <strong>cs客户端负载大</strong>。cs客户端不仅负责和用户的交互，收集用户信息，而且还需要通过网络向服务器发出请求。 bs把事务处理逻辑部分交给了服务器，客户端只是负责显示。</li>
<li>3、安全性 <strong>cs安全性高</strong>。cs适用于专人使用的系统，可以通过严格的管理派发软件。 bs使用人数多，不固定，安全性低。</li>
<li>4、作用范围 Client/Server是建立在<strong>局域网</strong>的基础上的。Browser/Server是建立在<strong>广域网</strong>的基础上的。</li>
</ul>
</li>
</ul>
<h2 id="3、可靠数据传输的原理"><a href="#3、可靠数据传输的原理" class="headerlink" title="3、可靠数据传输的原理"></a>3、可靠数据传输的原理</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611154205977.png" srcset="/img/loading.gif" lazyload alt="image-20210611154205977"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210611154251038.png" srcset="/img/loading.gif" lazyload alt="image-20210611154251038"></p>
<p><strong>rdt具有不同的情况，见PDF第三章第七页</strong></p>
<h1 id="三、TCP-UDP-HTTP协议"><a href="#三、TCP-UDP-HTTP协议" class="headerlink" title="三、TCP/UDP/HTTP协议"></a>三、TCP/UDP/HTTP协议</h1><h2 id="1、tcp协议"><a href="#1、tcp协议" class="headerlink" title="1、tcp协议"></a>1、tcp协议</h2><p>传输依靠什么进行控制</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqcikuhu8j30ym0jwq64.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420173839440"></p>
<blockquote>
<p>源端口和目的端口字段</p>
</blockquote>
<ul>
<li>TCP源端口（Source Port）：源计算机上的应用程序的端口号，占 16 位。 </li>
<li>TCP目的端口（Destination Port）：目标计算机的应用程序端口号，占 16 位。</li>
</ul>
<blockquote>
<p>序列号字段</p>
</blockquote>
<p>CP序列号（SequenceNumber）：占32位。它表示本报文段所发送数据的第一个字节的编号。在TCP连接中，所传送的字节流的每一个字节都会按顺序编号。当SYN标记不为1时，这是当前数据分段第一个字母的序列号；如果SYN的值是1时，这个字段的值就是初始序列值（ISN），用于对序列号进行同步。这时，第一个字节的序列号比这个字段的值大1，也就是ISN加1。</p>
<blockquote>
<p>确认号字段</p>
</blockquote>
<p>TCP 确认号（Acknowledgment Number，ACK Number）：占 32 位。它表示接收方期望收到发送方 下一个报文段的第一个字节数据的编号。其值是接收计算机即将接收到的下一个序列号，也就是下一个 接收到的字节的序列号加1。</p>
<blockquote>
<p>数据偏移字段</p>
</blockquote>
<p>TCP 首部长度（Header Length）：数据偏移是指数据段中的“数据”部分起始处距离 TCP 数据段起始处 的字节偏移量，占 4 位。其实这里的“数据偏移”也是在确定 TCP 数据段头部分的长度，告诉接收端的应 用程序，数据从何处开始。</p>
<blockquote>
<p>保留字段</p>
</blockquote>
<p>保留（Reserved）：占 4 位。为 TCP 将来的发展预留空间，目前必须全部为 0。</p>
<blockquote>
<p>标志位字段</p>
</blockquote>
<ul>
<li>CWR（CongestionWindowReduce）：拥塞窗口减少标志，用来表明它接收到了设置ECE标志的TCP包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率。</li>
<li>ECE（ECNEcho）：用来在TCP三次握手时表明一个TCP端是具备ECN功能的。在数据传输过程中，它也用来表明接收到的TCP包的IP头部的ECN被设置为11，即网络线路拥堵。</li>
<li>URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。 </li>
<li>ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字 段才有效。TCP 规定，连接建立后，ACK 必须为 1。 </li>
<li>PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即 把数据提交给上层，而不是缓存起来。 </li>
<li>RST：表示是否重置连接。如果RST=1，说明TCP连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。</li>
<li>SYN：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的 报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接 或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。 </li>
<li>FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。</li>
</ul>
<blockquote>
<p>窗口大小字段</p>
</blockquote>
<p>窗口大小（Window Size）：占 16 位。它表示从 Ack Number 开始还可以接收多少字节的数据量，也 表示当前接收端的接收窗口还有多少剩余空间。该字段可以用于 TCP 的流量控制。</p>
<blockquote>
<p>TCP 校验和字段</p>
</blockquote>
<p>校验位（TCPChecksum）：占16位。它用于确认传输的数据是否有损坏。发送端基于数据内容校验生成一个数值，接收端根据接收的数据校验生成一个值。两个值必须相同，才能证明数据是有效的。如果两个值不同，则丢掉这个数据包。Checksum是根据伪头+TCP头+TCP数据三部分进行计算的。</p>
<blockquote>
<p>紧急指针字段</p>
</blockquote>
<p>紧急指针（Urgent Pointer）：仅当前面的 URG 控制位为 1 时才有意义。它指出本数据段中为紧急数据 的字节数，占 16 位。当所有紧急数据处理完后，TCP 就会告诉应用程序恢复到正常操作。即使当前窗 口大小为 0，也是可以发送紧急数据的，因为紧急数据无须缓存。</p>
<blockquote>
<p>可选项字段</p>
</blockquote>
<p>选项（Option）：长度不定，但长度必须是 32bits 的整数倍。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210615205125038.png" srcset="/img/loading.gif" lazyload alt="image-20210615205125038"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210616101803429.png" srcset="/img/loading.gif" lazyload alt="image-20210616101803429"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210616103716046.png" srcset="/img/loading.gif" lazyload alt="image-20210616103716046"></p>
<h2 id="2、握手"><a href="#2、握手" class="headerlink" title="2、握手"></a>2、握手</h2><p>SYN–标志位</p>
<p>Seq–随机序列号</p>
<p>ACK–应答报文</p>
<p>ack–确认序列号（ack=x+1）</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqcmapkprj30pm0lk0w1.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420174213945"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqcmotnfjj31fy03w40t.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420174236651"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqcn921bej31by0hutgs.jpg" srcset="/img/loading.gif" lazyload alt="image-20210420174308237"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210615212011080.png" srcset="/img/loading.gif" lazyload alt="image-20210615212011080"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210615212132528.png" srcset="/img/loading.gif" lazyload alt="image-20210615212132528"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210615213000278.png" srcset="/img/loading.gif" lazyload alt="image-20210615213000278"></p>
<p><strong>具体的见PDF第三章26页</strong></p>
<p>在数据发送的过程中，利用滑动窗口进行数据的发送</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210422104504154.png" srcset="/img/loading.gif" lazyload alt="image-20210422104504154"></p>
<h2 id="3、udp协议"><a href="#3、udp协议" class="headerlink" title="3、udp协议"></a>3、udp协议</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4r871ksj319y0u0qen.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421095544693"></p>
<p>讲解一下： </p>
<p>*UDP头部很简单，包括源端口，目的端口，UDP总长度，校验和，各占16位/2字节，共8字节。 </p>
<p>*源端口：长度16位，指定发送方所使用的端口号，若不需要对方回发消息，则可全置为0。 </p>
<p>*目的端口：长度16位，指定接收方所使用的端口号。 </p>
<p>*UDP总长度：长度16位，指定了UDP数据报的总长度。 </p>
<p>*校验和：长度16位，用于UDP的差错检测，防止UDP报文出错，同时伪首部参与计算，避免UDP用户 数据报传送到错误的目的地。UDP的首部，数据部分，伪首部都会参与检验和的计算，各字段是按照16 比特为单位进行计算的，因此数据部分是要保证是16比特的倍数，不够用0填充。</p>
<blockquote>
<p>tcp与udp的区别</p>
</blockquote>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210422105701215.png" srcset="/img/loading.gif" lazyload alt="image-20210422105701215"></p>
<h2 id="4、http协议"><a href="#4、http协议" class="headerlink" title="4、http协议"></a>4、http协议</h2><h3 id="1、HTTP协议简介"><a href="#1、HTTP协议简介" class="headerlink" title="1、HTTP协议简介"></a>1、HTTP协议简介</h3><p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和 超媒体信息系统的<strong>应用层协议</strong>。HTTP是万维网的数据通信的基础。</p>
<p>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万 维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定 义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</p>
<p>2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将 HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。</p>
<h3 id="2、HTTP协议概述"><a href="#2、HTTP协议概述" class="headerlink" title="2、HTTP协议概述"></a>2、HTTP协议概述</h3><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。</p>
<p>通过使用网页浏览器或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为 80）。</p>
<p>我们称这个客户端为用户代理程序（user agent）。</p>
<p>应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。</p>
<p>通常，由HTTP客户端发起一个请求，创<strong>建一个到服务器指定端口（默认是80端口,https是443）的连接</strong>。HTTP服务器则<strong>在那个端口监听客户端的请求</strong>。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>
<h3 id="3、HTTP工作原理"><a href="#3、HTTP工作原理" class="headerlink" title="3、HTTP工作原理"></a>3、HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户 端。HTTP协议采用了<strong>请求/响应模型</strong>。客户端向服务器发送一个请求报文，请求报文包含请求的方法、 URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、 成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210610193946860.png" srcset="/img/loading.gif" lazyload alt="image-20210610193946860"></p>
<p>在端口号为80的本地建立一个守护socket，当任意一个请求来的时候，再建立一个socket，但守护socket一直存在。</p>
<p><strong>以下是 HTTP 请求/响应的步骤：</strong></p>
<ol>
<li><p>1.客户端连接到Web服务器浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址，一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如， <a target="_blank" rel="noopener" href="http://www.luffycity.com/">http://www.luffycity.com</a></p>
</li>
<li><p>发送HTTP请求 通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由<strong>请求行、请求头部、空行和请求数据</strong>4部分组成。</p>
</li>
<li><p>服务器接受请求并返回HTTP响应 Web服务器<strong>解析请求，定位请求资源</strong>。服务器将资源复本写到TCP套接字，由客户端读取。一个响 应由<strong>状态行、响应头部、空行和响应数据</strong>4部分组成。</p>
</li>
<li><p>释放连接TCP连接 若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若 connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
</li>
<li><p>客户端浏览器解析HTML内容</p>
<p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应 头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据 HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4uenbidj31b60f4133.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421095847308"></p>
<p><strong>http协议是基于TCP/IP协议之上的应用层协议</strong></p>
<p> <strong>基于 请求-响应 的模式</strong> </p>
<p>HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开 始建立通信的,服务器端在没有 接收到请求之前不会发送响应，<strong>服务端不能主动说话</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4v1bp61j31em0i8gxu.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421095923805"></p>
<p><strong>无状态</strong> </p>
<p>HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态 进行保存。也就是说在HTTP这个 级别,协议对于<strong>发送过的请求或响应都不做持久化处理</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4vk81ccj31b80mugz6.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421095953726"></p>
<p>使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能,于是<strong>引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管理状态了</strong>。</p>
<p><strong>无连接</strong></p>
<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是<strong>现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在</strong>，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210610194254771.png" srcset="/img/loading.gif" lazyload alt="image-20210610194254771"></p>
<blockquote>
<p>来个总结 http 是一种基于请求和响应的无状态、无连接的协议</p>
</blockquote>
<p><strong>简单的HTTP通信代码（基于TCP）</strong></p>
<p>客户端</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        Socket socket = <span class="hljs-keyword">new</span> Socket();
        socket.connect(<span class="hljs-keyword">new</span> InetSocketAddress(InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>),<span class="hljs-number">4000</span>));
        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);
        String msg = scanner.next();
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(msg.getBytes());
        outputStream.flush();
        outputStream.close();
        socket.close();
    &#125;
&#125;</code></pre></div>

<p>服务器</p>
<p>多线程并发模式采用一个连接一个线程的方式，优点是确实一定程度上提高了服务器的吞吐量，因为之前的请求在<code>read</code>读阻塞后不会影响到后续的请求，由于它们在不同的线程中，而且一个线程只能对应一个套接字<code>socket</code>，每一个套接字<code>socket</code>都是阻塞的，所以一个线程中只能处理一个套接字。就算<code>accept</code>多个<code>socket</code>，如果前一个<code>socket</code>被阻塞其后的<code>socket</code>是无法被执行到的</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        <span class="hljs-comment">//创建服务器</span>
        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket();
        <span class="hljs-comment">//绑定端口</span>
        server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">4000</span>));
        System.out.println(<span class="hljs-string">&quot;服务器已启动，监听4000端口&quot;</span>);
        <span class="hljs-comment">//进行监听</span>
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;
            Socket accept = server.accept();
          	<span class="hljs-comment">//利用多线程通信</span>
            <span class="hljs-keyword">new</span> MsgHandler(accept).start();
        &#125;
    &#125;
&#125;
<span class="hljs-comment">//多线程处理，如果是多个客户端连接，端口号不一样，IP相同</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;

    Socket accept = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MsgHandler</span><span class="hljs-params">(Socket accept)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.accept = accept;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

        InputStream inputStream = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//拿到数据进行读取</span>
            inputStream = accept.getInputStream();
            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];
            <span class="hljs-keyword">int</span> len;
            <span class="hljs-keyword">while</span> ((len = inputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;
                System.out.println(<span class="hljs-keyword">new</span> String(buf, <span class="hljs-number">0</span>, len));
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span>&#123;
            <span class="hljs-keyword">if</span>(inputStream != <span class="hljs-keyword">null</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    inputStream.close();
                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>



<h3 id="4、HTTP请求格式-请求协议"><a href="#4、HTTP请求格式-请求协议" class="headerlink" title="4、HTTP请求格式(请求协议)"></a>4、HTTP请求格式(请求协议)</h3><p>其实就是个字符串：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4x9w0jyj315y0jejww.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421100133351"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4xhmgr9j31ga0skthf.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421100146022"></p>
<p>请求头里面的内容举个例子：这个length表示请求体里面的数据长度，其他的请求头里面的这些键值对，陆续我们会讲的，大概知道一下就可以了，其中有一个user-agent，算是需要你记住的吧，就是告诉你的服务端，我是用什么给你发送的请求，是个啥客户端。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4y12qdmj30qm0feq5q.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421100214644"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4y7jdv4j31iu0ji48d.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421100226816"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4yfz6suj31ki0tik7p.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421100240863"></p>
<p>看一个爬虫的例子，爬京东的时候没问题，但是爬抽屉的时候必须带着user-agent，因为 抽屉对user-agent做了判断，来判断你是不是一个正常的请求，算是反扒机制的一种</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr4ywttdaj31hq0kwk2f.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421100307753"></p>
<p>打开我们保存的demo.html文件，然后通过浏览器打开看看就能看到页面效果。</p>
<p>写上面这些内容的意思是让你知道有这么个请求头的存在，有些是有意义的，请求头我们 还可以自己定义，就在requests模块里面那个headers={}，这个字典里面加就行</p>
<h3 id="5、HTTP请求方法"><a href="#5、HTTP请求方法" class="headerlink" title="5、HTTP请求方法"></a>5、HTTP请求方法</h3><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p>
<ul>
<li>GET</li>
</ul>
<p>向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，常用语查询数据的请求。</p>
<ul>
<li>POST</li>
</ul>
<p>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。常用于对数据的增删改操作。</p>
<blockquote>
<p>请求方式: get与post请求（通过form表单我们自己写写看）</p>
</blockquote>
<ul>
<li>GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲）POST方法是把提交的数据放在HTTP包的请求体中</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制</li>
<li>GET与POST请求在服务端获取请求数据方式不同，就是我们自己在服务端取请求数据的时候的方式不同了</li>
</ul>
<h3 id="6、URL"><a href="#6、URL" class="headerlink" title="6、URL"></a>6、URL</h3><p>超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：</p>
<ul>
<li>传送协议</li>
<li>层级URL标记符号(为[//],固定不变) </li>
<li>访问资源需要的凭证信息（可省略） </li>
<li>服务器（通常为域名，有时为IP地址） </li>
<li>端口号（以数字方式表示，若为HTTP的默认值“:80”可省略） </li>
<li>路径（以“/”字符区别路径中的每一个目录名称） </li>
<li>查询（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数 据，通常以UTF8的URL编码，避开字符冲突的问题） </li>
<li>片段，以“#”字符为起点</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs markdown">以http://www.xinzhi.com:80/news/index.html?id=250&amp;page=1 为例, 其中：

http，是协议； 
www.xinzhi.com，是服务器； 
80，是服务器上的默认网络端口号，默认不显示； 
/news/index.html，是路径（URI：直接定位到对应的资源）； 
?id=250&amp;page=1，是查询条件。 
大多数网页浏览器不要求用户输入网页中“[http://”的部分，因为绝大多数网页内容是超文本传输协议文件。 
“80”是超文本传输协议文件的常用默认端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分</code></pre></div>

<p>Java中的三板斧</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];
<span class="hljs-keyword">int</span> len;
<span class="hljs-keyword">while</span> ((len = inputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;
  System.out.println(<span class="hljs-keyword">new</span> String(buf, <span class="hljs-number">0</span>, len));
&#125;</code></pre></div>



<h3 id="7、请求中常见的ContentType"><a href="#7、请求中常见的ContentType" class="headerlink" title="7、请求中常见的ContentType"></a>7、请求中常见的ContentType</h3><p>就是告诉服务器，我给你发了个参数，参数是什么类型，你应该怎么接受，怎么解析</p>
<blockquote>
<p>application/x-www-form-urlencoded </p>
</blockquote>
<p>这应该是最常见的POST提交数据的方式了。浏览器的原生form表单，如果不设置enctype属性，那么最终就会以application/x-www-form-urlencoded方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）</p>
<p>格式 ： name=’lisi’&amp;age=13</p>
<blockquote>
<p>application/json </p>
</blockquote>
<p>application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p>
<p>格式： {“name”:”lisi”,”age”:13} </p>
<blockquote>
<p>multipart/form-data </p>
</blockquote>
<p>这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这 个值。直接来看一个请求示例：</p>
<h3 id="8、HTTP响应格式（响应协议）"><a href="#8、HTTP响应格式（响应协议）" class="headerlink" title="8、HTTP响应格式（响应协议）"></a>8、HTTP响应格式（响应协议）</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr548wtogj315y0h87c0.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421100814365"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr54gqhucj31aw0u0k1u.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421100827723"></p>
<h3 id="9、HTTP状态码"><a href="#9、HTTP状态码" class="headerlink" title="9、HTTP状态码"></a>9、HTTP状态码</h3><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态 的短语，彼此由空格分隔。</p>
<p>状态代码的第一个数字代表当前响应的类型：</p>
<ul>
<li>1xx消息——请求已被服务器接收，继续处理 </li>
<li>2xx成功——请求已成功被服务器接收、理解、并接受 </li>
<li>3xx重定向——需要后续操作才能完成这一请求 </li>
<li>4xx请求错误——请求含有词法错误或者无法被执行，客户端 </li>
<li>5xx服务器错误——服务器在处理某个正确请求时发生错误，500</li>
</ul>
<p>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍 然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr55eremqj31fu0han86.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421100922367"></p>
<p><strong>状态码（Status Codes）</strong></p>
<table>
<thead>
<tr>
<th>2xx：成功</th>
<th>3xx：重定向</th>
<th>4xx：客户端错误</th>
<th>5xx：服务器错误</th>
</tr>
</thead>
<tbody><tr>
<td>200 成功</td>
<td>301 永久重定向</td>
<td>400 错误请求</td>
<td>500 服务器错误</td>
</tr>
<tr>
<td>201 创建</td>
<td>304 资源未修改</td>
<td>401 未授权</td>
<td>501 尚未实施</td>
</tr>
<tr>
<td></td>
<td></td>
<td>410 已删除</td>
<td>502 网关错误</td>
</tr>
<tr>
<td></td>
<td></td>
<td>403 禁止访问</td>
<td>503 服务不可用</td>
</tr>
<tr>
<td></td>
<td></td>
<td>404 未找到</td>
<td>504 网关超时</td>
</tr>
<tr>
<td></td>
<td></td>
<td>405 请求方法不对</td>
<td>505 HTTP版本不支持</td>
</tr>
</tbody></table>
<h3 id="10、响应中常见的contentType"><a href="#10、响应中常见的contentType" class="headerlink" title="10、响应中常见的contentType"></a>10、响应中常见的contentType</h3><p><code>text/html </code></p>
<p>告诉浏览器，我给你返回的是html，请渲染</p>
<p><code>application/json</code></p>
<p>告诉浏览器，我给你返回的是json数据 ，一般会让js去处理</p>
<p><strong>常见的contenttype对照表</strong></p>
<p><a target="_blank" rel="noopener" href="https://tool.oschina.net/commons/">https://tool.oschina.net/commons/</a></p>
<h3 id="11、一些常见的响应头"><a href="#11、一些常见的响应头" class="headerlink" title="11、一些常见的响应头"></a>11、一些常见的响应头</h3><p>常见的请求头对照表</p>
<p><a target="_blank" rel="noopener" href="http://tools.jb51.net/table/http_header">http://tools.jb51.net/table/http_header</a></p>
<div class="hljs code-wrapper"><pre><code class="hljs css">Server: Apache-Coyote/<span class="hljs-number">1.1</span>：服务器的版本信息； 
Content-Type: text/html;charset=UTF-8：响应体使用的编码为UTF-8； 
<span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">724</span>：响应体为<span class="hljs-number">724</span>字节； 
Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/hello：响应给客户端的Cookie； Date: Wed, 25 Sep 2012 04:15:03 GMT：响应的时间，这可能会有8小时的时区差；
Last-Modified：最后的修改时间； 
If-Modified-Since：把上次请求的index<span class="hljs-selector-class">.html</span>的最后修改时间还给服务器；
//告诉浏览器不要缓存： 
Expires: -<span class="hljs-number">1</span>； 
Cache-Control: no-cache； 
Pragma: no-cache； 
**自动刷新**响应头，浏览器会在<span class="hljs-number">3</span>秒之后请求http://www.itcast.cn： 
Refresh: 3;url=http://www.itcast.cn</code></pre></div>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr5bf2wnrj31160u048m.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421101507448"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gpr5bqh57jj30yw0jcdii.jpg" srcset="/img/loading.gif" lazyload alt="image-20210421101526912"></p>
<h1 id="四、Tomcat"><a href="#四、Tomcat" class="headerlink" title="四、Tomcat"></a>四、Tomcat</h1><p>Web 应⽤服务器：Tomcat、Jboos、Weblogic、Jetty</p>
<h2 id="tomcat目录"><a href="#tomcat目录" class="headerlink" title="tomcat目录"></a><strong>tomcat目录</strong></h2><ul>
<li>bin：存放各个平台下启动和停⽌ Tomcat 服务的脚本⽂件</li>
<li>conf：存放各种 Tomcat 服务器的配置⽂件</li>
<li>lib：存放Tomcat服务器所需要的 jar</li>
<li>logs：存放Tomcar服务运⾏的⽇志 </li>
<li>temp：Tomcat 运⾏时的临时⽂件</li>
<li>webapps：专门用来存放部署的Web工程</li>
<li>work：是 Tomcat 工作时的目录，用来存放 Tomcat运行时jsp翻译为Servlet的源码，和Session钝化的目录</li>
</ul>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421100828862-9181885.png" srcset="/img/loading.gif" lazyload alt="image-20210421100828862"></p>
<h2 id="Http工作原理"><a href="#Http工作原理" class="headerlink" title="Http工作原理"></a><strong>Http工作原理</strong></h2><p>HTTP协议是浏览器与服务器之间的数据传送协议。作为应用层协议，HTTP是基于TCP/IP协议来传递数 据的（HTML文件、图片、查询结果等），HTTP协议不涉及数据包（Packet）传输，主要规定了客户端 和服务器之间的通信格式。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423205515478.png" srcset="/img/loading.gif" lazyload alt="image-20210423205515478"></p>
<p><strong>Http服务器请求处理</strong></p>
<p>浏览器发给服务端的是一个HTTP格式的请求，HTTP服务器收到这个请求后，需要调用服务端程序来处 理，所谓的服务端程序就是你写的Java类，一般来说不同的请求需要由不同的Java类来处理。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423205608522.png" srcset="/img/loading.gif" lazyload alt="image-20210423205608522"></p>
<ul>
<li>图1 ， 表示HTTP服务器直接调用具体业务类，它们是紧耦合的</li>
<li>图2，HTTP服务器不直接调用业务类，而是把请求交给容器来处理，容器通过Servlet接口调用业务 类。因此Servlet接口和Servlet容器的出现，达到了HTTP服务器与业务类解耦的目的。而Servlet接口和 Servlet容器这一整套规范叫作Servlet规范。Tomcat按照Servlet规范的要求实现了Servlet容器，同时它 们也具有HTTP服务器的功能。作为Java程序员，如果我们要实现新的业务功能，只需要实现一个Servlet，并把它注册到Tomcat（Servlet容器）中，剩下的事情就由Tomcat帮我们处理了</li>
</ul>
<h2 id="Servlet容器工作流程"><a href="#Servlet容器工作流程" class="headerlink" title="Servlet容器工作流程"></a><strong>Servlet容器工作流程</strong></h2><p>为了解耦，HTTP服务器不直接调用Servlet，而是把请求交给Servlet容器来处理</p>
<p>当客户请求某个资源时，HTTP服务器会用一个ServletRequest对象把客户的请求信息封装起来，然后 调用Servlet容器的service方法，Servlet容器拿到请求后，根据请求的URL和Servlet的映射关系，找到 相应的Servlet，如果Servlet还没有被加载，就用反射机制创建这个Servlet，并调用Servlet的init方法来 完成初始化，接着调用Servlet的service方法来处理请求，把ServletResponse对象返回给HTTP服务 器，HTTP服务器会把响应发送给客户端</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423205747804.png" srcset="/img/loading.gif" lazyload alt="image-20210423205747804"></p>
<h2 id="Tomcat整体架构"><a href="#Tomcat整体架构" class="headerlink" title="Tomcat整体架构"></a>Tomcat整体架构</h2><p>我们知道如果要设计一个系统，首先是要了解需求，我们已经了解了Tomcat要实现两个核心功能：</p>
<p>1） 处理Socket连接，负责网络字节流与Request和Response对象的转化。 </p>
<p>2） 加载和管理Servlet，以及具体处理Request请求。</p>
<p>因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。连接器负责对外交流，容器负责内部处理</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423205846503.png" srcset="/img/loading.gif" lazyload alt="image-20210423205846503"></p>
<h2 id="Tomcat-服务器配置"><a href="#Tomcat-服务器配置" class="headerlink" title="Tomcat 服务器配置"></a>Tomcat 服务器配置</h2><p>Tomcat 服务器的配置主要集中于 tomcat/conf 下的 catalina.policy、catalina.properties、 context.xml、server.xml、tomcat-users.xml、web.xml 文件</p>
<p><strong>server.xml</strong></p>
<p>server.xml 是tomcat 服务器的核心配置文件，包含了Tomcat的 Servlet 容器（Catalina）的所有配 置。由于配置的属性特别多，我们在这里主要讲解其中的一部分重要配置。</p>
<blockquote>
<p>Server</p>
</blockquote>
<p>Server是server.xml的根元素，用于创建一个Server实例，默认使用的实现类是 org.apache.catalina.core.StandardServer</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8005&quot;</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">&quot;SHUTDOWN&quot;</span>&gt;</span>

... <span class="hljs-tag">&lt;/<span class="hljs-name">Server</span>&gt;</span></code></pre></div>

<p>port : Tomcat 监听的关闭服务器的端口 </p>
<p>shutdown： 关闭服务器的指令字符串</p>
<blockquote>
<p>Connector</p>
</blockquote>
<p>Connector 用于创建链接器实例。默认情况下，server.xml 配置了两个链接器，一个支持HTTP协议， 一个支持AJP协议。因此大多数情况下，我们并不需要新增链接器配置，只是根据需要对已有链接器进 行优化。</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span>
<span class="hljs-tag"></span>
<span class="hljs-tag"><span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre></div>

<p>属性说明：</p>
<p>1）port：端口号，Connector用于创建服务端Socket并进行监听，以等待客户端请求链接。如果该属性设置为0，Tomcat将会随机选择一个可用的端口号给当前Connector使用</p>
<p>2） protocol ： 当前Connector 支持的访问协议。 默认为 HTTP/1.1 。</p>
<p> 3） connectionTimeOut : Connector 接收链接后的等待超时时间， 单位为毫秒。 -1 表示不超时</p>
<p> 4） URIEncoding : 用于指定编码URI的字符编码， Tomcat8.x版本默认的编码为 UTF-8 。 </p>
<p>完整的配置如下：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span></span>
<span class="hljs-tag"></span>
<span class="hljs-tag"><span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">executor</span>=<span class="hljs-string">&quot;tomcatThreadPool&quot;</span> <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">&quot;1000&quot;</span></span>
<span class="hljs-tag"></span>
<span class="hljs-tag"><span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">acceptCount</span>=<span class="hljs-string">&quot;1000&quot;</span></span>
<span class="hljs-tag"></span>
<span class="hljs-tag"><span class="hljs-attr">maxConnections</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span> <span class="hljs-attr">compression</span>=<span class="hljs-string">&quot;on&quot;</span> <span class="hljs-attr">compressionMinSize</span>=<span class="hljs-string">&quot;2048&quot;</span> <span class="hljs-attr">disableUploadTimeout</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span></span>
<span class="hljs-tag"></span>
<span class="hljs-tag"><span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span></code></pre></div>

<h2 id="Tomcat配置负载均衡"><a href="#Tomcat配置负载均衡" class="headerlink" title="Tomcat配置负载均衡"></a>Tomcat配置负载均衡</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/16.%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%9B%86%E7%BE%A4.jpg" srcset="/img/loading.gif" lazyload alt="16.负载均衡集群"></p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 0.准备多个tomcat</span>
<span class="hljs-code">	 tar -zxvf apache-tomcat-8.5.46.tar.gz #解压缩一个新的tomcat安装包</span>
<span class="hljs-code">	 mv apache-tomcat-8.5.46 tomcat1 			 #将名称改为tomcat1</span>
<span class="hljs-code">	 cp -r tomcat1/ tomcat2								 #复制一份</span>
<span class="hljs-code">	 cp -r tomcat1/ tomcat3                #复制一份</span>
<span class="hljs-code"></span>
<span class="hljs-code"># 1.此时当前目录中有三个服务器,如下:</span>
<span class="hljs-code">	[root@localhost ~]# ls -l</span>
<span class="hljs-code">	总用量 12248</span>
<span class="hljs-code">	-rwxrwxrwx. 1 root root  11623939 10月 13 12:25 apache-tomcat-8.5.46.tar.gz</span>
<span class="hljs-code">	drwxr-xr-x. 9 root root       220 10月 14 21:28 tomcat1</span>
<span class="hljs-code">	drwxr-xr-x. 9 root root       220 10月 14 21:38 tomcat2</span>
<span class="hljs-code">	drwxr-xr-x. 9 root root       220 10月 14 21:38 tomcat3</span></code></pre></div>

<p><strong>配置三个tomcat的端口号</strong></p>
<p>分别修改端口，http协议端口，AJP协议端口</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"># 2.修改tomcat1端口号:(伪分布式)
		vim tomcat1/conf/server.xml,命令修改如下内容:
		a.<span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8001&quot;</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">&quot;SHUTDOWN&quot;</span>&gt;</span>   ---关闭端口
		b.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8888&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">---http</span>协议端口</span>
<span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span>
<span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span>
		c.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;10010&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;AJP/1.3&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span> ---AJP协议端口</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs xml"># 3.修改tomcat2端口号:(伪分布式)
		vim tomcat2/conf/server.xml,命令修改如下内容:
  	a.<span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8002&quot;</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">&quot;SHUTDOWN&quot;</span>&gt;</span>
		b.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8889&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span>
<span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span>
<span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span>
   	c.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;10011&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;AJP/1.3&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs xml"># 4.修改tomcat3端口号:(伪分布式)
		vim tomcat2/conf/server.xml,命令修改如下内容:
  	a.<span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8003&quot;</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">&quot;SHUTDOWN&quot;</span>&gt;</span>
		b.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8890&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span>
<span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span>
<span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span>
   	c.<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;10012&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;AJP/1.3&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 5.将多个tomcat启动:</span>
<span class="hljs-code">		tomcat1/bin/startup.sh </span>
<span class="hljs-code">		tomcat2/bin/startup.sh </span>
<span class="hljs-code">		tomcat3/bin/startup.sh</span>
<span class="hljs-code">    </span>
<span class="hljs-code"># 6.查看tomcat是否启动成功</span>
<span class="hljs-code">		ps -aux|grep tomcat</span></code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191014215035543.png" srcset="/img/loading.gif" lazyload alt="image-20191014215035543"></p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 7.在windows中分别访问tomcat,都看到主页代表启动成功:</span>
<span class="hljs-code">	</span>
<span class="hljs-code">	http://10.15.0.8:8888/</span>
<span class="hljs-code">	http://10.15.0.8:8889/</span>
<span class="hljs-code">	http://10.15.0.8:8890/</span>
<span class="hljs-code">	</span>
<span class="hljs-code">	注意:这步一定要关闭网路防火墙</span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 8.将多个tomcat配置到nginx的配置文件中:</span>
<span class="hljs-code">	vim /conf/nginx.conf</span>
<span class="hljs-code">	</span>
<span class="hljs-code">## 在server标签上加入如下配置:</span>
<span class="hljs-code">    upstream tomcat-servers &#123;</span>
<span class="hljs-code">      server 10.15.0.8:8888;</span>
<span class="hljs-code">      server 10.15.0.8:8889;</span>
<span class="hljs-code">      server 10.15.0.8:8890;</span>
<span class="hljs-code">    &#125;</span>
<span class="hljs-code">## 将配置文件中 location /替换为如下配置:</span>
<span class="hljs-code">		location / &#123;</span>
<span class="hljs-code">			 proxy_pass http://tomcat-servers;</span>
<span class="hljs-code">			 proxy_redirect    off;</span>
<span class="hljs-code">			 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span>
<span class="hljs-code">			 proxy_set_header X-Real-IP $remote_addr;</span>
<span class="hljs-code">			 proxy_set_header Host $http_host;</span>
<span class="hljs-code">			 proxy_next_upstream http_502 http_504 error timeout invalid_header;</span>
<span class="hljs-code">		   &#125;</span></code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191014215825240.png" srcset="/img/loading.gif" lazyload alt="image-20191014215825240"></p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 9.进入nginx安装目录sbin目录加载配置文件的形式启动nginx</span>
<span class="hljs-code">	./nginx -c /usr/nginx/conf/nginx.conf</span></code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 10.访问nginx,看到其中一个tomcat画面:</span>
<span class="hljs-code">	http://10.15.0.8/ </span></code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20191014220145379.png" srcset="/img/loading.gif" lazyload alt="image-20191014220145379"></p>
<p><strong>Nginx负载均衡策略</strong></p>
<blockquote>
<p>默认策略：每个请求会按时间顺序逐一分配到不同的后端服务器</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 以下配置都在vim /conf/nginx.conf中</span>
<span class="hljs-section"># weight 权重</span>
<span class="hljs-code">	说明: weight参数用于指定轮询几率，weight的默认值为1,；weight的数值与访问比率成正比 </span>
<span class="hljs-code">    upstream tomcat-servers &#123;</span>
<span class="hljs-code">        server localhost:8888   weight=2;  </span>
<span class="hljs-code">        server localhost:8889;  </span>
<span class="hljs-code">        server localhost:8890   backup;  </span>
<span class="hljs-code">    &#125;</span>
<span class="hljs-code">注意：1.权重越高分配到需要处理的请求越多。2.此策略可以与least_conn和ip_hash结合使用主要用于后端服务器性能不均</span>
<span class="hljs-code"></span>
<span class="hljs-code"># ip_hash </span>
<span class="hljs-code">	　说明:指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题。</span>
<span class="hljs-code">	　upstream tomcat-servers &#123;</span>
<span class="hljs-code">        ip_hash;    #保证每个访客固定访问一个后端服务器</span>
<span class="hljs-code">        ......</span>
<span class="hljs-code">    &#125;</span>
<span class="hljs-code"># least_conn</span>
<span class="hljs-code">	说明: 把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。</span>
<span class="hljs-code">	upstream tomcat-servers&#123;</span>
<span class="hljs-code">        least_conn;    #把请求转发给连接数较少的后端服务器</span>
<span class="hljs-code">    &#125;</span></code></pre></div>

<h2 id="Session共享"><a href="#Session共享" class="headerlink" title="Session共享"></a><strong>Session共享</strong></h2><p><strong>Memcached Session Manager</strong></p>
<blockquote>
<p>Memcached Session Manager基于memcache缓存的session共享.即使用cacheDB存取session信息，应用服务器接受新请求将session信息保存在cache DB中，当应用服务器发生故障时，调度器会遍历寻找可用节点，分发请求，当应用服务器发现session不在本机内存时，则去cacheDB中查找，如果找到则复制到本机，这样实现session共享和高可用。</p>
</blockquote>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 1.安装memcached</span>
yum install -y memcached

<span class="hljs-section"># 2.启动memcached（port:11211）</span>
memcached -p 11211 -vvv -u root

<span class="hljs-section"># 3.tomcat安装的lib目录中放入与memcache整合jar包</span>
<span class="hljs-code">		cp *.jar tomcat1/lib</span>
<span class="hljs-code">		cp *.jar tomcat2/lib</span>
<span class="hljs-code">		cp *.jar tomcat3/lib</span>
<span class="hljs-code"></span>
<span class="hljs-code"># 4.配置tomcat目录中conf目录中context.xml(所有tomcat均需要配置)</span>
<span class="hljs-code">&lt;Context&gt;</span>
<span class="hljs-code"> &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;</span>
<span class="hljs-code">        memcachedNodes=&quot;n1:10.15.0.8:11211,n2:....&quot; --对应name:msm的ip:port，可以加多台做分布式</span>
<span class="hljs-code">        sticky=&quot;false&quot;  </span>
<span class="hljs-code">    		sessionBackupAsync=&quot;false&quot;  </span>
<span class="hljs-code">        requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot;        transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot;</span>
<span class="hljs-code">        /&gt;</span>
<span class="hljs-code">&lt;/Context&gt;</span>
<span class="hljs-code"></span>
<span class="hljs-code"># 5.然后启动tomcat和nginx并放入测试项目进行测试</span></code></pre></div>

<p><strong>Redis</strong></p>
<blockquote>
<p>同样利用tomcat与nginx搭建，但是利用Redis集群进行管理，redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据</p>
</blockquote>
<h1 id="五、Nginx"><a href="#五、Nginx" class="headerlink" title="五、Nginx"></a>五、Nginx</h1><p><code>Nginx</code> 是一个高性能的 <code>HTTP</code> 和反向代理 <code>web</code> 服务器，同时也提供了 <code>IMAP/POP3/SMTP</code> 服务。</p>
<p><code>Nginx</code> 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 <code>Rambler.ru</code> 站点开发的，第一个公开版本 <code>0.1.0</code> 发布于 <code>2004</code>年 <code>10</code> 月 <code>4</code> 日。</p>
<p><code>Nginx</code> 特点是占有内存少，并发能力强。</p>
<p>事实上 <code>nginx</code> 的并发能力确实在同类型的网页服务器中表现较好，一般来说，如果我们在项目中引入了 <code>Nginx</code> ，我们的项目架构可能是这样：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/15-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在这样的架构中 ， <code>Nginx</code> 所代表的角色叫做负载均衡服务器或者反向代理服务器，所有请求首先到达 <code>Nginx</code> 上，再由 <code>Nginx</code> 根据提前配置好的转发规则，将客户端发来的请求转发到某一个 <code>Tomcat</code> 上去。</p>
<p>那么这里涉及到两个概念：</p>
<ul>
<li>负载均衡服务器</li>
</ul>
<p>就是进行请求转发，降低某一个服务器的压力。负载均衡策略很多，也有很多层，对于一些大型网站基本上从 <code>DNS</code>就开始负载均衡，负载均衡有硬件和软件之分，各自代表分别是 <code>F5</code> 和 <code>Nginx</code> （目前 <code>Nginx</code> 已经被 <code>F5</code> 收购），早些年，也可以使用 <code>Apache</code> 来做负载均衡，但是效率不如 <code>Nginx</code> ，所以现在主流方案是 <code>Nginx</code> 。</p>
<ul>
<li>反向代理服务器：</li>
</ul>
<p>另一个概念是反向代理服务器，得先说正向代理，看下面一张图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/15-2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在这个过程中，Google 并不知道真正访问它的客户端是谁，它只知道这个中间服务器在访问它。因此，这里的代理，实际上是中间服务器代理了客户端，这种代理叫做正向代理。</p>
<p>那么什么是反向代理呢？看下面一张图：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/15-3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在这个过程中，10086 这个号码相当于是一个代理，真正提供服务的，是话务员，但是对于客户来说，他不关心到底是哪一个话务员提供的服务，他只需要记得 10086 这个号码就行了。</p>
<p>所有的请求打到 10086 上，再由 10086 将请求转发给某一个话务员去处理。因此，在这里，10086 就相当于是一个代理，只不过它代理的是话务员而不是客户端，这种代理称之为反向代理。</p>
<h2 id="Nginx-的优势"><a href="#Nginx-的优势" class="headerlink" title="Nginx 的优势"></a>Nginx 的优势</h2><p>在 Java 开发中，Nginx 有着非常广泛的使用，随便举几点：</p>
<ul>
<li>使用 Nginx 做静态资源服务器：Java 中的资源可以分为动态和静态，动态需要经过 Tomcat 解析之后，才能返回给浏览器，例如 JSP 页面、Freemarker 页面、控制器返回的 JSON 数据等，都算作动态资源，动态资源经过了 Tomcat 处理，速度必然降低。对于静态资源，例如图片、HTML、JS、CSS 等资源，这种资源可以不必经过 Tomcat 解析，当客户端请求这些资源时，之间将资源返回给客户端就行了。此时，可以使用 Nginx 搭建静态资源服务器，将静态资源直接返回给客户端。</li>
<li>使用 Nginx 做负载均衡服务器，无论是使用 Dubbo 还是 Spirng Cloud ，除了使用各自自带的负载均衡策略之外，也都可以使用 Nginx 做负载均衡服务器。</li>
<li>支持高并发、内存消耗少、成本低廉、配置简单、运行稳定等。</li>
</ul>
<h1 id="六、Servlet"><a href="#六、Servlet" class="headerlink" title="六、Servlet"></a>六、Servlet</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><ul>
<li>Servlet 是 JavaEE 规范之一。规范就是接口</li>
<li>Servlet 就 JavaWeb 三大组件之一。三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器</li>
<li>Servlet 是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端</li>
</ul>
<p><strong>功能</strong></p>
<ul>
<li>接受请求</li>
<li>处理请求</li>
<li>完成相应</li>
</ul>
<h2 id="Servlet加载时机"><a href="#Servlet加载时机" class="headerlink" title="Servlet加载时机"></a>Servlet加载时机</h2><p>在默认情况下，当Web客户第一次请求访问某个Servlet时，Web容器会创建这个Servlet的实例。</p>
<p>当设置了web.xml中的子元素后，Servlet容器在启动Web应用时，将按照指定顺序创建并初始化这个 Servlet。设置的数值大于0即可。例如：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.langsin.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></code></pre></div>

<h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>先看与Servlet生命周期有关的三个方法：init(), service(), destroy(). Servlet生命周期可被定义为从创建 直到毁灭的整个过程。以下是三个方法分别对应的Servlet过程：</p>
<ul>
<li>执行 Servlet 构造器方法</li>
<li>执行 init 初始化方法<ul>
<li>第一、二步，是在第一次访问的时候创建 Servlet 程序会调用</li>
</ul>
</li>
<li>执行 service 方法<ul>
<li>第三步，每次访问都会调用</li>
</ul>
</li>
<li>执行 destroy 销毁方法<ul>
<li>第四步，在 web 工程停止的时候调用</li>
</ul>
</li>
</ul>
<h2 id="手动实现-Servlet-程序"><a href="#手动实现-Servlet-程序" class="headerlink" title="手动实现 Servlet 程序"></a>手动实现 Servlet 程序</h2><ul>
<li>编写一个类去实现 Servlet 接口</li>
<li>实现 service 方法，处理请求，并响应数据</li>
<li>到 web.xml 中去配置 servlet 程序的访问地址<ul>
<li>浏览器不能直接访问 Servlet ⽂件，只能通过映射的⽅式来间接访问 Servlet，映射需要开发者⼿动配置，有两种配置⽅式</li>
</ul>
</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * service 方法是专门用来处理请求和响应的</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> servletRequest</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> servletResponse</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span></span>
<span class="hljs-function">        ServletException, IOException </span>&#123;
        	System.out.println(<span class="hljs-string">&quot;Hello Servlet 被访问了&quot;</span>);
        &#125;
&#125;</code></pre></div>

<p><strong>基于 XML ⽂件的配置⽅式:</strong></p>
<p><code>Web.xml</code></p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-comment">&lt;!--全类名--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.southwind.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
<span class="hljs-comment">&lt;!--  mapping标签给servlet程序配置访问地址--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
<span class="hljs-comment">&lt;!--    告诉服务器，我当前配置的地址给那个servlet程序使用--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
<span class="hljs-comment">&lt;!--    访问地址--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/demo2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>

<p><strong>基于注解的⽅式</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/demo2&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>&#123;
 
	&#125;</code></pre></div>

<p><strong>url 地址到 Servlet 程序的访问</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423170521391.png" srcset="/img/loading.gif" lazyload alt="image-20210423170521391"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210423170614051.png" srcset="/img/loading.gif" lazyload alt="image-20210423170614051"></p>
<p><strong>通过继承 HttpServlet 实现 Servlet 程序</strong></p>
<p>一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。 </p>
<ul>
<li>编写一个类去继承 HttpServlet 类 </li>
<li>根据业务需要重写 doGet 或 doPost 方法 </li>
<li>到 web.xml 中的配置 Servlet 程序的访问地址</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * doGet（）在 get 请求的时候调用</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> req</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resp</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;
    	System.out.println(<span class="hljs-string">&quot;HelloServlet2 的 doGet 方法&quot;</span>);
    &#125;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * doPost（）在 post 请求的时候调用</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> req</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resp</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;
    	System.out.println(<span class="hljs-string">&quot;HelloServlet2 的 doPost 方法&quot;</span>);
    &#125;
&#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.atguigu.servlet.HelloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>

<p><strong>Servlet 类的继承体系</strong></p>
<p><code>Servlet ---&gt; GenericServlet ---〉HttpServlet</code></p>
<p>HTTP 请求有很多种类型，常⽤的有四种： </p>
<ul>
<li><p>GET 读取 </p>
</li>
<li><p>POST 保存 </p>
</li>
<li><p>PUT 修改</p>
</li>
<li><p>DELETE 删除</p>
</li>
</ul>
<p>GenericServlet 实现 Servlet 接⼝，同时为它的⼦类屏蔽了不常⽤的⽅法，⼦类只需要重写 service⽅法即可。</p>
<p>HttpServlet 继承 GenericServlet，根据请求类型进⾏分发处理，GET 进⼊ doGET ⽅法，POST 进⼊ doPOST ⽅法。 开发者⾃定义的 Servlet 类只需要继承 HttpServlet 即可，重新 doGET 和 doPOST。</p>
<h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><ul>
<li>ServletConfig类从类名上来看，就知道是Servlet程序的配置信息类</li>
<li>Servlet 程序和 ServletConfig 对象都是由Tomcat负责创建，我们负责使用</li>
<li>Servlet 程序默认是第一次访问的时候创建，ServletConfig是每个Servlet 程序创建时，就创建一个对应的ServletConfig对象</li>
</ul>
<p><strong>ServletConfig 类的三大作用</strong></p>
<p>1、可以获取 Servlet 程序的别名 servlet-name 的值<br>2、获取Servlet 初始化参数 init-param<br>3、获取 ServletContext 对象</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-comment">&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-comment">&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.atguigu.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
    <span class="hljs-comment">&lt;!--init-param 是初始化参数--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-comment">&lt;!--是参数名--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-comment">&lt;!--是参数值--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-comment">&lt;!--init-param 是初始化参数--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-comment">&lt;!--是参数名--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-comment">&lt;!--是参数值--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-comment">&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
        <span class="hljs-comment">&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">        url-pattern 标签配置访问地址 &lt;br/&gt;</span>
<span class="hljs-comment">        / 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径 &lt;br/&gt;</span>
<span class="hljs-comment">        /hello 表示地址为：http://ip:port/工程路径/hello &lt;br/&gt;</span>
<span class="hljs-comment">        --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></code></pre></div>

<p><strong>ServletConfig 各个方法</strong></p>
<p><code>getServletName()</code> 返回 Servlet的别名<br><code>getInitParameter(String key)</code> 获取init参数的值（web.xml）<br><code>getInitParameterNames()</code> 返回所有的 initParamter的name值，⼀般⽤作遍历初始化参数<br><code>getServletContext()</code> 返回 ServletContext 对象，它是 Servlet 的上下⽂，整个 Servlet 的管理者</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;
    System.out.println(<span class="hljs-string">&quot;2 init 初始化方法&quot;</span>);
    <span class="hljs-comment">// 1、可以获取 Servlet 程序的别名 servlet-name 的值</span>
    System.out.println(<span class="hljs-string">&quot;HelloServlet 程序的别名是:&quot;</span> + servletConfig.getServletName());
    <span class="hljs-comment">// 2、获取初始化参数 init-param</span>
    System.out.println(<span class="hljs-string">&quot;初始化参数 username 的值是;&quot;</span> + servletConfig.getInitParameter(<span class="hljs-string">&quot;username&quot;</span>));
    System.out.println(<span class="hljs-string">&quot;初始化参数 url 的值是;&quot;</span> + servletConfig.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>));
    <span class="hljs-comment">// 3、获取 ServletContext 对象</span>
    System.out.println(servletConfig.getServletContext());
&#125;</code></pre></div>

<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p><strong>什么是 ServletContext?</strong></p>
<p>1、ServletContext 是一个接口，它表示 Servlet 上下文对象<br>2、一个 web 工程，只有一个 ServletContext 对象实例<br>3、ServletContext 对象是一个域对象<br>4、ServletContext 是在 web 工程部署启动的时候创建，<strong>在 web 工程停止的时候销毁</strong></p>
<p><strong>什么是域对象?</strong><br>域对象，是可以像Map一样存取数据的对象，叫域对象</p>
<p>这里的域指的是存取数据的操作范围，整个 web工程</p>
<div class="hljs code-wrapper"><pre><code class="hljs css">		 存数据  		 取数据   		    删除数据
Map 	 put()   		get()  			remove()
域对象 setAttribute() getAttribute() removeAttribute();</code></pre></div>

<p><strong>ServletContext对象的作用</strong></p>
<p>1、获取 web.xml 中配置的上下文参数 context-param<br>2、获取当前的工程路径，格式: /工程路径<br>3、获取工程部署后在服务器硬盘上的绝对路径<br>4、像 Map 一样存取数据</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span></span>
<span class="hljs-function">ServletException, IOException </span>&#123;
    <span class="hljs-comment">// 1、获取 web.xml 中配置的上下文参数 context-param</span>
    ServletContext context = getServletConfig().getServletContext();
    String username = context.getInitParameter(<span class="hljs-string">&quot;username&quot;</span>);
    System.out.println(<span class="hljs-string">&quot;context-param 参数 username 的值是:&quot;</span> + username);
    System.out.println(<span class="hljs-string">&quot;context-param 参数 password 的值是:&quot;</span> +
    context.getInitParameter(<span class="hljs-string">&quot;password&quot;</span>));
    <span class="hljs-comment">// 2、获取当前的工程路径，格式: /工程路径</span>
  	System.out.println( <span class="hljs-string">&quot;当前工程路径:&quot;</span> + context.getContextPath() );
    <span class="hljs-comment">// 3、获取工程部署后在服务器硬盘上的绝对路径</span>
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * / 斜杠被服务器解析地址为:http://ip:port/工程名/ 映射到 IDEA 代码的 web 目录&lt;br/&gt;</span>
<span class="hljs-comment">    */</span>
    System.out.println(<span class="hljs-string">&quot;工程部署的路径是:&quot;</span> + context.getRealPath(<span class="hljs-string">&quot;/&quot;</span>));
    System.out.println(<span class="hljs-string">&quot;工程下 css 目录的绝对路径是:&quot;</span> + context.getRealPath(<span class="hljs-string">&quot;/css&quot;</span>));
    System.out.println(<span class="hljs-string">&quot;工程下 imgs 目录 1.jpg 的绝对路径是:&quot;</span> + context.getRealPath(<span class="hljs-string">&quot;/imgs/1.jpg&quot;</span>));
&#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs xml">!--context-param 是上下文参数(它属于整个 web 工程)--&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>context<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>
<span class="hljs-comment">&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>password<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre></div>

<p>ServletContext 像 Map 一样存取数据：</p>
<p>ContextServlet1 代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextServlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span></span>
<span class="hljs-function">        ServletException, IOException </span>&#123;
        <span class="hljs-comment">// 获取 ServletContext 对象</span>
        ServletContext context = getServletContext();
        System.out.println(context);
        System.out.println(<span class="hljs-string">&quot;保存之前: Context1 获取 key1 的值是:&quot;</span>+ context.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>));
        context.setAttribute(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;Context1 中获取域数据 key1 的值是:&quot;</span>+ context.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>));
    &#125;
&#125;</code></pre></div>

<p>ContextServlet2 代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException,</span>
<span class="hljs-function">IOException </span>&#123;
    ServletContext context = getServletContext();System.out.println(context);
    System.out.println(<span class="hljs-string">&quot;Context2 中获取域数据 key1 的值是:&quot;</span>+ context.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>));
&#125;</code></pre></div>

<p><strong>ServletConfig 和 ServletContext 的区别：</strong></p>
<p>ServletConfig 作⽤于某个 Servlet 实例，每个 Servlet 都有对应的 ServletConfig，ServletContext 作⽤于整个 Web 应⽤，⼀个 Web 应⽤对应⼀个 ServletContext，多个 Servlet 实例对应⼀个ServletContext</p>
<p><strong>⼀个是局部对象，⼀个是全局对象</strong></p>
<h2 id="HTTP-协议回顾"><a href="#HTTP-协议回顾" class="headerlink" title="HTTP 协议回顾"></a><strong>HTTP 协议回顾</strong></h2><p><a href="#3%E3%80%81http%E5%8D%8F%E8%AE%AE">什么是 HTTP 协议</a></p>
<ul>
<li>协议是指双方，或多方，相互约定好，大家都需要遵守的规则，叫协议</li>
<li>所谓 HTTP 协议，就是指，客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫 HTTP 协议</li>
<li>HTTP 协议中的数据又叫报文</li>
</ul>
<p><strong>请求的 HTTP 协议格式</strong></p>
<ul>
<li>客户端给服务器发送数据叫请求 </li>
<li>服务器给客户端回传数据叫响应</li>
<li>请求又分为 GET 请求，和 POST 请求两种</li>
</ul>
<p><strong>GET 请求</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">1</span>、请求行
    (<span class="hljs-number">1</span>) 请求的方式 <span class="hljs-selector-tag">GET</span>
    (<span class="hljs-number">2</span>) 请求的资源路径<span class="hljs-selector-attr">[+?+请求参数]</span>
    (<span class="hljs-number">3</span>) 请求的协议的版本号 <span class="hljs-selector-tag">HTTP</span>/<span class="hljs-selector-tag">1</span><span class="hljs-selector-class">.1</span>
<span class="hljs-selector-tag">2</span>、请求头
	<span class="hljs-selector-tag">key</span> : <span class="hljs-selector-tag">value</span> 组成不同的键值对，表示不同的含义。</code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421104718675-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210421104718675"></p>
<p> <strong>POST 请求</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">1</span>、请求行
    (<span class="hljs-number">1</span>) 请求的方式 <span class="hljs-selector-tag">POST</span> 
    (<span class="hljs-number">2</span>) 请求的资源路径<span class="hljs-selector-attr">[+?+请求参数]</span> 
    (<span class="hljs-number">3</span>) 请求的协议的版本号 <span class="hljs-selector-tag">HTTP</span>/<span class="hljs-selector-tag">1</span><span class="hljs-selector-class">.1</span> 
<span class="hljs-selector-tag">2</span>、请求头 
	<span class="hljs-selector-tag">key</span> : <span class="hljs-selector-tag">value</span> 不同的请求头，有不同的含义 
空行
<span class="hljs-selector-tag">3</span>、请求体
	就是发送给服务器的数据</code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421104938669-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210421104938669"></p>
<p> <strong>常用请求头的说明</strong></p>
<p><code>Accept</code> 表示客户端可以接收的数据类型<br><code>Accpet-Languege</code> 表示客户端可以接收的语言类型<br><code>User-Agent</code> 表示客户端浏览器的信息<br><code>Host</code> 表示请求时的服务器 ip 和端口号</p>
<p><strong>区分GET和POST请求</strong></p>
<p><strong>GET</strong></p>
<ul>
<li>from标签 method=get</li>
<li>a标签</li>
<li>link标签引入css</li>
<li>Script标签引入js文件</li>
<li>img标签引入图片</li>
<li>iframe引入html页面</li>
<li>在浏览器地址栏输入地址后翘回车</li>
</ul>
<p><strong>POST</strong></p>
<ul>
<li>from标签 method=post</li>
</ul>
<p><strong>响应的 HTTP 协议格式</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>、响应行
    (<span class="hljs-number">1</span>) 响应的协议和版本号
    (<span class="hljs-number">2</span>) 响应状态码
    (<span class="hljs-number">3</span>) 响应状态描述符
<span class="hljs-number">2</span>、响应头
	  key : value 不同的响应头，有其不同含义
空行
<span class="hljs-number">3</span>、响应体
	就是回传给客户端的数据</code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421105124947-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210421105124947"></p>
<p><strong>常用的响应码说明</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">200 </span>表示请求成功
<span class="hljs-symbol">302 </span>表示请求重定向
<span class="hljs-symbol">404 </span>表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误）
<span class="hljs-symbol">500 </span>表示服务器已经收到请求，但是服务器内部错误（代码错误）</code></pre></div>

<p><strong>MIME 类型说明</strong></p>
<ul>
<li>MIME 是 HTTP 协议中数据类型</li>
<li>MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型/小类型”，并与某一种文件的扩展名相对应</li>
</ul>
<p>常见的 MIME 类型</p>
<table>
<thead>
<tr>
<th align="center">文件</th>
<th align="center">MIME 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">超文本标记语言文本</td>
<td align="center">text/html</td>
</tr>
<tr>
<td align="center">普通文本</td>
<td align="center">text/plain</td>
</tr>
<tr>
<td align="center">TAR 文件</td>
<td align="center">application/x-tar</td>
</tr>
<tr>
<td align="center">GIF 图形</td>
<td align="center">image/gif</td>
</tr>
</tbody></table>
<h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a><strong>HttpServletRequest</strong></h2><p><strong>HttpServletRequest 类的作用</strong></p>
<ul>
<li>每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中</li>
<li>然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的信息</li>
</ul>
<p><strong>HttpServletRequest 类的常用方法</strong></p>
<p> <code>getRequestURI()</code> 获取请求的资源路径<br> <code>getRequestURL() </code>获取请求的统一资源定位符（绝对路径）<br> <code>getRemoteHost() </code>获取客户端的ip地址<br> <code>getHeader()</code> 获取请求头<br> <code>getParameter()</code>获取请求的参数<br> <code>getParameterValues()</code>获取请求的参数（多个值的时候使用）<br> <code> setAttribute(key, value)</code> 设置域数据<br> <code>getAttribute(key)</code>获取域数据<br> <code> getRequestDispatcher()</code> 获取请求转发对<br> <code>getMethod()</code> 获取请求的方式GET或POST</p>
<p>常用 API 示例代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestAPIServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span>
<span class="hljs-function">    IOException </span>&#123;
        <span class="hljs-comment">// i.getRequestURI() 获取请求的资源路径</span>
        System.out.println(<span class="hljs-string">&quot;URI =&gt; &quot;</span> + req.getRequestURI());
        <span class="hljs-comment">// ii.getRequestURL() 获取请求的统一资源定位符（绝对路径）</span>
        System.out.println(<span class="hljs-string">&quot;URL =&gt; &quot;</span> + req.getRequestURL());
      	<span class="hljs-comment">// iii.getRemoteHost() 获取客户端的 ip 地址</span>
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">        * 在 IDEA 中，使用 localhost 访问时，得到的客户端 ip 地址是 ===&gt;&gt;&gt; 127.0.0.1&lt;br/&gt;</span>
<span class="hljs-comment">        * 在 IDEA 中，使用 127.0.0.1 访问时，得到的客户端 ip 地址是 ===&gt;&gt;&gt; 127.0.0.1&lt;br/&gt;</span>
<span class="hljs-comment">        * 在 IDEA 中，使用 真实 ip 访问时，得到的客户端 ip 地址是 ===&gt;&gt;&gt; 真实的客户端 ip 地址&lt;br/&gt;</span>
<span class="hljs-comment">        */</span>
        System.out.println(<span class="hljs-string">&quot;客户端 ip 地址 =&gt; &quot;</span> + req.getRemoteHost());
        <span class="hljs-comment">// iv.getHeader() 获取请求头</span>
        System.out.println(<span class="hljs-string">&quot;请求头 User-Agent ==&gt;&gt; &quot;</span> + req.getHeader(<span class="hljs-string">&quot;User-Agent&quot;</span>));
        <span class="hljs-comment">// vii.getMethod() 获取请求的方式 GET 或 POST</span>
        System.out.println( <span class="hljs-string">&quot;请求的方式 ==&gt;&gt; &quot;</span> + req.getMethod() );
    &#125;
&#125;</code></pre></div>

<p><strong>如何获取请求参数</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://localhost:8080/07_servlet/parameterServlet&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span>
        用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
        密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
        兴趣爱好：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cpp&quot;</span>&gt;</span>C++
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span>Java
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div>

<p>Java 代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParameterServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span>
<span class="hljs-function">    IOException </span>&#123;
      	<span class="hljs-comment">//设置编码</span>
     		req.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);
        <span class="hljs-comment">// 获取请求参数</span>
        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);
        String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);
        String[] hobby = req.getParameterValues(<span class="hljs-string">&quot;hobby&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;用户名：&quot;</span> + username);
        System.out.println(<span class="hljs-string">&quot;密码：&quot;</span> + password);
        System.out.println(<span class="hljs-string">&quot;兴趣爱好：&quot;</span> + Arrays.asList(hobby));
    &#125;
&#125;</code></pre></div>

<p><strong>请求转发</strong></p>
<p>什么是请求的转发? </p>
<blockquote>
<p>请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发。</p>
</blockquote>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421111014356-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210421111014356"></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Servlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span>
<span class="hljs-function">    IOException </span>&#123;
        <span class="hljs-comment">// 获取请求的参数（办事的材料）查看</span>
        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;在 Servlet1（柜台 1）中查看参数（材料）：&quot;</span> + username);
        <span class="hljs-comment">// 给材料 盖一个章，并传递到 Servlet2（柜台 2）去查看</span>
        req.setAttribute(<span class="hljs-string">&quot;key1&quot;</span>,<span class="hljs-string">&quot;柜台 1 的章&quot;</span>);
        <span class="hljs-comment">// 问路：Servlet2（柜台 2）怎么走</span>
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">        * 请求转发必须要以斜杠打头，/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到 IDEA 代码的 web 目录</span>
<span class="hljs-comment">        &lt;br/&gt;</span>
<span class="hljs-comment">        *</span>
<span class="hljs-comment">        */</span>
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(<span class="hljs-string">&quot;/servlet2&quot;</span>);
        <span class="hljs-comment">// 走向 Sevlet2（柜台 2）</span>
        requestDispatcher.forward(req,resp);
    &#125;
&#125;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Servlet2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span>
<span class="hljs-function">    IOException </span>&#123;
        <span class="hljs-comment">// 获取请求的参数（办事的材料）查看</span>
        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;在 Servlet2（柜台 2）中查看参数（材料）：&quot;</span> + username);
        <span class="hljs-comment">// 查看柜台1是否有盖章</span>
        Object key1 = req.getAttribute(<span class="hljs-string">&quot;key1&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;柜台 1 是否有章：&quot;</span> + key1);
        <span class="hljs-comment">// 处理自己的业务</span>
        System.out.println(<span class="hljs-string">&quot;Servlet2 处理自己的业务 &quot;</span>);
	&#125;
&#125;</code></pre></div>

<p><strong>base标签</strong></p>
<p>比如这里设置</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://localhost:8080/07_servlet/a/b/c.html&quot;</span>&gt;</span>
或者
<span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://localhost:8080/07_servlet/a/b/&quot;</span>&gt;</span></code></pre></div>

<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424201046209.png" srcset="/img/loading.gif" lazyload alt="image-20210424201046209"></p>
<p><strong>Web 中的相对路径和绝对路径</strong></p>
<p>在 javaWeb 中， 路径分为相对路径和绝对路径两种：</p>
<ul>
<li>相对路径是：</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">.          </span>表示当前目录
<span class="hljs-bullet">..         </span>表示上一级目录
资源名     表示当前目录/资源名</code></pre></div>

<p>绝对路径： <code>http://ip:port/工程路径/资源路径</code> </p>
<p>在实际开发中， 路径都使用绝对路径， 而不简单的使用相对路径,具体而言, 绝对路径的表示方式有:</p>
<ul>
<li>绝对路径</li>
<li>base+相对</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// i.getRequestURI() 获取请求的资源路径</span>
System.out.println(<span class="hljs-string">&quot;URI =&gt; &quot;</span> + req.getRequestURI());
<span class="hljs-comment">// ii.getRequestURL() 获取请求的统一资源定位符（绝对路径）</span>
System.out.println(<span class="hljs-string">&quot;URL =&gt; &quot;</span> + req.getRequestURL());
<span class="hljs-comment">//动态获取当前项目的路径(磁盘上的真实路径)</span>
ServletContext context=getServletContext();
response.sendRedirect(context.getContextPath()+<span class="hljs-string">&quot;/pages/a.html&quot;</span>)</code></pre></div>

<p><strong>web 中 / 斜杠的不同意义</strong></p>
<p>在 web 中 / 斜杠 是一种绝对路径</p>
<p>/ 斜杠 如果被浏览器解析，得到的地址是：<a href="http://ip:port/">http://ip:port/</a></p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>斜杠<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div>

<p>/ 斜杠 如果被服务器解析，得到的地址是：<a href="http://ip:port/工程路径">http://ip:port/工程路径</a></p>
<ul>
<li><url-pattern>/servlet1</url-pattern></li>
<li>servletContext.getRealPath(“/”);</li>
<li>request.getRequestDispatcher(“/”);</li>
</ul>
<p><strong>特殊情况</strong>：</p>
<p>response.sendRediect(“/”); 把斜杠发送给浏览器解析。得到 <a href="http://ip:port/">http://ip:port/</a></p>
<p><strong>中文乱码问题</strong></p>
<p><strong>get请求：</strong></p>
<p>使用Servlet处理get请求时，如果get请求的参数中有中文，直接接收会是乱码，这个时候需要使用类似下面的语句来处理乱码:</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">String name = request.getParameter(<span class="hljs-string">&quot;name&quot;</span>);
System.out.prinlnt(name); <span class="hljs-comment">// 乱码</span>

<span class="hljs-comment">// 处理乱码</span>
name = <span class="hljs-keyword">new</span> String(name.getBytes(<span class="hljs-string">&quot;ISO8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);
System.out.println(name);<span class="hljs-comment">// 乱码问题解决</span></code></pre></div>

<p>每次中文都要处理，比较麻烦，可以使用过滤器，使用类似下面的代码处理乱码问题:</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getParameter</span><span class="hljs-params">(String name)</span> </span>&#123;
    String value = <span class="hljs-keyword">super</span>.getParameter(name);
    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    String method = request.getMethod();
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;get&quot;</span>.equalsIgnoreCase(method)) &#123;
        <span class="hljs-keyword">try</span> &#123;
            value = <span class="hljs-keyword">new</span> String(value.getBytes(<span class="hljs-string">&quot;ISO8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);
        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> value;
&#125;</code></pre></div>

<p>为什么我们需要将ISO8859-1转为UTF-8？为什么接收到的参数是ISO8859-1这种编码方式的？<br>其实很简单，只是个配置问题：<br>在tomcat安装目录下的conf/server.xml中，有如下的配置：</p>
<p>URIEncoding该配置决定了使用get请求通过浏览器地址栏访问tomcat时的编码方式，默认的编码方式使ISO8859-1:</p>
<div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">URIEncoding:This specifies <span class="hljs-keyword">the</span> <span class="hljs-keyword">character</span> encoding used <span class="hljs-built_in">to</span> decode <span class="hljs-keyword">the</span> URI <span class="hljs-keyword">bytes</span>, <span class="hljs-keyword">after</span> %xx decoding <span class="hljs-keyword">the</span> <span class="hljs-built_in">URL</span>. If <span class="hljs-keyword">not</span> specified, ISO-``<span class="hljs-number">8859</span>``-``<span class="hljs-number">1</span>` `will be used.</code></pre></div>

<p>可以这样配置，则上述代码中，就不需要再从ISO8859-1转为UTF-8了：</p>
<div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span></code></pre></div>

<p>值得注意的是，从tomcat8.0开始，URIEncoding默认值不再是ISO8859-1，而变成了UTF-8 ，那么也就意味着，从tomcat8.0开始，get请求中的中文参数，不需要特殊处理了</p>
<p><strong>post请求：</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span>
<span class="hljs-function">IOException </span>&#123;
    <span class="hljs-comment">// 设置请求体的字符集为 UTF-8，从而解决 post 请求的中文乱码问题</span>
    req.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);
    System.out.println(<span class="hljs-string">&quot;-------------doPost------------&quot;</span>);
    <span class="hljs-comment">// 获取请求参数</span>
    String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);
    String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);
    String[] hobby = req.getParameterValues(<span class="hljs-string">&quot;hobby&quot;</span>);
    System.out.println(<span class="hljs-string">&quot;用户名：&quot;</span> + username);
    System.out.println(<span class="hljs-string">&quot;密码：&quot;</span> + password);
    System.out.println(<span class="hljs-string">&quot;兴趣爱好：&quot;</span> + Arrays.asList(hobby));
&#125;</code></pre></div>

<h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><p><strong>HttpServletResponse 类的作用</strong> </p>
<ul>
<li>HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息</li>
<li>我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置</li>
</ul>
<p><strong>两个输出流的说明</strong></p>
<ul>
<li><p>字节流 getOutputStream(); 常用于下载（传递二进制数据） </p>
</li>
<li><p>字符流 getWriter(); 常用于回传字符串（常用）</p>
</li>
<li><p>两个流同时只能使用一个，使用了字节流，就不能再使用字符流，反之亦然，否则就会报错</p>
</li>
</ul>
<p><strong>响应的乱码解决</strong></p>
<p>解决响应中文乱码方案一（不推荐使用）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 设置服务器字符集为 UTF-8</span>
resp.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);
<span class="hljs-comment">// 通过响应头，设置浏览器也使用 UTF-8 字符集</span>
resp.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html; charset=UTF-8);</span></code></pre></div>

<p>解决响应中文乱码方案二（推荐）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 它会同时设置服务器和客户端都使用 UTF-8 字符集，还设置了响应头</span>
<span class="hljs-comment">// 此方法一定要在获取流对象之前调用才有效</span>
resp.setContentType(<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);</code></pre></div>

<p><strong>请求重定向</strong></p>
<p>请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求 重定向（因为之前的地址可能已经被废弃）。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210421113301751-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210421113301751"></p>
<p>请求重定向的第一种方案：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 设置响应状态码 302 ，表示重定向，（已搬迁）</span>
resp.setStatus(<span class="hljs-number">302</span>);
<span class="hljs-comment">// 设置响应头，说明 新的地址在哪里</span>
resp.setHeader(<span class="hljs-string">&quot;Location&quot;</span>, <span class="hljs-string">&quot;http://localhost:8080&quot;</span>);</code></pre></div>

<p>请求重定向的第二种方案（推荐使用）：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">resp.sendRedirect(<span class="hljs-string">&quot;http://localhost:8080&quot;</span>);</code></pre></div>

<h2 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h2><p>文件的上传和下载，是非常常见的功能。很多的系统中，或者软件中都经常使用文件的上传和下载。 比如：QQ 头像，就使用了上传。 邮箱中也有附件的上传和下载功能。 OA 系统中审批有附件材料的上传</p>
<p><strong>文件的上传介绍</strong></p>
<p>1、要有一个 form 标签，<code>method=post </code>请求 </p>
<p>2、form 标签的 encType 属性值必须为<code>multipart/form-data</code>值 </p>
<p>3、在 form 标签中使用<code>input type=file</code>添加上传的文件 </p>
<p>4、编写服务器代码（Servlet 程序）接收，处理上传的数据</p>
<p><code>encType=multipart/form-data</code>表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼接，然后以二进制流的形式发送给服务器</p>
<p><strong>HTTP 协议的说明</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424203534339.png" srcset="/img/loading.gif" lazyload alt="image-20210424203534339"></p>
<p><strong>commons-fileupload.jar常用API</strong></p>
<p><code>commons-fileupload.jar</code> 需要依赖 <code>commons-io.jar</code> 这个包，所以两个包我们都要引入</p>
<p>第一步，就是需要导入两个 jar 包：</p>
<ul>
<li><p>commons-fileupload-1.2.1.jar</p>
</li>
<li><p>commons-io-1.4.jar</p>
</li>
</ul>
<p><code>commons-fileupload.jar</code> 和 <code>commons-io.jar</code> 包中，我们常用的类有哪些？</p>
<ul>
<li><code>ServletFileUpload</code> 类，用于解析上传的数据</li>
<li><code>FileItem</code>类，表示每一个表单项</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//判断当前上传的数据格式是否是多段的格式</span>
<span class="hljs-keyword">boolean</span> ServletFileUpload.isMultipartContent(HttpServletRequest request);
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;FileItem&gt; <span class="hljs-title">parseRequest</span><span class="hljs-params">(HttpServletRequest request)</span><span class="hljs-comment">//解析上传的数据</span></span>
<span class="hljs-function"><span class="hljs-comment">//判断当前这个表单项，是否是普通的表单项。还是上传的文件类型</span></span>
<span class="hljs-function"><span class="hljs-comment">//true 表示普通类型的表单项 false 表示上传的文件类型</span></span>
<span class="hljs-function"><span class="hljs-keyword">boolean</span> FileItem.<span class="hljs-title">isFormField</span><span class="hljs-params">()</span></span>
<span class="hljs-function">String FileItem.<span class="hljs-title">getFieldName</span><span class="hljs-params">()</span><span class="hljs-comment">//获取表单项的 name 属性值</span></span>
<span class="hljs-function">String FileItem.<span class="hljs-title">getString</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前表单项的值。</span></span>
<span class="hljs-function">String FileItem.<span class="hljs-title">getName</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取上传的文件名</span>
<span class="hljs-keyword">void</span> FileItem.write( file ); <span class="hljs-comment">//将上传的文件写到参数 file 所指向硬盘位置</span></code></pre></div>

<p><strong>fileupload 类库的使用</strong></p>
<p>上传文件的表单</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://192.168.31.74:8080/09_EL_JSTL/uploadServlet&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>

用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
头像：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;photo&quot;</span> &gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div>

<p>解析上传的数据的代码</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424204308913.png" srcset="/img/loading.gif" lazyload alt="image-20210424204308913"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424204320995.png" srcset="/img/loading.gif" lazyload alt="image-20210424204320995"></p>
<p><strong>文件下载</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424210255797.png" srcset="/img/loading.gif" lazyload alt="image-20210424210255797"></p>
<p>下载的常用 API 说明</p>
<ul>
<li>response.getOutputStream(); </li>
<li>servletContext.getResourceAsStream(); </li>
<li>servletContext.getMimeType(); </li>
<li>response.setContentType();</li>
</ul>
<p><code>response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; fileName=1.jpg&quot;);</code></p>
<p>这个响应头告诉浏览器。这是需要下载的。而attachment表示附件，也就是下载的一个文件。fileName=后面，表示下载的文件名。</p>
<p>完成上面的两个步骤，下载文件是没问题了。但是如果我们要下载的文件是中文名的话。你会发现，下载无法正确显示出正确的中文名。</p>
<p>原因是在响应头中，不能包含有中文字符，只能包含 ASCII 码</p>
<p><strong>中文名乱码问题解决方案</strong></p>
<p>URLEncoder 解决 IE 和谷歌浏览器的附件中文名问题</p>
<p>如果客户端浏览器是 IE 浏览器 或者 是谷歌浏览器。我们需要使用 URLEncoder 类先对中文名进行 UTF-8 的编码 操作。 因为 IE 浏览器和谷歌浏览器收到含有编码后的字符串后会以 UTF-8 字符集进行解码显示。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 把中文名进行 UTF-8 编码操作。</span>
String str = <span class="hljs-string">&quot;attachment; fileName=&quot;</span> + URLEncoder.encode(<span class="hljs-string">&quot;中文.jpg&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);
<span class="hljs-comment">// 然后把编码后的字符串设置到响应头中 </span>
response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, str);</code></pre></div>

<p>如果是FireFox，需要Base64编码</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210424211335676.png" srcset="/img/loading.gif" lazyload alt="image-20210424211335676"></p>
<h1 id="七、Cookie-amp-Session"><a href="#七、Cookie-amp-Session" class="headerlink" title="七、Cookie&amp;Session"></a>七、Cookie&amp;Session</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>http是无状态的，他不保存状态，意思就是一个浏览器发的请求，随后就断开了，下一次发送请求就和 上一次无关了。</p>
<p>比如一个用户购买一个商品，第一次需要登录，如果再买一个时向服务器发送请求，服务器如果不知道是谁发的，那么他就得再登录一次，这显然是不合理的，于是就提出了cookie和session的概念。</p>
<p>cookie是记录在浏览器端的一个字符串，session是保存在服务器端的一个对象。他们两互相配合让服务器有了能识别客户端一些状态的能力，意思就是服务就就能知道这个客户端有没有登录等。cookie就相当于通行证，session就是门房，进去时需要从门房识别一个身份。</p>
<p><strong>创建时机</strong></p>
<ol>
<li><p>当浏览器向客户端发送请求时，服务器会为他创建一个session，同时相应会加一个头（SetCookie: jsessionid=ewrwerwer123）</p>
</li>
<li><p>浏览器得到相应就会在在自己这保存下这个字符串，以后访问这个网站的时候就会一直带着。</p>
</li>
<li><p>当下一个请求发起时，会带着这个cookie的信息，服务器通过查询id找的session，通过session内保存的信息，就能获得这个客户端的状态。</p>
</li>
</ol>
<p><strong>什么是 Cookie?</strong> </p>
<ul>
<li>Cookie 翻译过来是饼干的意思</li>
<li>Cookie 是服务器通知客户端保存键值对的一种技术 </li>
<li>客户端有了 Cookie 后，每次请求都发送给服务器</li>
<li>每个 Cookie 的大小不能超过 4kb</li>
</ul>
<p><strong>如何创建 Cookie</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210419220806656-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210419220806656"></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createCookie</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,</span>
<span class="hljs-function">IOException </span>&#123;
<span class="hljs-comment">//1 创建 Cookie 对象</span>
Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-string">&quot;value4&quot;</span>);
<span class="hljs-comment">//2 通知客户端保存 Cookie</span>
resp.addCookie(cookie);
<span class="hljs-comment">//1 创建 Cookie 对象</span>
Cookie cookie1 = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;key5&quot;</span>, <span class="hljs-string">&quot;value5&quot;</span>);
<span class="hljs-comment">//2 通知客户端保存 Cookie</span>
resp.addCookie(cookie1);
resp.getWriter().write(<span class="hljs-string">&quot;Cookie 创建成功&quot;</span>);
&#125;</code></pre></div>

<p><strong>服务器如何获取 Cookie</strong></p>
<p>服务器获取客户端的 Cookie 只需要一行代码：req.getCookies():Cookie[]</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210419221025141-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210419221025141"></p>
<p>Cookie 的工具类：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CookieUtils</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 查找指定名称的Cookie对象</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookies</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cookie <span class="hljs-title">findCookie</span><span class="hljs-params">(String name , Cookie[] cookies)</span></span>&#123;
        <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span> || cookies == <span class="hljs-keyword">null</span> || cookies.length == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;
            <span class="hljs-keyword">if</span> (name.equals(cookie.getName())) &#123;
                <span class="hljs-keyword">return</span> cookie;
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;

&#125;</code></pre></div>

<p>Servlet 程序中的代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCookie</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        Cookie[] cookies = req.getCookies();

        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;
            <span class="hljs-comment">// getName方法返回Cookie的key（名）</span>
            <span class="hljs-comment">// getValue方法返回Cookie的value值</span>
            resp.getWriter().write(<span class="hljs-string">&quot;Cookie[&quot;</span> + cookie.getName() + <span class="hljs-string">&quot;=&quot;</span> + cookie.getValue() + <span class="hljs-string">&quot;] &lt;br/&gt;&quot;</span>);
        &#125;

        Cookie iWantCookie = CookieUtils.findCookie(<span class="hljs-string">&quot;key1&quot;</span>, cookies);

<span class="hljs-comment">//        for (Cookie cookie : cookies) &#123;</span>
<span class="hljs-comment">//            if (&quot;key2&quot;.equals(cookie.getName())) &#123;</span>
<span class="hljs-comment">//                iWantCookie = cookie;</span>
<span class="hljs-comment">//                break;</span>
<span class="hljs-comment">//            &#125;</span>
<span class="hljs-comment">//        &#125;</span>
        <span class="hljs-comment">// 如果不等于null，说明赋过值，也就是找到了需要的Cookie</span>
        <span class="hljs-keyword">if</span> (iWantCookie != <span class="hljs-keyword">null</span>) &#123;
            resp.getWriter().write(<span class="hljs-string">&quot;找到了需要的Cookie&quot;</span>);
        &#125;
    &#125;</code></pre></div>

<p><strong>Cookie 值的修改</strong></p>
<p>方案一： </p>
<div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span>、先创建一个要修改的同名（指的就是 <span class="hljs-keyword">key</span>）的 Cookie 对象 

<span class="hljs-number">2</span>、在构造器，同时赋于新的 Cookie 值。 

<span class="hljs-number">3</span>、调用 response.addCookie( Cookie )</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;key1&quot;</span>,<span class="hljs-string">&quot;newValue1&quot;</span>);
resp.addCookie(cookie);</code></pre></div>

<p>方案二： </p>
<div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">1</span>、先查找到需要修改的 <span class="hljs-selector-tag">Cookie</span> 对象 

<span class="hljs-selector-tag">2</span>、调用 <span class="hljs-selector-tag">setValue</span>()方法赋于新的 <span class="hljs-selector-tag">Cookie</span> 值。 

<span class="hljs-selector-tag">3</span>、调用 <span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.addCookie</span>()通知客户端保存修改</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs java">Cookie cookie = CookieUtils.findCookie(<span class="hljs-string">&quot;key2&quot;</span>, req.getCookies());
       <span class="hljs-keyword">if</span> (cookie != <span class="hljs-keyword">null</span>) &#123;
           cookie.setValue(<span class="hljs-string">&quot;newValue2&quot;</span>);
           resp.addCookie(cookie);
       &#125;</code></pre></div>

<p> <strong>Cookie 生命控制</strong></p>
<p>Cookie 的生命控制指的是如何管理 Cookie 什么时候被销毁（删除） </p>
<p><code>setMaxAge() </code></p>
<ul>
<li>正数，表示在指定的秒数后过期 </li>
<li>负数，表示浏览器一关，Cookie 就会被删除（默认值是-1）</li>
<li>零，表示马上删除 Cookie</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">    * 设置存活1个小时的Cooie</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> req</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resp</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">    */</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">life3600</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;

       Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;life3600&quot;</span>, <span class="hljs-string">&quot;life3600&quot;</span>);
       cookie.setMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">60</span>); <span class="hljs-comment">// 设置Cookie一小时之后被删除。无效</span>
       resp.addCookie(cookie);
       resp.getWriter().write(<span class="hljs-string">&quot;已经创建了一个存活一小时的Cookie&quot;</span>);

   &#125;

   <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * 马上删除一个Cookie</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> req</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resp</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">    */</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNow</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
       <span class="hljs-comment">// 先找到你要删除的Cookie对象</span>
       Cookie cookie = CookieUtils.findCookie(<span class="hljs-string">&quot;key4&quot;</span>, req.getCookies());
       <span class="hljs-keyword">if</span> (cookie != <span class="hljs-keyword">null</span>) &#123;
           <span class="hljs-comment">// 调用setMaxAge(0);</span>
           cookie.setMaxAge(<span class="hljs-number">0</span>); <span class="hljs-comment">// 表示马上删除，都不需要等待浏览器关闭</span>
           <span class="hljs-comment">// 调用response.addCookie(cookie);</span>
           resp.addCookie(cookie);

           resp.getWriter().write(<span class="hljs-string">&quot;key4的Cookie已经被删除&quot;</span>);
       &#125;

   &#125;

   <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * 默认的会话级别的Cookie</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> req</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resp</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> ServletException</span>
<span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">    */</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultLife</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
       Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;defalutLife&quot;</span>,<span class="hljs-string">&quot;defaultLife&quot;</span>);
       cookie.setMaxAge(-<span class="hljs-number">1</span>);<span class="hljs-comment">//设置存活时间</span>
       resp.addCookie(cookie);
   &#125;</code></pre></div>

<p><strong>Cookie 有效路径 Path 的设置</strong></p>
<p>Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。 </p>
<p>path 属性是通过请求的地址来进行有效的过滤。</p>
<div class="hljs code-wrapper"><pre><code class="hljs routeros">CookieA <span class="hljs-attribute">path</span>=/工程路径 

CookieB <span class="hljs-attribute">path</span>=/工程路径/abc</code></pre></div>

<p>请求地址如下： <a href="http://ip:port/工程路径/a.html">http://ip:port/工程路径/a.html</a> </p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">CookieA</span> 发送 

CookieB 不发送</code></pre></div>

<p> <a href="http://ip:port/工程路径/abc/a.html">http://ip:port/工程路径/abc/a.html</a> </p>
<div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">CookieA</span> 发送 

CookieB 发送</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;path1&quot;</span>, <span class="hljs-string">&quot;path1&quot;</span>);
    <span class="hljs-comment">// getContextPath() ===&gt;&gt;&gt;&gt;  得到工程路径</span>
    cookie.setPath( req.getContextPath() + <span class="hljs-string">&quot;/abc&quot;</span> ); <span class="hljs-comment">// ===&gt;&gt;&gt;&gt;  /工程路径/abc</span>
    resp.addCookie(cookie);
    resp.getWriter().write(<span class="hljs-string">&quot;创建了一个带有Path路径的Cookie&quot;</span>);</code></pre></div>

<p> <strong>Cookie 练习—免输入用户名登录</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210419222822461-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210419222822461"></p>
<p>login.jsp 页面</p>
<div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;http://localhost:8080/13_cookie_session/loginServlet&quot;</span> method=<span class="hljs-string">&quot;get&quot;</span>&gt;
	用户名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;$&#123;cookie.username.value&#125;&quot;</span>&gt; &lt;br&gt;
	密码：&lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>&gt; &lt;br&gt;
	&lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;登录&quot;</span>&gt;
&lt;/form&gt;</code></pre></div>

<p>LoginServlet </p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;
	String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);
	String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;wzg168&quot;</span>.equals(username) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(password)) &#123;
		<span class="hljs-comment">//登录 成功</span>
		Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;username&quot;</span>, username);
		cookie.setMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>);<span class="hljs-comment">//当前 Cookie 一周内有效</span>
		resp.addCookie(cookie);
		System.out.println(<span class="hljs-string">&quot;登录 成功&quot;</span>);
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-comment">// 登录 失败</span>
		System.out.println(<span class="hljs-string">&quot;登录 失败&quot;</span>);
	&#125;
&#125;</code></pre></div>

<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p> <strong>什么是 Session 会话?</strong></p>
<p>1、Session 就一个接口（HttpSession）。 </p>
<p>2、Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。 </p>
<p>3、每个客户端都有自己的一个 Session 会话。 </p>
<p>4、Session 会话中，我们经常用来保存用户登录之后的信息。</p>
<p> <strong>如何创建 Session 和获取(id 号,是否为新)</strong></p>
<p>如何创建和获取 Session。它们的 API 是一样的。 request.getSession() </p>
<ul>
<li><p>第一次调用是：创建 Session 会话 </p>
</li>
<li><p>之后调用都是：获取前面创建好的 Session 会话对象 </p>
</li>
</ul>
<p>isNew(); 判断到底是不是刚创建出来的（新的） </p>
<div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span> 表示刚创建 

<span class="hljs-literal">false</span> 表示获取之前创建</code></pre></div>

<p>每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 是唯一的。 </p>
<div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getId</span><span class="hljs-params">()</span></span> 得到 Session 的会话 id 值。</code></pre></div>

<p><strong>Session 域数据的存取</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 往 Session 中保存数据</span>
<span class="hljs-comment">* <span class="hljs-doctag">@param</span> req* <span class="hljs-doctag">@param</span> resp</span>
<span class="hljs-comment">* <span class="hljs-doctag">@throws</span> ServletException</span>
<span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;
	req.getSession().setAttribute(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);
	resp.getWriter().write(<span class="hljs-string">&quot;已经往 Session 中保存了数据&quot;</span>);
&#125;
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 获取 Session 域中的数据</span>
<span class="hljs-comment">* <span class="hljs-doctag">@param</span> req</span>
<span class="hljs-comment">* <span class="hljs-doctag">@param</span> resp</span>
<span class="hljs-comment">* <span class="hljs-doctag">@throws</span> ServletException</span>
<span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAttribute</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;
	Object attribute = req.getSession().getAttribute(<span class="hljs-string">&quot;key1&quot;</span>);
	resp.getWriter().write(<span class="hljs-string">&quot;从 Session 中获取出 key1 的数据是：&quot;</span> + attribute);
&#125;</code></pre></div>

<p> <strong>Session 生命周期控制</strong></p>
<p><code> public void setMaxInactiveInterval(int interval)</code> 设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。 </p>
<div class="hljs code-wrapper"><pre><code class="hljs pgsql">值为正数的时候，设定 <span class="hljs-keyword">Session</span> 的超时时长。 

负数表示永不超时（极少使用）</code></pre></div>

<p><code>public int getMaxInactiveInterval()</code> 获取 Session 的超时时间 </p>
<p><code>public void invalidate()</code>  让当前 Session 会话马上超时无效</p>
<p>Session 默认的超时时间长为 30 分钟</p>
<p>因为在 Tomcat 服务器的配置文件 web.xml中默认有以下的配置，它就表示配置了当前 Tomcat 服务器下所有的 Session 超时配置默认时长为：30 分钟。  </p>
<p>如果说。你希望你的 web 工程，默认的 Session 的超时时长为其他时长。你可以在你自己的 web.xml 配置文件中做 以上相同的配置。就可以修改你的 web 工程所有 Seession 的默认超时时长。</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--表示当前 web 工程。创建出来 的所有 Session 默认是 20 分钟 超时时长--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span></code></pre></div>

<p>Session 超时的概念介绍：</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210420170135655-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210420170135655"></p>
<p>示例代码：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">life3</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;
	<span class="hljs-comment">// 先获取 Session 对象</span>
	HttpSession session = req.getSession();
	<span class="hljs-comment">// 设置当前 Session3 秒后超时</span>
	session.setMaxInactiveInterval(<span class="hljs-number">3</span>);
	resp.getWriter().write(<span class="hljs-string">&quot;当前 Session 已经设置为 3 秒后超时&quot;</span>);
&#125;</code></pre></div>

<p>Session 马上超时示例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNow</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;
	<span class="hljs-comment">// 先获取 Session 对象</span>
	HttpSession session = req.getSession();
	<span class="hljs-comment">// 让 Session 会话马上超时</span>
	session.invalidate();
	resp.getWriter().write(<span class="hljs-string">&quot;Session 已经设置为超时（无效）&quot;</span>);
&#125;</code></pre></div>

<p> <strong>浏览器和 Session 之间关联的技术内幕</strong></p>
<p>Session 技术，底层其实是基于 Cookie 技术来实现的。</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210420170339207-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210420170339207"></p>
<h1 id="八、Filter"><a href="#八、Filter" class="headerlink" title="八、Filter"></a>八、Filter</h1><h2 id="什么是过滤器"><a href="#什么是过滤器" class="headerlink" title="什么是过滤器"></a>什么是过滤器</h2><p>1、Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是：Servlet 程序、Listener 监听器、Filter 过滤器</p>
<p>2、Filter 过滤器它是 JavaEE 的规范。也就是接口 </p>
<p>3、Filter 过滤器它的作用是：拦截请求，过滤响应。</p>
<p><strong>拦截请求常见的应用场景有：</strong></p>
<p>1、权限检查 </p>
<p>2、日记操作 </p>
<p>3、事务管理</p>
<p><strong>Filter 的初体验</strong></p>
<p>要求：在你的 web 工程下，有一个 admin 目录。这个 admin 目录下的所有资源（html 页面、jpg 图片、jsp 文件、等等）都必 须是用户登录之后才允许访问。 </p>
<p>思考：根据之前我们学过内容。我们知道，用户登录之后都会把用户登录的信息保存到Session域中。所以要检查用户是否登录，可以判断Session中否包含有用户登录的信息</p>
<div class="hljs code-wrapper"><pre><code class="hljs java">Object user = session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);
<span class="hljs-comment">// 如果等于 null，说明还没有登录</span>
<span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;
	request.getRequestDispatcher(<span class="hljs-string">&quot;/login.jsp&quot;</span>).forward(request,response);
	<span class="hljs-keyword">return</span>;
&#125;</code></pre></div>

<h2 id="Filter-的工作流程图"><a href="#Filter-的工作流程图" class="headerlink" title="Filter 的工作流程图"></a>Filter 的工作流程图</h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210420171201652-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210420171201652"></p>
<p>Filter 代码:</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * doFilter 方法，专门用于拦截请求。可以做权限检查</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChainfilterChain)</span> <span class="hljs-keyword">throws</span> IOException,ServletException </span>&#123;
   		HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;
    	HttpSession session = httpServletRequest.getSession();
    	Object user = session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);
    	<span class="hljs-comment">// 如果等于 null，说明还没有登录</span>
    	<span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;
    		servletRequest.getRequestDispatcher(<span class="hljs-string">&quot;/login.jsp&quot;</span>).forward(servletRequest,servletResponse);
    		<span class="hljs-keyword">return</span>;
    	&#125; <span class="hljs-keyword">else</span> &#123;
    	<span class="hljs-comment">// 让程序继续往下访问用户的目标资源</span>
    		filterChain.doFilter(servletRequest,servletResponse);
    	&#125;
    &#125;
&#125;</code></pre></div>

<p>web.xml 中的配置：</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--filter 标签用于配置一个 Filter 过滤器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-comment">&lt;!--给 filter 起一个别名--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-comment">&lt;!--配置 filter 的全类名--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.atguigu.filter.AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-comment">&lt;!--filter-mapping 配置 Filter 过滤器的拦截路径--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
    <span class="hljs-comment">&lt;!--filter-name 表示当前的拦截路径给哪个 filter 使用--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-comment">&lt;!--url-pattern 配置拦截路径</span>
<span class="hljs-comment">    / 表示请求地址为：http://ip:port/工程路径/ 映射到 IDEA 的 web 目录</span>
<span class="hljs-comment">    /admin/* 表示请求地址为：http://ip:port/工程路径/admin/*</span>
<span class="hljs-comment">    --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/admin/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div>

<p>Filter 过滤器的使用步骤： </p>
<p>1、编写一个类去实现 Filter 接口 </p>
<p>2、实现过滤方法 doFilter() </p>
<p>3、到 web.xml 中去配置 Filter 的拦截路径</p>
<h2 id="Filter-的生命周期"><a href="#Filter-的生命周期" class="headerlink" title="Filter 的生命周期"></a><strong>Filter 的生命周期</strong></h2><p>Filter 的生命周期包含几个方法 </p>
<ul>
<li><p>构造器方法 </p>
</li>
<li><p>init 初始化方法 </p>
<ul>
<li>第 1，2 步，在 web 工程启动的时候执行（Filter 已经创建）</li>
</ul>
</li>
<li><p>doFilter 过滤方法 </p>
<ul>
<li>第 3 步，每次拦截到请求，就会执行</li>
</ul>
</li>
<li><p>destroy 销毁 </p>
<ul>
<li>第 4 步，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器）</li>
</ul>
</li>
</ul>
<h2 id="FilterConfig-类"><a href="#FilterConfig-类" class="headerlink" title="FilterConfig 类"></a><strong>FilterConfig 类</strong></h2><p>FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。 </p>
<p>Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。 </p>
<p>FilterConfig 类的作用是获取 filter 过滤器的配置内容 </p>
<ul>
<li>获取 Filter 的名称 filter-name 的内容</li>
<li>获取在 Filter 中配置的 init-param 初始化参数 </li>
<li>获取 ServletContext 对象</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;
    System.out.println(<span class="hljs-string">&quot;2.Filter 的 init(FilterConfig filterConfig)初始化&quot;</span>);
    <span class="hljs-comment">// 1、获取 Filter 的名称 filter-name 的内容</span>
    System.out.println(<span class="hljs-string">&quot;filter-name 的值是：&quot;</span> + filterConfig.getFilterName());
    <span class="hljs-comment">// 2、获取在 web.xml 中配置的 init-param 初始化参数</span>
    System.out.println(<span class="hljs-string">&quot;初始化参数 username 的值是：&quot;</span> + filterConfig.getInitParameter(<span class="hljs-string">&quot;username&quot;</span>));
    System.out.println(<span class="hljs-string">&quot;初始化参数 url 的值是：&quot;</span> + filterConfig.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>));
    <span class="hljs-comment">// 3、获取 ServletContext 对象</span>
    System.out.println(filterConfig.getServletContext());
&#125;</code></pre></div>

<p>web.xml 配置</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--filter 标签用于配置一个 Filter 过滤器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-comment">&lt;!--给 filter 起一个别名--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-comment">&lt;!--配置 filter 的全类名--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.atguigu.filter.AdminFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost3306/test<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span></code></pre></div>

<h2 id="FilterChain-过滤器链"><a href="#FilterChain-过滤器链" class="headerlink" title="FilterChain 过滤器链"></a><strong>FilterChain 过滤器链</strong></h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210420172137716-9168959.png" srcset="/img/loading.gif" lazyload alt="image-20210420172137716"></p>
<h2 id="Filter-的拦截路径"><a href="#Filter-的拦截路径" class="headerlink" title="Filter 的拦截路径"></a><strong>Filter 的拦截路径</strong></h2><p>精确匹配</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/target.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/target.jsp</code></pre></div>

<p>目录匹配</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/admin/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/admin/*</code></pre></div>

<p>后缀名匹配</p>
<div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.html<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
以上配置的路径，表示请求地址必须以.html 结尾才会拦截到
<span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
以上配置的路径，表示请求地址必须以.do 结尾才会拦截到
<span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.action<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
以上配置的路径，表示请求地址必须以.action 结尾才会拦截到</code></pre></div>

<h2 id="使用-Filter和ThreadLocal组合管理事务"><a href="#使用-Filter和ThreadLocal组合管理事务" class="headerlink" title="使用 Filter和ThreadLocal组合管理事务"></a><strong>使用 Filter和ThreadLocal组合管理事务</strong></h2><p>使用 ThreadLocal 来确保所有 dao 操作都在同一个 Connection 连接对象中完成</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425220820180.png" srcset="/img/loading.gif" lazyload alt="image-20210425220820180"></p>
<p><strong>JdbcUtils 工具类的修改</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221034230.png" srcset="/img/loading.gif" lazyload alt="image-20210425221034230"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221121726.png" srcset="/img/loading.gif" lazyload alt="image-20210425221121726"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221143361.png" srcset="/img/loading.gif" lazyload alt="image-20210425221143361"></p>
<p><strong>修改 BaseDao</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221206385.png" srcset="/img/loading.gif" lazyload alt="image-20210425221206385"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221232144.png" srcset="/img/loading.gif" lazyload alt="image-20210425221232144"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221250908.png" srcset="/img/loading.gif" lazyload alt="image-20210425221250908"></p>
<p><strong>使用 Filter 过滤器统一给所有的 Service 方法都加上 try-catch。来进行实现的管理</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221339475.png" srcset="/img/loading.gif" lazyload alt="image-20210425221339475"></p>
<p><strong>Filter 类代码</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221416401.png" srcset="/img/loading.gif" lazyload alt="image-20210425221416401"></p>
<p><strong>在 web.xml 中的配置</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221444049.png" srcset="/img/loading.gif" lazyload alt="image-20210425221444049"></p>
<p><strong>记得把 BaseServlet 中的异常往外抛给 Filter 过滤器</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221511723.png" srcset="/img/loading.gif" lazyload alt="image-20210425221511723"></p>
<p><strong>将所有异常都统一交给 Tomcat，让 Tomcat 展示友好的错误信息页面</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221540610.png" srcset="/img/loading.gif" lazyload alt="image-20210425221540610"></p>
<h1 id="九、Listener"><a href="#九、Listener" class="headerlink" title="九、Listener"></a>九、Listener</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>监听器用于监听Web应用中某些对象的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理。当监听范围的对象的状态发生变化的时候，服务器自动调用监听器对象中的方法。常用于统计网站在线人数、系统加载时进行信息初始化、统计网站的访问量等等。</p>
<p>实现监听：</p>
<ol>
<li>创建类实现监听器接口</li>
<li><code>web.xml</code>文件中配置(注册）监听器<code>&lt;listener&gt; &lt;listener-class&gt;url&lt;/listener-class&gt;&lt;/listener&gt;</code> ，<code>Servlet3.0</code>后可以通过注解@WebListener 注册监听器</li>
</ol>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210425221742885.png" srcset="/img/loading.gif" lazyload alt="image-20210425221742885"></p>
<p>web.xml 的加载顺序是：context- param -&gt; listener -&gt; filter -&gt; servlet</p>
<h2 id="Listener监听三个域对象创建与销毁"><a href="#Listener监听三个域对象创建与销毁" class="headerlink" title="Listener监听三个域对象创建与销毁"></a>Listener监听三个域对象创建与销毁</h2><p>监听<code>ServletContext</code>域对象的创建与销毁：实现<code>ServletContextListener</code>接口。</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServletContextListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span></span>&#123;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;
		System.out.println(<span class="hljs-string">&quot;初始化&quot;</span>);
	&#125;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent arg0)</span> </span>&#123;
		System.out.println(<span class="hljs-string">&quot;销毁了&quot;</span>);
	&#125;

&#125;</code></pre></div>

<p>监听<code>ServletRequest</code>域对象的创建与销毁：实现<code>ServletRequestListener</code>接口。</p>
<p><code>ServletRequest</code>域对象的生命周期：</p>
<div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">创建：访问服务器任何资源都会发送请求<span class="hljs-params">(ServletRequest)</span>出现,访问<span class="hljs-string">.html</span>和<span class="hljs-string">.jsp</span>和<span class="hljs-string">.servlet</span>都会创建请求
销毁：服务器已经对该次请求做出了响应</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServletRequestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletRequestListener</span></span>&#123;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestDestroyed</span><span class="hljs-params">(ServletRequestEvent arg0)</span> </span>&#123;
		System.out.println(<span class="hljs-string">&quot;ServletRequest销毁了&quot;</span>);
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestInitialized</span><span class="hljs-params">(ServletRequestEvent arg0)</span> </span>&#123;
		System.out.println(<span class="hljs-string">&quot;ServletRequest创建了&quot;</span>);
	&#125;

&#125;
</code></pre></div>

<p>监听<code>HttpSession</code>域对象的创建与销毁：实现<code>HttpSessionListener</code>接口：<br><code>HttpSession</code>域对象的生命周期：</p>
<div class="hljs code-wrapper"><pre><code class="hljs less">创建：只要调用了<span class="hljs-selector-tag">getSession</span>()方法就会创建，一次会话只会创建一次
销毁：<span class="hljs-selector-tag">1</span>.超时(默认为<span class="hljs-number">30</span>分钟)<span class="hljs-selector-tag">2</span>.非正常关闭，销毁<span class="hljs-selector-tag">3</span>.正常关闭服务器(序列化)</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHttpSessionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span></span>&#123;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent arg0)</span> </span>&#123;
		System.out.println(<span class="hljs-string">&quot;HttpSession创建了&quot;</span>);
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent arg0)</span> </span>&#123;
		System.out.println(<span class="hljs-string">&quot;HTTPSession销毁了&quot;</span>);
	&#125;

&#125;
</code></pre></div>

<h1 id="十、JSON"><a href="#十、JSON" class="headerlink" title="十、JSON"></a>十、JSON</h1><h2 id="什么是-JSON"><a href="#什么是-JSON" class="headerlink" title="什么是 JSON?"></a>什么是 JSON?</h2><p> JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 这样就使得 JSON 成为理想的数据交换格式。</p>
<p> json 是一种轻量级的数据交换格式。 </p>
<ul>
<li><p>轻量级指的是跟 xml 做比较</p>
</li>
<li><p>数据交换指的是客户端和服务器之间业务数据的传递格式</p>
</li>
</ul>
<h2 id="JSON-在-JavaScript-中的使用"><a href="#JSON-在-JavaScript-中的使用" class="headerlink" title="JSON 在 JavaScript 中的使用"></a>JSON 在 JavaScript 中的使用</h2><p><strong>json 的定义</strong></p>
<p>json 是由键值对组成，并且由花括号（大括号）包围。每个键由引号引起来，键和值之间使用冒号进行分隔， 多组键值对之间进行逗号进行分隔。</p>
<p>json 定义示例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> jsonObj = &#123;
    <span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-number">12</span>,
    <span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;abc&quot;</span>,
    <span class="hljs-string">&quot;key3&quot;</span>:<span class="hljs-literal">true</span>,
    <span class="hljs-string">&quot;key4&quot;</span>:[<span class="hljs-number">11</span>,<span class="hljs-string">&quot;arr&quot;</span>,<span class="hljs-literal">false</span>],
    <span class="hljs-string">&quot;key5&quot;</span>:&#123;
        <span class="hljs-string">&quot;key5_1&quot;</span> : <span class="hljs-number">551</span>,
        <span class="hljs-string">&quot;key5_2&quot;</span> : <span class="hljs-string">&quot;key5_2_value&quot;</span>
	&#125;,
    <span class="hljs-string">&quot;key6&quot;</span>:[&#123;
        <span class="hljs-string">&quot;key6_1_1&quot;</span>:<span class="hljs-number">6611</span>,
        <span class="hljs-string">&quot;key6_1_2&quot;</span>:<span class="hljs-string">&quot;key6_1_2_value&quot;</span>&#125;,&#123;
        <span class="hljs-string">&quot;key6_2_1&quot;</span>:<span class="hljs-number">6621</span>,
        <span class="hljs-string">&quot;key6_2_2&quot;</span>:<span class="hljs-string">&quot;key6_2_2_value&quot;</span>
    &#125;]
&#125;;</code></pre></div>

<p><strong>json的访问</strong></p>
<p>json 本身是一个对象。 </p>
<p>json 中的 key 我们可以理解为是对象中的一个属性。 </p>
<p>json 中的 key 访问就跟访问对象的属性一样： json 对象.key </p>
<p>json访问示例：</p>
<div class="hljs code-wrapper"><pre><code class="hljs javascript">alert(<span class="hljs-keyword">typeof</span>(jsonObj));<span class="hljs-comment">// object json 就是一个对象</span>
alert(jsonObj.key1); <span class="hljs-comment">//12</span>
alert(jsonObj.key2); <span class="hljs-comment">// abc</span>
alert(jsonObj.key3); <span class="hljs-comment">// true</span>
alert(jsonObj.key4);<span class="hljs-comment">// 得到数组[11,&quot;arr&quot;,false]</span>
<span class="hljs-comment">// json 中 数组值的遍历</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; jsonObj.key4.length; i++) &#123;
alert(jsonObj.key4[i]);
&#125;
alert(jsonObj.key5.key5_1);<span class="hljs-comment">//551</span>
alert(jsonObj.key5.key5_2);<span class="hljs-comment">//key5_2_value</span>
alert( jsonObj.key6 );<span class="hljs-comment">// 得到 json 数组</span>
<span class="hljs-comment">// 取出来每一个元素都是 json 对象</span>
<span class="hljs-keyword">var</span> jsonItem = jsonObj.key6[<span class="hljs-number">0</span>];
<span class="hljs-comment">// alert( jsonItem.key6_1_1 ); //6611</span>
alert( jsonItem.key6_1_2 ); <span class="hljs-comment">//key6_1_2_value</span></code></pre></div>

<h2 id="json-的两个常用方法"><a href="#json-的两个常用方法" class="headerlink" title="json 的两个常用方法"></a><strong>json 的两个常用方法</strong></h2><ul>
<li><p>JSON.stringify() 把 json 对象转换成为 json 字符串</p>
</li>
<li><p>JSON.parse() 把 json 字符串转换成为 json 对象</p>
</li>
</ul>
<p><strong>json 的存在有两种形式。</strong></p>
<ul>
<li><p> 一种是：对象的形式存在，我们叫它 json 对象。 </p>
</li>
<li><p>一种是：字符串的形式存在，我们叫它 json 字符串。</p>
</li>
<li><p> 一般我们要操作 json 中的数据的时候，需要 json 对象的格式。</p>
</li>
<li><p>一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串。</p>
</li>
</ul>
<h2 id="JSON-在-java-中的使用"><a href="#JSON-在-java-中的使用" class="headerlink" title="JSON 在 java 中的使用"></a><strong>JSON 在 java 中的使用</strong></h2><p>jackson fastjson Gson </p>
<p><strong>JSON介绍</strong></p>
<p><strong>Java–&gt;json</strong></p>
<p>将一个类以json字符串的形式输出：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将一个类以json字符串的形式输出</span>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;
      	<span class="hljs-comment">//使用Jackson的ObjectMapper</span>
        ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();
        User user = <span class="hljs-keyword">new</span> User();
        user.setMoney(<span class="hljs-number">1000</span>);
        user.setUsername(<span class="hljs-string">&quot;张三&quot;</span>);
        user.setPassword(<span class="hljs-string">&quot;123&quot;</span>);
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(mapper.writeValueAsString(user));
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;</code></pre></div>

<p>以json字符串输出一个List集合：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;
    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();
    List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;User&gt;();
    User u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">1000</span>);
    list.add(u);
    u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;456&quot;</span>, <span class="hljs-number">2000</span>);
    list.add(u);
    u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-string">&quot;789&quot;</span>, <span class="hljs-number">3000</span>);
    list.add(u);
    u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;赵六&quot;</span>, <span class="hljs-string">&quot;555&quot;</span>, <span class="hljs-number">4000</span>);
    list.add(u);
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(mapper.writeValueAsString(list));
    &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;
        <span class="hljs-comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    &#125;
&#125;</code></pre></div>

<p>将一个Map以json字符串的形式输出：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;
    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();
    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();
    map.put(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);
    map.put(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(mapper.writeValueAsString(map));
    &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre></div>

<p><strong>Json–&gt;java</strong></p>
<p>json字符串转为javaBean</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;
    String str = <span class="hljs-string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;三国演义\&quot;,\&quot;price\&quot;:20,\&quot;author\&quot;:\&quot;罗贯中\&quot;,\&quot;detail\&quot;:&#123;\&quot;pressTime\&quot;:\&quot;2001-01-01\&quot;,\&quot;storyTime\&quot;:\&quot;196-05-06\&quot;&#125;,\&quot;attribute\&quot;:&#123;\&quot;category\&quot;:\&quot;小说\&quot;,\&quot;edition\&quot;:\&quot;9\&quot;&#125;&#125;&quot;</span>;
    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();
    <span class="hljs-keyword">try</span> &#123;
        Book book = mapper.readValue(str, Book.class);
        System.out.println(book.getAuthor()+<span class="hljs-string">&quot;,&quot;</span>+book.getAttribute().getCategory());
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre></div>

<p>json字符串转为List</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//json--&gt;List</span>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;
        String str = <span class="hljs-string">&quot;[&#123;\&quot;username\&quot;:\&quot;张三\&quot;,\&quot;password\&quot;:\&quot;123\&quot;,\&quot;money\&quot;:1000&#125;,&#123;\&quot;username\&quot;:\&quot;李四\&quot;,\&quot;password\&quot;:\&quot;456\&quot;,\&quot;money\&quot;:2000&#125;,&#123;\&quot;username\&quot;:\&quot;王五\&quot;,\&quot;password\&quot;:\&quot;789\&quot;,\&quot;money\&quot;:3000&#125;,&#123;\&quot;username\&quot;:\&quot;赵六\&quot;,\&quot;password\&quot;:\&quot;555\&quot;,\&quot;money\&quot;:4000&#125;]&quot;</span>;
        ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();
        <span class="hljs-keyword">try</span> &#123;
            List&lt;User&gt; us = mapper.readValue(str, <span class="hljs-keyword">new</span> TypeReference&lt;ArrayList&lt;User&gt;&gt;() &#123;&#125;);
            <span class="hljs-keyword">for</span> (User user : us) &#123;
                System.out.println(user.getUsername()+<span class="hljs-string">&quot;,&quot;</span>+user.getMoney());
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;</code></pre></div>

<p>json字符串转为Map：</p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//json--&gt;map</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;
    String str = <span class="hljs-string">&quot;&#123;\&quot;password\&quot;:\&quot;888888\&quot;,\&quot;username\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;
    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();
    <span class="hljs-keyword">try</span> &#123;
        Map&lt;String, String&gt; map = mapper.readValue(str, <span class="hljs-keyword">new</span> TypeReference&lt;Map&lt;String, String&gt;&gt;() &#123;&#125;);
        <span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;
            System.out.println(key+<span class="hljs-string">&quot;,&quot;</span>+map.get(key));
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre></div>

<h1 id="十一、Ajax"><a href="#十一、Ajax" class="headerlink" title="十一、Ajax"></a>十一、Ajax</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>AJAX即“Asynchronous Javascript And XML”(异步JavaScript和XML)，是指一种创建交互式网页应用的网页开发技术</p>
<ul>
<li><strong>ajax 是一种浏览器通过 js 异步发起请求，局部更新页面的技术</strong></li>
<li>ajax 请求的局部更新，浏览器地址栏不会发生变化 局部更新不会舍弃原来页面的内容</li>
</ul>
<p><strong>传统请求和异步请求</strong></p>
<ul>
<li>基于超级链接 地址栏 form表单 地址栏 location.href 发起的请求全部是传统请求<br>  特点: 请求之后,刷新整张页面<br>  缺点: 由于刷新了整张页面,用户操作被中断,造成大量网络流量的极大浪费。</li>
<li>基于ajax发起的请求都是异步请求<br>  特点: 多个请求并行发生,请求之间互不影响,请求之后页面不动,刷新页面的局部</li>
</ul>
<p><strong>传统网站中存在的问题</strong></p>
<ul>
<li>网速慢的情况下，页面加载时间长，用户只能等待</li>
<li>表单提交后，如果一项内容不合格，需要重新填写所有表单内容</li>
<li>页面跳转，重新加载页面，造成资源浪费，增加用户等待时间</li>
</ul>
<p><strong>Ajax 的应用场景</strong></p>
<ul>
<li>页面上拉加载更多数据</li>
<li>列表数据无刷新分页</li>
<li>表单项离开焦点数据验证</li>
<li>搜索框提示文字下拉列表</li>
</ul>
<p><strong>Ajax 运行原理</strong></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210426102426443.png" srcset="/img/loading.gif" lazyload alt="image-20210426102426443"></p>
<p><strong>核心对象</strong></p>
<p><code>XMLHttpRequest </code>对象是一个javascript对象，存在着浏览器差异。简称xhr对象</p>
<h2 id="Ajax入门"><a href="#Ajax入门" class="headerlink" title="Ajax入门"></a><strong>Ajax入门</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span>
<span class="javascript">		<span class="hljs-comment">// 1.创建ajax对象</span></span>
<span class="javascript">		<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span>
<span class="javascript">		<span class="hljs-comment">// 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求</span></span>
<span class="javascript">		<span class="hljs-comment">// 1)请求方式 2)请求地址</span></span>
<span class="javascript">		xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:3000/first&#x27;</span>);</span>
<span class="javascript">		<span class="hljs-comment">// 3.发送请求</span></span>
		xhr.send();
<span class="javascript">		<span class="hljs-comment">// 4.获取服务器端响应到客户端的数据</span></span>
<span class="javascript">		xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span>
<span class="javascript">			<span class="hljs-built_in">console</span>.log(xhr.responseText)</span>
		&#125;
	<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre></div>

<h2 id="Ajax-状态码"><a href="#Ajax-状态码" class="headerlink" title="Ajax 状态码"></a><strong>Ajax 状态码</strong></h2><p>在创建ajax对象，配置ajax对象，发送请求，以及接收完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。</p>
<blockquote>
<p>0：请求未初始化(还没有调用open())<br>1：请求已经建立，但是还没有发送(还没有调用send())<br>2：请求已经发送<br>3：请求正在处理中，通常响应中已经有部分数据可以用了<br>4：响应已经完成，可以获取并使用服务器的响应了<br>xhr.readyState // 获取Ajax状态码</p>
</blockquote>
<h2 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a><strong>onreadystatechange 事件</strong></h2><p>当 Ajax 状态码发生变化时将自动触发该事件。<br>在事件处理函数中可以获取 Ajax 状态码并对其进行判断，当状态码为 4 时就可以通过 xhr.responseText 获取服务器端的响应数据了。</p>
<p>不推荐,因为这种方式会由于状态码的变化被触发多次,效率低.推荐使用onload这种方式.唯一不足就是不兼容低版本IE浏览器</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210426104807866.png" srcset="/img/loading.gif" lazyload alt="image-20210426104807866"></p>
<h2 id="原生-ajax-请求的示例"><a href="#原生-ajax-请求的示例" class="headerlink" title="原生 ajax 请求的示例"></a><strong>原生 ajax 请求的示例</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;!DOCTYPE html PUBLIC <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;
&lt;html&gt;
	&lt;head&gt;
    &lt;meta http-equiv=<span class="hljs-string">&quot;pragma&quot;</span> content=<span class="hljs-string">&quot;no-cache&quot;</span> /&gt;
    &lt;meta http-equiv=<span class="hljs-string">&quot;cache-control&quot;</span> content=<span class="hljs-string">&quot;no-cache&quot;</span> /&gt;
    &lt;meta http-equiv=<span class="hljs-string">&quot;Expires&quot;</span> content=<span class="hljs-string">&quot;0&quot;</span> /&gt;
    &lt;meta http-equiv=<span class="hljs-string">&quot;Content-Type&quot;</span> content=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;
    &lt;title&gt;Insert title here&lt;/title&gt;
    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;
	<span class="hljs-comment">// 在这里使用 javaScript 语言发起 Ajax 请求，访问服务器 AjaxServlet 中 javaScriptAjax</span>
		<span class="hljs-function">function <span class="hljs-title">ajaxRequest</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-comment">// 1、我们首先要创建 XMLHttpRequest</span>
            <span class="hljs-keyword">var</span> xmlhttprequest = <span class="hljs-keyword">new</span> XMLHttpRequest();
            <span class="hljs-comment">// 2、调用 open 方法设置请求参数</span>
      	xmlhttprequest.open(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet?action=javaScriptAjax&quot;</span>,<span class="hljs-keyword">true</span>)
            <span class="hljs-comment">// 4、在 send 方法前绑定 onreadystatechange 事件，处理请求完成后的操作。</span>
            xmlhttprequest.onreadystatechange = function()&#123;
                <span class="hljs-keyword">if</span> (xmlhttprequest.readyState == <span class="hljs-number">4</span> &amp;&amp; xmlhttprequest.status == <span class="hljs-number">200</span>) &#123;
                    <span class="hljs-keyword">var</span> jsonObj = JSON.parse(xmlhttprequest.responseText);
                    <span class="hljs-comment">// 把响应的数据显示在页面上</span>
                    document.getElementById(<span class="hljs-string">&quot;div01&quot;</span>).innerHTML = <span class="hljs-string">&quot;编号：&quot;</span> + jsonObj.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> +jsonObj.name;
                &#125;
            &#125;
            <span class="hljs-comment">// 3、调用 send 方法发送请求</span>
            xmlhttprequest.send();
		&#125;
    &lt;/script&gt;
   &lt;/head&gt;
    &lt;body&gt;
    	&lt;button onclick=&quot;ajaxRequest()&quot;&gt;ajax request&lt;/button&gt;
    	&lt;div id=<span class="hljs-string">&quot;div01&quot;</span>&gt;
    	&lt;/div&gt;
    &lt;/body&gt;
   &lt;/html&gt;</code></pre></div>

<h2 id="发送GET方式请求"><a href="#发送GET方式请求" class="headerlink" title="发送GET方式请求"></a><strong>发送GET方式请求</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 创建xhr对象</span>
<span class="hljs-keyword">var</span> xhr ; 
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.XMLHttpRequest)&#123;
	xhr = <span class="hljs-keyword">new</span> XMLHttpRequest(); 
&#125;<span class="hljs-keyword">else</span>&#123;
	xhr = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>); 
&#125;
<span class="hljs-comment">//2.发送请求,并传递参数</span>
xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/ajax_day2/test?name=zhangsan&quot;</span>);
xhr.send();
<span class="hljs-comment">//3.处理响应</span>
xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; 
  <span class="hljs-keyword">if</span>(xhr.readyState==<span class="hljs-number">4</span> &amp;&amp; xhr.status==<span class="hljs-number">200</span>)&#123;
     <span class="hljs-built_in">console</span>.log(xhr.responseText);
 	&#125;
&#125;</code></pre></div>

<h2 id="发送POST方式请求"><a href="#发送POST方式请求" class="headerlink" title="发送POST方式请求"></a><strong>发送POST方式请求</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 创建xhr对象</span>
<span class="hljs-keyword">var</span> xhr; <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.XMLHttpRequest)&#123;
xhr = <span class="hljs-keyword">new</span> XMLHttpRequest(); &#125;<span class="hljs-keyword">else</span>&#123;
xhr = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>); &#125;
<span class="hljs-comment">//2.发送请求,并传递参数</span>
xhr.open(<span class="hljs-string">&quot;POST&quot;</span>,<span class="hljs-string">&quot;/ajax_day2/test&quot;</span>);
xhr.setRequestHeader(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>); xhr.send(<span class="hljs-string">&quot;name=zhangsan&quot;</span>);
<span class="hljs-comment">//3.处理响应</span>
xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
<span class="hljs-keyword">if</span>(xhr.readyState==<span class="hljs-number">4</span> &amp;&amp; xhr.status==<span class="hljs-number">200</span>)&#123; <span class="hljs-built_in">console</span>.log(xhr.reponseText);
&#125; 
&#125;
</code></pre></div>

<h2 id="Ajax的数据交换机制"><a href="#Ajax的数据交换机制" class="headerlink" title="Ajax的数据交换机制"></a><strong>Ajax的数据交换机制</strong></h2><p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210426110333170.png" srcset="/img/loading.gif" lazyload alt="image-20210426110333170"></p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210426110704108.png" srcset="/img/loading.gif" lazyload alt="image-20210426110704108"></p>
<h2 id="Ajax函数封装"><a href="#Ajax函数封装" class="headerlink" title="Ajax函数封装"></a><strong>Ajax函数封装</strong></h2><p>问题：发送一次请求代码过多，发送多次请求代码冗余且重复<br>解决方案：将请求代码封装到函数中，发请求时调用函数即可</p>
<p>利用回调函数</p>
<p><img src="https://luciferfigurebed.oss-cn-chengdu.aliyuncs.com/uPic/image-20210426112409636.png" srcset="/img/loading.gif" lazyload alt="image-20210426112409636"></p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span>
<span class="javascript">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span> (<span class="hljs-params">options</span>) </span>&#123;</span>
<span class="javascript">			<span class="hljs-comment">// 存储的是默认值</span></span>
<span class="javascript">			<span class="hljs-keyword">var</span> defaults = &#123;</span>
<span class="javascript">				type: <span class="hljs-string">&#x27;get&#x27;</span>,</span>
<span class="javascript">				url: <span class="hljs-string">&#x27;&#x27;</span>,</span>
				data: &#123;&#125;,
				header: &#123;
<span class="javascript">					<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span></span>
				&#125;,
<span class="javascript">				success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,</span>
<span class="javascript">				error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;</span>
			&#125;;

<span class="javascript">			<span class="hljs-comment">// 使用options对象中的属性覆盖defaults对象中的属性</span></span>
<span class="javascript">			<span class="hljs-built_in">Object</span>.assign(defaults, options); <span class="hljs-comment">//options会覆盖defaults原有的属性</span></span>

<span class="javascript">			<span class="hljs-comment">// 创建ajax对象</span></span>
<span class="javascript">			<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span>
<span class="javascript">			<span class="hljs-comment">// 拼接请求参数的变量</span></span>
<span class="javascript">			<span class="hljs-keyword">var</span> params = <span class="hljs-string">&#x27;&#x27;</span>;</span>
<span class="javascript">			<span class="hljs-comment">// 循环用户传递进来的对象格式参数</span></span>
<span class="javascript">			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> defaults.data) &#123;</span>
<span class="javascript">				<span class="hljs-comment">// 将参数转换为字符串格式</span></span>
<span class="javascript">				params += attr + <span class="hljs-string">&#x27;=&#x27;</span> + defaults.data[attr] + <span class="hljs-string">&#x27;&amp;&#x27;</span>;</span>
			&#125;
<span class="javascript">			<span class="hljs-comment">// 将参数最后面的&amp;截取掉 </span></span>
<span class="javascript">			<span class="hljs-comment">// 将截取的结果重新赋值给params变量</span></span>
			params = params.substr(0, params.length - 1);

<span class="javascript">			<span class="hljs-comment">// 判断请求方式</span></span>
<span class="javascript">			<span class="hljs-keyword">if</span> (defaults.type == <span class="hljs-string">&#x27;get&#x27;</span>) &#123;</span>
<span class="javascript">				defaults.url = defaults.url + <span class="hljs-string">&#x27;?&#x27;</span> + params;</span>
			&#125;

			/*
				&#123;
<span class="javascript">					name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,</span>
					age: 20
				&#125;

				name=zhangsan&amp;age=20

			 */

<span class="javascript">			<span class="hljs-comment">// 配置ajax对象</span></span>
			xhr.open(defaults.type, defaults.url);
<span class="javascript">			<span class="hljs-comment">// 如果请求方式为post</span></span>
<span class="javascript">			<span class="hljs-keyword">if</span> (defaults.type == <span class="hljs-string">&#x27;post&#x27;</span>) &#123;</span>
<span class="javascript">				<span class="hljs-comment">// 用户希望的向服务器端`		`传递的请求参数的类型</span></span>
<span class="javascript">				<span class="hljs-keyword">var</span> contentType = defaults.header[<span class="hljs-string">&#x27;Content-Type&#x27;</span>]</span>
<span class="javascript">				<span class="hljs-comment">// 设置请求参数格式的类型</span></span>
<span class="javascript">				xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, contentType);</span>
<span class="javascript">				<span class="hljs-comment">// 判断用户希望的请求参数格式的类型</span></span>
<span class="javascript">				<span class="hljs-comment">// 如果类型为json</span></span>
<span class="javascript">				<span class="hljs-keyword">if</span> (contentType == <span class="hljs-string">&#x27;application/json&#x27;</span>) &#123;</span>
<span class="javascript">					<span class="hljs-comment">// 向服务器端传递json数据格式的参数</span></span>
<span class="javascript">					xhr.send(<span class="hljs-built_in">JSON</span>.stringify(defaults.data))</span>
<span class="javascript">				&#125;<span class="hljs-keyword">else</span> &#123;</span>
<span class="javascript">					<span class="hljs-comment">// 向服务器端传递普通类型的请求参数</span></span>
					xhr.send(params);
				&#125;

<span class="javascript">			&#125;<span class="hljs-keyword">else</span> &#123;</span>
<span class="javascript">				<span class="hljs-comment">// 发送请求</span></span>
				xhr.send();
			&#125;
<span class="javascript">			<span class="hljs-comment">// 监听xhr对象下面的onload事件</span></span>
<span class="javascript">			<span class="hljs-comment">// 当xhr对象接收完响应数据后触发</span></span>
<span class="javascript">			xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>

<span class="javascript">				<span class="hljs-comment">// xhr.getResponseHeader()</span></span>
<span class="javascript">				<span class="hljs-comment">// 获取响应头中的数据</span></span>
<span class="javascript">				<span class="hljs-keyword">var</span> contentType = xhr.getResponseHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>);</span>
<span class="javascript">				<span class="hljs-comment">// 服务器端返回的数据</span></span>
<span class="javascript">				<span class="hljs-keyword">var</span> responseText = xhr.responseText;</span>

<span class="javascript">				<span class="hljs-comment">// 如果响应类型中包含applicaition/json</span></span>
<span class="javascript">				<span class="hljs-keyword">if</span> (contentType.includes(<span class="hljs-string">&#x27;application/json&#x27;</span>)) &#123;</span>
<span class="javascript">					<span class="hljs-comment">// 将json字符串转换为json对象</span></span>
<span class="javascript">					responseText = <span class="hljs-built_in">JSON</span>.parse(responseText)</span>
				&#125;

<span class="javascript">				<span class="hljs-comment">// 当http状态码等于200的时候</span></span>
				if (xhr.status == 200) &#123;
<span class="javascript">					<span class="hljs-comment">// 请求成功 调用处理成功情况的函数</span></span>
					defaults.success(responseText, xhr);
<span class="javascript">				&#125;<span class="hljs-keyword">else</span> &#123;</span>
<span class="javascript">					<span class="hljs-comment">// 请求失败 调用处理失败情况的函数</span></span>
					defaults.error(responseText, xhr);
				&#125;
			&#125;
		&#125;
    
    ajax(&#123;
<span class="javascript">      type: <span class="hljs-string">&#x27;post&#x27;</span>,</span>
<span class="javascript">      url: <span class="hljs-string">&#x27;http://localhost:3000/responseData&#x27;</span>,</span>
<span class="javascript">      sucess:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;</span>
<span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is success&#x27;</span>);</span>
<span class="javascript">        <span class="hljs-built_in">console</span>.log(data);</span>
      &#125;
    &#125;)
    
		/*
			请求参数要考虑的问题

				1.请求参数位置的问题

					将请求参数传递到ajax函数内部, 在函数内部根据请求方式的不同将请求参数放置在不同的位置

					get 放在请求地址的后面

					post 放在send方法中

				2.请求参数格式的问题

					application/x-www-form-urlencoded

						参数名称=参数值&amp;参数名称=参数值

						name=zhangsan&amp;age=20

					application/json

<span class="javascript">						&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;</span>

					1.传递对象数据类型对于函数的调用者更加友好
					2.在函数内部对象数据类型转换为字符串数据类型更加方便

		*/
	<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre></div>

<h2 id="jQuery-中的-AJAX-请求"><a href="#jQuery-中的-AJAX-请求" class="headerlink" title="jQuery 中的 AJAX 请求"></a><strong>jQuery 中的 AJAX 请求</strong></h2><p><strong>ajax 方法</strong></p>
<ul>
<li>url 表示请求的地址</li>
<li>type 表示请求的类型 GET 或 POST 请求</li>
<li>data 表示发送给服务器的数据<ul>
<li>格式有两种：<div class="hljs code-wrapper"><pre><code>        一：name=value&amp;name=value
          二：&#123;key:value&#125;
</code></pre></div>
</li>
</ul>
</li>
</ul>
<p>success 请求成功，响应的回调函数</p>
<p><strong>dataType 响应的数据类型</strong></p>
<ul>
<li>text 表示纯文本</li>
<li>xml 表示 xml 数据</li>
<li>json 表示 json 对象</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#ajaxBtn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
	$.ajax(&#123;
		url:<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;</span>,
		<span class="hljs-comment">// data:&quot;action=jQueryAjax&quot;,</span>
		data:&#123;<span class="hljs-attr">action</span>:<span class="hljs-string">&quot;jQueryAjax&quot;</span>&#125;,
		type:<span class="hljs-string">&quot;GET&quot;</span>,
		success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;
			<span class="hljs-comment">// alert(&quot;服务器返回的数据是：&quot; + data);</span>
			<span class="hljs-comment">// var jsonObj = JSON.parse(data);</span>
			$(<span class="hljs-string">&quot;#msg&quot;</span>).html(<span class="hljs-string">&quot;编号：&quot;</span> + data.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> + data.name);
		&#125;,
		dataType : <span class="hljs-string">&quot;json&quot;</span>
	&#125;);
&#125;);</code></pre></div>

<p><code>$.get 方法</code>和<code>$.post 方法</code></p>
<ul>
<li>url 请求的 url 地址</li>
<li>data 发送的数据</li>
<li>callback 成功的回调函数</li>
<li>type 返回的数据类型</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ajax--get 请求</span>
$(<span class="hljs-string">&quot;#getBtn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
	$.get(<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;</span>,<span class="hljs-string">&quot;action=jQueryGet&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;
		$(<span class="hljs-string">&quot;#msg&quot;</span>).html(<span class="hljs-string">&quot; get 编号：&quot;</span> + data.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> + data.name);
	&#125;,<span class="hljs-string">&quot;json&quot;</span>);
&#125;);
<span class="hljs-comment">// ajax--post 请求</span>
$(<span class="hljs-string">&quot;#postBtn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
	$.post(<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;</span>,<span class="hljs-string">&quot;action=jQueryPost&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)</span>
<span class="hljs-function">	</span>&#123;
		$(<span class="hljs-string">&quot;#msg&quot;</span>).html(<span class="hljs-string">&quot; post 编号：&quot;</span> + data.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> + data.name);&#125;,<span class="hljs-string">&quot;json&quot;</span>);
&#125;);</code></pre></div>

<p><code>$.getJSON</code> 方法</p>
<ul>
<li>url 请求的 url 地址</li>
<li>data 发送给服务器的数据</li>
<li>callback 成功的回调函数</li>
</ul>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ajax--getJson 请求</span>
$(<span class="hljs-string">&quot;#getJSONBtn&quot;</span>).click(function()&#123;
	$.getJSON(<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;</span>,<span class="hljs-string">&quot;action=jQueryGetJSON&quot;</span>,function
	(data) &#123;
		$(<span class="hljs-string">&quot;#msg&quot;</span>).html(<span class="hljs-string">&quot; getJSON 编号：&quot;</span> + data.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> + data.name);
	&#125;);
&#125;);</code></pre></div>

<p>表单序列化 serialize() serialize()可以把表单中所有表单项的内容都获取到，并以 name=value&amp;name=value 的形式进行拼接。</p>
<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ajax 请求</span>
$(<span class="hljs-string">&quot;#submit&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
	<span class="hljs-comment">// 把参数序列化</span>
	$.getJSON(<span class="hljs-string">&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;</span>,<span class="hljs-string">&quot;action=jQuerySerialize&amp;&quot;</span> +
$(<span class="hljs-string">&quot;#form01&quot;</span>).serialize(),<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;
	$(<span class="hljs-string">&quot;#msg&quot;</span>).html(<span class="hljs-string">&quot; Serialize 编号：&quot;</span> + data.id + <span class="hljs-string">&quot; , 姓名：&quot;</span> + data.name);
	&#125;);
&#125;);</code></pre></div>

<h1 id="十二、Axios"><a href="#十二、Axios" class="headerlink" title="十二、Axios"></a>十二、Axios</h1><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># axios的引言</span>
<span class="hljs-code">	Axios 是一个  异步请求 技术</span>
<span class="hljs-code"></span>
<span class="hljs-code"># 异步请求</span>
<span class="hljs-code">	基于XMLHttpRequest对象发起的请求都是异步请求</span>
<span class="hljs-code"></span>
<span class="hljs-code"># 异步请求特点</span>
<span class="hljs-code">	请求之后页面不动,响应回来更新的是页面的局部,多个请求之间互不影响,并行执行</span>
<span class="hljs-code">	ajax确实用来发送异步请求,ajax过气  </span>
<span class="hljs-code">	系统架构 前后端分离架构系统 ---- 异步请求技术-----&gt; Vue 全家桶系列 前端技术端  Vue  淘汰了jQuery </span></code></pre></div>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<h2 id="GET方式请求"><a href="#GET方式请求" class="headerlink" title="GET方式请求"></a>GET方式请求</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--引入axios的相关依赖--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">      <span class="hljs-comment">//get方式请求</span></span>
<span class="javascript">      axios.get(<span class="hljs-string">&#x27;http://localhost:8888/axios/findAll?username=zhangsan&amp;password=123&#x27;</span>)<span class="hljs-comment">//发送请求的url</span></span>
<span class="javascript">          .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>&#123;</span>
<span class="javascript">              <span class="hljs-built_in">console</span>.log(response.data);</span>
<span class="javascript">          &#125;)<span class="hljs-comment">//响应回来触发的回调函数</span></span>
<span class="javascript">          .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123; <span class="hljs-comment">//当请求出现错误时回调函数</span></span>
<span class="javascript">              <span class="hljs-built_in">console</span>.log(err);</span>
          &#125;);
  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<h2 id="POST方式的请求"><a href="#POST方式的请求" class="headerlink" title="POST方式的请求"></a>POST方式的请求</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--引入axios的相关依赖--&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">       <span class="hljs-comment">//post请求</span></span>
<span class="javascript">       axios.post(<span class="hljs-string">&#x27;http://localhost:8888/axios/save&#x27;</span>,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">23</span>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span>
<span class="javascript">           <span class="hljs-built_in">console</span>.log(response.data);</span>
<span class="javascript">       &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;</span>
<span class="javascript">           <span class="hljs-built_in">console</span>.log(err);</span>
       &#125;);
   <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p><strong>总结</strong></p>
<ol>
<li>axios在发送post方式的请求时传递的参数如果为对象类型,axios会自动将对象转为json格式的字符串使用 application/json的请求头向后端服务接口传递参数</li>
<li>axios的post请求传递参数的两种方式:</li>
<li>第一种使用字符串进行参数传递: “name=zhangsan&amp;age=23” 这种形式</li>
<li>第二种方式后端接口直接使用<code>@RequestBody</code>注解形式接收参数: </li>
<li>发送get跟post时，发送参数名称要跟接受参数名称保持一致（如果是对象的话，则跟对象属性的名称保持一致）</li>
</ol>
<h2 id="Axios的并发请求"><a href="#Axios的并发请求" class="headerlink" title="Axios的并发请求"></a>Axios的并发请求</h2><p>在同一时间发送多个不同的请求到后端服务,最后同一处理不同服务的响应结果</p>
<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--引入axios的相关依赖--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-comment">//并发请求: 在同一时间发送多个不同的请求到后端服务,最后同一处理不同服务的响应结果</span></span>
<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findAll</span>(<span class="hljs-params"></span>)</span>&#123;</span>
<span class="javascript">        <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">&quot;http://localhost:8888/axios/findAll?username=xiaochen&amp;password=123&quot;</span>);</span>
    &#125;
<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">save</span>(<span class="hljs-params"></span>)</span>&#123;</span>
<span class="javascript">        <span class="hljs-keyword">return</span> axios.post(<span class="hljs-string">&#x27;h tp://localhost:8888/axios/save&#x27;</span>,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaosun&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">23</span>&#125;)</span>
    &#125;
<span class="javascript">    <span class="hljs-comment">//并行发送</span></span>
    axios.all([findAll(),save()]).then(
<span class="javascript">        axios.spread(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result1,result2</span>)</span>&#123;</span>
<span class="javascript">            <span class="hljs-built_in">console</span>.log(result1.data);</span>
<span class="javascript">            <span class="hljs-built_in">console</span>.log(result2.data);</span>
<span class="javascript">        &#125;)<span class="hljs-comment">//用来统一处理多个并发请求的执行结果</span></span>
<span class="javascript">    );<span class="hljs-comment">//all用来处理并发请求</span></span>
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p><strong>总结</strong></p>
<ol>
<li>针对于并发请求需要用到<code>axios.all()</code>函数来完成并发请求的处理</li>
<li>针对于并发请求的结果汇总需要使用<code>axios.spread()</code>函数来统一汇总请求结果</li>
</ol>
<h2 id="Axios的高级使用配置对象"><a href="#Axios的高级使用配置对象" class="headerlink" title="Axios的高级使用配置对象"></a>Axios的高级使用配置对象</h2><p><strong>配置对象</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;
  <span class="hljs-comment">// `url` 是用于请求的服务器 URL</span>
  url: <span class="hljs-string">&#x27;/user&#x27;</span>,

  <span class="hljs-comment">// `method` 是创建请求时使用的方法</span>
  method: <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-comment">// 默认是 get</span>

  <span class="hljs-comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span>
  <span class="hljs-comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span>
  baseURL: <span class="hljs-string">&#x27;htt ps://some-domain.com/api/&#x27;</span>,

  <span class="hljs-comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span>
  <span class="hljs-comment">// 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span>
  <span class="hljs-comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span>
  transformRequest: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;
    <span class="hljs-comment">// 对 data 进行任意转换处理</span>

    <span class="hljs-keyword">return</span> data;
  &#125;],

  <span class="hljs-comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span>
  transformResponse: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;
    <span class="hljs-comment">// 对 data 进行任意转换处理</span>

    <span class="hljs-keyword">return</span> data;
  &#125;],

  <span class="hljs-comment">// `headers` 是即将被发送的自定义请求头</span>
  headers: &#123;<span class="hljs-string">&#x27;X-Requested-With&#x27;</span>: <span class="hljs-string">&#x27;XMLHttpRequest&#x27;</span>&#125;,

  <span class="hljs-comment">// `params` 是即将与请求一起发送的 URL 参数</span>
  <span class="hljs-comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span>
  params: &#123;
    ID: <span class="hljs-number">12345</span>
  &#125;,

  <span class="hljs-comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span>
  <span class="hljs-comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>
  paramsSerializer: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params</span>) </span>&#123;
    <span class="hljs-keyword">return</span> Qs.stringify(params, &#123;<span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">&#x27;brackets&#x27;</span>&#125;)
  &#125;,

  <span class="hljs-comment">// `data` 是作为请求主体被发送的数据</span>
  <span class="hljs-comment">// 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27;</span>
  <span class="hljs-comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span>
  <span class="hljs-comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>
  <span class="hljs-comment">// - 浏览器专属：FormData, File, Blob</span>
  <span class="hljs-comment">// - Node 专属： Stream</span>
  data: &#123;
    firstName: <span class="hljs-string">&#x27;Fred&#x27;</span>
  &#125;,

  <span class="hljs-comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span>
  <span class="hljs-comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span>
  timeout: <span class="hljs-number">1000</span>,

  <span class="hljs-comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span>
  withCredentials: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 默认的</span>

  <span class="hljs-comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span>
  <span class="hljs-comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span>
  adapter: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>&#123;
    <span class="hljs-comment">/* ... */</span>
  &#125;,

  <span class="hljs-comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span>
  <span class="hljs-comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span>
  auth: &#123;
    username: <span class="hljs-string">&#x27;janedoe&#x27;</span>,
    password: <span class="hljs-string">&#x27;s00pers3cret&#x27;</span>
  &#125;,

  <span class="hljs-comment">// `responseType` 表示服务器响应的数据类型，可以是 &#x27;arraybuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span>
  responseType: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-comment">// 默认的</span>

  <span class="hljs-comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span>
  xsrfCookieName: <span class="hljs-string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span>
  xsrfHeaderName: <span class="hljs-string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="hljs-comment">// 默认的</span>

  <span class="hljs-comment">// `onUploadProgress` 允许为上传处理进度事件</span>
  onUploadProgress: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>&#123;
    <span class="hljs-comment">// 对原生进度事件的处理</span>
  &#125;,

  <span class="hljs-comment">// `onDownloadProgress` 允许为下载处理进度事件</span>
  onDownloadProgress: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>&#123;
    <span class="hljs-comment">// 对原生进度事件的处理</span>
  &#125;,

  <span class="hljs-comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span>
  maxContentLength: <span class="hljs-number">2000</span>,

  <span class="hljs-comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span>
  validateStatus: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) </span>&#123;
    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-comment">// 默认的</span>
  &#125;,

  <span class="hljs-comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span>
  <span class="hljs-comment">// 如果设置为0，将不会 follow 任何重定向</span>
  maxRedirects: <span class="hljs-number">5</span>, <span class="hljs-comment">// 默认的</span>

  <span class="hljs-comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span>
  <span class="hljs-comment">// `keepAlive` 默认没有启用</span>
  httpAgent: <span class="hljs-keyword">new</span> http.Agent(&#123; <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> &#125;),
  httpsAgent: <span class="hljs-keyword">new</span> https.Agent(&#123; <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> &#125;),

  <span class="hljs-comment">// &#x27;proxy&#x27; 定义代理服务器的主机名称和端口</span>
  <span class="hljs-comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span>
  <span class="hljs-comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span>
  proxy: &#123;
    host: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,
    port: <span class="hljs-number">9000</span>,
    auth: : &#123;
      username: <span class="hljs-string">&#x27;mikeymike&#x27;</span>,
      password: <span class="hljs-string">&#x27;rapunz3l&#x27;</span>
    &#125;
  &#125;,

  <span class="hljs-comment">// `cancelToken` 指定用于取消请求的 cancel token</span>
  <span class="hljs-comment">// （查看后面的 Cancellation 这节了解更多）</span>
  cancelToken: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cancel</span>) </span>&#123;
  &#125;)
&#125;</code></pre></div>

<p><strong>使用配置对象形式发送请求</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs javascript"> <span class="hljs-keyword">var</span> instance = axios.create(&#123;
   method:<span class="hljs-string">&quot;GET&quot;</span>,
   baseURL:<span class="hljs-string">&quot;http://localhost:8888&quot;</span>,
   data:&#123;  <span class="hljs-comment">//作为请求体发送的数据,只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27;</span>
   &#125;
 &#125;);

instance.get(<span class="hljs-string">&quot;/axios/findAll?username=zhangsan&quot;</span>);</code></pre></div>

<p><strong>Axios的Restful风格的API</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># Axios的API总结</span>
  axios.request(config)
  axios.get(url[, config])
  axios.delete(url[, config])
  axios.head(url[, config])
  axios.post(url[, data[, config]])
  axios.put(url[, data[, config]])
  axios.patch(url[, data[, config]])
<span class="hljs-section"># NOTE:</span>
<span class="hljs-code">		在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</span></code></pre></div>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/26/MySQL/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/16/Linux/">
                        <span class="hidden-mobile">Java开发所需的Linux环境配置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#valine",
          app_id: "Q8utolFFXQsi71pQY6bCltkI-gzGzoHsz",
          app_key: "x4RAlPOpmFX9HdGyI6MLoCGn",
          placeholder: "说点什么....",
          path: window.location.pathname,
          avatar: "monsterid",
          meta: ["nick","mail","link"],
          pageSize: "12",
          lang: "zh-CN",
          highlight: true,
          recordIP: true,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>





  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
